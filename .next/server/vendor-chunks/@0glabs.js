"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@0glabs";
exports.ids = ["vendor-chunks/@0glabs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@0glabs/0g-serving-broker/lib.esm/adm-zip-86f30d47.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@0glabs/0g-serving-broker/lib.esm/adm-zip-86f30d47.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ admZip$1)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction getAugmentedNamespace(n) {\n  if (n.__esModule) return n;\n  var f = n.default;\n\tif (typeof f == \"function\") {\n\t\tvar a = function a () {\n\t\t\tif (this instanceof a) {\n        return Reflect.construct(f, arguments, this.constructor);\n\t\t\t}\n\t\t\treturn f.apply(this, arguments);\n\t\t};\n\t\ta.prototype = f.prototype;\n  } else a = {};\n  Object.defineProperty(a, '__esModule', {value: true});\n\tObject.keys(n).forEach(function (k) {\n\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn n[k];\n\t\t\t}\n\t\t});\n\t});\n\treturn a;\n}\n\nvar util = {exports: {}};\n\nvar constants;\nvar hasRequiredConstants;\n\nfunction requireConstants () {\n\tif (hasRequiredConstants) return constants;\n\thasRequiredConstants = 1;\n\tconstants = {\n\t    /* The local file header */\n\t    LOCHDR           : 30, // LOC header size\n\t    LOCSIG           : 0x04034b50, // \"PK\\003\\004\"\n\t    LOCVER           : 4,\t// version needed to extract\n\t    LOCFLG           : 6, // general purpose bit flag\n\t    LOCHOW           : 8, // compression method\n\t    LOCTIM           : 10, // modification time (2 bytes time, 2 bytes date)\n\t    LOCCRC           : 14, // uncompressed file crc-32 value\n\t    LOCSIZ           : 18, // compressed size\n\t    LOCLEN           : 22, // uncompressed size\n\t    LOCNAM           : 26, // filename length\n\t    LOCEXT           : 28, // extra field length\n\n\t    /* The Data descriptor */\n\t    EXTSIG           : 0x08074b50, // \"PK\\007\\008\"\n\t    EXTHDR           : 16, // EXT header size\n\t    EXTCRC           : 4, // uncompressed file crc-32 value\n\t    EXTSIZ           : 8, // compressed size\n\t    EXTLEN           : 12, // uncompressed size\n\n\t    /* The central directory file header */\n\t    CENHDR           : 46, // CEN header size\n\t    CENSIG           : 0x02014b50, // \"PK\\001\\002\"\n\t    CENVEM           : 4, // version made by\n\t    CENVER           : 6, // version needed to extract\n\t    CENFLG           : 8, // encrypt, decrypt flags\n\t    CENHOW           : 10, // compression method\n\t    CENTIM           : 12, // modification time (2 bytes time, 2 bytes date)\n\t    CENCRC           : 16, // uncompressed file crc-32 value\n\t    CENSIZ           : 20, // compressed size\n\t    CENLEN           : 24, // uncompressed size\n\t    CENNAM           : 28, // filename length\n\t    CENEXT           : 30, // extra field length\n\t    CENCOM           : 32, // file comment length\n\t    CENDSK           : 34, // volume number start\n\t    CENATT           : 36, // internal file attributes\n\t    CENATX           : 38, // external file attributes (host system dependent)\n\t    CENOFF           : 42, // LOC header offset\n\n\t    /* The entries in the end of central directory */\n\t    ENDHDR           : 22, // END header size\n\t    ENDSIG           : 0x06054b50, // \"PK\\005\\006\"\n\t    ENDSUB           : 8, // number of entries on this disk\n\t    ENDTOT           : 10, // total number of entries\n\t    ENDSIZ           : 12, // central directory size in bytes\n\t    ENDOFF           : 16, // offset of first CEN header\n\t    ENDCOM           : 20, // zip file comment length\n\n\t    END64HDR         : 20, // zip64 END header size\n\t    END64SIG         : 0x07064b50, // zip64 Locator signature, \"PK\\006\\007\"\n\t    END64START       : 4, // number of the disk with the start of the zip64\n\t    END64OFF         : 8, // relative offset of the zip64 end of central directory\n\t    END64NUMDISKS    : 16, // total number of disks\n\n\t    ZIP64SIG         : 0x06064b50, // zip64 signature, \"PK\\006\\006\"\n\t    ZIP64HDR         : 56, // zip64 record minimum size\n\t    ZIP64LEAD        : 12, // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE\n\t    ZIP64SIZE        : 4, // zip64 size of the central directory record\n\t    ZIP64VEM         : 12, // zip64 version made by\n\t    ZIP64VER         : 14, // zip64 version needed to extract\n\t    ZIP64DSK         : 16, // zip64 number of this disk\n\t    ZIP64DSKDIR      : 20, // number of the disk with the start of the record directory\n\t    ZIP64SUB         : 24, // number of entries on this disk\n\t    ZIP64TOT         : 32, // total number of entries\n\t    ZIP64SIZB        : 40, // zip64 central directory size in bytes\n\t    ZIP64OFF         : 48, // offset of start of central directory with respect to the starting disk number\n\t    ZIP64EXTRA       : 56, // extensible data sector\n\n\t    /* Compression methods */\n\t    STORED           : 0, // no compression\n\t    SHRUNK           : 1, // shrunk\n\t    REDUCED1         : 2, // reduced with compression factor 1\n\t    REDUCED2         : 3, // reduced with compression factor 2\n\t    REDUCED3         : 4, // reduced with compression factor 3\n\t    REDUCED4         : 5, // reduced with compression factor 4\n\t    IMPLODED         : 6, // imploded\n\t    // 7 reserved for Tokenizing compression algorithm\n\t    DEFLATED         : 8, // deflated\n\t    ENHANCED_DEFLATED: 9, // enhanced deflated\n\t    PKWARE           : 10,// PKWare DCL imploded\n\t    // 11 reserved by PKWARE\n\t    BZIP2            : 12, //  compressed using BZIP2\n\t    // 13 reserved by PKWARE\n\t    LZMA             : 14, // LZMA\n\t    // 15-17 reserved by PKWARE\n\t    IBM_TERSE        : 18, // compressed using IBM TERSE\n\t    IBM_LZ77         : 19, // IBM LZ77 z\n\t    AES_ENCRYPT      : 99, // WinZIP AES encryption method\n\n\t    /* General purpose bit flag */\n\t    // values can obtained with expression 2**bitnr\n\t    FLG_ENC          : 1,    // Bit 0: encrypted file\n\t    FLG_COMP1        : 2,    // Bit 1, compression option\n\t    FLG_COMP2        : 4,    // Bit 2, compression option\n\t    FLG_DESC         : 8,    // Bit 3, data descriptor\n\t    FLG_ENH          : 16,   // Bit 4, enhanced deflating\n\t    FLG_PATCH        : 32,   // Bit 5, indicates that the file is compressed patched data.\n\t    FLG_STR          : 64,   // Bit 6, strong encryption (patented)\n\t                             // Bits 7-10: Currently unused.\n\t    FLG_EFS          : 2048, // Bit 11: Language encoding flag (EFS)\n\t                             // Bit 12: Reserved by PKWARE for enhanced compression.\n\t                             // Bit 13: encrypted the Central Directory (patented).\n\t                             // Bits 14-15: Reserved by PKWARE.\n\t    FLG_MSK          : 4096, // mask header values\n\n\t    /* Load type */\n\t    FILE             : 2,\n\t    BUFFER           : 1,\n\t    NONE             : 0,\n\n\t    /* 4.5 Extensible data fields */\n\t    EF_ID            : 0,\n\t    EF_SIZE          : 2,\n\n\t    /* Header IDs */\n\t    ID_ZIP64         : 0x0001,\n\t    ID_AVINFO        : 0x0007,\n\t    ID_PFS           : 0x0008,\n\t    ID_OS2           : 0x0009,\n\t    ID_NTFS          : 0x000a,\n\t    ID_OPENVMS       : 0x000c,\n\t    ID_UNIX          : 0x000d,\n\t    ID_FORK          : 0x000e,\n\t    ID_PATCH         : 0x000f,\n\t    ID_X509_PKCS7    : 0x0014,\n\t    ID_X509_CERTID_F : 0x0015,\n\t    ID_X509_CERTID_C : 0x0016,\n\t    ID_STRONGENC     : 0x0017,\n\t    ID_RECORD_MGT    : 0x0018,\n\t    ID_X509_PKCS7_RL : 0x0019,\n\t    ID_IBM1          : 0x0065,\n\t    ID_IBM2          : 0x0066,\n\t    ID_POSZIP        : 0x4690,\n\n\t    EF_ZIP64_OR_32   : 0xffffffff,\n\t    EF_ZIP64_OR_16   : 0xffff,\n\t    EF_ZIP64_SUNCOMP : 0,\n\t    EF_ZIP64_SCOMP   : 8,\n\t    EF_ZIP64_RHO     : 16,\n\t    EF_ZIP64_DSN     : 24\n\t};\n\treturn constants;\n}\n\nvar errors = {};\n\nvar hasRequiredErrors;\n\nfunction requireErrors () {\n\tif (hasRequiredErrors) return errors;\n\thasRequiredErrors = 1;\n\t(function (exports) {\n\t\tconst errors = {\n\t\t    /* Header error messages */\n\t\t    INVALID_LOC: \"Invalid LOC header (bad signature)\",\n\t\t    INVALID_CEN: \"Invalid CEN header (bad signature)\",\n\t\t    INVALID_END: \"Invalid END header (bad signature)\",\n\n\t\t    /* Descriptor */\n\t\t    DESCRIPTOR_NOT_EXIST: \"No descriptor present\",\n\t\t    DESCRIPTOR_UNKNOWN: \"Unknown descriptor format\",\n\t\t    DESCRIPTOR_FAULTY: \"Descriptor data is malformed\",\n\n\t\t    /* ZipEntry error messages*/\n\t\t    NO_DATA: \"Nothing to decompress\",\n\t\t    BAD_CRC: \"CRC32 checksum failed {0}\",\n\t\t    FILE_IN_THE_WAY: \"There is a file in the way: {0}\",\n\t\t    UNKNOWN_METHOD: \"Invalid/unsupported compression method\",\n\n\t\t    /* Inflater error messages */\n\t\t    AVAIL_DATA: \"inflate::Available inflate data did not terminate\",\n\t\t    INVALID_DISTANCE: \"inflate::Invalid literal/length or distance code in fixed or dynamic block\",\n\t\t    TO_MANY_CODES: \"inflate::Dynamic block code description: too many length or distance codes\",\n\t\t    INVALID_REPEAT_LEN: \"inflate::Dynamic block code description: repeat more than specified lengths\",\n\t\t    INVALID_REPEAT_FIRST: \"inflate::Dynamic block code description: repeat lengths with no first length\",\n\t\t    INCOMPLETE_CODES: \"inflate::Dynamic block code description: code lengths codes incomplete\",\n\t\t    INVALID_DYN_DISTANCE: \"inflate::Dynamic block code description: invalid distance code lengths\",\n\t\t    INVALID_CODES_LEN: \"inflate::Dynamic block code description: invalid literal/length code lengths\",\n\t\t    INVALID_STORE_BLOCK: \"inflate::Stored block length did not match one's complement\",\n\t\t    INVALID_BLOCK_TYPE: \"inflate::Invalid block type (type == 3)\",\n\n\t\t    /* ADM-ZIP error messages */\n\t\t    CANT_EXTRACT_FILE: \"Could not extract the file\",\n\t\t    CANT_OVERRIDE: \"Target file already exists\",\n\t\t    DISK_ENTRY_TOO_LARGE: \"Number of disk entries is too large\",\n\t\t    NO_ZIP: \"No zip file was loaded\",\n\t\t    NO_ENTRY: \"Entry doesn't exist\",\n\t\t    DIRECTORY_CONTENT_ERROR: \"A directory cannot have content\",\n\t\t    FILE_NOT_FOUND: 'File not found: \"{0}\"',\n\t\t    NOT_IMPLEMENTED: \"Not implemented\",\n\t\t    INVALID_FILENAME: \"Invalid filename\",\n\t\t    INVALID_FORMAT: \"Invalid or unsupported zip format. No END header found\",\n\t\t    INVALID_PASS_PARAM: \"Incompatible password parameter\",\n\t\t    WRONG_PASSWORD: \"Wrong Password\",\n\n\t\t    /* ADM-ZIP */\n\t\t    COMMENT_TOO_LONG: \"Comment is too long\", // Comment can be max 65535 bytes long (NOTE: some non-US characters may take more space)\n\t\t    EXTRA_FIELD_PARSE_ERROR: \"Extra field parsing error\"\n\t\t};\n\n\t\t// template\n\t\tfunction E(message) {\n\t\t    return function (...args) {\n\t\t        if (args.length) { // Allow {0} .. {9} arguments in error message, based on argument number\n\t\t            message = message.replace(/\\{(\\d)\\}/g, (_, n) => args[n] || '');\n\t\t        }\n\n\t\t        return new Error('ADM-ZIP: ' + message);\n\t\t    };\n\t\t}\n\n\t\t// Init errors with template\n\t\tfor (const msg of Object.keys(errors)) {\n\t\t    exports[msg] = E(errors[msg]);\n\t\t} \n\t} (errors));\n\treturn errors;\n}\n\nvar utils;\nvar hasRequiredUtils;\n\nfunction requireUtils () {\n\tif (hasRequiredUtils) return utils;\n\thasRequiredUtils = 1;\n\tconst fsystem = (fs__WEBPACK_IMPORTED_MODULE_0___default());\n\tconst pth = (path__WEBPACK_IMPORTED_MODULE_1___default());\n\tconst Constants = requireConstants();\n\tconst Errors = requireErrors();\n\tconst isWin = typeof process === \"object\" && \"win32\" === process.platform;\n\n\tconst is_Obj = (obj) => typeof obj === \"object\" && obj !== null;\n\n\t// generate CRC32 lookup table\n\tconst crcTable = new Uint32Array(256).map((t, c) => {\n\t    for (let k = 0; k < 8; k++) {\n\t        if ((c & 1) !== 0) {\n\t            c = 0xedb88320 ^ (c >>> 1);\n\t        } else {\n\t            c >>>= 1;\n\t        }\n\t    }\n\t    return c >>> 0;\n\t});\n\n\t// UTILS functions\n\n\tfunction Utils(opts) {\n\t    this.sep = pth.sep;\n\t    this.fs = fsystem;\n\n\t    if (is_Obj(opts)) {\n\t        // custom filesystem\n\t        if (is_Obj(opts.fs) && typeof opts.fs.statSync === \"function\") {\n\t            this.fs = opts.fs;\n\t        }\n\t    }\n\t}\n\n\tutils = Utils;\n\n\t// INSTANTIABLE functions\n\n\tUtils.prototype.makeDir = function (/*String*/ folder) {\n\t    const self = this;\n\n\t    // Sync - make directories tree\n\t    function mkdirSync(/*String*/ fpath) {\n\t        let resolvedPath = fpath.split(self.sep)[0];\n\t        fpath.split(self.sep).forEach(function (name) {\n\t            if (!name || name.substr(-1, 1) === \":\") return;\n\t            resolvedPath += self.sep + name;\n\t            var stat;\n\t            try {\n\t                stat = self.fs.statSync(resolvedPath);\n\t            } catch (e) {\n\t                self.fs.mkdirSync(resolvedPath);\n\t            }\n\t            if (stat && stat.isFile()) throw Errors.FILE_IN_THE_WAY(`\"${resolvedPath}\"`);\n\t        });\n\t    }\n\n\t    mkdirSync(folder);\n\t};\n\n\tUtils.prototype.writeFileTo = function (/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr) {\n\t    const self = this;\n\t    if (self.fs.existsSync(path)) {\n\t        if (!overwrite) return false; // cannot overwrite\n\n\t        var stat = self.fs.statSync(path);\n\t        if (stat.isDirectory()) {\n\t            return false;\n\t        }\n\t    }\n\t    var folder = pth.dirname(path);\n\t    if (!self.fs.existsSync(folder)) {\n\t        self.makeDir(folder);\n\t    }\n\n\t    var fd;\n\t    try {\n\t        fd = self.fs.openSync(path, \"w\", 0o666); // 0666\n\t    } catch (e) {\n\t        self.fs.chmodSync(path, 0o666);\n\t        fd = self.fs.openSync(path, \"w\", 0o666);\n\t    }\n\t    if (fd) {\n\t        try {\n\t            self.fs.writeSync(fd, content, 0, content.length, 0);\n\t        } finally {\n\t            self.fs.closeSync(fd);\n\t        }\n\t    }\n\t    self.fs.chmodSync(path, attr || 0o666);\n\t    return true;\n\t};\n\n\tUtils.prototype.writeFileToAsync = function (/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr, /*Function*/ callback) {\n\t    if (typeof attr === \"function\") {\n\t        callback = attr;\n\t        attr = undefined;\n\t    }\n\n\t    const self = this;\n\n\t    self.fs.exists(path, function (exist) {\n\t        if (exist && !overwrite) return callback(false);\n\n\t        self.fs.stat(path, function (err, stat) {\n\t            if (exist && stat.isDirectory()) {\n\t                return callback(false);\n\t            }\n\n\t            var folder = pth.dirname(path);\n\t            self.fs.exists(folder, function (exists) {\n\t                if (!exists) self.makeDir(folder);\n\n\t                self.fs.open(path, \"w\", 0o666, function (err, fd) {\n\t                    if (err) {\n\t                        self.fs.chmod(path, 0o666, function () {\n\t                            self.fs.open(path, \"w\", 0o666, function (err, fd) {\n\t                                self.fs.write(fd, content, 0, content.length, 0, function () {\n\t                                    self.fs.close(fd, function () {\n\t                                        self.fs.chmod(path, attr || 0o666, function () {\n\t                                            callback(true);\n\t                                        });\n\t                                    });\n\t                                });\n\t                            });\n\t                        });\n\t                    } else if (fd) {\n\t                        self.fs.write(fd, content, 0, content.length, 0, function () {\n\t                            self.fs.close(fd, function () {\n\t                                self.fs.chmod(path, attr || 0o666, function () {\n\t                                    callback(true);\n\t                                });\n\t                            });\n\t                        });\n\t                    } else {\n\t                        self.fs.chmod(path, attr || 0o666, function () {\n\t                            callback(true);\n\t                        });\n\t                    }\n\t                });\n\t            });\n\t        });\n\t    });\n\t};\n\n\tUtils.prototype.findFiles = function (/*String*/ path) {\n\t    const self = this;\n\n\t    function findSync(/*String*/ dir, /*RegExp*/ pattern, /*Boolean*/ recursive) {\n\t        if (typeof pattern === \"boolean\") {\n\t            recursive = pattern;\n\t            pattern = undefined;\n\t        }\n\t        let files = [];\n\t        self.fs.readdirSync(dir).forEach(function (file) {\n\t            const path = pth.join(dir, file);\n\t            const stat = self.fs.statSync(path);\n\n\t            if (!pattern || pattern.test(path)) {\n\t                files.push(pth.normalize(path) + (stat.isDirectory() ? self.sep : \"\"));\n\t            }\n\n\t            if (stat.isDirectory() && recursive) files = files.concat(findSync(path, pattern, recursive));\n\t        });\n\t        return files;\n\t    }\n\n\t    return findSync(path, undefined, true);\n\t};\n\n\t/**\n\t * Callback for showing if everything was done.\n\t *\n\t * @callback filelistCallback\n\t * @param {Error} err - Error object\n\t * @param {string[]} list - was request fully completed\n\t */\n\n\t/**\n\t *\n\t * @param {string} dir\n\t * @param {filelistCallback} cb\n\t */\n\tUtils.prototype.findFilesAsync = function (dir, cb) {\n\t    const self = this;\n\t    let results = [];\n\t    self.fs.readdir(dir, function (err, list) {\n\t        if (err) return cb(err);\n\t        let list_length = list.length;\n\t        if (!list_length) return cb(null, results);\n\t        list.forEach(function (file) {\n\t            file = pth.join(dir, file);\n\t            self.fs.stat(file, function (err, stat) {\n\t                if (err) return cb(err);\n\t                if (stat) {\n\t                    results.push(pth.normalize(file) + (stat.isDirectory() ? self.sep : \"\"));\n\t                    if (stat.isDirectory()) {\n\t                        self.findFilesAsync(file, function (err, res) {\n\t                            if (err) return cb(err);\n\t                            results = results.concat(res);\n\t                            if (!--list_length) cb(null, results);\n\t                        });\n\t                    } else {\n\t                        if (!--list_length) cb(null, results);\n\t                    }\n\t                }\n\t            });\n\t        });\n\t    });\n\t};\n\n\tUtils.prototype.getAttributes = function () {};\n\n\tUtils.prototype.setAttributes = function () {};\n\n\t// STATIC functions\n\n\t// crc32 single update (it is part of crc32)\n\tUtils.crc32update = function (crc, byte) {\n\t    return crcTable[(crc ^ byte) & 0xff] ^ (crc >>> 8);\n\t};\n\n\tUtils.crc32 = function (buf) {\n\t    if (typeof buf === \"string\") {\n\t        buf = Buffer.from(buf, \"utf8\");\n\t    }\n\n\t    let len = buf.length;\n\t    let crc = ~0;\n\t    for (let off = 0; off < len; ) crc = Utils.crc32update(crc, buf[off++]);\n\t    // xor and cast as uint32 number\n\t    return ~crc >>> 0;\n\t};\n\n\tUtils.methodToString = function (/*Number*/ method) {\n\t    switch (method) {\n\t        case Constants.STORED:\n\t            return \"STORED (\" + method + \")\";\n\t        case Constants.DEFLATED:\n\t            return \"DEFLATED (\" + method + \")\";\n\t        default:\n\t            return \"UNSUPPORTED (\" + method + \")\";\n\t    }\n\t};\n\n\t/**\n\t * removes \"..\" style path elements\n\t * @param {string} path - fixable path\n\t * @returns string - fixed filepath\n\t */\n\tUtils.canonical = function (/*string*/ path) {\n\t    if (!path) return \"\";\n\t    // trick normalize think path is absolute\n\t    const safeSuffix = pth.posix.normalize(\"/\" + path.split(\"\\\\\").join(\"/\"));\n\t    return pth.join(\".\", safeSuffix);\n\t};\n\n\t/**\n\t * fix file names in achive\n\t * @param {string} path - fixable path\n\t * @returns string - fixed filepath\n\t */\n\n\tUtils.zipnamefix = function (path) {\n\t    if (!path) return \"\";\n\t    // trick normalize think path is absolute\n\t    const safeSuffix = pth.posix.normalize(\"/\" + path.split(\"\\\\\").join(\"/\"));\n\t    return pth.posix.join(\".\", safeSuffix);\n\t};\n\n\t/**\n\t *\n\t * @param {Array} arr\n\t * @param {function} callback\n\t * @returns\n\t */\n\tUtils.findLast = function (arr, callback) {\n\t    if (!Array.isArray(arr)) throw new TypeError(\"arr is not array\");\n\n\t    const len = arr.length >>> 0;\n\t    for (let i = len - 1; i >= 0; i--) {\n\t        if (callback(arr[i], i, arr)) {\n\t            return arr[i];\n\t        }\n\t    }\n\t    return void 0;\n\t};\n\n\t// make abolute paths taking prefix as root folder\n\tUtils.sanitize = function (/*string*/ prefix, /*string*/ name) {\n\t    prefix = pth.resolve(pth.normalize(prefix));\n\t    var parts = name.split(\"/\");\n\t    for (var i = 0, l = parts.length; i < l; i++) {\n\t        var path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));\n\t        if (path.indexOf(prefix) === 0) {\n\t            return path;\n\t        }\n\t    }\n\t    return pth.normalize(pth.join(prefix, pth.basename(name)));\n\t};\n\n\t// converts buffer, Uint8Array, string types to buffer\n\tUtils.toBuffer = function toBuffer(/*buffer, Uint8Array, string*/ input, /* function */ encoder) {\n\t    if (Buffer.isBuffer(input)) {\n\t        return input;\n\t    } else if (input instanceof Uint8Array) {\n\t        return Buffer.from(input);\n\t    } else {\n\t        // expect string all other values are invalid and return empty buffer\n\t        return typeof input === \"string\" ? encoder(input) : Buffer.alloc(0);\n\t    }\n\t};\n\n\tUtils.readBigUInt64LE = function (/*Buffer*/ buffer, /*int*/ index) {\n\t    var slice = Buffer.from(buffer.slice(index, index + 8));\n\t    slice.swap64();\n\n\t    return parseInt(`0x${slice.toString(\"hex\")}`);\n\t};\n\n\tUtils.fromDOS2Date = function (val) {\n\t    return new Date(((val >> 25) & 0x7f) + 1980, Math.max(((val >> 21) & 0x0f) - 1, 0), Math.max((val >> 16) & 0x1f, 1), (val >> 11) & 0x1f, (val >> 5) & 0x3f, (val & 0x1f) << 1);\n\t};\n\n\tUtils.fromDate2DOS = function (val) {\n\t    let date = 0;\n\t    let time = 0;\n\t    if (val.getFullYear() > 1979) {\n\t        date = (((val.getFullYear() - 1980) & 0x7f) << 9) | ((val.getMonth() + 1) << 5) | val.getDate();\n\t        time = (val.getHours() << 11) | (val.getMinutes() << 5) | (val.getSeconds() >> 1);\n\t    }\n\t    return (date << 16) | time;\n\t};\n\n\tUtils.isWin = isWin; // Do we have windows system\n\tUtils.crcTable = crcTable;\n\treturn utils;\n}\n\nvar fattr;\nvar hasRequiredFattr;\n\nfunction requireFattr () {\n\tif (hasRequiredFattr) return fattr;\n\thasRequiredFattr = 1;\n\tconst pth = (path__WEBPACK_IMPORTED_MODULE_1___default());\n\n\tfattr = function (/*String*/ path, /*Utils object*/ { fs }) {\n\t    var _path = path || \"\",\n\t        _obj = newAttr(),\n\t        _stat = null;\n\n\t    function newAttr() {\n\t        return {\n\t            directory: false,\n\t            readonly: false,\n\t            hidden: false,\n\t            executable: false,\n\t            mtime: 0,\n\t            atime: 0\n\t        };\n\t    }\n\n\t    if (_path && fs.existsSync(_path)) {\n\t        _stat = fs.statSync(_path);\n\t        _obj.directory = _stat.isDirectory();\n\t        _obj.mtime = _stat.mtime;\n\t        _obj.atime = _stat.atime;\n\t        _obj.executable = (0o111 & _stat.mode) !== 0; // file is executable who ever har right not just owner\n\t        _obj.readonly = (0o200 & _stat.mode) === 0; // readonly if owner has no write right\n\t        _obj.hidden = pth.basename(_path)[0] === \".\";\n\t    } else {\n\t        console.warn(\"Invalid path: \" + _path);\n\t    }\n\n\t    return {\n\t        get directory() {\n\t            return _obj.directory;\n\t        },\n\n\t        get readOnly() {\n\t            return _obj.readonly;\n\t        },\n\n\t        get hidden() {\n\t            return _obj.hidden;\n\t        },\n\n\t        get mtime() {\n\t            return _obj.mtime;\n\t        },\n\n\t        get atime() {\n\t            return _obj.atime;\n\t        },\n\n\t        get executable() {\n\t            return _obj.executable;\n\t        },\n\n\t        decodeAttributes: function () {},\n\n\t        encodeAttributes: function () {},\n\n\t        toJSON: function () {\n\t            return {\n\t                path: _path,\n\t                isDirectory: _obj.directory,\n\t                isReadOnly: _obj.readonly,\n\t                isHidden: _obj.hidden,\n\t                isExecutable: _obj.executable,\n\t                mTime: _obj.mtime,\n\t                aTime: _obj.atime\n\t            };\n\t        },\n\n\t        toString: function () {\n\t            return JSON.stringify(this.toJSON(), null, \"\\t\");\n\t        }\n\t    };\n\t};\n\treturn fattr;\n}\n\nvar decoder;\nvar hasRequiredDecoder;\n\nfunction requireDecoder () {\n\tif (hasRequiredDecoder) return decoder;\n\thasRequiredDecoder = 1;\n\tdecoder = {\n\t    efs: true,\n\t    encode: (data) => Buffer.from(data, \"utf8\"),\n\t    decode: (data) => data.toString(\"utf8\")\n\t};\n\treturn decoder;\n}\n\nvar hasRequiredUtil;\n\nfunction requireUtil () {\n\tif (hasRequiredUtil) return util.exports;\n\thasRequiredUtil = 1;\n\tutil.exports = requireUtils();\n\tutil.exports.Constants = requireConstants();\n\tutil.exports.Errors = requireErrors();\n\tutil.exports.FileAttr = requireFattr();\n\tutil.exports.decoder = requireDecoder();\n\treturn util.exports;\n}\n\nvar headers = {};\n\nvar entryHeader;\nvar hasRequiredEntryHeader;\n\nfunction requireEntryHeader () {\n\tif (hasRequiredEntryHeader) return entryHeader;\n\thasRequiredEntryHeader = 1;\n\tvar Utils = requireUtil(),\n\t    Constants = Utils.Constants;\n\n\t/* The central directory file header */\n\tentryHeader = function () {\n\t    var _verMade = 20, // v2.0\n\t        _version = 10, // v1.0\n\t        _flags = 0,\n\t        _method = 0,\n\t        _time = 0,\n\t        _crc = 0,\n\t        _compressedSize = 0,\n\t        _size = 0,\n\t        _fnameLen = 0,\n\t        _extraLen = 0,\n\t        _comLen = 0,\n\t        _diskStart = 0,\n\t        _inattr = 0,\n\t        _attr = 0,\n\t        _offset = 0;\n\n\t    _verMade |= Utils.isWin ? 0x0a00 : 0x0300;\n\n\t    // Set EFS flag since filename and comment fields are all by default encoded using UTF-8.\n\t    // Without it file names may be corrupted for other apps when file names use unicode chars\n\t    _flags |= Constants.FLG_EFS;\n\n\t    const _localHeader = {\n\t        extraLen: 0\n\t    };\n\n\t    // casting\n\t    const uint32 = (val) => Math.max(0, val) >>> 0;\n\t    const uint8 = (val) => Math.max(0, val) & 0xff;\n\n\t    _time = Utils.fromDate2DOS(new Date());\n\n\t    return {\n\t        get made() {\n\t            return _verMade;\n\t        },\n\t        set made(val) {\n\t            _verMade = val;\n\t        },\n\n\t        get version() {\n\t            return _version;\n\t        },\n\t        set version(val) {\n\t            _version = val;\n\t        },\n\n\t        get flags() {\n\t            return _flags;\n\t        },\n\t        set flags(val) {\n\t            _flags = val;\n\t        },\n\n\t        get flags_efs() {\n\t            return (_flags & Constants.FLG_EFS) > 0;\n\t        },\n\t        set flags_efs(val) {\n\t            if (val) {\n\t                _flags |= Constants.FLG_EFS;\n\t            } else {\n\t                _flags &= ~Constants.FLG_EFS;\n\t            }\n\t        },\n\n\t        get flags_desc() {\n\t            return (_flags & Constants.FLG_DESC) > 0;\n\t        },\n\t        set flags_desc(val) {\n\t            if (val) {\n\t                _flags |= Constants.FLG_DESC;\n\t            } else {\n\t                _flags &= ~Constants.FLG_DESC;\n\t            }\n\t        },\n\n\t        get method() {\n\t            return _method;\n\t        },\n\t        set method(val) {\n\t            switch (val) {\n\t                case Constants.STORED:\n\t                    this.version = 10;\n\t                case Constants.DEFLATED:\n\t                default:\n\t                    this.version = 20;\n\t            }\n\t            _method = val;\n\t        },\n\n\t        get time() {\n\t            return Utils.fromDOS2Date(this.timeval);\n\t        },\n\t        set time(val) {\n\t            this.timeval = Utils.fromDate2DOS(val);\n\t        },\n\n\t        get timeval() {\n\t            return _time;\n\t        },\n\t        set timeval(val) {\n\t            _time = uint32(val);\n\t        },\n\n\t        get timeHighByte() {\n\t            return uint8(_time >>> 8);\n\t        },\n\t        get crc() {\n\t            return _crc;\n\t        },\n\t        set crc(val) {\n\t            _crc = uint32(val);\n\t        },\n\n\t        get compressedSize() {\n\t            return _compressedSize;\n\t        },\n\t        set compressedSize(val) {\n\t            _compressedSize = uint32(val);\n\t        },\n\n\t        get size() {\n\t            return _size;\n\t        },\n\t        set size(val) {\n\t            _size = uint32(val);\n\t        },\n\n\t        get fileNameLength() {\n\t            return _fnameLen;\n\t        },\n\t        set fileNameLength(val) {\n\t            _fnameLen = val;\n\t        },\n\n\t        get extraLength() {\n\t            return _extraLen;\n\t        },\n\t        set extraLength(val) {\n\t            _extraLen = val;\n\t        },\n\n\t        get extraLocalLength() {\n\t            return _localHeader.extraLen;\n\t        },\n\t        set extraLocalLength(val) {\n\t            _localHeader.extraLen = val;\n\t        },\n\n\t        get commentLength() {\n\t            return _comLen;\n\t        },\n\t        set commentLength(val) {\n\t            _comLen = val;\n\t        },\n\n\t        get diskNumStart() {\n\t            return _diskStart;\n\t        },\n\t        set diskNumStart(val) {\n\t            _diskStart = uint32(val);\n\t        },\n\n\t        get inAttr() {\n\t            return _inattr;\n\t        },\n\t        set inAttr(val) {\n\t            _inattr = uint32(val);\n\t        },\n\n\t        get attr() {\n\t            return _attr;\n\t        },\n\t        set attr(val) {\n\t            _attr = uint32(val);\n\t        },\n\n\t        // get Unix file permissions\n\t        get fileAttr() {\n\t            return (_attr || 0) >> 16 & 0xfff;\n\t        },\n\n\t        get offset() {\n\t            return _offset;\n\t        },\n\t        set offset(val) {\n\t            _offset = uint32(val);\n\t        },\n\n\t        get encrypted() {\n\t            return (_flags & Constants.FLG_ENC) === Constants.FLG_ENC;\n\t        },\n\n\t        get centralHeaderSize() {\n\t            return Constants.CENHDR + _fnameLen + _extraLen + _comLen;\n\t        },\n\n\t        get realDataOffset() {\n\t            return _offset + Constants.LOCHDR + _localHeader.fnameLen + _localHeader.extraLen;\n\t        },\n\n\t        get localHeader() {\n\t            return _localHeader;\n\t        },\n\n\t        loadLocalHeaderFromBinary: function (/*Buffer*/ input) {\n\t            var data = input.slice(_offset, _offset + Constants.LOCHDR);\n\t            // 30 bytes and should start with \"PK\\003\\004\"\n\t            if (data.readUInt32LE(0) !== Constants.LOCSIG) {\n\t                throw Utils.Errors.INVALID_LOC();\n\t            }\n\n\t            // version needed to extract\n\t            _localHeader.version = data.readUInt16LE(Constants.LOCVER);\n\t            // general purpose bit flag\n\t            _localHeader.flags = data.readUInt16LE(Constants.LOCFLG);\n\t            // compression method\n\t            _localHeader.method = data.readUInt16LE(Constants.LOCHOW);\n\t            // modification time (2 bytes time, 2 bytes date)\n\t            _localHeader.time = data.readUInt32LE(Constants.LOCTIM);\n\t            // uncompressed file crc-32 valu\n\t            _localHeader.crc = data.readUInt32LE(Constants.LOCCRC);\n\t            // compressed size\n\t            _localHeader.compressedSize = data.readUInt32LE(Constants.LOCSIZ);\n\t            // uncompressed size\n\t            _localHeader.size = data.readUInt32LE(Constants.LOCLEN);\n\t            // filename length\n\t            _localHeader.fnameLen = data.readUInt16LE(Constants.LOCNAM);\n\t            // extra field length\n\t            _localHeader.extraLen = data.readUInt16LE(Constants.LOCEXT);\n\n\t            // read extra data\n\t            const extraStart = _offset + Constants.LOCHDR + _localHeader.fnameLen;\n\t            const extraEnd = extraStart + _localHeader.extraLen;\n\t            return input.slice(extraStart, extraEnd);\n\t        },\n\n\t        loadFromBinary: function (/*Buffer*/ data) {\n\t            // data should be 46 bytes and start with \"PK 01 02\"\n\t            if (data.length !== Constants.CENHDR || data.readUInt32LE(0) !== Constants.CENSIG) {\n\t                throw Utils.Errors.INVALID_CEN();\n\t            }\n\t            // version made by\n\t            _verMade = data.readUInt16LE(Constants.CENVEM);\n\t            // version needed to extract\n\t            _version = data.readUInt16LE(Constants.CENVER);\n\t            // encrypt, decrypt flags\n\t            _flags = data.readUInt16LE(Constants.CENFLG);\n\t            // compression method\n\t            _method = data.readUInt16LE(Constants.CENHOW);\n\t            // modification time (2 bytes time, 2 bytes date)\n\t            _time = data.readUInt32LE(Constants.CENTIM);\n\t            // uncompressed file crc-32 value\n\t            _crc = data.readUInt32LE(Constants.CENCRC);\n\t            // compressed size\n\t            _compressedSize = data.readUInt32LE(Constants.CENSIZ);\n\t            // uncompressed size\n\t            _size = data.readUInt32LE(Constants.CENLEN);\n\t            // filename length\n\t            _fnameLen = data.readUInt16LE(Constants.CENNAM);\n\t            // extra field length\n\t            _extraLen = data.readUInt16LE(Constants.CENEXT);\n\t            // file comment length\n\t            _comLen = data.readUInt16LE(Constants.CENCOM);\n\t            // volume number start\n\t            _diskStart = data.readUInt16LE(Constants.CENDSK);\n\t            // internal file attributes\n\t            _inattr = data.readUInt16LE(Constants.CENATT);\n\t            // external file attributes\n\t            _attr = data.readUInt32LE(Constants.CENATX);\n\t            // LOC header offset\n\t            _offset = data.readUInt32LE(Constants.CENOFF);\n\t        },\n\n\t        localHeaderToBinary: function () {\n\t            // LOC header size (30 bytes)\n\t            var data = Buffer.alloc(Constants.LOCHDR);\n\t            // \"PK\\003\\004\"\n\t            data.writeUInt32LE(Constants.LOCSIG, 0);\n\t            // version needed to extract\n\t            data.writeUInt16LE(_version, Constants.LOCVER);\n\t            // general purpose bit flag\n\t            data.writeUInt16LE(_flags, Constants.LOCFLG);\n\t            // compression method\n\t            data.writeUInt16LE(_method, Constants.LOCHOW);\n\t            // modification time (2 bytes time, 2 bytes date)\n\t            data.writeUInt32LE(_time, Constants.LOCTIM);\n\t            // uncompressed file crc-32 value\n\t            data.writeUInt32LE(_crc, Constants.LOCCRC);\n\t            // compressed size\n\t            data.writeUInt32LE(_compressedSize, Constants.LOCSIZ);\n\t            // uncompressed size\n\t            data.writeUInt32LE(_size, Constants.LOCLEN);\n\t            // filename length\n\t            data.writeUInt16LE(_fnameLen, Constants.LOCNAM);\n\t            // extra field length\n\t            data.writeUInt16LE(_localHeader.extraLen, Constants.LOCEXT);\n\t            return data;\n\t        },\n\n\t        centralHeaderToBinary: function () {\n\t            // CEN header size (46 bytes)\n\t            var data = Buffer.alloc(Constants.CENHDR + _fnameLen + _extraLen + _comLen);\n\t            // \"PK\\001\\002\"\n\t            data.writeUInt32LE(Constants.CENSIG, 0);\n\t            // version made by\n\t            data.writeUInt16LE(_verMade, Constants.CENVEM);\n\t            // version needed to extract\n\t            data.writeUInt16LE(_version, Constants.CENVER);\n\t            // encrypt, decrypt flags\n\t            data.writeUInt16LE(_flags, Constants.CENFLG);\n\t            // compression method\n\t            data.writeUInt16LE(_method, Constants.CENHOW);\n\t            // modification time (2 bytes time, 2 bytes date)\n\t            data.writeUInt32LE(_time, Constants.CENTIM);\n\t            // uncompressed file crc-32 value\n\t            data.writeUInt32LE(_crc, Constants.CENCRC);\n\t            // compressed size\n\t            data.writeUInt32LE(_compressedSize, Constants.CENSIZ);\n\t            // uncompressed size\n\t            data.writeUInt32LE(_size, Constants.CENLEN);\n\t            // filename length\n\t            data.writeUInt16LE(_fnameLen, Constants.CENNAM);\n\t            // extra field length\n\t            data.writeUInt16LE(_extraLen, Constants.CENEXT);\n\t            // file comment length\n\t            data.writeUInt16LE(_comLen, Constants.CENCOM);\n\t            // volume number start\n\t            data.writeUInt16LE(_diskStart, Constants.CENDSK);\n\t            // internal file attributes\n\t            data.writeUInt16LE(_inattr, Constants.CENATT);\n\t            // external file attributes\n\t            data.writeUInt32LE(_attr, Constants.CENATX);\n\t            // LOC header offset\n\t            data.writeUInt32LE(_offset, Constants.CENOFF);\n\t            return data;\n\t        },\n\n\t        toJSON: function () {\n\t            const bytes = function (nr) {\n\t                return nr + \" bytes\";\n\t            };\n\n\t            return {\n\t                made: _verMade,\n\t                version: _version,\n\t                flags: _flags,\n\t                method: Utils.methodToString(_method),\n\t                time: this.time,\n\t                crc: \"0x\" + _crc.toString(16).toUpperCase(),\n\t                compressedSize: bytes(_compressedSize),\n\t                size: bytes(_size),\n\t                fileNameLength: bytes(_fnameLen),\n\t                extraLength: bytes(_extraLen),\n\t                commentLength: bytes(_comLen),\n\t                diskNumStart: _diskStart,\n\t                inAttr: _inattr,\n\t                attr: _attr,\n\t                offset: _offset,\n\t                centralHeaderSize: bytes(Constants.CENHDR + _fnameLen + _extraLen + _comLen)\n\t            };\n\t        },\n\n\t        toString: function () {\n\t            return JSON.stringify(this.toJSON(), null, \"\\t\");\n\t        }\n\t    };\n\t};\n\treturn entryHeader;\n}\n\nvar mainHeader;\nvar hasRequiredMainHeader;\n\nfunction requireMainHeader () {\n\tif (hasRequiredMainHeader) return mainHeader;\n\thasRequiredMainHeader = 1;\n\tvar Utils = requireUtil(),\n\t    Constants = Utils.Constants;\n\n\t/* The entries in the end of central directory */\n\tmainHeader = function () {\n\t    var _volumeEntries = 0,\n\t        _totalEntries = 0,\n\t        _size = 0,\n\t        _offset = 0,\n\t        _commentLength = 0;\n\n\t    return {\n\t        get diskEntries() {\n\t            return _volumeEntries;\n\t        },\n\t        set diskEntries(/*Number*/ val) {\n\t            _volumeEntries = _totalEntries = val;\n\t        },\n\n\t        get totalEntries() {\n\t            return _totalEntries;\n\t        },\n\t        set totalEntries(/*Number*/ val) {\n\t            _totalEntries = _volumeEntries = val;\n\t        },\n\n\t        get size() {\n\t            return _size;\n\t        },\n\t        set size(/*Number*/ val) {\n\t            _size = val;\n\t        },\n\n\t        get offset() {\n\t            return _offset;\n\t        },\n\t        set offset(/*Number*/ val) {\n\t            _offset = val;\n\t        },\n\n\t        get commentLength() {\n\t            return _commentLength;\n\t        },\n\t        set commentLength(/*Number*/ val) {\n\t            _commentLength = val;\n\t        },\n\n\t        get mainHeaderSize() {\n\t            return Constants.ENDHDR + _commentLength;\n\t        },\n\n\t        loadFromBinary: function (/*Buffer*/ data) {\n\t            // data should be 22 bytes and start with \"PK 05 06\"\n\t            // or be 56+ bytes and start with \"PK 06 06\" for Zip64\n\t            if (\n\t                (data.length !== Constants.ENDHDR || data.readUInt32LE(0) !== Constants.ENDSIG) &&\n\t                (data.length < Constants.ZIP64HDR || data.readUInt32LE(0) !== Constants.ZIP64SIG)\n\t            ) {\n\t                throw Utils.Errors.INVALID_END();\n\t            }\n\n\t            if (data.readUInt32LE(0) === Constants.ENDSIG) {\n\t                // number of entries on this volume\n\t                _volumeEntries = data.readUInt16LE(Constants.ENDSUB);\n\t                // total number of entries\n\t                _totalEntries = data.readUInt16LE(Constants.ENDTOT);\n\t                // central directory size in bytes\n\t                _size = data.readUInt32LE(Constants.ENDSIZ);\n\t                // offset of first CEN header\n\t                _offset = data.readUInt32LE(Constants.ENDOFF);\n\t                // zip file comment length\n\t                _commentLength = data.readUInt16LE(Constants.ENDCOM);\n\t            } else {\n\t                // number of entries on this volume\n\t                _volumeEntries = Utils.readBigUInt64LE(data, Constants.ZIP64SUB);\n\t                // total number of entries\n\t                _totalEntries = Utils.readBigUInt64LE(data, Constants.ZIP64TOT);\n\t                // central directory size in bytes\n\t                _size = Utils.readBigUInt64LE(data, Constants.ZIP64SIZE);\n\t                // offset of first CEN header\n\t                _offset = Utils.readBigUInt64LE(data, Constants.ZIP64OFF);\n\n\t                _commentLength = 0;\n\t            }\n\t        },\n\n\t        toBinary: function () {\n\t            var b = Buffer.alloc(Constants.ENDHDR + _commentLength);\n\t            // \"PK 05 06\" signature\n\t            b.writeUInt32LE(Constants.ENDSIG, 0);\n\t            b.writeUInt32LE(0, 4);\n\t            // number of entries on this volume\n\t            b.writeUInt16LE(_volumeEntries, Constants.ENDSUB);\n\t            // total number of entries\n\t            b.writeUInt16LE(_totalEntries, Constants.ENDTOT);\n\t            // central directory size in bytes\n\t            b.writeUInt32LE(_size, Constants.ENDSIZ);\n\t            // offset of first CEN header\n\t            b.writeUInt32LE(_offset, Constants.ENDOFF);\n\t            // zip file comment length\n\t            b.writeUInt16LE(_commentLength, Constants.ENDCOM);\n\t            // fill comment memory with spaces so no garbage is left there\n\t            b.fill(\" \", Constants.ENDHDR);\n\n\t            return b;\n\t        },\n\n\t        toJSON: function () {\n\t            // creates 0x0000 style output\n\t            const offset = function (nr, len) {\n\t                let offs = nr.toString(16).toUpperCase();\n\t                while (offs.length < len) offs = \"0\" + offs;\n\t                return \"0x\" + offs;\n\t            };\n\n\t            return {\n\t                diskEntries: _volumeEntries,\n\t                totalEntries: _totalEntries,\n\t                size: _size + \" bytes\",\n\t                offset: offset(_offset, 4),\n\t                commentLength: _commentLength\n\t            };\n\t        },\n\n\t        toString: function () {\n\t            return JSON.stringify(this.toJSON(), null, \"\\t\");\n\t        }\n\t    };\n\t};\n\t// Misspelled\n\treturn mainHeader;\n}\n\nvar hasRequiredHeaders;\n\nfunction requireHeaders () {\n\tif (hasRequiredHeaders) return headers;\n\thasRequiredHeaders = 1;\n\theaders.EntryHeader = requireEntryHeader();\n\theaders.MainHeader = requireMainHeader();\n\treturn headers;\n}\n\nvar methods = {};\n\nvar domain;\n\n// This constructor is used to store event handlers. Instantiating this is\n// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n// object (tested with v8 v4.9).\nfunction EventHandlers() {}\nEventHandlers.prototype = Object.create(null);\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\n\n// nodejs oddity\n// require('events') === require('events').EventEmitter\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this.domain = null;\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    if (domain.active ) ;\n  }\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  domain = this.domain;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    er = arguments[1];\n    if (domain) {\n      if (!er)\n        er = new Error('Uncaught, unspecified \"error\" event');\n      er.domainEmitter = this;\n      er.domain = domain;\n      er.domainThrown = false;\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = new EventHandlers();\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] :\n                                          [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n                            existing.length + ' ' + type + ' listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        emitWarning(w);\n      }\n    }\n  }\n\n  return target;\n}\nfunction emitWarning(e) {\n  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction _onceWrap(target, type, listener) {\n  var fired = false;\n  function g() {\n    target.removeListener(type, g);\n    if (!fired) {\n      fired = true;\n      listener.apply(target, arguments);\n    }\n  }\n  g.listener = listener;\n  return g;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || (list.listener && list.listener === listener)) {\n        if (--this._eventsCount === 0)\n          this._events = new EventHandlers();\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length; i-- > 0;) {\n          if (list[i] === listener ||\n              (list[i].listener && list[i].listener === listener)) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (list.length === 1) {\n          list[0] = undefined;\n          if (--this._eventsCount === 0) {\n            this._events = new EventHandlers();\n            return this;\n          } else {\n            delete events[type];\n          }\n        } else {\n          spliceOne(list, position);\n        }\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n    \n// Alias for removeListener added in NodeJS 10.0\n// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener\nEventEmitter.prototype.off = function(type, listener){\n    return this.removeListener(type, listener);\n};\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = new EventHandlers();\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = new EventHandlers();\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        for (var i = 0, key; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = new EventHandlers();\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        do {\n          this.removeListener(type, listeners[listeners.length - 1]);\n        } while (listeners[0]);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n\n  if (!events)\n    ret = [];\n  else {\n    evlistener = events[type];\n    if (!evlistener)\n      ret = [];\n    else if (typeof evlistener === 'function')\n      ret = [evlistener.listener || evlistener];\n    else\n      ret = unwrapListeners(evlistener);\n  }\n\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount$1.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount$1;\nfunction listenerCount$1(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, i) {\n  var copy = new Array(i);\n  while (i--)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n// shim for using process in browser\n// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\nvar cachedSetTimeout = defaultSetTimout;\nvar cachedClearTimeout = defaultClearTimeout;\nif (typeof global.setTimeout === 'function') {\n    cachedSetTimeout = setTimeout;\n}\nif (typeof global.clearTimeout === 'function') {\n    cachedClearTimeout = clearTimeout;\n}\n\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\nfunction nextTick(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n}\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nvar title = 'browser';\nvar platform = 'browser';\nvar browser = true;\nvar env = {};\nvar argv = [];\nvar version = ''; // empty string to avoid regexp issues\nvar versions = {};\nvar release = {};\nvar config = {};\n\nfunction noop() {}\n\nvar on = noop;\nvar addListener = noop;\nvar once = noop;\nvar off = noop;\nvar removeListener = noop;\nvar removeAllListeners = noop;\nvar emit = noop;\n\nfunction binding$1(name) {\n    throw new Error('process.binding is not supported');\n}\n\nfunction cwd () { return '/' }\nfunction chdir (dir) {\n    throw new Error('process.chdir is not supported');\n}function umask() { return 0; }\n\n// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\nvar performance = global.performance || {};\nvar performanceNow =\n  performance.now        ||\n  performance.mozNow     ||\n  performance.msNow      ||\n  performance.oNow       ||\n  performance.webkitNow  ||\n  function(){ return (new Date()).getTime() };\n\n// generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\nfunction hrtime(previousTimestamp){\n  var clocktime = performanceNow.call(performance)*1e-3;\n  var seconds = Math.floor(clocktime);\n  var nanoseconds = Math.floor((clocktime%1)*1e9);\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0];\n    nanoseconds = nanoseconds - previousTimestamp[1];\n    if (nanoseconds<0) {\n      seconds--;\n      nanoseconds += 1e9;\n    }\n  }\n  return [seconds,nanoseconds]\n}\n\nvar startTime = new Date();\nfunction uptime() {\n  var currentTime = new Date();\n  var dif = currentTime - startTime;\n  return dif / 1000;\n}\n\nvar browser$1 = {\n  nextTick: nextTick,\n  title: title,\n  browser: browser,\n  env: env,\n  argv: argv,\n  version: version,\n  versions: versions,\n  on: on,\n  addListener: addListener,\n  once: once,\n  off: off,\n  removeListener: removeListener,\n  removeAllListeners: removeAllListeners,\n  emit: emit,\n  binding: binding$1,\n  cwd: cwd,\n  chdir: chdir,\n  umask: umask,\n  hrtime: hrtime,\n  platform: platform,\n  release: release,\n  config: config,\n  uptime: uptime\n};\n\nvar inherits;\nif (typeof Object.create === 'function'){\n  inherits = function inherits(ctor, superCtor) {\n    // implementation from standard node.js 'util' module\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  inherits = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  };\n}\nvar inherits$1 = inherits;\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nfunction format(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n}\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nfunction deprecate(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (browser$1.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (browser$1.throwDeprecation) {\n        throw new Error(msg);\n      } else if (browser$1.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\nvar debugs = {};\nvar debugEnviron;\nfunction debuglog(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = browser$1.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = 0;\n      debugs[set] = function() {\n        var msg = format.apply(null, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n}\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    _extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray$1(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var length = output.reduce(function(prev, cur) {\n    if (cur.indexOf('\\n') >= 0) ;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray$1(ar) {\n  return Array.isArray(ar);\n}\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\n\nfunction isNull(arg) {\n  return arg === null;\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\nfunction _extend(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n}\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar inited = false;\nfunction init () {\n  inited = true;\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n  }\n\n  revLookup['-'.charCodeAt(0)] = 62;\n  revLookup['_'.charCodeAt(0)] = 63;\n}\n\nfunction toByteArray (b64) {\n  if (!inited) {\n    init();\n  }\n  var i, j, l, tmp, placeHolders, arr;\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\n  // base64 is 4/3 + up to two characters of the original data\n  arr = new Arr(len * 3 / 4 - placeHolders);\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len;\n\n  var L = 0;\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];\n    arr[L++] = (tmp >> 16) & 0xFF;\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[L++] = tmp & 0xFF;\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  if (!inited) {\n    init();\n  }\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var output = '';\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    output += lookup[tmp >> 2];\n    output += lookup[(tmp << 4) & 0x3F];\n    output += '==';\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);\n    output += lookup[tmp >> 10];\n    output += lookup[(tmp >> 4) & 0x3F];\n    output += lookup[(tmp << 2) & 0x3F];\n    output += '=';\n  }\n\n  parts.push(output);\n\n  return parts.join('')\n}\n\nfunction read (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? (nBytes - 1) : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nfunction write (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n  var i = isLE ? 0 : (nBytes - 1);\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n}\n\nvar toString = {}.toString;\n\nvar isArray = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\nvar INSPECT_MAX_BYTES = 50;\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer$1.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : true;\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nkMaxLength();\n\nfunction kMaxLength () {\n  return Buffer$1.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer$1.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer$1.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer$1(length);\n    }\n    that.length = length;\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer$1 (arg, encodingOrOffset, length) {\n  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {\n    return new Buffer$1(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer$1.poolSize = 8192; // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer$1._augment = function (arr) {\n  arr.__proto__ = Buffer$1.prototype;\n  return arr\n};\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer$1.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n};\n\nif (Buffer$1.TYPED_ARRAY_SUPPORT) {\n  Buffer$1.prototype.__proto__ = Uint8Array.prototype;\n  Buffer$1.__proto__ = Uint8Array;\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer$1[Symbol.species] === Buffer$1) ;\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer$1.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n};\n\nfunction allocUnsafe (that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer$1.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer$1.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n};\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer$1.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer$1.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer$1.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (internalIsBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\nBuffer$1.isBuffer = isBuffer;\nfunction internalIsBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer$1.compare = function compare (a, b) {\n  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\nBuffer$1.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n};\n\nBuffer$1.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer$1.alloc(0)\n  }\n\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer$1.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!internalIsBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer\n};\n\nfunction byteLength (string, encoding) {\n  if (internalIsBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\nBuffer$1.byteLength = byteLength;\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false;\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0;\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer$1.prototype._isBuffer = true;\n\nfunction swap (b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer$1.prototype.swap16 = function swap16 () {\n  var len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n  return this\n};\n\nBuffer$1.prototype.swap32 = function swap32 () {\n  var len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n  return this\n};\n\nBuffer$1.prototype.swap64 = function swap64 () {\n  var len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n  return this\n};\n\nBuffer$1.prototype.toString = function toString () {\n  var length = this.length | 0;\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n};\n\nBuffer$1.prototype.equals = function equals (b) {\n  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer$1.compare(this, b) === 0\n};\n\nBuffer$1.prototype.inspect = function inspect () {\n  var str = '';\n  var max = INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n  return '<Buffer ' + str + '>'\n};\n\nBuffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!internalIsBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  byteOffset = +byteOffset;  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1);\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer$1.from(val, encoding);\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (internalIsBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n    if (Buffer$1.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i;\n  if (dir) {\n    var foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer$1.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n};\n\nBuffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n};\n\nBuffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n};\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed;\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer$1.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer$1.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n};\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return fromByteArray(buf)\n  } else {\n    return fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n\n  var i = start;\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = '';\n  var i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    );\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n  return res\n}\n\nBuffer$1.prototype.slice = function slice (start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n\n  var newBuf;\n  if (Buffer$1.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer$1.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer$1(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf\n};\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val\n};\n\nBuffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val\n};\n\nBuffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset]\n};\n\nBuffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | (this[offset + 1] << 8)\n};\n\nBuffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return (this[offset] << 8) | this[offset + 1]\n};\n\nBuffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n};\n\nBuffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n};\n\nBuffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n};\n\nBuffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | (this[offset + 1] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | (this[offset] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n};\n\nBuffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n};\n\nBuffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, true, 23, 4)\n};\n\nBuffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, false, 23, 4)\n};\n\nBuffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, true, 52, 8)\n};\n\nBuffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, false, 52, 8)\n};\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer$1.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer$1.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;\n  }\n}\n\nBuffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer$1.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 1] = (value >>> 8);\n    this[offset] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer$1.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nBuffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nBuffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer$1.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer$1.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nBuffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (Buffer$1.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 3] = (value >>> 24);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  if (Buffer$1.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4);\n  }\n  write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4\n}\n\nBuffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n};\n\nBuffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n};\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8);\n  }\n  write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8\n}\n\nBuffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n};\n\nBuffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer$1.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    );\n  }\n\n  return len\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer$1.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = internalIsBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer$1(val, encoding).toString());\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this\n};\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray\n}\n\n\nfunction base64ToBytes (str) {\n  return toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i];\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj) {\n  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n}\n\nfunction isFastBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))\n}\n\nfunction BufferList() {\n  this.head = null;\n  this.tail = null;\n  this.length = 0;\n}\n\nBufferList.prototype.push = function (v) {\n  var entry = { data: v, next: null };\n  if (this.length > 0) this.tail.next = entry;else this.head = entry;\n  this.tail = entry;\n  ++this.length;\n};\n\nBufferList.prototype.unshift = function (v) {\n  var entry = { data: v, next: this.head };\n  if (this.length === 0) this.tail = entry;\n  this.head = entry;\n  ++this.length;\n};\n\nBufferList.prototype.shift = function () {\n  if (this.length === 0) return;\n  var ret = this.head.data;\n  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n  --this.length;\n  return ret;\n};\n\nBufferList.prototype.clear = function () {\n  this.head = this.tail = null;\n  this.length = 0;\n};\n\nBufferList.prototype.join = function (s) {\n  if (this.length === 0) return '';\n  var p = this.head;\n  var ret = '' + p.data;\n  while (p = p.next) {\n    ret += s + p.data;\n  }return ret;\n};\n\nBufferList.prototype.concat = function (n) {\n  if (this.length === 0) return Buffer$1.alloc(0);\n  if (this.length === 1) return this.head.data;\n  var ret = Buffer$1.allocUnsafe(n >>> 0);\n  var p = this.head;\n  var i = 0;\n  while (p) {\n    p.data.copy(ret, i);\n    i += p.data.length;\n    p = p.next;\n  }\n  return ret;\n};\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar isBufferEncoding = Buffer$1.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     };\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nfunction StringDecoder(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer$1(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n}\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\nReadable.ReadableState = ReadableState;\n\nvar debug = debuglog('stream');\ninherits$1(Readable, EventEmitter);\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') {\n    return emitter.prependListener(event, fn);\n  } else {\n    // This is a hack to make sure that our error handler is attached before any\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\n    // to continue to work with older versions of Node.js that do not include\n    // the prependListener() method. The goal is to eventually remove this hack.\n    if (!emitter._events || !emitter._events[event])\n      emitter.on(event, fn);\n    else if (Array.isArray(emitter._events[event]))\n      emitter._events[event].unshift(fn);\n    else\n      emitter._events[event] = [fn, emitter._events[event]];\n  }\n}\nfunction listenerCount (emitter, type) {\n  return emitter.listeners(type).length;\n}\nfunction ReadableState(options, stream) {\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options && typeof options.read === 'function') this._read = options.read;\n\n  EventEmitter.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = Buffer.from(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var _e = new Error('stream.unshift() after end event');\n      stream.emit('error', _e);\n    } else {\n      var skipAdd;\n      if (state.decoder && !addToFront && !encoding) {\n        chunk = state.decoder.write(chunk);\n        skipAdd = !state.objectMode && chunk.length === 0;\n      }\n\n      if (!addToFront) state.reading = false;\n\n      // Don't add to the buffer if we've decoded to an empty string chunk and\n      // we're not in object mode\n      if (!skipAdd) {\n        // if we want the data now, just emit it.\n        if (state.flowing && state.length === 0 && !state.sync) {\n          stream.emit('data', chunk);\n          stream.read(0);\n        } else {\n          // update the buffer info.\n          state.length += state.objectMode ? 1 : chunk.length;\n          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n          if (state.needReadable) emitReadable(stream);\n        }\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false);\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (listenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && src.listeners('data').length) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var _i = 0; _i < len; _i++) {\n      dests[_i].emit('unpipe', this);\n    }return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1) return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = EventEmitter.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function (ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\nWritable.WritableState = WritableState;\ninherits$1(Writable, EventEmitter);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nfunction WritableState(options, stream) {\n  Object.defineProperty(this, 'buffer', {\n    get: deprecate(function () {\n      return this.getBuffer();\n    }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n  });\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\nfunction Writable(options) {\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n  }\n\n  EventEmitter.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  nextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n  // Always throw error if a null is written\n  // if we are not in object mode then throw\n  // if it is not a buffer, string, or undefined.\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (!Buffer$1.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer$1.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer$1.from(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer$1.isBuffer(chunk)) encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) nextTick(cb, er);else cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n        nextTick(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n        afterWrite(stream, state, finished, cb);\n      }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;\n    }\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;\n    } else {\n      state.corkedRequestsFree = _this;\n    }\n  };\n}\n\ninherits$1(Duplex, Readable);\n\nvar keys = Object.keys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\ninherits$1(Transform, Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er) {\n      done(stream, er);\n    });else done(stream);\n  });\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('Not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nfunction done(stream, er) {\n  if (er) return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\ninherits$1(PassThrough, Transform);\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\ninherits$1(Stream, EventEmitter);\nStream.Readable = Readable;\nStream.Writable = Writable;\nStream.Duplex = Duplex;\nStream.Transform = Transform;\nStream.PassThrough = PassThrough;\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EventEmitter.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EventEmitter.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\nvar msg = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nfunction arraySet(dest, src, src_offs, len, dest_offs) {\n  if (src.subarray && dest.subarray) {\n    dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n    return;\n  }\n  // Fallback to ordinary array\n  for (var i = 0; i < len; i++) {\n    dest[dest_offs + i] = src[src_offs + i];\n  }\n}\n\n\nvar Buf8 = Uint8Array;\nvar Buf16 = Uint16Array;\nvar Buf32 = Int32Array;\n// Enable/Disable typed arrays use, for testing\n//\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED$2 = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY$1 = 0;\nvar Z_TEXT$1 = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN$2 = 2;\n\n/*============================================================================*/\n\n\nfunction zero$1(buf) {\n  var len = buf.length;\n  while (--len >= 0) {\n    buf[len] = 0;\n  }\n}\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH$1 = 3;\nvar MAX_MATCH$1 = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES$1 = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS$1 = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES$1 = 30;\n/* number of distance codes */\n\nvar BL_CODES$1 = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE$1 = 2 * L_CODES$1 + 1;\n/* maximum heap size */\n\nvar MAX_BITS$1 = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK = 256;\n/* end of block literal code */\n\nvar REP_3_6 = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10 = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits = /* extra bits for each length code */ [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\n\nvar extra_dbits = /* extra bits for each distance code */ [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n\nvar extra_blbits = /* extra bits for each bit length code */ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\n\nvar bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree = new Array((L_CODES$1 + 2) * 2);\nzero$1(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree = new Array(D_CODES$1 * 2);\nzero$1(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code = new Array(DIST_CODE_LEN);\nzero$1(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);\nzero$1(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length = new Array(LENGTH_CODES$1);\nzero$1(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist = new Array(D_CODES$1);\nzero$1(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree = static_tree; /* static tree or NULL */\n  this.extra_bits = extra_bits; /* extra bits for each code or NULL */\n  this.extra_base = extra_base; /* base index for extra_bits */\n  this.elems = elems; /* max number of elements in the tree */\n  this.max_length = max_length; /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree; /* the dynamic tree */\n  this.max_code = 0; /* largest code with non zero frequency */\n  this.stat_desc = stat_desc; /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n  //    put_byte(s, (uch)((w) & 0xff));\n  //    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2] /*.Code*/ , tree[c * 2 + 1] /*.Len*/ );\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc) {\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n  var tree = desc.dyn_tree;\n  var max_code = desc.max_code;\n  var stree = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var extra = desc.stat_desc.extra_bits;\n  var base = desc.stat_desc.extra_base;\n  var max_length = desc.stat_desc.max_length;\n  var h; /* heap index */\n  var n, m; /* iterate over the tree elements */\n  var bits; /* bit length */\n  var xbits; /* extra bits */\n  var f; /* frequency */\n  var overflow = 0; /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1] /*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) {\n      continue;\n    } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2] /*.Freq*/ ;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) {\n    return;\n  }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) {\n      bits--;\n    }\n    s.bl_count[bits]--; /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) {\n        continue;\n      }\n      if (tree[m * 2 + 1] /*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1] /*.Len*/ ) * tree[m * 2] /*.Freq*/ ;\n        tree[m * 2 + 1] /*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count) {\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n\n  var next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */\n  var code = 0; /* running code value */\n  var bits; /* bit index */\n  var n; /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS$1; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0; n <= max_code; n++) {\n    var len = tree[n * 2 + 1] /*.Len*/ ;\n    if (len === 0) {\n      continue;\n    }\n    /* Now reverse the bits */\n    tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n; /* iterates over tree elements */\n  var bits; /* bit counter */\n  var length; /* length value */\n  var code; /* code value */\n  var dist; /* distance index */\n  var bl_count = new Array(MAX_BITS$1 + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n  /*#ifdef NO_INIT_GLOBAL_POINTERS\n    static_l_desc.static_tree = static_ltree;\n    static_l_desc.extra_bits = extra_lbits;\n    static_d_desc.static_tree = static_dtree;\n    static_d_desc.extra_bits = extra_dbits;\n    static_bl_desc.extra_bits = extra_blbits;\n  #endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES$1; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1] /*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1] /*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1] /*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1] /*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES$1; n++) {\n    static_dtree[n * 2 + 1] /*.Len*/ = 5;\n    static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES$1; n++) {\n    s.dyn_ltree[n * 2] /*.Freq*/ = 0;\n  }\n  for (n = 0; n < D_CODES$1; n++) {\n    s.dyn_dtree[n * 2] /*.Freq*/ = 0;\n  }\n  for (n = 0; n < BL_CODES$1; n++) {\n    s.bl_tree[n * 2] /*.Freq*/ = 0;\n  }\n\n  s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s) {\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header) {\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n\n  bi_windup(s); /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n  //  while (len--) {\n  //    put_byte(s, *buf++);\n  //  }\n  arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ ||\n    (tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1; /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) {\n      break;\n    }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist; /* distance of matched string */\n  var lc; /* match length or unmatched char (if dist == 0) */\n  var lx = 0; /* running index in l_buf */\n  var code; /* the code to send */\n  var extra; /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra); /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree); /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra); /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree = desc.dyn_tree;\n  var stree = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems = desc.stat_desc.elems;\n  var n, m; /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node; /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE$1;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2] /*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1] /*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2] /*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1] /*.Len*/ ;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1 /*int /2*/ ); n >= 1; n--) {\n    pqdownheap(s, tree, n);\n  }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems; /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1 /*SMALLEST*/ ];\n    s.heap[1 /*SMALLEST*/ ] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1 /*SMALLEST*/ );\n    /***/\n\n    m = s.heap[1 /*SMALLEST*/ ]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/ ;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1 /*SMALLEST*/ ] = node++;\n    pqdownheap(s, tree, 1 /*SMALLEST*/ );\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/ ];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n; /* iterates over all tree elements */\n  var prevlen = -1; /* last emitted length */\n  var curlen; /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1] /*.Len*/ ; /* length of next code */\n\n  var count = 0; /* repeat count of the current code */\n  var max_count = 7; /* max repeat count */\n  var min_count = 4; /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2] /*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) {\n        s.bl_tree[curlen * 2] /*.Freq*/ ++;\n      }\n      s.bl_tree[REP_3_6 * 2] /*.Freq*/ ++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/ ++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/ ++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n; /* iterates over all tree elements */\n  var prevlen = -1; /* last emitted length */\n  var curlen; /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1] /*.Len*/ ; /* length of next code */\n\n  var count = 0; /* repeat count of the current code */\n  var max_count = 7; /* max repeat count */\n  var min_count = 4; /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */\n  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do {\n        send_code(s, curlen, s.bl_tree);\n      } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex; /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank; /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1, 5);\n  send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/ , 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2] /*.Freq*/ !== 0)) {\n      return Z_BINARY$1;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 ||\n    s.dyn_ltree[13 * 2] /*.Freq*/ !== 0) {\n    return Z_TEXT$1;\n  }\n  for (n = 32; n < LITERALS$1; n++) {\n    if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {\n      return Z_TEXT$1;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY$1;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s) {\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb; /* opt_len and static_len in bytes */\n  var max_blindex = 0; /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN$2) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) {\n      opt_lenb = static_lenb;\n    }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED$2 || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2] /*.Freq*/ ++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--; /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2] /*.Freq*/ ++;\n    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/ ++;\n  }\n\n  // (!) This block is disabled in zlib defailts,\n  // don't enable it for binary compatibility\n\n  //#ifdef TRUNCATE_BLOCK\n  //  /* Try to guess if it is profitable to stop the current block here */\n  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n  //    /* Compute an upper bound for the compressed length */\n  //    out_length = s.last_lit*8;\n  //    in_length = s.strstart - s.block_start;\n  //\n  //    for (dcode = 0; dcode < D_CODES; dcode++) {\n  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n  //    }\n  //    out_length >>>= 3;\n  //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n  //    //       s->last_lit, in_length, out_length,\n  //    //       100L - out_length*100L/in_length));\n  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n  //      return true;\n  //    }\n  //  }\n  //#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It doesn't worth to make additional optimizationa as in original.\n// Small size is preferable.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH$1 = 0;\nvar Z_PARTIAL_FLUSH$1 = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH$1 = 3;\nvar Z_FINISH$2 = 4;\nvar Z_BLOCK$2 = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK$2 = 0;\nvar Z_STREAM_END$2 = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR$2 = -2;\nvar Z_DATA_ERROR$2 = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR$2 = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION$1 = -1;\n\n\nvar Z_FILTERED$1 = 1;\nvar Z_HUFFMAN_ONLY$1 = 2;\nvar Z_RLE$1 = 3;\nvar Z_FIXED$1 = 4;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN$1 = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED$2 = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n\n\nvar LENGTH_CODES = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES = 30;\n/* number of distance codes */\nvar BL_CODES = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) {\n  var len = buf.length;\n  while (--len >= 0) {\n    buf[len] = 0;\n  }\n}\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) {\n    return;\n  }\n\n  arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n  //  put_byte(s, (Byte)(b >> 8));\n  //  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) {\n    len = size;\n  }\n  if (len === 0) {\n    return 0;\n  }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  } else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length; /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match; /* matched string */\n  var len; /* length of current match */\n  var best_len = s.prev_length; /* best match length so far */\n  var nice_match = s.nice_match; /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n    s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/ ;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1 = _win[scan + best_len - 1];\n  var scan_end = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) {\n    nice_match = s.lookahead;\n  }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len] !== scan_end ||\n      _win[match + best_len - 1] !== scan_end1 ||\n      _win[match] !== _win[scan] ||\n      _win[++match] !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n      scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1 = _win[scan + best_len - 1];\n      scan_end = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n      //#if MIN_MATCH != 3\n      //        Call update_hash() MIN_MATCH-3 more times\n      //#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n  //  if (s.high_water < s.window_size) {\n  //    var curr = s.strstart + s.lookahead;\n  //    var init = 0;\n  //\n  //    if (s.high_water < curr) {\n  //      /* Previous high water mark below current data -- zero WIN_INIT\n  //       * bytes or up to end of window, whichever is less.\n  //       */\n  //      init = s.window_size - curr;\n  //      if (init > WIN_INIT)\n  //        init = WIN_INIT;\n  //      zmemzero(s->window + curr, (unsigned)init);\n  //      s->high_water = curr + init;\n  //    }\n  //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n  //      /* High water mark at or above current data, but below current data\n  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n  //       * to end of window, whichever is less.\n  //       */\n  //      init = (ulg)curr + WIN_INIT - s->high_water;\n  //      if (init > s->window_size - s->high_water)\n  //        init = s->window_size - s->high_water;\n  //      zmemzero(s->window + s->high_water, (unsigned)init);\n  //      s->high_water += init;\n  //    }\n  //  }\n  //\n  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n  //    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n      //        s.block_start >= s.w_size)) {\n      //        throw  new Error(\"slide too late\");\n      //      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH$1) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n    //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH$2) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head; /* head of the hash chain */\n  var bflush; /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0 /*NIL*/ ;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0 /*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match /*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n        //#if MIN_MATCH != 3\n        //                Call UPDATE_HASH() MIN_MATCH-3 more times\n        //#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH$2) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head; /* head of hash chain */\n  var bflush; /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break;\n      } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0 /*NIL*/ ;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0 /*NIL*/ && s.prev_length < s.max_lazy_match &&\n      s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD) /*MAX_DIST(s)*/ ) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n        (s.strategy === Z_FILTERED$1 || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/ ))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH$2) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush; /* set if current block must be flushed */\n  var prev; /* byte at distance one to match */\n  var scan, strend; /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$1) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break;\n      } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n          prev === _win[++scan] && prev === _win[++scan] &&\n          prev === _win[++scan] && prev === _win[++scan] &&\n          prev === _win[++scan] && prev === _win[++scan] &&\n          scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$2) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush; /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH$1) {\n          return BS_NEED_MORE;\n        }\n        break; /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$2) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored), /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast), /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast), /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast), /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow), /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow), /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow), /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow), /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow), /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null; /* pointer back to this zlib stream */\n  this.status = 0; /* as the name implies */\n  this.pending_buf = null; /* output still pending */\n  this.pending_buf_size = 0; /* size of pending_buf */\n  this.pending_out = 0; /* next pending byte to output to the stream */\n  this.pending = 0; /* nb of bytes in the pending buffer */\n  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null; /* gzip header information to write */\n  this.gzindex = 0; /* where in extra, name, or comment */\n  this.method = Z_DEFLATED$2; /* can only be DEFLATED */\n  this.last_flush = -1; /* value of flush param for previous deflate call */\n\n  this.w_size = 0; /* LZ77 window size (32K by default) */\n  this.w_bits = 0; /* log2(w_size)  (8..16) */\n  this.w_mask = 0; /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null; /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0; /* hash index of string to be inserted */\n  this.hash_size = 0; /* number of elements in hash table */\n  this.hash_bits = 0; /* log2(hash_size) */\n  this.hash_mask = 0; /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0; /* length of best match */\n  this.prev_match = 0; /* previous match */\n  this.match_available = 0; /* set if previous match exists */\n  this.strstart = 0; /* start of string to insert */\n  this.match_start = 0; /* start of matching string */\n  this.lookahead = 0; /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0; /* compression level (1..9) */\n  this.strategy = 0; /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n  /* used by c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree = new Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree = new Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree = new Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc = null; /* desc. for literal tree */\n  this.d_desc = null; /* desc. for distance tree */\n  this.bl_desc = null; /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0; /* number of elements in the heap */\n  this.heap_max = 0; /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all\n   */\n\n  this.depth = new Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0; /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0; /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0; /* bit length of current block with optimal trees */\n  this.static_len = 0; /* bit length of current block with static trees */\n  this.matches = 0; /* number of string matches in current block */\n  this.insert = 0; /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN$1;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0 // crc32(0, Z_NULL, 0)\n    :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH$1;\n  _tr_init(s);\n  return Z_OK$2;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK$2) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR$2;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION$1) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  } else if (windowBits > 15) {\n    wrap = 2; /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED$1) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new Buf8(s.w_size * 2);\n  s.head = new Buf16(s.hash_size);\n  s.prev = new Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\n\nfunction deflate$1(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK$2 || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n    (!strm.input && strm.avail_in !== 0) ||\n    (s.status === FINISH_STATE && flush !== Z_FINISH$2)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$2 : Z_STREAM_ERROR$2);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n    if (s.wrap === 2) {\n      // GZIP header\n      strm.adler = 0; //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n          (s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2 ?\n            4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      } else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n          (s.gzhead.hcrc ? 2 : 0) +\n          (!s.gzhead.extra ? 0 : 4) +\n          (!s.gzhead.name ? 0 : 8) +\n          (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n          (s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2 ?\n            4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    } else // DEFLATE header\n    {\n      var header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) {\n        header |= PRESET_DICT;\n      }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n  //#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra /* != Z_NULL*/ ) {\n      beg = s.pending; /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    } else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name /* != Z_NULL*/ ) {\n      beg = s.pending; /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    } else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment /* != Z_NULL*/ ) {\n      beg = s.pending; /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    } else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    } else {\n      s.status = BUSY_STATE;\n    }\n  }\n  //#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK$2;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH$2) {\n    return err(strm, Z_BUF_ERROR$2);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR$2);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH$1 && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY$1) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE$1 ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK$2;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH$1) {\n        _tr_align(s);\n      } else if (flush !== Z_BLOCK$2) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        _tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH$1) {\n          /*** CLEAR_HASH(s); ***/\n          /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK$2;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH$2) {\n    return Z_OK$2;\n  }\n  if (s.wrap <= 0) {\n    return Z_STREAM_END$2;\n  }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  } else {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) {\n    s.wrap = -s.wrap;\n  }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK$2 : Z_STREAM_END$2;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/ ) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$2;\n}\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n// See state defs from inflate.js\nvar BAD$1 = 30;       /* got a data error -- remain here until reset */\nvar TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nfunction inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD$1;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD$1;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD$1;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE$1;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD$1;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n}\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS$1 = 852;\nvar ENOUGH_DISTS$1 = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES$1 = 0;\nvar LENS$1 = 1;\nvar DISTS$1 = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nfunction inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {\n  var bits = opts.bits;\n  //here = opts.here; /* table entry for duplication */\n\n  var len = 0; /* a code's length in bits */\n  var sym = 0; /* index of code symbols */\n  var min = 0,\n    max = 0; /* minimum and maximum code lengths */\n  var root = 0; /* number of index bits for root table */\n  var curr = 0; /* number of index bits for current table */\n  var drop = 0; /* code bits to drop for sub-table */\n  var left = 0; /* number of prefix codes available */\n  var used = 0; /* code entries in table used */\n  var huff = 0; /* Huffman code */\n  var incr; /* for incrementing code, index */\n  var fill; /* index for replicating entries */\n  var low; /* low bits for current root entry */\n  var mask; /* mask for low root bits */\n  var next; /* next available space in table */\n  var base = null; /* base value table to use */\n  var base_index = 0;\n  //  var shoextra;    /* extra bits table to use */\n  var end; /* use base and extra for symbol > end */\n  var count = new Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) {\n      break;\n    }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) { /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0; /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) {\n      break;\n    }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    } /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES$1 || max !== 1)) {\n    return -1; /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES$1) {\n    base = extra = work; /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS$1) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else { /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0; /* starting code */\n  sym = 0; /* starting code symbol */\n  len = min; /* starting code length */\n  next = table_index; /* current table to fill in */\n  curr = root; /* current table index bits */\n  drop = 0; /* current bits to drop from code for index */\n  low = -1; /* trigger new sub-table when len > root */\n  used = 1 << root; /* use root table entries */\n  mask = used - 1; /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n    return 1;\n  }\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    } else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    } else {\n      here_op = 32 + 64; /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill; /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val | 0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) {\n        break;\n      }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min; /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) {\n          break;\n        }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n}\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH$1 = 4;\nvar Z_BLOCK$1 = 5;\nvar Z_TREES$1 = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK$1 = 0;\nvar Z_STREAM_END$1 = 1;\nvar Z_NEED_DICT$1 = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR$1 = -2;\nvar Z_DATA_ERROR$1 = -3;\nvar Z_MEM_ERROR = -4;\nvar Z_BUF_ERROR$1 = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED$1 = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar HEAD = 1; /* i: waiting for magic header */\nvar FLAGS = 2; /* i: waiting for method and flags (gzip) */\nvar TIME = 3; /* i: waiting for modification time (gzip) */\nvar OS = 4; /* i: waiting for extra flags and operating system (gzip) */\nvar EXLEN = 5; /* i: waiting for extra length (gzip) */\nvar EXTRA = 6; /* i: waiting for extra bytes (gzip) */\nvar NAME = 7; /* i: waiting for end of file name (gzip) */\nvar COMMENT = 8; /* i: waiting for end of comment (gzip) */\nvar HCRC = 9; /* i: waiting for header crc (gzip) */\nvar DICTID = 10; /* i: waiting for dictionary check value */\nvar DICT = 11; /* waiting for inflateSetDictionary() call */\nvar TYPE = 12; /* i: waiting for type bits, including last-flag bit */\nvar TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */\nvar STORED = 14; /* i: waiting for stored size (length and complement) */\nvar COPY_ = 15; /* i/o: same as COPY below, but only first time in */\nvar COPY = 16; /* i/o: waiting for input or output to copy stored block */\nvar TABLE = 17; /* i: waiting for dynamic block table lengths */\nvar LENLENS = 18; /* i: waiting for code length code lengths */\nvar CODELENS = 19; /* i: waiting for length/lit and distance code lengths */\nvar LEN_ = 20; /* i: same as LEN below, but only first time in */\nvar LEN = 21; /* i: waiting for length/lit/eob code */\nvar LENEXT = 22; /* i: waiting for length extra bits */\nvar DIST = 23; /* i: waiting for distance code */\nvar DISTEXT = 24; /* i: waiting for distance extra bits */\nvar MATCH = 25; /* o: waiting for output space to copy string */\nvar LIT = 26; /* o: waiting for output space to write literal */\nvar CHECK = 27; /* i: waiting for 32-bit check value */\nvar LENGTH = 28; /* i: waiting for 32-bit length (gzip) */\nvar DONE = 29; /* finished check, done -- remain here until reset */\nvar BAD = 30; /* got a data error -- remain here until reset */\nvar MEM = 31; /* got an inflate() memory error -- remain here until reset */\nvar SYNC = 32; /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n\n\nfunction zswap32(q) {\n  return (((q >>> 24) & 0xff) +\n    ((q >>> 8) & 0xff00) +\n    ((q & 0xff00) << 8) +\n    ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0; /* current inflate mode */\n  this.last = false; /* true if processing last block */\n  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false; /* true if dictionary provided */\n  this.flags = 0; /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0; /* protected copy of check value */\n  this.total = 0; /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null; /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0; /* log base 2 of requested window size */\n  this.wsize = 0; /* window size or zero if not using window */\n  this.whave = 0; /* valid bytes in the window */\n  this.wnext = 0; /* window write index */\n  this.window = null; /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0; /* input bit accumulator */\n  this.bits = 0; /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0; /* literal or length of data to copy */\n  this.offset = 0; /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0; /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null; /* starting table for length/literal codes */\n  this.distcode = null; /* starting table for distance codes */\n  this.lenbits = 0; /* index bits for lencode */\n  this.distbits = 0; /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0; /* number of code length code lengths */\n  this.nlen = 0; /* number of length code lengths */\n  this.ndist = 0; /* number of distance code lengths */\n  this.have = 0; /* number of code lengths in lens[] */\n  this.next = null; /* next available space in codes[] */\n\n  this.lens = new Buf16(320); /* temporary storage for code lengths */\n  this.work = new Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null; /* dynamic table for distance codes (JS specific) */\n  this.sane = 0; /* if false, allow invalid distance too far */\n  this.back = 0; /* bits back of last unprocessed length/lit */\n  this.was = 0; /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR$1;\n  }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) { /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null /*Z_NULL*/ ;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK$1;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR$1;\n  }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR$1;\n  }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  } else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR$1;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) {\n    return Z_STREAM_ERROR$1;\n  }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null /*Z_NULL*/ ;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK$1) {\n    strm.state = null /*Z_NULL*/ ;\n  }\n  return ret;\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new Buf32(512);\n    distfix = new Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) {\n      state.lens[sym++] = 8;\n    }\n    while (sym < 256) {\n      state.lens[sym++] = 9;\n    }\n    while (sym < 280) {\n      state.lens[sym++] = 7;\n    }\n    while (sym < 288) {\n      state.lens[sym++] = 8;\n    }\n\n    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {\n      bits: 9\n    });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) {\n      state.lens[sym++] = 5;\n    }\n\n    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {\n      bits: 5\n    });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  } else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    } else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) {\n        state.wnext = 0;\n      }\n      if (state.whave < state.wsize) {\n        state.whave += dist;\n      }\n    }\n  }\n  return 0;\n}\n\nfunction inflate$1(strm, flush) {\n  var state;\n  var input, output; // input/output buffers\n  var next; /* next input INDEX */\n  var put; /* next output INDEX */\n  var have, left; /* available input and output */\n  var hold; /* bit buffer */\n  var bits; /* bits in bit buffer */\n  var _in, _out; /* save starting available input and output */\n  var copy; /* number of stored or match bytes to copy */\n  var from; /* where to copy match bytes from */\n  var from_source;\n  var here = 0; /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len; /* length to copy for repeats, bits to drop */\n  var ret; /* return code */\n  var hbuf = new Buf8(4); /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */ [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n\n  if (!strm || !strm.state || !strm.output ||\n    (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) {\n    state.mode = TYPEDO;\n  } /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK$1;\n\n  inf_leave: // goto emulation\n    for (;;) {\n      switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) {\n            break inf_leave;\n          }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) { /* gzip header */\n          state.check = 0 /*crc32(0L, Z_NULL, 0)*/ ;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0; /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) || /* check if zlib header allowed */\n          (((hold & 0xff) /*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f) /*BITS(4)*/ !== Z_DEFLATED$1) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f) /*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        } else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) {\n            break inf_leave;\n          }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED$1) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) {\n            break inf_leave;\n          }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) {\n            break inf_leave;\n          }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        } else if (state.head) {\n          state.head.extra = null /*Z_NULL*/ ;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) {\n            copy = have;\n          }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more conveniend processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) {\n            break inf_leave;\n          }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) {\n            break inf_leave;\n          }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n              (state.length < 65536 /*state.head.name_max*/ )) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) {\n            break inf_leave;\n          }\n        } else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) {\n            break inf_leave;\n          }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n              (state.length < 65536 /*state.head.comm_max*/ )) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) {\n            break inf_leave;\n          }\n        } else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) {\n            break inf_leave;\n          }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT$1;\n        }\n        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK$1 || flush === Z_TREES$1) {\n          break inf_leave;\n        }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) {\n            break inf_leave;\n          }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01) /*BITS(1)*/ ;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03) /*BITS(2)*/ ) {\n        case 0:\n          /* stored block */\n          //Tracev((stderr, \"inflate:     stored block%s\\n\",\n          //        state.last ? \" (last)\" : \"\"));\n          state.mode = STORED;\n          break;\n        case 1:\n          /* fixed block */\n          fixedtables(state);\n          //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n          //        state.last ? \" (last)\" : \"\"));\n          state.mode = LEN_; /* decode codes */\n          if (flush === Z_TREES$1) {\n            //--- DROPBITS(2) ---//\n            hold >>>= 2;\n            bits -= 2;\n            //---//\n            break inf_leave;\n          }\n          break;\n        case 2:\n          /* dynamic block */\n          //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n          //        state.last ? \" (last)\" : \"\"));\n          state.mode = TABLE;\n          break;\n        case 3:\n          strm.msg = 'invalid block type';\n          state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) {\n            break inf_leave;\n          }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES$1) {\n          break inf_leave;\n        }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) {\n            copy = have;\n          }\n          if (copy > left) {\n            copy = left;\n          }\n          if (copy === 0) {\n            break inf_leave;\n          }\n          //--- zmemcpy(put, next, copy); ---\n          arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) {\n            break inf_leave;\n          }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f) /*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f) /*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f) /*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        //#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n        //#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07); //BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = {\n          bits: state.lenbits\n        };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)]; /*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) {\n              break;\n            }\n            //--- PULLBYTE() ---//\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          } else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03); //BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            } else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07); //BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            } else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f); //BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) {\n          break;\n        }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = {\n          bits: state.lenbits\n        };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = {\n          bits: state.distbits\n        };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES$1) {\n          break inf_leave;\n        }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)]; /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) {\n            break;\n          }\n          //--- PULLBYTE() ---//\n          if (have === 0) {\n            break inf_leave;\n          }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n              ((hold & ((1 << (last_bits + last_op)) - 1)) /*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) {\n              break;\n            }\n            //--- PULLBYTE() ---//\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1) /*BITS(state.extra)*/ ;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)]; /*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) {\n            break;\n          }\n          //--- PULLBYTE() ---//\n          if (have === 0) {\n            break inf_leave;\n          }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n              ((hold & ((1 << (last_bits + last_op)) - 1)) /*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) {\n              break;\n            }\n            //--- PULLBYTE() ---//\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1) /*BITS(state.extra)*/ ;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n        //#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) {\n          break inf_leave;\n        }\n        copy = _out - left;\n        if (state.offset > copy) { /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n            // (!) This block is disabled in zlib defailts,\n            // don't enable it for binary compatibility\n            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n            //          Trace((stderr, \"inflate.c too far\\n\"));\n            //          copy -= state.whave;\n            //          if (copy > state.length) { copy = state.length; }\n            //          if (copy > left) { copy = left; }\n            //          left -= copy;\n            //          state.length -= copy;\n            //          do {\n            //            output[put++] = 0;\n            //          } while (--copy);\n            //          if (state.length === 0) { state.mode = LEN; }\n            //          break;\n            //#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          } else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) {\n            copy = state.length;\n          }\n          from_source = state.window;\n        } else { /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) {\n          copy = left;\n        }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) {\n          state.mode = LEN;\n        }\n        break;\n      case LIT:\n        if (left === 0) {\n          break inf_leave;\n        }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            // Use '|' insdead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n              /*UPDATE(state.check, put - _out, _out);*/\n              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END$1;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR$1;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR$1;\n      }\n    }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n      (state.mode < CHECK || flush !== Z_FINISH$1))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n    (state.mode === TYPE ? 128 : 0) +\n    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {\n    ret = Z_BUF_ERROR$1;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/ ) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK$1;\n}\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n\n// import constants from './constants';\n\n\n// zlib modes\nvar NONE = 0;\nvar DEFLATE = 1;\nvar INFLATE = 2;\nvar GZIP = 3;\nvar GUNZIP = 4;\nvar DEFLATERAW = 5;\nvar INFLATERAW = 6;\nvar UNZIP = 7;\nvar Z_NO_FLUSH=         0,\n  Z_PARTIAL_FLUSH=    1,\n  Z_SYNC_FLUSH=    2,\n  Z_FULL_FLUSH=       3,\n  Z_FINISH=       4,\n  Z_BLOCK=           5,\n  Z_TREES=            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK=               0,\n  Z_STREAM_END=       1,\n  Z_NEED_DICT=      2,\n  Z_ERRNO=       -1,\n  Z_STREAM_ERROR=   -2,\n  Z_DATA_ERROR=    -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR=    -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION=         0,\n  Z_BEST_SPEED=             1,\n  Z_BEST_COMPRESSION=       9,\n  Z_DEFAULT_COMPRESSION=   -1,\n\n\n  Z_FILTERED=               1,\n  Z_HUFFMAN_ONLY=           2,\n  Z_RLE=                    3,\n  Z_FIXED=                  4,\n  Z_DEFAULT_STRATEGY=       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY=                 0,\n  Z_TEXT=                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN=                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED=               8;\nfunction Zlib$1(mode) {\n  if (mode < DEFLATE || mode > UNZIP)\n    throw new TypeError('Bad argument');\n\n  this.mode = mode;\n  this.init_done = false;\n  this.write_in_progress = false;\n  this.pending_close = false;\n  this.windowBits = 0;\n  this.level = 0;\n  this.memLevel = 0;\n  this.strategy = 0;\n  this.dictionary = null;\n}\n\nZlib$1.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {\n  this.windowBits = windowBits;\n  this.level = level;\n  this.memLevel = memLevel;\n  this.strategy = strategy;\n  // dictionary not supported.\n\n  if (this.mode === GZIP || this.mode === GUNZIP)\n    this.windowBits += 16;\n\n  if (this.mode === UNZIP)\n    this.windowBits += 32;\n\n  if (this.mode === DEFLATERAW || this.mode === INFLATERAW)\n    this.windowBits = -this.windowBits;\n\n  this.strm = new ZStream();\n  var status;\n  switch (this.mode) {\n  case DEFLATE:\n  case GZIP:\n  case DEFLATERAW:\n    status = deflateInit2(\n      this.strm,\n      this.level,\n      Z_DEFLATED,\n      this.windowBits,\n      this.memLevel,\n      this.strategy\n    );\n    break;\n  case INFLATE:\n  case GUNZIP:\n  case INFLATERAW:\n  case UNZIP:\n    status  = inflateInit2(\n      this.strm,\n      this.windowBits\n    );\n    break;\n  default:\n    throw new Error('Unknown mode ' + this.mode);\n  }\n\n  if (status !== Z_OK) {\n    this._error(status);\n    return;\n  }\n\n  this.write_in_progress = false;\n  this.init_done = true;\n};\n\nZlib$1.prototype.params = function() {\n  throw new Error('deflateParams Not supported');\n};\n\nZlib$1.prototype._writeCheck = function() {\n  if (!this.init_done)\n    throw new Error('write before init');\n\n  if (this.mode === NONE)\n    throw new Error('already finalized');\n\n  if (this.write_in_progress)\n    throw new Error('write already in progress');\n\n  if (this.pending_close)\n    throw new Error('close is pending');\n};\n\nZlib$1.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {\n  this._writeCheck();\n  this.write_in_progress = true;\n\n  var self = this;\n  process.nextTick(function() {\n    self.write_in_progress = false;\n    var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);\n    self.callback(res[0], res[1]);\n\n    if (self.pending_close)\n      self.close();\n  });\n\n  return this;\n};\n\n// set method for Node buffers, used by pako\nfunction bufferSet(data, offset) {\n  for (var i = 0; i < data.length; i++) {\n    this[offset + i] = data[i];\n  }\n}\n\nZlib$1.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {\n  this._writeCheck();\n  return this._write(flush, input, in_off, in_len, out, out_off, out_len);\n};\n\nZlib$1.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {\n  this.write_in_progress = true;\n\n  if (flush !== Z_NO_FLUSH &&\n      flush !== Z_PARTIAL_FLUSH &&\n      flush !== Z_SYNC_FLUSH &&\n      flush !== Z_FULL_FLUSH &&\n      flush !== Z_FINISH &&\n      flush !== Z_BLOCK) {\n    throw new Error('Invalid flush value');\n  }\n\n  if (input == null) {\n    input = new Buffer(0);\n    in_len = 0;\n    in_off = 0;\n  }\n\n  if (out._set)\n    out.set = out._set;\n  else\n    out.set = bufferSet;\n\n  var strm = this.strm;\n  strm.avail_in = in_len;\n  strm.input = input;\n  strm.next_in = in_off;\n  strm.avail_out = out_len;\n  strm.output = out;\n  strm.next_out = out_off;\n  var status;\n  switch (this.mode) {\n  case DEFLATE:\n  case GZIP:\n  case DEFLATERAW:\n    status = deflate$1(strm, flush);\n    break;\n  case UNZIP:\n  case INFLATE:\n  case GUNZIP:\n  case INFLATERAW:\n    status = inflate$1(strm, flush);\n    break;\n  default:\n    throw new Error('Unknown mode ' + this.mode);\n  }\n\n  if (!this._checkError(status, strm, flush)) {\n    this._error(status);\n  }\n\n  this.write_in_progress = false;\n  return [strm.avail_in, strm.avail_out];\n};\n\nZlib$1.prototype._checkError = function (status, strm, flush) {\n  // Acceptable error states depend on the type of zlib stream.\n  switch (status) {\n    case Z_OK:\n    case Z_BUF_ERROR:\n      if (strm.avail_out !== 0 && flush === Z_FINISH) {\n        return false\n      }\n      break\n    case Z_STREAM_END:\n      // normal statuses, not fatal\n      break\n    case Z_NEED_DICT:\n      return false\n    default:\n      return false\n  }\n\n  return true\n};\n\nZlib$1.prototype.close = function() {\n  if (this.write_in_progress) {\n    this.pending_close = true;\n    return;\n  }\n\n  this.pending_close = false;\n\n  if (this.mode === DEFLATE || this.mode === GZIP || this.mode === DEFLATERAW) {\n    deflateEnd(this.strm);\n  } else {\n    inflateEnd(this.strm);\n  }\n\n  this.mode = NONE;\n};\nvar status;\nZlib$1.prototype.reset = function() {\n  switch (this.mode) {\n  case DEFLATE:\n  case DEFLATERAW:\n    status = deflateReset(this.strm);\n    break;\n  case INFLATE:\n  case INFLATERAW:\n    status = inflateReset(this.strm);\n    break;\n  }\n\n  if (status !== Z_OK) {\n    this._error(status);\n  }\n};\n\nZlib$1.prototype._error = function(status) {\n  this.onerror(msg[status] + ': ' + this.strm.msg, status);\n\n  this.write_in_progress = false;\n  if (this.pending_close)\n    this.close();\n};\n\nvar _binding = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tDEFLATE: DEFLATE,\n\tDEFLATERAW: DEFLATERAW,\n\tGUNZIP: GUNZIP,\n\tGZIP: GZIP,\n\tINFLATE: INFLATE,\n\tINFLATERAW: INFLATERAW,\n\tNONE: NONE,\n\tUNZIP: UNZIP,\n\tZ_BEST_COMPRESSION: Z_BEST_COMPRESSION,\n\tZ_BEST_SPEED: Z_BEST_SPEED,\n\tZ_BINARY: Z_BINARY,\n\tZ_BLOCK: Z_BLOCK,\n\tZ_BUF_ERROR: Z_BUF_ERROR,\n\tZ_DATA_ERROR: Z_DATA_ERROR,\n\tZ_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION,\n\tZ_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY,\n\tZ_DEFLATED: Z_DEFLATED,\n\tZ_ERRNO: Z_ERRNO,\n\tZ_FILTERED: Z_FILTERED,\n\tZ_FINISH: Z_FINISH,\n\tZ_FIXED: Z_FIXED,\n\tZ_FULL_FLUSH: Z_FULL_FLUSH,\n\tZ_HUFFMAN_ONLY: Z_HUFFMAN_ONLY,\n\tZ_NEED_DICT: Z_NEED_DICT,\n\tZ_NO_COMPRESSION: Z_NO_COMPRESSION,\n\tZ_NO_FLUSH: Z_NO_FLUSH,\n\tZ_OK: Z_OK,\n\tZ_PARTIAL_FLUSH: Z_PARTIAL_FLUSH,\n\tZ_RLE: Z_RLE,\n\tZ_STREAM_END: Z_STREAM_END,\n\tZ_STREAM_ERROR: Z_STREAM_ERROR,\n\tZ_SYNC_FLUSH: Z_SYNC_FLUSH,\n\tZ_TEXT: Z_TEXT,\n\tZ_TREES: Z_TREES,\n\tZ_UNKNOWN: Z_UNKNOWN,\n\tZlib: Zlib$1\n});\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction assert (a, msg) {\n  if (!a) {\n    throw new Error(msg);\n  }\n}\nvar binding = {};\nObject.keys(_binding).forEach(function (key) {\n  binding[key] = _binding[key];\n});\n// zlib doesn't provide these, so kludge them in following the same\n// const naming scheme zlib uses.\nbinding.Z_MIN_WINDOWBITS = 8;\nbinding.Z_MAX_WINDOWBITS = 15;\nbinding.Z_DEFAULT_WINDOWBITS = 15;\n\n// fewer than 64 bytes per chunk is stupid.\n// technically it could work with as few as 8, but even 64 bytes\n// is absurdly low.  Usually a MB or more is best.\nbinding.Z_MIN_CHUNK = 64;\nbinding.Z_MAX_CHUNK = Infinity;\nbinding.Z_DEFAULT_CHUNK = (16 * 1024);\n\nbinding.Z_MIN_MEMLEVEL = 1;\nbinding.Z_MAX_MEMLEVEL = 9;\nbinding.Z_DEFAULT_MEMLEVEL = 8;\n\nbinding.Z_MIN_LEVEL = -1;\nbinding.Z_MAX_LEVEL = 9;\nbinding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n\n\n// translation table for return codes.\nvar codes = {\n  Z_OK: binding.Z_OK,\n  Z_STREAM_END: binding.Z_STREAM_END,\n  Z_NEED_DICT: binding.Z_NEED_DICT,\n  Z_ERRNO: binding.Z_ERRNO,\n  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n  Z_DATA_ERROR: binding.Z_DATA_ERROR,\n  Z_MEM_ERROR: binding.Z_MEM_ERROR,\n  Z_BUF_ERROR: binding.Z_BUF_ERROR,\n  Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n};\n\nObject.keys(codes).forEach(function(k) {\n  codes[codes[k]] = k;\n});\n\nfunction createDeflate(o) {\n  return new Deflate(o);\n}\n\nfunction createInflate(o) {\n  return new Inflate(o);\n}\n\nfunction createDeflateRaw(o) {\n  return new DeflateRaw(o);\n}\n\nfunction createInflateRaw(o) {\n  return new InflateRaw(o);\n}\n\nfunction createGzip(o) {\n  return new Gzip(o);\n}\n\nfunction createGunzip(o) {\n  return new Gunzip(o);\n}\n\nfunction createUnzip(o) {\n  return new Unzip(o);\n}\n\n\n// Convenience methods.\n// compress/decompress a string or buffer in one step.\nfunction deflate(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Deflate(opts), buffer, callback);\n}\n\nfunction deflateSync(buffer, opts) {\n  return zlibBufferSync(new Deflate(opts), buffer);\n}\n\nfunction gzip(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gzip(opts), buffer, callback);\n}\n\nfunction gzipSync(buffer, opts) {\n  return zlibBufferSync(new Gzip(opts), buffer);\n}\n\nfunction deflateRaw(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n}\n\nfunction deflateRawSync(buffer, opts) {\n  return zlibBufferSync(new DeflateRaw(opts), buffer);\n}\n\nfunction unzip(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Unzip(opts), buffer, callback);\n}\n\nfunction unzipSync(buffer, opts) {\n  return zlibBufferSync(new Unzip(opts), buffer);\n}\n\nfunction inflate(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Inflate(opts), buffer, callback);\n}\n\nfunction inflateSync(buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n}\n\nfunction gunzip(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gunzip(opts), buffer, callback);\n}\n\nfunction gunzipSync(buffer, opts) {\n  return zlibBufferSync(new Gunzip(opts), buffer);\n}\n\nfunction inflateRaw(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new InflateRaw(opts), buffer, callback);\n}\n\nfunction inflateRawSync(buffer, opts) {\n  return zlibBufferSync(new InflateRaw(opts), buffer);\n}\n\nfunction zlibBuffer(engine, buffer, callback) {\n  var buffers = [];\n  var nread = 0;\n\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n\n  engine.end(buffer);\n  flow();\n\n  function flow() {\n    var chunk;\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }\n    engine.once('readable', flow);\n  }\n\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n\n  function onEnd() {\n    var buf = Buffer.concat(buffers, nread);\n    buffers = [];\n    callback(null, buf);\n    engine.close();\n  }\n}\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string')\n    buffer = new Buffer(buffer);\n  if (!Buffer.isBuffer(buffer))\n    throw new TypeError('Not a string or buffer');\n\n  var flushFlag = binding.Z_FINISH;\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\n// generic zlib\n// minimal 2-byte header\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate)) return new Deflate(opts);\n  Zlib.call(this, opts, binding.DEFLATE);\n}\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) return new Inflate(opts);\n  Zlib.call(this, opts, binding.INFLATE);\n}\n\n\n\n// gzip - bigger header, same deflate compression\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip)) return new Gzip(opts);\n  Zlib.call(this, opts, binding.GZIP);\n}\n\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip)) return new Gunzip(opts);\n  Zlib.call(this, opts, binding.GUNZIP);\n}\n\n\n\n// raw - no header\nfunction DeflateRaw(opts) {\n  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n  Zlib.call(this, opts, binding.DEFLATERAW);\n}\n\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n  Zlib.call(this, opts, binding.INFLATERAW);\n}\n\n\n// auto-detect header.\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip)) return new Unzip(opts);\n  Zlib.call(this, opts, binding.UNZIP);\n}\n\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\nfunction Zlib(opts, mode) {\n  this._opts = opts = opts || {};\n  this._chunkSize = opts.chunkSize || binding.Z_DEFAULT_CHUNK;\n\n  Transform.call(this, opts);\n\n  if (opts.flush) {\n    if (opts.flush !== binding.Z_NO_FLUSH &&\n        opts.flush !== binding.Z_PARTIAL_FLUSH &&\n        opts.flush !== binding.Z_SYNC_FLUSH &&\n        opts.flush !== binding.Z_FULL_FLUSH &&\n        opts.flush !== binding.Z_FINISH &&\n        opts.flush !== binding.Z_BLOCK) {\n      throw new Error('Invalid flush flag: ' + opts.flush);\n    }\n  }\n  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n\n  if (opts.chunkSize) {\n    if (opts.chunkSize < binding.Z_MIN_CHUNK ||\n        opts.chunkSize > binding.Z_MAX_CHUNK) {\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\n    }\n  }\n\n  if (opts.windowBits) {\n    if (opts.windowBits < binding.Z_MIN_WINDOWBITS ||\n        opts.windowBits > binding.Z_MAX_WINDOWBITS) {\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\n    }\n  }\n\n  if (opts.level) {\n    if (opts.level < binding.Z_MIN_LEVEL ||\n        opts.level > binding.Z_MAX_LEVEL) {\n      throw new Error('Invalid compression level: ' + opts.level);\n    }\n  }\n\n  if (opts.memLevel) {\n    if (opts.memLevel < binding.Z_MIN_MEMLEVEL ||\n        opts.memLevel > binding.Z_MAX_MEMLEVEL) {\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\n    }\n  }\n\n  if (opts.strategy) {\n    if (opts.strategy != binding.Z_FILTERED &&\n        opts.strategy != binding.Z_HUFFMAN_ONLY &&\n        opts.strategy != binding.Z_RLE &&\n        opts.strategy != binding.Z_FIXED &&\n        opts.strategy != binding.Z_DEFAULT_STRATEGY) {\n      throw new Error('Invalid strategy: ' + opts.strategy);\n    }\n  }\n\n  if (opts.dictionary) {\n    if (!Buffer.isBuffer(opts.dictionary)) {\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\n    }\n  }\n\n  this._binding = new binding.Zlib(mode);\n\n  var self = this;\n  this._hadError = false;\n  this._binding.onerror = function(message, errno) {\n    // there is no way to cleanly recover.\n    // continuing only obscures problems.\n    self._binding = null;\n    self._hadError = true;\n\n    var error = new Error(message);\n    error.errno = errno;\n    error.code = codes[errno];\n    self.emit('error', error);\n  };\n\n  var level = binding.Z_DEFAULT_COMPRESSION;\n  if (typeof opts.level === 'number') level = opts.level;\n\n  var strategy = binding.Z_DEFAULT_STRATEGY;\n  if (typeof opts.strategy === 'number') strategy = opts.strategy;\n\n  this._binding.init(opts.windowBits || binding.Z_DEFAULT_WINDOWBITS,\n                     level,\n                     opts.memLevel || binding.Z_DEFAULT_MEMLEVEL,\n                     strategy,\n                     opts.dictionary);\n\n  this._buffer = new Buffer(this._chunkSize);\n  this._offset = 0;\n  this._closed = false;\n  this._level = level;\n  this._strategy = strategy;\n\n  this.once('end', this.close);\n}\n\ninherits$1(Zlib, Transform);\n\nZlib.prototype.params = function(level, strategy, callback) {\n  if (level < binding.Z_MIN_LEVEL ||\n      level > binding.Z_MAX_LEVEL) {\n    throw new RangeError('Invalid compression level: ' + level);\n  }\n  if (strategy != binding.Z_FILTERED &&\n      strategy != binding.Z_HUFFMAN_ONLY &&\n      strategy != binding.Z_RLE &&\n      strategy != binding.Z_FIXED &&\n      strategy != binding.Z_DEFAULT_STRATEGY) {\n    throw new TypeError('Invalid strategy: ' + strategy);\n  }\n\n  if (this._level !== level || this._strategy !== strategy) {\n    var self = this;\n    this.flush(binding.Z_SYNC_FLUSH, function() {\n      self._binding.params(level, strategy);\n      if (!self._hadError) {\n        self._level = level;\n        self._strategy = strategy;\n        if (callback) callback();\n      }\n    });\n  } else {\n    process.nextTick(callback);\n  }\n};\n\nZlib.prototype.reset = function() {\n  return this._binding.reset();\n};\n\n// This is the _flush function called by the transform class,\n// internally, when the last chunk has been written.\nZlib.prototype._flush = function(callback) {\n  this._transform(new Buffer(0), '', callback);\n};\n\nZlib.prototype.flush = function(kind, callback) {\n  var ws = this._writableState;\n\n  if (typeof kind === 'function' || (kind === void 0 && !callback)) {\n    callback = kind;\n    kind = binding.Z_FULL_FLUSH;\n  }\n\n  if (ws.ended) {\n    if (callback)\n      process.nextTick(callback);\n  } else if (ws.ending) {\n    if (callback)\n      this.once('end', callback);\n  } else if (ws.needDrain) {\n    var self = this;\n    this.once('drain', function() {\n      self.flush(callback);\n    });\n  } else {\n    this._flushFlag = kind;\n    this.write(new Buffer(0), '', callback);\n  }\n};\n\nZlib.prototype.close = function(callback) {\n  if (callback)\n    process.nextTick(callback);\n\n  if (this._closed)\n    return;\n\n  this._closed = true;\n\n  this._binding.close();\n\n  var self = this;\n  process.nextTick(function() {\n    self.emit('close');\n  });\n};\n\nZlib.prototype._transform = function(chunk, encoding, cb) {\n  var flushFlag;\n  var ws = this._writableState;\n  var ending = ws.ending || ws.ended;\n  var last = ending && (!chunk || ws.length === chunk.length);\n\n  if (!chunk === null && !Buffer.isBuffer(chunk))\n    return cb(new Error('invalid input'));\n\n  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.\n  // If it's explicitly flushing at some other time, then we use\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n  // goodness.\n  if (last)\n    flushFlag = binding.Z_FINISH;\n  else {\n    flushFlag = this._flushFlag;\n    // once we've flushed the last of the queue, stop flushing and\n    // go back to the normal behavior.\n    if (chunk.length >= ws.length) {\n      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n    }\n  }\n\n  this._processChunk(chunk, flushFlag, cb);\n};\n\nZlib.prototype._processChunk = function(chunk, flushFlag, cb) {\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var inOff = 0;\n\n  var self = this;\n\n  var async = typeof cb === 'function';\n\n  if (!async) {\n    var buffers = [];\n    var nread = 0;\n\n    var error;\n    this.on('error', function(er) {\n      error = er;\n    });\n\n    do {\n      var res = this._binding.writeSync(flushFlag,\n                                        chunk, // in\n                                        inOff, // in_off\n                                        availInBefore, // in_len\n                                        this._buffer, // out\n                                        this._offset, //out_off\n                                        availOutBefore); // out_len\n    } while (!this._hadError && callback(res[0], res[1]));\n\n    if (this._hadError) {\n      throw error;\n    }\n\n    var buf = Buffer.concat(buffers, nread);\n    this.close();\n\n    return buf;\n  }\n\n  var req = this._binding.write(flushFlag,\n                                chunk, // in\n                                inOff, // in_off\n                                availInBefore, // in_len\n                                this._buffer, // out\n                                this._offset, //out_off\n                                availOutBefore); // out_len\n\n  req.buffer = chunk;\n  req.callback = callback;\n\n  function callback(availInAfter, availOutAfter) {\n    if (self._hadError)\n      return;\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n      // serve some output to the consumer.\n      if (async) {\n        self.push(out);\n      } else {\n        buffers.push(out);\n        nread += out.length;\n      }\n    }\n\n    // exhausted the output buffer, or used all the input create a new one.\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = new Buffer(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      // Not actually done.  Need to reprocess.\n      // Also, update the availInBefore to the availInAfter value,\n      // so that if we have to hit it a third (fourth, etc.) time,\n      // it'll have the correct byte counts.\n      inOff += (availInBefore - availInAfter);\n      availInBefore = availInAfter;\n\n      if (!async)\n        return true;\n\n      var newReq = self._binding.write(flushFlag,\n                                       chunk,\n                                       inOff,\n                                       availInBefore,\n                                       self._buffer,\n                                       self._offset,\n                                       self._chunkSize);\n      newReq.callback = callback; // this same function\n      newReq.buffer = chunk;\n      return;\n    }\n\n    if (!async)\n      return false;\n\n    // finished with the chunk.\n    cb();\n  }\n};\n\ninherits$1(Deflate, Zlib);\ninherits$1(Inflate, Zlib);\ninherits$1(Gzip, Zlib);\ninherits$1(Gunzip, Zlib);\ninherits$1(DeflateRaw, Zlib);\ninherits$1(InflateRaw, Zlib);\ninherits$1(Unzip, Zlib);\nvar _polyfillNode_zlib = {\n  codes: codes,\n  createDeflate: createDeflate,\n  createInflate: createInflate,\n  createDeflateRaw: createDeflateRaw,\n  createInflateRaw: createInflateRaw,\n  createGzip: createGzip,\n  createGunzip: createGunzip,\n  createUnzip: createUnzip,\n  deflate: deflate,\n  deflateSync: deflateSync,\n  gzip: gzip,\n  gzipSync: gzipSync,\n  deflateRaw: deflateRaw,\n  deflateRawSync: deflateRawSync,\n  unzip: unzip,\n  unzipSync: unzipSync,\n  inflate: inflate,\n  inflateSync: inflateSync,\n  gunzip: gunzip,\n  gunzipSync: gunzipSync,\n  inflateRaw: inflateRaw,\n  inflateRawSync: inflateRawSync,\n  Deflate: Deflate,\n  Inflate: Inflate,\n  Gzip: Gzip,\n  Gunzip: Gunzip,\n  DeflateRaw: DeflateRaw,\n  InflateRaw: InflateRaw,\n  Unzip: Unzip,\n  Zlib: Zlib\n};\n\nvar _polyfillNode_zlib$1 = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tDeflate: Deflate,\n\tDeflateRaw: DeflateRaw,\n\tGunzip: Gunzip,\n\tGzip: Gzip,\n\tInflate: Inflate,\n\tInflateRaw: InflateRaw,\n\tUnzip: Unzip,\n\tZlib: Zlib,\n\tcodes: codes,\n\tcreateDeflate: createDeflate,\n\tcreateDeflateRaw: createDeflateRaw,\n\tcreateGunzip: createGunzip,\n\tcreateGzip: createGzip,\n\tcreateInflate: createInflate,\n\tcreateInflateRaw: createInflateRaw,\n\tcreateUnzip: createUnzip,\n\tdefault: _polyfillNode_zlib,\n\tdeflate: deflate,\n\tdeflateRaw: deflateRaw,\n\tdeflateRawSync: deflateRawSync,\n\tdeflateSync: deflateSync,\n\tgunzip: gunzip,\n\tgunzipSync: gunzipSync,\n\tgzip: gzip,\n\tgzipSync: gzipSync,\n\tinflate: inflate,\n\tinflateRaw: inflateRaw,\n\tinflateRawSync: inflateRawSync,\n\tinflateSync: inflateSync,\n\tunzip: unzip,\n\tunzipSync: unzipSync\n});\n\nvar require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_zlib$1);\n\nvar deflater;\nvar hasRequiredDeflater;\n\nfunction requireDeflater () {\n\tif (hasRequiredDeflater) return deflater;\n\thasRequiredDeflater = 1;\n\tdeflater = function (/*Buffer*/ inbuf) {\n\t    var zlib = require$$0;\n\n\t    var opts = { chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024 };\n\n\t    return {\n\t        deflate: function () {\n\t            return zlib.deflateRawSync(inbuf, opts);\n\t        },\n\n\t        deflateAsync: function (/*Function*/ callback) {\n\t            var tmp = zlib.createDeflateRaw(opts),\n\t                parts = [],\n\t                total = 0;\n\t            tmp.on(\"data\", function (data) {\n\t                parts.push(data);\n\t                total += data.length;\n\t            });\n\t            tmp.on(\"end\", function () {\n\t                var buf = Buffer.alloc(total),\n\t                    written = 0;\n\t                buf.fill(0);\n\t                for (var i = 0; i < parts.length; i++) {\n\t                    var part = parts[i];\n\t                    part.copy(buf, written);\n\t                    written += part.length;\n\t                }\n\t                callback && callback(buf);\n\t            });\n\t            tmp.end(inbuf);\n\t        }\n\t    };\n\t};\n\treturn deflater;\n}\n\nvar inflater;\nvar hasRequiredInflater;\n\nfunction requireInflater () {\n\tif (hasRequiredInflater) return inflater;\n\thasRequiredInflater = 1;\n\tconst version = +(process.versions ? process.versions.node : \"\").split(\".\")[0] || 0;\n\n\tinflater = function (/*Buffer*/ inbuf, /*number*/ expectedLength) {\n\t    var zlib = require$$0;\n\t    const option = version >= 15 && expectedLength > 0 ? { maxOutputLength: expectedLength } : {};\n\n\t    return {\n\t        inflate: function () {\n\t            return zlib.inflateRawSync(inbuf, option);\n\t        },\n\n\t        inflateAsync: function (/*Function*/ callback) {\n\t            var tmp = zlib.createInflateRaw(option),\n\t                parts = [],\n\t                total = 0;\n\t            tmp.on(\"data\", function (data) {\n\t                parts.push(data);\n\t                total += data.length;\n\t            });\n\t            tmp.on(\"end\", function () {\n\t                var buf = Buffer.alloc(total),\n\t                    written = 0;\n\t                buf.fill(0);\n\t                for (var i = 0; i < parts.length; i++) {\n\t                    var part = parts[i];\n\t                    part.copy(buf, written);\n\t                    written += part.length;\n\t                }\n\t                callback && callback(buf);\n\t            });\n\t            tmp.end(inbuf);\n\t        }\n\t    };\n\t};\n\treturn inflater;\n}\n\nvar zipcrypto;\nvar hasRequiredZipcrypto;\n\nfunction requireZipcrypto () {\n\tif (hasRequiredZipcrypto) return zipcrypto;\n\thasRequiredZipcrypto = 1;\n\n\t// node crypt, we use it for generate salt\n\t// eslint-disable-next-line node/no-unsupported-features/node-builtins\n\tconst { randomFillSync } = (crypto__WEBPACK_IMPORTED_MODULE_2___default());\n\tconst Errors = requireErrors();\n\n\t// generate CRC32 lookup table\n\tconst crctable = new Uint32Array(256).map((t, crc) => {\n\t    for (let j = 0; j < 8; j++) {\n\t        if (0 !== (crc & 1)) {\n\t            crc = (crc >>> 1) ^ 0xedb88320;\n\t        } else {\n\t            crc >>>= 1;\n\t        }\n\t    }\n\t    return crc >>> 0;\n\t});\n\n\t// C-style uInt32 Multiply (discards higher bits, when JS multiply discards lower bits)\n\tconst uMul = (a, b) => Math.imul(a, b) >>> 0;\n\n\t// crc32 byte single update (actually same function is part of utils.crc32 function :) )\n\tconst crc32update = (pCrc32, bval) => {\n\t    return crctable[(pCrc32 ^ bval) & 0xff] ^ (pCrc32 >>> 8);\n\t};\n\n\t// function for generating salt for encrytion header\n\tconst genSalt = () => {\n\t    if (\"function\" === typeof randomFillSync) {\n\t        return randomFillSync(Buffer.alloc(12));\n\t    } else {\n\t        // fallback if function is not defined\n\t        return genSalt.node();\n\t    }\n\t};\n\n\t// salt generation with node random function (mainly as fallback)\n\tgenSalt.node = () => {\n\t    const salt = Buffer.alloc(12);\n\t    const len = salt.length;\n\t    for (let i = 0; i < len; i++) salt[i] = (Math.random() * 256) & 0xff;\n\t    return salt;\n\t};\n\n\t// general config\n\tconst config = {\n\t    genSalt\n\t};\n\n\t// Class Initkeys handles same basic ops with keys\n\tfunction Initkeys(pw) {\n\t    const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);\n\t    this.keys = new Uint32Array([0x12345678, 0x23456789, 0x34567890]);\n\t    for (let i = 0; i < pass.length; i++) {\n\t        this.updateKeys(pass[i]);\n\t    }\n\t}\n\n\tInitkeys.prototype.updateKeys = function (byteValue) {\n\t    const keys = this.keys;\n\t    keys[0] = crc32update(keys[0], byteValue);\n\t    keys[1] += keys[0] & 0xff;\n\t    keys[1] = uMul(keys[1], 134775813) + 1;\n\t    keys[2] = crc32update(keys[2], keys[1] >>> 24);\n\t    return byteValue;\n\t};\n\n\tInitkeys.prototype.next = function () {\n\t    const k = (this.keys[2] | 2) >>> 0; // key\n\t    return (uMul(k, k ^ 1) >> 8) & 0xff; // decode\n\t};\n\n\tfunction make_decrypter(/*Buffer*/ pwd) {\n\t    // 1. Stage initialize key\n\t    const keys = new Initkeys(pwd);\n\n\t    // return decrypter function\n\t    return function (/*Buffer*/ data) {\n\t        // result - we create new Buffer for results\n\t        const result = Buffer.alloc(data.length);\n\t        let pos = 0;\n\t        // process input data\n\t        for (let c of data) {\n\t            //c ^= keys.next();\n\t            //result[pos++] = c; // decode & Save Value\n\t            result[pos++] = keys.updateKeys(c ^ keys.next()); // update keys with decoded byte\n\t        }\n\t        return result;\n\t    };\n\t}\n\n\tfunction make_encrypter(/*Buffer*/ pwd) {\n\t    // 1. Stage initialize key\n\t    const keys = new Initkeys(pwd);\n\n\t    // return encrypting function, result and pos is here so we dont have to merge buffers later\n\t    return function (/*Buffer*/ data, /*Buffer*/ result, /* Number */ pos = 0) {\n\t        // result - we create new Buffer for results\n\t        if (!result) result = Buffer.alloc(data.length);\n\t        // process input data\n\t        for (let c of data) {\n\t            const k = keys.next(); // save key byte\n\t            result[pos++] = c ^ k; // save val\n\t            keys.updateKeys(c); // update keys with decoded byte\n\t        }\n\t        return result;\n\t    };\n\t}\n\n\tfunction decrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd) {\n\t    if (!data || !Buffer.isBuffer(data) || data.length < 12) {\n\t        return Buffer.alloc(0);\n\t    }\n\n\t    // 1. We Initialize and generate decrypting function\n\t    const decrypter = make_decrypter(pwd);\n\n\t    // 2. decrypt salt what is always 12 bytes and is a part of file content\n\t    const salt = decrypter(data.slice(0, 12));\n\n\t    // if bit 3 (0x08) of the general-purpose flags field is set, check salt[11] with the high byte of the header time\n\t    // 2 byte data block (as per Info-Zip spec), otherwise check with the high byte of the header entry\n\t    const verifyByte = (header.flags & 0x8) === 0x8 ? header.timeHighByte : header.crc >>> 24;\n\n\t    //3. does password meet expectations\n\t    if (salt[11] !== verifyByte) {\n\t        throw Errors.WRONG_PASSWORD();\n\t    }\n\n\t    // 4. decode content\n\t    return decrypter(data.slice(12));\n\t}\n\n\t// lets add way to populate salt, NOT RECOMMENDED for production but maybe useful for testing general functionality\n\tfunction _salter(data) {\n\t    if (Buffer.isBuffer(data) && data.length >= 12) {\n\t        // be aware - currently salting buffer data is modified\n\t        config.genSalt = function () {\n\t            return data.slice(0, 12);\n\t        };\n\t    } else if (data === \"node\") {\n\t        // test salt generation with node random function\n\t        config.genSalt = genSalt.node;\n\t    } else {\n\t        // if value is not acceptable config gets reset.\n\t        config.genSalt = genSalt;\n\t    }\n\t}\n\n\tfunction encrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd, /*Boolean*/ oldlike = false) {\n\t    // 1. test data if data is not Buffer we make buffer from it\n\t    if (data == null) data = Buffer.alloc(0);\n\t    // if data is not buffer be make buffer from it\n\t    if (!Buffer.isBuffer(data)) data = Buffer.from(data.toString());\n\n\t    // 2. We Initialize and generate encrypting function\n\t    const encrypter = make_encrypter(pwd);\n\n\t    // 3. generate salt (12-bytes of random data)\n\t    const salt = config.genSalt();\n\t    salt[11] = (header.crc >>> 24) & 0xff;\n\n\t    // old implementations (before PKZip 2.04g) used two byte check\n\t    if (oldlike) salt[10] = (header.crc >>> 16) & 0xff;\n\n\t    // 4. create output\n\t    const result = Buffer.alloc(data.length + 12);\n\t    encrypter(salt, result);\n\n\t    // finally encode content\n\t    return encrypter(data, result, 12);\n\t}\n\n\tzipcrypto = { decrypt, encrypt, _salter };\n\treturn zipcrypto;\n}\n\nvar hasRequiredMethods;\n\nfunction requireMethods () {\n\tif (hasRequiredMethods) return methods;\n\thasRequiredMethods = 1;\n\tmethods.Deflater = requireDeflater();\n\tmethods.Inflater = requireInflater();\n\tmethods.ZipCrypto = requireZipcrypto();\n\treturn methods;\n}\n\nvar zipEntry;\nvar hasRequiredZipEntry;\n\nfunction requireZipEntry () {\n\tif (hasRequiredZipEntry) return zipEntry;\n\thasRequiredZipEntry = 1;\n\tvar Utils = requireUtil(),\n\t    Headers = requireHeaders(),\n\t    Constants = Utils.Constants,\n\t    Methods = requireMethods();\n\n\tzipEntry = function (/** object */ options, /*Buffer*/ input) {\n\t    var _centralHeader = new Headers.EntryHeader(),\n\t        _entryName = Buffer.alloc(0),\n\t        _comment = Buffer.alloc(0),\n\t        _isDirectory = false,\n\t        uncompressedData = null,\n\t        _extra = Buffer.alloc(0),\n\t        _extralocal = Buffer.alloc(0),\n\t        _efs = true;\n\n\t    // assign options\n\t    const opts = options;\n\n\t    const decoder = typeof opts.decoder === \"object\" ? opts.decoder : Utils.decoder;\n\t    _efs = decoder.hasOwnProperty(\"efs\") ? decoder.efs : false;\n\n\t    function getCompressedDataFromZip() {\n\t        //if (!input || !Buffer.isBuffer(input)) {\n\t        if (!input || !(input instanceof Uint8Array)) {\n\t            return Buffer.alloc(0);\n\t        }\n\t        _extralocal = _centralHeader.loadLocalHeaderFromBinary(input);\n\t        return input.slice(_centralHeader.realDataOffset, _centralHeader.realDataOffset + _centralHeader.compressedSize);\n\t    }\n\n\t    function crc32OK(data) {\n\t        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the local header is written\n\t        if (!_centralHeader.flags_desc) {\n\t            if (Utils.crc32(data) !== _centralHeader.localHeader.crc) {\n\t                return false;\n\t            }\n\t        } else {\n\t            const descriptor = {};\n\t            const dataEndOffset = _centralHeader.realDataOffset + _centralHeader.compressedSize;\n\t            // no descriptor after compressed data, instead new local header\n\t            if (input.readUInt32LE(dataEndOffset) == Constants.LOCSIG || input.readUInt32LE(dataEndOffset) == Constants.CENSIG) {\n\t                throw Utils.Errors.DESCRIPTOR_NOT_EXIST();\n\t            }\n\n\t            // get decriptor data\n\t            if (input.readUInt32LE(dataEndOffset) == Constants.EXTSIG) {\n\t                // descriptor with signature\n\t                descriptor.crc = input.readUInt32LE(dataEndOffset + Constants.EXTCRC);\n\t                descriptor.compressedSize = input.readUInt32LE(dataEndOffset + Constants.EXTSIZ);\n\t                descriptor.size = input.readUInt32LE(dataEndOffset + Constants.EXTLEN);\n\t            } else if (input.readUInt16LE(dataEndOffset + 12) === 0x4b50) {\n\t                // descriptor without signature (we check is new header starting where we expect)\n\t                descriptor.crc = input.readUInt32LE(dataEndOffset + Constants.EXTCRC - 4);\n\t                descriptor.compressedSize = input.readUInt32LE(dataEndOffset + Constants.EXTSIZ - 4);\n\t                descriptor.size = input.readUInt32LE(dataEndOffset + Constants.EXTLEN - 4);\n\t            } else {\n\t                throw Utils.Errors.DESCRIPTOR_UNKNOWN();\n\t            }\n\n\t            // check data integrity\n\t            if (descriptor.compressedSize !== _centralHeader.compressedSize || descriptor.size !== _centralHeader.size || descriptor.crc !== _centralHeader.crc) {\n\t                throw Utils.Errors.DESCRIPTOR_FAULTY();\n\t            }\n\t            if (Utils.crc32(data) !== descriptor.crc) {\n\t                return false;\n\t            }\n\n\t            // @TODO: zip64 bit descriptor fields\n\t            // if bit 3 is set and any value in local header \"zip64 Extended information\" extra field are set 0 (place holder)\n\t            // then 64-bit descriptor format is used instead of 32-bit\n\t            // central header - \"zip64 Extended information\" extra field should store real values and not place holders\n\t        }\n\t        return true;\n\t    }\n\n\t    function decompress(/*Boolean*/ async, /*Function*/ callback, /*String, Buffer*/ pass) {\n\t        if (typeof callback === \"undefined\" && typeof async === \"string\") {\n\t            pass = async;\n\t            async = void 0;\n\t        }\n\t        if (_isDirectory) {\n\t            if (async && callback) {\n\t                callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR()); //si added error.\n\t            }\n\t            return Buffer.alloc(0);\n\t        }\n\n\t        var compressedData = getCompressedDataFromZip();\n\n\t        if (compressedData.length === 0) {\n\t            // File is empty, nothing to decompress.\n\t            if (async && callback) callback(compressedData);\n\t            return compressedData;\n\t        }\n\n\t        if (_centralHeader.encrypted) {\n\t            if (\"string\" !== typeof pass && !Buffer.isBuffer(pass)) {\n\t                throw Utils.Errors.INVALID_PASS_PARAM();\n\t            }\n\t            compressedData = Methods.ZipCrypto.decrypt(compressedData, _centralHeader, pass);\n\t        }\n\n\t        var data = Buffer.alloc(_centralHeader.size);\n\n\t        switch (_centralHeader.method) {\n\t            case Utils.Constants.STORED:\n\t                compressedData.copy(data);\n\t                if (!crc32OK(data)) {\n\t                    if (async && callback) callback(data, Utils.Errors.BAD_CRC()); //si added error\n\t                    throw Utils.Errors.BAD_CRC();\n\t                } else {\n\t                    //si added otherwise did not seem to return data.\n\t                    if (async && callback) callback(data);\n\t                    return data;\n\t                }\n\t            case Utils.Constants.DEFLATED:\n\t                var inflater = new Methods.Inflater(compressedData, _centralHeader.size);\n\t                if (!async) {\n\t                    const result = inflater.inflate(data);\n\t                    result.copy(data, 0);\n\t                    if (!crc32OK(data)) {\n\t                        throw Utils.Errors.BAD_CRC(`\"${decoder.decode(_entryName)}\"`);\n\t                    }\n\t                    return data;\n\t                } else {\n\t                    inflater.inflateAsync(function (result) {\n\t                        result.copy(result, 0);\n\t                        if (callback) {\n\t                            if (!crc32OK(result)) {\n\t                                callback(result, Utils.Errors.BAD_CRC()); //si added error\n\t                            } else {\n\t                                callback(result);\n\t                            }\n\t                        }\n\t                    });\n\t                }\n\t                break;\n\t            default:\n\t                if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD());\n\t                throw Utils.Errors.UNKNOWN_METHOD();\n\t        }\n\t    }\n\n\t    function compress(/*Boolean*/ async, /*Function*/ callback) {\n\t        if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {\n\t            // no data set or the data wasn't changed to require recompression\n\t            if (async && callback) callback(getCompressedDataFromZip());\n\t            return getCompressedDataFromZip();\n\t        }\n\n\t        if (uncompressedData.length && !_isDirectory) {\n\t            var compressedData;\n\t            // Local file header\n\t            switch (_centralHeader.method) {\n\t                case Utils.Constants.STORED:\n\t                    _centralHeader.compressedSize = _centralHeader.size;\n\n\t                    compressedData = Buffer.alloc(uncompressedData.length);\n\t                    uncompressedData.copy(compressedData);\n\n\t                    if (async && callback) callback(compressedData);\n\t                    return compressedData;\n\t                default:\n\t                case Utils.Constants.DEFLATED:\n\t                    var deflater = new Methods.Deflater(uncompressedData);\n\t                    if (!async) {\n\t                        var deflated = deflater.deflate();\n\t                        _centralHeader.compressedSize = deflated.length;\n\t                        return deflated;\n\t                    } else {\n\t                        deflater.deflateAsync(function (data) {\n\t                            compressedData = Buffer.alloc(data.length);\n\t                            _centralHeader.compressedSize = data.length;\n\t                            data.copy(compressedData);\n\t                            callback && callback(compressedData);\n\t                        });\n\t                    }\n\t                    deflater = null;\n\t                    break;\n\t            }\n\t        } else if (async && callback) {\n\t            callback(Buffer.alloc(0));\n\t        } else {\n\t            return Buffer.alloc(0);\n\t        }\n\t    }\n\n\t    function readUInt64LE(buffer, offset) {\n\t        return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);\n\t    }\n\n\t    function parseExtra(data) {\n\t        try {\n\t            var offset = 0;\n\t            var signature, size, part;\n\t            while (offset + 4 < data.length) {\n\t                signature = data.readUInt16LE(offset);\n\t                offset += 2;\n\t                size = data.readUInt16LE(offset);\n\t                offset += 2;\n\t                part = data.slice(offset, offset + size);\n\t                offset += size;\n\t                if (Constants.ID_ZIP64 === signature) {\n\t                    parseZip64ExtendedInformation(part);\n\t                }\n\t            }\n\t        } catch (error) {\n\t            throw Utils.Errors.EXTRA_FIELD_PARSE_ERROR();\n\t        }\n\t    }\n\n\t    //Override header field values with values from the ZIP64 extra field\n\t    function parseZip64ExtendedInformation(data) {\n\t        var size, compressedSize, offset, diskNumStart;\n\n\t        if (data.length >= Constants.EF_ZIP64_SCOMP) {\n\t            size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);\n\t            if (_centralHeader.size === Constants.EF_ZIP64_OR_32) {\n\t                _centralHeader.size = size;\n\t            }\n\t        }\n\t        if (data.length >= Constants.EF_ZIP64_RHO) {\n\t            compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);\n\t            if (_centralHeader.compressedSize === Constants.EF_ZIP64_OR_32) {\n\t                _centralHeader.compressedSize = compressedSize;\n\t            }\n\t        }\n\t        if (data.length >= Constants.EF_ZIP64_DSN) {\n\t            offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);\n\t            if (_centralHeader.offset === Constants.EF_ZIP64_OR_32) {\n\t                _centralHeader.offset = offset;\n\t            }\n\t        }\n\t        if (data.length >= Constants.EF_ZIP64_DSN + 4) {\n\t            diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);\n\t            if (_centralHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {\n\t                _centralHeader.diskNumStart = diskNumStart;\n\t            }\n\t        }\n\t    }\n\n\t    return {\n\t        get entryName() {\n\t            return decoder.decode(_entryName);\n\t        },\n\t        get rawEntryName() {\n\t            return _entryName;\n\t        },\n\t        set entryName(val) {\n\t            _entryName = Utils.toBuffer(val, decoder.encode);\n\t            var lastChar = _entryName[_entryName.length - 1];\n\t            _isDirectory = lastChar === 47 || lastChar === 92;\n\t            _centralHeader.fileNameLength = _entryName.length;\n\t        },\n\n\t        get efs() {\n\t            if (typeof _efs === \"function\") {\n\t                return _efs(this.entryName);\n\t            } else {\n\t                return _efs;\n\t            }\n\t        },\n\n\t        get extra() {\n\t            return _extra;\n\t        },\n\t        set extra(val) {\n\t            _extra = val;\n\t            _centralHeader.extraLength = val.length;\n\t            parseExtra(val);\n\t        },\n\n\t        get comment() {\n\t            return decoder.decode(_comment);\n\t        },\n\t        set comment(val) {\n\t            _comment = Utils.toBuffer(val, decoder.encode);\n\t            _centralHeader.commentLength = _comment.length;\n\t            if (_comment.length > 0xffff) throw Utils.Errors.COMMENT_TOO_LONG();\n\t        },\n\n\t        get name() {\n\t            var n = decoder.decode(_entryName);\n\t            return _isDirectory\n\t                ? n\n\t                      .substr(n.length - 1)\n\t                      .split(\"/\")\n\t                      .pop()\n\t                : n.split(\"/\").pop();\n\t        },\n\t        get isDirectory() {\n\t            return _isDirectory;\n\t        },\n\n\t        getCompressedData: function () {\n\t            return compress(false, null);\n\t        },\n\n\t        getCompressedDataAsync: function (/*Function*/ callback) {\n\t            compress(true, callback);\n\t        },\n\n\t        setData: function (value) {\n\t            uncompressedData = Utils.toBuffer(value, Utils.decoder.encode);\n\t            if (!_isDirectory && uncompressedData.length) {\n\t                _centralHeader.size = uncompressedData.length;\n\t                _centralHeader.method = Utils.Constants.DEFLATED;\n\t                _centralHeader.crc = Utils.crc32(value);\n\t                _centralHeader.changed = true;\n\t            } else {\n\t                // folders and blank files should be stored\n\t                _centralHeader.method = Utils.Constants.STORED;\n\t            }\n\t        },\n\n\t        getData: function (pass) {\n\t            if (_centralHeader.changed) {\n\t                return uncompressedData;\n\t            } else {\n\t                return decompress(false, null, pass);\n\t            }\n\t        },\n\n\t        getDataAsync: function (/*Function*/ callback, pass) {\n\t            if (_centralHeader.changed) {\n\t                callback(uncompressedData);\n\t            } else {\n\t                decompress(true, callback, pass);\n\t            }\n\t        },\n\n\t        set attr(attr) {\n\t            _centralHeader.attr = attr;\n\t        },\n\t        get attr() {\n\t            return _centralHeader.attr;\n\t        },\n\n\t        set header(/*Buffer*/ data) {\n\t            _centralHeader.loadFromBinary(data);\n\t        },\n\n\t        get header() {\n\t            return _centralHeader;\n\t        },\n\n\t        packCentralHeader: function () {\n\t            _centralHeader.flags_efs = this.efs;\n\t            _centralHeader.extraLength = _extra.length;\n\t            // 1. create header (buffer)\n\t            var header = _centralHeader.centralHeaderToBinary();\n\t            var addpos = Utils.Constants.CENHDR;\n\t            // 2. add file name\n\t            _entryName.copy(header, addpos);\n\t            addpos += _entryName.length;\n\t            // 3. add extra data\n\t            _extra.copy(header, addpos);\n\t            addpos += _centralHeader.extraLength;\n\t            // 4. add file comment\n\t            _comment.copy(header, addpos);\n\t            return header;\n\t        },\n\n\t        packLocalHeader: function () {\n\t            let addpos = 0;\n\t            _centralHeader.flags_efs = this.efs;\n\t            _centralHeader.extraLocalLength = _extralocal.length;\n\t            // 1. construct local header Buffer\n\t            const localHeaderBuf = _centralHeader.localHeaderToBinary();\n\t            // 2. localHeader - crate header buffer\n\t            const localHeader = Buffer.alloc(localHeaderBuf.length + _entryName.length + _centralHeader.extraLocalLength);\n\t            // 2.1 add localheader\n\t            localHeaderBuf.copy(localHeader, addpos);\n\t            addpos += localHeaderBuf.length;\n\t            // 2.2 add file name\n\t            _entryName.copy(localHeader, addpos);\n\t            addpos += _entryName.length;\n\t            // 2.3 add extra field\n\t            _extralocal.copy(localHeader, addpos);\n\t            addpos += _extralocal.length;\n\n\t            return localHeader;\n\t        },\n\n\t        toJSON: function () {\n\t            const bytes = function (nr) {\n\t                return \"<\" + ((nr && nr.length + \" bytes buffer\") || \"null\") + \">\";\n\t            };\n\n\t            return {\n\t                entryName: this.entryName,\n\t                name: this.name,\n\t                comment: this.comment,\n\t                isDirectory: this.isDirectory,\n\t                header: _centralHeader.toJSON(),\n\t                compressedData: bytes(input),\n\t                data: bytes(uncompressedData)\n\t            };\n\t        },\n\n\t        toString: function () {\n\t            return JSON.stringify(this.toJSON(), null, \"\\t\");\n\t        }\n\t    };\n\t};\n\treturn zipEntry;\n}\n\nvar zipFile;\nvar hasRequiredZipFile;\n\nfunction requireZipFile () {\n\tif (hasRequiredZipFile) return zipFile;\n\thasRequiredZipFile = 1;\n\tconst ZipEntry = requireZipEntry();\n\tconst Headers = requireHeaders();\n\tconst Utils = requireUtil();\n\n\tzipFile = function (/*Buffer|null*/ inBuffer, /** object */ options) {\n\t    var entryList = [],\n\t        entryTable = {},\n\t        _comment = Buffer.alloc(0),\n\t        mainHeader = new Headers.MainHeader(),\n\t        loadedEntries = false;\n\t    const temporary = new Set();\n\n\t    // assign options\n\t    const opts = options;\n\n\t    const { noSort, decoder } = opts;\n\n\t    if (inBuffer) {\n\t        // is a memory buffer\n\t        readMainHeader(opts.readEntries);\n\t    } else {\n\t        // none. is a new file\n\t        loadedEntries = true;\n\t    }\n\n\t    function makeTemporaryFolders() {\n\t        const foldersList = new Set();\n\n\t        // Make list of all folders in file\n\t        for (const elem of Object.keys(entryTable)) {\n\t            const elements = elem.split(\"/\");\n\t            elements.pop(); // filename\n\t            if (!elements.length) continue; // no folders\n\t            for (let i = 0; i < elements.length; i++) {\n\t                const sub = elements.slice(0, i + 1).join(\"/\") + \"/\";\n\t                foldersList.add(sub);\n\t            }\n\t        }\n\n\t        // create missing folders as temporary\n\t        for (const elem of foldersList) {\n\t            if (!(elem in entryTable)) {\n\t                const tempfolder = new ZipEntry(opts);\n\t                tempfolder.entryName = elem;\n\t                tempfolder.attr = 0x10;\n\t                tempfolder.temporary = true;\n\t                entryList.push(tempfolder);\n\t                entryTable[tempfolder.entryName] = tempfolder;\n\t                temporary.add(tempfolder);\n\t            }\n\t        }\n\t    }\n\n\t    function readEntries() {\n\t        loadedEntries = true;\n\t        entryTable = {};\n\t        if (mainHeader.diskEntries > (inBuffer.length - mainHeader.offset) / Utils.Constants.CENHDR) {\n\t            throw Utils.Errors.DISK_ENTRY_TOO_LARGE();\n\t        }\n\t        entryList = new Array(mainHeader.diskEntries); // total number of entries\n\t        var index = mainHeader.offset; // offset of first CEN header\n\t        for (var i = 0; i < entryList.length; i++) {\n\t            var tmp = index,\n\t                entry = new ZipEntry(opts, inBuffer);\n\t            entry.header = inBuffer.slice(tmp, (tmp += Utils.Constants.CENHDR));\n\n\t            entry.entryName = inBuffer.slice(tmp, (tmp += entry.header.fileNameLength));\n\n\t            if (entry.header.extraLength) {\n\t                entry.extra = inBuffer.slice(tmp, (tmp += entry.header.extraLength));\n\t            }\n\n\t            if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\n\n\t            index += entry.header.centralHeaderSize;\n\n\t            entryList[i] = entry;\n\t            entryTable[entry.entryName] = entry;\n\t        }\n\t        temporary.clear();\n\t        makeTemporaryFolders();\n\t    }\n\n\t    function readMainHeader(/*Boolean*/ readNow) {\n\t        var i = inBuffer.length - Utils.Constants.ENDHDR, // END header size\n\t            max = Math.max(0, i - 0xffff), // 0xFFFF is the max zip file comment length\n\t            n = max,\n\t            endStart = inBuffer.length,\n\t            endOffset = -1, // Start offset of the END header\n\t            commentEnd = 0;\n\n\t        // option to search header form entire file\n\t        const trailingSpace = typeof opts.trailingSpace === \"boolean\" ? opts.trailingSpace : false;\n\t        if (trailingSpace) max = 0;\n\n\t        for (i; i >= n; i--) {\n\t            if (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'\n\t            if (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) {\n\t                // \"PK\\005\\006\"\n\t                endOffset = i;\n\t                commentEnd = i;\n\t                endStart = i + Utils.Constants.ENDHDR;\n\t                // We already found a regular signature, let's look just a bit further to check if there's any zip64 signature\n\t                n = i - Utils.Constants.END64HDR;\n\t                continue;\n\t            }\n\n\t            if (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {\n\t                // Found a zip64 signature, let's continue reading the whole zip64 record\n\t                n = max;\n\t                continue;\n\t            }\n\n\t            if (inBuffer.readUInt32LE(i) === Utils.Constants.ZIP64SIG) {\n\t                // Found the zip64 record, let's determine it's size\n\t                endOffset = i;\n\t                endStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;\n\t                break;\n\t            }\n\t        }\n\n\t        if (endOffset == -1) throw Utils.Errors.INVALID_FORMAT();\n\n\t        mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));\n\t        if (mainHeader.commentLength) {\n\t            _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);\n\t        }\n\t        if (readNow) readEntries();\n\t    }\n\n\t    function sortEntries() {\n\t        if (entryList.length > 1 && !noSort) {\n\t            entryList.sort((a, b) => a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));\n\t        }\n\t    }\n\n\t    return {\n\t        /**\n\t         * Returns an array of ZipEntry objects existent in the current opened archive\n\t         * @return Array\n\t         */\n\t        get entries() {\n\t            if (!loadedEntries) {\n\t                readEntries();\n\t            }\n\t            return entryList.filter((e) => !temporary.has(e));\n\t        },\n\n\t        /**\n\t         * Archive comment\n\t         * @return {String}\n\t         */\n\t        get comment() {\n\t            return decoder.decode(_comment);\n\t        },\n\t        set comment(val) {\n\t            _comment = Utils.toBuffer(val, decoder.encode);\n\t            mainHeader.commentLength = _comment.length;\n\t        },\n\n\t        getEntryCount: function () {\n\t            if (!loadedEntries) {\n\t                return mainHeader.diskEntries;\n\t            }\n\n\t            return entryList.length;\n\t        },\n\n\t        forEach: function (callback) {\n\t            this.entries.forEach(callback);\n\t        },\n\n\t        /**\n\t         * Returns a reference to the entry with the given name or null if entry is inexistent\n\t         *\n\t         * @param entryName\n\t         * @return ZipEntry\n\t         */\n\t        getEntry: function (/*String*/ entryName) {\n\t            if (!loadedEntries) {\n\t                readEntries();\n\t            }\n\t            return entryTable[entryName] || null;\n\t        },\n\n\t        /**\n\t         * Adds the given entry to the entry list\n\t         *\n\t         * @param entry\n\t         */\n\t        setEntry: function (/*ZipEntry*/ entry) {\n\t            if (!loadedEntries) {\n\t                readEntries();\n\t            }\n\t            entryList.push(entry);\n\t            entryTable[entry.entryName] = entry;\n\t            mainHeader.totalEntries = entryList.length;\n\t        },\n\n\t        /**\n\t         * Removes the file with the given name from the entry list.\n\t         *\n\t         * If the entry is a directory, then all nested files and directories will be removed\n\t         * @param entryName\n\t         * @returns {void}\n\t         */\n\t        deleteFile: function (/*String*/ entryName, withsubfolders = true) {\n\t            if (!loadedEntries) {\n\t                readEntries();\n\t            }\n\t            const entry = entryTable[entryName];\n\t            const list = this.getEntryChildren(entry, withsubfolders).map((child) => child.entryName);\n\n\t            list.forEach(this.deleteEntry);\n\t        },\n\n\t        /**\n\t         * Removes the entry with the given name from the entry list.\n\t         *\n\t         * @param {string} entryName\n\t         * @returns {void}\n\t         */\n\t        deleteEntry: function (/*String*/ entryName) {\n\t            if (!loadedEntries) {\n\t                readEntries();\n\t            }\n\t            const entry = entryTable[entryName];\n\t            const index = entryList.indexOf(entry);\n\t            if (index >= 0) {\n\t                entryList.splice(index, 1);\n\t                delete entryTable[entryName];\n\t                mainHeader.totalEntries = entryList.length;\n\t            }\n\t        },\n\n\t        /**\n\t         *  Iterates and returns all nested files and directories of the given entry\n\t         *\n\t         * @param entry\n\t         * @return Array\n\t         */\n\t        getEntryChildren: function (/*ZipEntry*/ entry, subfolders = true) {\n\t            if (!loadedEntries) {\n\t                readEntries();\n\t            }\n\t            if (typeof entry === \"object\") {\n\t                if (entry.isDirectory && subfolders) {\n\t                    const list = [];\n\t                    const name = entry.entryName;\n\n\t                    for (const zipEntry of entryList) {\n\t                        if (zipEntry.entryName.startsWith(name)) {\n\t                            list.push(zipEntry);\n\t                        }\n\t                    }\n\t                    return list;\n\t                } else {\n\t                    return [entry];\n\t                }\n\t            }\n\t            return [];\n\t        },\n\n\t        /**\n\t         *  How many child elements entry has\n\t         *\n\t         * @param {ZipEntry} entry\n\t         * @return {integer}\n\t         */\n\t        getChildCount: function (entry) {\n\t            if (entry && entry.isDirectory) {\n\t                const list = this.getEntryChildren(entry);\n\t                return list.includes(entry) ? list.length - 1 : list.length;\n\t            }\n\t            return 0;\n\t        },\n\n\t        /**\n\t         * Returns the zip file\n\t         *\n\t         * @return Buffer\n\t         */\n\t        compressToBuffer: function () {\n\t            if (!loadedEntries) {\n\t                readEntries();\n\t            }\n\t            sortEntries();\n\n\t            const dataBlock = [];\n\t            const headerBlocks = [];\n\t            let totalSize = 0;\n\t            let dindex = 0;\n\n\t            mainHeader.size = 0;\n\t            mainHeader.offset = 0;\n\t            let totalEntries = 0;\n\n\t            for (const entry of this.entries) {\n\t                // compress data and set local and entry header accordingly. Reason why is called first\n\t                const compressedData = entry.getCompressedData();\n\t                entry.header.offset = dindex;\n\n\t                // 1. construct local header\n\t                const localHeader = entry.packLocalHeader();\n\n\t                // 2. offsets\n\t                const dataLength = localHeader.length + compressedData.length;\n\t                dindex += dataLength;\n\n\t                // 3. store values in sequence\n\t                dataBlock.push(localHeader);\n\t                dataBlock.push(compressedData);\n\n\t                // 4. construct central header\n\t                const centralHeader = entry.packCentralHeader();\n\t                headerBlocks.push(centralHeader);\n\t                // 5. update main header\n\t                mainHeader.size += centralHeader.length;\n\t                totalSize += dataLength + centralHeader.length;\n\t                totalEntries++;\n\t            }\n\n\t            totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n\t            // point to end of data and beginning of central directory first record\n\t            mainHeader.offset = dindex;\n\t            mainHeader.totalEntries = totalEntries;\n\n\t            dindex = 0;\n\t            const outBuffer = Buffer.alloc(totalSize);\n\t            // write data blocks\n\t            for (const content of dataBlock) {\n\t                content.copy(outBuffer, dindex);\n\t                dindex += content.length;\n\t            }\n\n\t            // write central directory entries\n\t            for (const content of headerBlocks) {\n\t                content.copy(outBuffer, dindex);\n\t                dindex += content.length;\n\t            }\n\n\t            // write main header\n\t            const mh = mainHeader.toBinary();\n\t            if (_comment) {\n\t                _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n\t            }\n\t            mh.copy(outBuffer, dindex);\n\n\t            // Since we update entry and main header offsets,\n\t            // they are no longer valid and we have to reset content\n\t            // (Issue 64)\n\n\t            inBuffer = outBuffer;\n\t            loadedEntries = false;\n\n\t            return outBuffer;\n\t        },\n\n\t        toAsyncBuffer: function (/*Function*/ onSuccess, /*Function*/ onFail, /*Function*/ onItemStart, /*Function*/ onItemEnd) {\n\t            try {\n\t                if (!loadedEntries) {\n\t                    readEntries();\n\t                }\n\t                sortEntries();\n\n\t                const dataBlock = [];\n\t                const centralHeaders = [];\n\t                let totalSize = 0;\n\t                let dindex = 0;\n\t                let totalEntries = 0;\n\n\t                mainHeader.size = 0;\n\t                mainHeader.offset = 0;\n\n\t                const compress2Buffer = function (entryLists) {\n\t                    if (entryLists.length > 0) {\n\t                        const entry = entryLists.shift();\n\t                        const name = entry.entryName + entry.extra.toString();\n\t                        if (onItemStart) onItemStart(name);\n\t                        entry.getCompressedDataAsync(function (compressedData) {\n\t                            if (onItemEnd) onItemEnd(name);\n\t                            entry.header.offset = dindex;\n\n\t                            // 1. construct local header\n\t                            const localHeader = entry.packLocalHeader();\n\n\t                            // 2. offsets\n\t                            const dataLength = localHeader.length + compressedData.length;\n\t                            dindex += dataLength;\n\n\t                            // 3. store values in sequence\n\t                            dataBlock.push(localHeader);\n\t                            dataBlock.push(compressedData);\n\n\t                            // central header\n\t                            const centalHeader = entry.packCentralHeader();\n\t                            centralHeaders.push(centalHeader);\n\t                            mainHeader.size += centalHeader.length;\n\t                            totalSize += dataLength + centalHeader.length;\n\t                            totalEntries++;\n\n\t                            compress2Buffer(entryLists);\n\t                        });\n\t                    } else {\n\t                        totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n\t                        // point to end of data and beginning of central directory first record\n\t                        mainHeader.offset = dindex;\n\t                        mainHeader.totalEntries = totalEntries;\n\n\t                        dindex = 0;\n\t                        const outBuffer = Buffer.alloc(totalSize);\n\t                        dataBlock.forEach(function (content) {\n\t                            content.copy(outBuffer, dindex); // write data blocks\n\t                            dindex += content.length;\n\t                        });\n\t                        centralHeaders.forEach(function (content) {\n\t                            content.copy(outBuffer, dindex); // write central directory entries\n\t                            dindex += content.length;\n\t                        });\n\n\t                        const mh = mainHeader.toBinary();\n\t                        if (_comment) {\n\t                            _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n\t                        }\n\n\t                        mh.copy(outBuffer, dindex); // write main header\n\n\t                        // Since we update entry and main header offsets, they are no\n\t                        // longer valid and we have to reset content using our new buffer\n\t                        // (Issue 64)\n\n\t                        inBuffer = outBuffer;\n\t                        loadedEntries = false;\n\n\t                        onSuccess(outBuffer);\n\t                    }\n\t                };\n\n\t                compress2Buffer(Array.from(this.entries));\n\t            } catch (e) {\n\t                onFail(e);\n\t            }\n\t        }\n\t    };\n\t};\n\treturn zipFile;\n}\n\nvar admZip$2;\nvar hasRequiredAdmZip;\n\nfunction requireAdmZip () {\n\tif (hasRequiredAdmZip) return admZip$2;\n\thasRequiredAdmZip = 1;\n\tconst Utils = requireUtil();\n\tconst pth = (path__WEBPACK_IMPORTED_MODULE_1___default());\n\tconst ZipEntry = requireZipEntry();\n\tconst ZipFile = requireZipFile();\n\n\tconst get_Bool = (...val) => Utils.findLast(val, (c) => typeof c === \"boolean\");\n\tconst get_Str = (...val) => Utils.findLast(val, (c) => typeof c === \"string\");\n\tconst get_Fun = (...val) => Utils.findLast(val, (c) => typeof c === \"function\");\n\n\tconst defaultOptions = {\n\t    // option \"noSort\" : if true it disables files sorting\n\t    noSort: false,\n\t    // read entries during load (initial loading may be slower)\n\t    readEntries: false,\n\t    // default method is none\n\t    method: Utils.Constants.NONE,\n\t    // file system\n\t    fs: null\n\t};\n\n\tadmZip$2 = function (/**String*/ input, /** object */ options) {\n\t    let inBuffer = null;\n\n\t    // create object based default options, allowing them to be overwritten\n\t    const opts = Object.assign(Object.create(null), defaultOptions);\n\n\t    // test input variable\n\t    if (input && \"object\" === typeof input) {\n\t        // if value is not buffer we accept it to be object with options\n\t        if (!(input instanceof Uint8Array)) {\n\t            Object.assign(opts, input);\n\t            input = opts.input ? opts.input : undefined;\n\t            if (opts.input) delete opts.input;\n\t        }\n\n\t        // if input is buffer\n\t        if (Buffer.isBuffer(input)) {\n\t            inBuffer = input;\n\t            opts.method = Utils.Constants.BUFFER;\n\t            input = undefined;\n\t        }\n\t    }\n\n\t    // assign options\n\t    Object.assign(opts, options);\n\n\t    // instanciate utils filesystem\n\t    const filetools = new Utils(opts);\n\n\t    if (typeof opts.decoder !== \"object\" || typeof opts.decoder.encode !== \"function\" || typeof opts.decoder.decode !== \"function\") {\n\t        opts.decoder = Utils.decoder;\n\t    }\n\n\t    // if input is file name we retrieve its content\n\t    if (input && \"string\" === typeof input) {\n\t        // load zip file\n\t        if (filetools.fs.existsSync(input)) {\n\t            opts.method = Utils.Constants.FILE;\n\t            opts.filename = input;\n\t            inBuffer = filetools.fs.readFileSync(input);\n\t        } else {\n\t            throw Utils.Errors.INVALID_FILENAME();\n\t        }\n\t    }\n\n\t    // create variable\n\t    const _zip = new ZipFile(inBuffer, opts);\n\n\t    const { canonical, sanitize, zipnamefix } = Utils;\n\n\t    function getEntry(/**Object*/ entry) {\n\t        if (entry && _zip) {\n\t            var item;\n\t            // If entry was given as a file name\n\t            if (typeof entry === \"string\") item = _zip.getEntry(pth.posix.normalize(entry));\n\t            // if entry was given as a ZipEntry object\n\t            if (typeof entry === \"object\" && typeof entry.entryName !== \"undefined\" && typeof entry.header !== \"undefined\") item = _zip.getEntry(entry.entryName);\n\n\t            if (item) {\n\t                return item;\n\t            }\n\t        }\n\t        return null;\n\t    }\n\n\t    function fixPath(zipPath) {\n\t        const { join, normalize, sep } = pth.posix;\n\t        // convert windows file separators and normalize\n\t        return join(\".\", normalize(sep + zipPath.split(\"\\\\\").join(sep) + sep));\n\t    }\n\n\t    function filenameFilter(filterfn) {\n\t        if (filterfn instanceof RegExp) {\n\t            // if filter is RegExp wrap it\n\t            return (function (rx) {\n\t                return function (filename) {\n\t                    return rx.test(filename);\n\t                };\n\t            })(filterfn);\n\t        } else if (\"function\" !== typeof filterfn) {\n\t            // if filter is not function we will replace it\n\t            return () => true;\n\t        }\n\t        return filterfn;\n\t    }\n\n\t    // keep last character on folders\n\t    const relativePath = (local, entry) => {\n\t        let lastChar = entry.slice(-1);\n\t        lastChar = lastChar === filetools.sep ? filetools.sep : \"\";\n\t        return pth.relative(local, entry) + lastChar;\n\t    };\n\n\t    return {\n\t        /**\n\t         * Extracts the given entry from the archive and returns the content as a Buffer object\n\t         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry\n\t         * @param {Buffer|string} [pass] - password\n\t         * @return Buffer or Null in case of error\n\t         */\n\t        readFile: function (entry, pass) {\n\t            var item = getEntry(entry);\n\t            return (item && item.getData(pass)) || null;\n\t        },\n\n\t        /**\n\t         * Returns how many child elements has on entry (directories) on files it is always 0\n\t         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry\n\t         * @returns {integer}\n\t         */\n\t        childCount: function (entry) {\n\t            const item = getEntry(entry);\n\t            if (item) {\n\t                return _zip.getChildCount(item);\n\t            }\n\t        },\n\n\t        /**\n\t         * Asynchronous readFile\n\t         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry\n\t         * @param {callback} callback\n\t         *\n\t         * @return Buffer or Null in case of error\n\t         */\n\t        readFileAsync: function (entry, callback) {\n\t            var item = getEntry(entry);\n\t            if (item) {\n\t                item.getDataAsync(callback);\n\t            } else {\n\t                callback(null, \"getEntry failed for:\" + entry);\n\t            }\n\t        },\n\n\t        /**\n\t         * Extracts the given entry from the archive and returns the content as plain text in the given encoding\n\t         * @param {ZipEntry|string} entry - ZipEntry object or String with the full path of the entry\n\t         * @param {string} encoding - Optional. If no encoding is specified utf8 is used\n\t         *\n\t         * @return String\n\t         */\n\t        readAsText: function (entry, encoding) {\n\t            var item = getEntry(entry);\n\t            if (item) {\n\t                var data = item.getData();\n\t                if (data && data.length) {\n\t                    return data.toString(encoding || \"utf8\");\n\t                }\n\t            }\n\t            return \"\";\n\t        },\n\n\t        /**\n\t         * Asynchronous readAsText\n\t         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry\n\t         * @param {callback} callback\n\t         * @param {string} [encoding] - Optional. If no encoding is specified utf8 is used\n\t         *\n\t         * @return String\n\t         */\n\t        readAsTextAsync: function (entry, callback, encoding) {\n\t            var item = getEntry(entry);\n\t            if (item) {\n\t                item.getDataAsync(function (data, err) {\n\t                    if (err) {\n\t                        callback(data, err);\n\t                        return;\n\t                    }\n\n\t                    if (data && data.length) {\n\t                        callback(data.toString(encoding || \"utf8\"));\n\t                    } else {\n\t                        callback(\"\");\n\t                    }\n\t                });\n\t            } else {\n\t                callback(\"\");\n\t            }\n\t        },\n\n\t        /**\n\t         * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\n\t         *\n\t         * @param {ZipEntry|string} entry\n\t         * @returns {void}\n\t         */\n\t        deleteFile: function (entry, withsubfolders = true) {\n\t            // @TODO: test deleteFile\n\t            var item = getEntry(entry);\n\t            if (item) {\n\t                _zip.deleteFile(item.entryName, withsubfolders);\n\t            }\n\t        },\n\n\t        /**\n\t         * Remove the entry from the file or directory without affecting any nested entries\n\t         *\n\t         * @param {ZipEntry|string} entry\n\t         * @returns {void}\n\t         */\n\t        deleteEntry: function (entry) {\n\t            // @TODO: test deleteEntry\n\t            var item = getEntry(entry);\n\t            if (item) {\n\t                _zip.deleteEntry(item.entryName);\n\t            }\n\t        },\n\n\t        /**\n\t         * Adds a comment to the zip. The zip must be rewritten after adding the comment.\n\t         *\n\t         * @param {string} comment\n\t         */\n\t        addZipComment: function (comment) {\n\t            // @TODO: test addZipComment\n\t            _zip.comment = comment;\n\t        },\n\n\t        /**\n\t         * Returns the zip comment\n\t         *\n\t         * @return String\n\t         */\n\t        getZipComment: function () {\n\t            return _zip.comment || \"\";\n\t        },\n\n\t        /**\n\t         * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\n\t         * The comment cannot exceed 65535 characters in length\n\t         *\n\t         * @param {ZipEntry} entry\n\t         * @param {string} comment\n\t         */\n\t        addZipEntryComment: function (entry, comment) {\n\t            var item = getEntry(entry);\n\t            if (item) {\n\t                item.comment = comment;\n\t            }\n\t        },\n\n\t        /**\n\t         * Returns the comment of the specified entry\n\t         *\n\t         * @param {ZipEntry} entry\n\t         * @return String\n\t         */\n\t        getZipEntryComment: function (entry) {\n\t            var item = getEntry(entry);\n\t            if (item) {\n\t                return item.comment || \"\";\n\t            }\n\t            return \"\";\n\t        },\n\n\t        /**\n\t         * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\n\t         *\n\t         * @param {ZipEntry} entry\n\t         * @param {Buffer} content\n\t         */\n\t        updateFile: function (entry, content) {\n\t            var item = getEntry(entry);\n\t            if (item) {\n\t                item.setData(content);\n\t            }\n\t        },\n\n\t        /**\n\t         * Adds a file from the disk to the archive\n\t         *\n\t         * @param {string} localPath File to add to zip\n\t         * @param {string} [zipPath] Optional path inside the zip\n\t         * @param {string} [zipName] Optional name for the file\n\t         * @param {string} [comment] Optional file comment\n\t         */\n\t        addLocalFile: function (localPath, zipPath, zipName, comment) {\n\t            if (filetools.fs.existsSync(localPath)) {\n\t                // fix ZipPath\n\t                zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n\t                // p - local file name\n\t                const p = pth.win32.basename(pth.win32.normalize(localPath));\n\n\t                // add file name into zippath\n\t                zipPath += zipName ? zipName : p;\n\n\t                // read file attributes\n\t                const _attr = filetools.fs.statSync(localPath);\n\n\t                // get file content\n\t                const data = _attr.isFile() ? filetools.fs.readFileSync(localPath) : Buffer.alloc(0);\n\n\t                // if folder\n\t                if (_attr.isDirectory()) zipPath += filetools.sep;\n\n\t                // add file into zip file\n\t                this.addFile(zipPath, data, comment, _attr);\n\t            } else {\n\t                throw Utils.Errors.FILE_NOT_FOUND(localPath);\n\t            }\n\t        },\n\n\t        /**\n\t         * Callback for showing if everything was done.\n\t         *\n\t         * @callback doneCallback\n\t         * @param {Error} err - Error object\n\t         * @param {boolean} done - was request fully completed\n\t         */\n\n\t        /**\n\t         * Adds a file from the disk to the archive\n\t         *\n\t         * @param {(object|string)} options - options object, if it is string it us used as localPath.\n\t         * @param {string} options.localPath - Local path to the file.\n\t         * @param {string} [options.comment] - Optional file comment.\n\t         * @param {string} [options.zipPath] - Optional path inside the zip\n\t         * @param {string} [options.zipName] - Optional name for the file\n\t         * @param {doneCallback} callback - The callback that handles the response.\n\t         */\n\t        addLocalFileAsync: function (options, callback) {\n\t            options = typeof options === \"object\" ? options : { localPath: options };\n\t            const localPath = pth.resolve(options.localPath);\n\t            const { comment } = options;\n\t            let { zipPath, zipName } = options;\n\t            const self = this;\n\n\t            filetools.fs.stat(localPath, function (err, stats) {\n\t                if (err) return callback(err, false);\n\t                // fix ZipPath\n\t                zipPath = zipPath ? fixPath(zipPath) : \"\";\n\t                // p - local file name\n\t                const p = pth.win32.basename(pth.win32.normalize(localPath));\n\t                // add file name into zippath\n\t                zipPath += zipName ? zipName : p;\n\n\t                if (stats.isFile()) {\n\t                    filetools.fs.readFile(localPath, function (err, data) {\n\t                        if (err) return callback(err, false);\n\t                        self.addFile(zipPath, data, comment, stats);\n\t                        return setImmediate(callback, undefined, true);\n\t                    });\n\t                } else if (stats.isDirectory()) {\n\t                    zipPath += filetools.sep;\n\t                    self.addFile(zipPath, Buffer.alloc(0), comment, stats);\n\t                    return setImmediate(callback, undefined, true);\n\t                }\n\t            });\n\t        },\n\n\t        /**\n\t         * Adds a local directory and all its nested files and directories to the archive\n\t         *\n\t         * @param {string} localPath - local path to the folder\n\t         * @param {string} [zipPath] - optional path inside zip\n\t         * @param {(RegExp|function)} [filter] - optional RegExp or Function if files match will be included.\n\t         */\n\t        addLocalFolder: function (localPath, zipPath, filter) {\n\t            // Prepare filter\n\t            filter = filenameFilter(filter);\n\n\t            // fix ZipPath\n\t            zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n\t            // normalize the path first\n\t            localPath = pth.normalize(localPath);\n\n\t            if (filetools.fs.existsSync(localPath)) {\n\t                const items = filetools.findFiles(localPath);\n\t                const self = this;\n\n\t                if (items.length) {\n\t                    for (const filepath of items) {\n\t                        const p = pth.join(zipPath, relativePath(localPath, filepath));\n\t                        if (filter(p)) {\n\t                            self.addLocalFile(filepath, pth.dirname(p));\n\t                        }\n\t                    }\n\t                }\n\t            } else {\n\t                throw Utils.Errors.FILE_NOT_FOUND(localPath);\n\t            }\n\t        },\n\n\t        /**\n\t         * Asynchronous addLocalFolder\n\t         * @param {string} localPath\n\t         * @param {callback} callback\n\t         * @param {string} [zipPath] optional path inside zip\n\t         * @param {RegExp|function} [filter] optional RegExp or Function if files match will\n\t         *               be included.\n\t         */\n\t        addLocalFolderAsync: function (localPath, callback, zipPath, filter) {\n\t            // Prepare filter\n\t            filter = filenameFilter(filter);\n\n\t            // fix ZipPath\n\t            zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n\t            // normalize the path first\n\t            localPath = pth.normalize(localPath);\n\n\t            var self = this;\n\t            filetools.fs.open(localPath, \"r\", function (err) {\n\t                if (err && err.code === \"ENOENT\") {\n\t                    callback(undefined, Utils.Errors.FILE_NOT_FOUND(localPath));\n\t                } else if (err) {\n\t                    callback(undefined, err);\n\t                } else {\n\t                    var items = filetools.findFiles(localPath);\n\t                    var i = -1;\n\n\t                    var next = function () {\n\t                        i += 1;\n\t                        if (i < items.length) {\n\t                            var filepath = items[i];\n\t                            var p = relativePath(localPath, filepath).split(\"\\\\\").join(\"/\"); //windows fix\n\t                            p = p\n\t                                .normalize(\"NFD\")\n\t                                .replace(/[\\u0300-\\u036f]/g, \"\")\n\t                                .replace(/[^\\x20-\\x7E]/g, \"\"); // accent fix\n\t                            if (filter(p)) {\n\t                                filetools.fs.stat(filepath, function (er0, stats) {\n\t                                    if (er0) callback(undefined, er0);\n\t                                    if (stats.isFile()) {\n\t                                        filetools.fs.readFile(filepath, function (er1, data) {\n\t                                            if (er1) {\n\t                                                callback(undefined, er1);\n\t                                            } else {\n\t                                                self.addFile(zipPath + p, data, \"\", stats);\n\t                                                next();\n\t                                            }\n\t                                        });\n\t                                    } else {\n\t                                        self.addFile(zipPath + p + \"/\", Buffer.alloc(0), \"\", stats);\n\t                                        next();\n\t                                    }\n\t                                });\n\t                            } else {\n\t                                process.nextTick(() => {\n\t                                    next();\n\t                                });\n\t                            }\n\t                        } else {\n\t                            callback(true, undefined);\n\t                        }\n\t                    };\n\n\t                    next();\n\t                }\n\t            });\n\t        },\n\n\t        /**\n\t         * Adds a local directory and all its nested files and directories to the archive\n\t         *\n\t         * @param {object | string} options - options object, if it is string it us used as localPath.\n\t         * @param {string} options.localPath - Local path to the folder.\n\t         * @param {string} [options.zipPath] - optional path inside zip.\n\t         * @param {RegExp|function} [options.filter] - optional RegExp or Function if files match will be included.\n\t         * @param {function|string} [options.namefix] - optional function to help fix filename\n\t         * @param {doneCallback} callback - The callback that handles the response.\n\t         *\n\t         */\n\t        addLocalFolderAsync2: function (options, callback) {\n\t            const self = this;\n\t            options = typeof options === \"object\" ? options : { localPath: options };\n\t            localPath = pth.resolve(fixPath(options.localPath));\n\t            let { zipPath, filter, namefix } = options;\n\n\t            if (filter instanceof RegExp) {\n\t                filter = (function (rx) {\n\t                    return function (filename) {\n\t                        return rx.test(filename);\n\t                    };\n\t                })(filter);\n\t            } else if (\"function\" !== typeof filter) {\n\t                filter = function () {\n\t                    return true;\n\t                };\n\t            }\n\n\t            // fix ZipPath\n\t            zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n\t            // Check Namefix function\n\t            if (namefix == \"latin1\") {\n\t                namefix = (str) =>\n\t                    str\n\t                        .normalize(\"NFD\")\n\t                        .replace(/[\\u0300-\\u036f]/g, \"\")\n\t                        .replace(/[^\\x20-\\x7E]/g, \"\"); // accent fix (latin1 characers only)\n\t            }\n\n\t            if (typeof namefix !== \"function\") namefix = (str) => str;\n\n\t            // internal, create relative path + fix the name\n\t            const relPathFix = (entry) => pth.join(zipPath, namefix(relativePath(localPath, entry)));\n\t            const fileNameFix = (entry) => pth.win32.basename(pth.win32.normalize(namefix(entry)));\n\n\t            filetools.fs.open(localPath, \"r\", function (err) {\n\t                if (err && err.code === \"ENOENT\") {\n\t                    callback(undefined, Utils.Errors.FILE_NOT_FOUND(localPath));\n\t                } else if (err) {\n\t                    callback(undefined, err);\n\t                } else {\n\t                    filetools.findFilesAsync(localPath, function (err, fileEntries) {\n\t                        if (err) return callback(err);\n\t                        fileEntries = fileEntries.filter((dir) => filter(relPathFix(dir)));\n\t                        if (!fileEntries.length) callback(undefined, false);\n\n\t                        setImmediate(\n\t                            fileEntries.reverse().reduce(function (next, entry) {\n\t                                return function (err, done) {\n\t                                    if (err || done === false) return setImmediate(next, err, false);\n\n\t                                    self.addLocalFileAsync(\n\t                                        {\n\t                                            localPath: entry,\n\t                                            zipPath: pth.dirname(relPathFix(entry)),\n\t                                            zipName: fileNameFix(entry)\n\t                                        },\n\t                                        next\n\t                                    );\n\t                                };\n\t                            }, callback)\n\t                        );\n\t                    });\n\t                }\n\t            });\n\t        },\n\n\t        /**\n\t         * Adds a local directory and all its nested files and directories to the archive\n\t         *\n\t         * @param {string} localPath - path where files will be extracted\n\t         * @param {object} props - optional properties\n\t         * @param {string} [props.zipPath] - optional path inside zip\n\t         * @param {RegExp|function} [props.filter] - optional RegExp or Function if files match will be included.\n\t         * @param {function|string} [props.namefix] - optional function to help fix filename\n\t         */\n\t        addLocalFolderPromise: function (localPath, props) {\n\t            return new Promise((resolve, reject) => {\n\t                this.addLocalFolderAsync2(Object.assign({ localPath }, props), (err, done) => {\n\t                    if (err) reject(err);\n\t                    if (done) resolve(this);\n\t                });\n\t            });\n\t        },\n\n\t        /**\n\t         * Allows you to create a entry (file or directory) in the zip file.\n\t         * If you want to create a directory the entryName must end in / and a null buffer should be provided.\n\t         * Comment and attributes are optional\n\t         *\n\t         * @param {string} entryName\n\t         * @param {Buffer | string} content - file content as buffer or utf8 coded string\n\t         * @param {string} [comment] - file comment\n\t         * @param {number | object} [attr] - number as unix file permissions, object as filesystem Stats object\n\t         */\n\t        addFile: function (entryName, content, comment, attr) {\n\t            entryName = zipnamefix(entryName);\n\t            let entry = getEntry(entryName);\n\t            const update = entry != null;\n\n\t            // prepare new entry\n\t            if (!update) {\n\t                entry = new ZipEntry(opts);\n\t                entry.entryName = entryName;\n\t            }\n\t            entry.comment = comment || \"\";\n\n\t            const isStat = \"object\" === typeof attr && attr instanceof filetools.fs.Stats;\n\n\t            // last modification time from file stats\n\t            if (isStat) {\n\t                entry.header.time = attr.mtime;\n\t            }\n\n\t            // Set file attribute\n\t            var fileattr = entry.isDirectory ? 0x10 : 0; // (MS-DOS directory flag)\n\n\t            // extended attributes field for Unix\n\t            // set file type either S_IFDIR / S_IFREG\n\t            let unix = entry.isDirectory ? 0x4000 : 0x8000;\n\n\t            if (isStat) {\n\t                // File attributes from file stats\n\t                unix |= 0xfff & attr.mode;\n\t            } else if (\"number\" === typeof attr) {\n\t                // attr from given attr values\n\t                unix |= 0xfff & attr;\n\t            } else {\n\t                // Default values:\n\t                unix |= entry.isDirectory ? 0o755 : 0o644; // permissions (drwxr-xr-x) or (-r-wr--r--)\n\t            }\n\n\t            fileattr = (fileattr | (unix << 16)) >>> 0; // add attributes\n\n\t            entry.attr = fileattr;\n\n\t            entry.setData(content);\n\t            if (!update) _zip.setEntry(entry);\n\n\t            return entry;\n\t        },\n\n\t        /**\n\t         * Returns an array of ZipEntry objects representing the files and folders inside the archive\n\t         *\n\t         * @param {string} [password]\n\t         * @returns Array\n\t         */\n\t        getEntries: function (password) {\n\t            _zip.password = password;\n\t            return _zip ? _zip.entries : [];\n\t        },\n\n\t        /**\n\t         * Returns a ZipEntry object representing the file or folder specified by ``name``.\n\t         *\n\t         * @param {string} name\n\t         * @return ZipEntry\n\t         */\n\t        getEntry: function (/**String*/ name) {\n\t            return getEntry(name);\n\t        },\n\n\t        getEntryCount: function () {\n\t            return _zip.getEntryCount();\n\t        },\n\n\t        forEach: function (callback) {\n\t            return _zip.forEach(callback);\n\t        },\n\n\t        /**\n\t         * Extracts the given entry to the given targetPath\n\t         * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\n\t         *\n\t         * @param {string|ZipEntry} entry - ZipEntry object or String with the full path of the entry\n\t         * @param {string} targetPath - Target folder where to write the file\n\t         * @param {boolean} [maintainEntryPath=true] - If maintainEntryPath is true and the entry is inside a folder, the entry folder will be created in targetPath as well. Default is TRUE\n\t         * @param {boolean} [overwrite=false] - If the file already exists at the target path, the file will be overwriten if this is true.\n\t         * @param {boolean} [keepOriginalPermission=false] - The file will be set as the permission from the entry if this is true.\n\t         * @param {string} [outFileName] - String If set will override the filename of the extracted file (Only works if the entry is a file)\n\t         *\n\t         * @return Boolean\n\t         */\n\t        extractEntryTo: function (entry, targetPath, maintainEntryPath, overwrite, keepOriginalPermission, outFileName) {\n\t            overwrite = get_Bool(false, overwrite);\n\t            keepOriginalPermission = get_Bool(false, keepOriginalPermission);\n\t            maintainEntryPath = get_Bool(true, maintainEntryPath);\n\t            outFileName = get_Str(keepOriginalPermission, outFileName);\n\n\t            var item = getEntry(entry);\n\t            if (!item) {\n\t                throw Utils.Errors.NO_ENTRY();\n\t            }\n\n\t            var entryName = canonical(item.entryName);\n\n\t            var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));\n\n\t            if (item.isDirectory) {\n\t                var children = _zip.getEntryChildren(item);\n\t                children.forEach(function (child) {\n\t                    if (child.isDirectory) return;\n\t                    var content = child.getData();\n\t                    if (!content) {\n\t                        throw Utils.Errors.CANT_EXTRACT_FILE();\n\t                    }\n\t                    var name = canonical(child.entryName);\n\t                    var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name));\n\t                    // The reverse operation for attr depend on method addFile()\n\t                    const fileAttr = keepOriginalPermission ? child.header.fileAttr : undefined;\n\t                    filetools.writeFileTo(childName, content, overwrite, fileAttr);\n\t                });\n\t                return true;\n\t            }\n\n\t            var content = item.getData(_zip.password);\n\t            if (!content) throw Utils.Errors.CANT_EXTRACT_FILE();\n\n\t            if (filetools.fs.existsSync(target) && !overwrite) {\n\t                throw Utils.Errors.CANT_OVERRIDE();\n\t            }\n\t            // The reverse operation for attr depend on method addFile()\n\t            const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n\t            filetools.writeFileTo(target, content, overwrite, fileAttr);\n\n\t            return true;\n\t        },\n\n\t        /**\n\t         * Test the archive\n\t         * @param {string} [pass]\n\t         */\n\t        test: function (pass) {\n\t            if (!_zip) {\n\t                return false;\n\t            }\n\n\t            for (var entry in _zip.entries) {\n\t                try {\n\t                    if (entry.isDirectory) {\n\t                        continue;\n\t                    }\n\t                    var content = _zip.entries[entry].getData(pass);\n\t                    if (!content) {\n\t                        return false;\n\t                    }\n\t                } catch (err) {\n\t                    return false;\n\t                }\n\t            }\n\t            return true;\n\t        },\n\n\t        /**\n\t         * Extracts the entire archive to the given location\n\t         *\n\t         * @param {string} targetPath Target location\n\t         * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.\n\t         *                  Default is FALSE\n\t         * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.\n\t         *                  Default is FALSE\n\t         * @param {string|Buffer} [pass] password\n\t         */\n\t        extractAllTo: function (targetPath, overwrite, keepOriginalPermission, pass) {\n\t            keepOriginalPermission = get_Bool(false, keepOriginalPermission);\n\t            pass = get_Str(keepOriginalPermission, pass);\n\t            overwrite = get_Bool(false, overwrite);\n\t            if (!_zip) throw Utils.Errors.NO_ZIP();\n\n\t            _zip.entries.forEach(function (entry) {\n\t                var entryName = sanitize(targetPath, canonical(entry.entryName));\n\t                if (entry.isDirectory) {\n\t                    filetools.makeDir(entryName);\n\t                    return;\n\t                }\n\t                var content = entry.getData(pass);\n\t                if (!content) {\n\t                    throw Utils.Errors.CANT_EXTRACT_FILE();\n\t                }\n\t                // The reverse operation for attr depend on method addFile()\n\t                const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n\t                filetools.writeFileTo(entryName, content, overwrite, fileAttr);\n\t                try {\n\t                    filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);\n\t                } catch (err) {\n\t                    throw Utils.Errors.CANT_EXTRACT_FILE();\n\t                }\n\t            });\n\t        },\n\n\t        /**\n\t         * Asynchronous extractAllTo\n\t         *\n\t         * @param {string} targetPath Target location\n\t         * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.\n\t         *                  Default is FALSE\n\t         * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.\n\t         *                  Default is FALSE\n\t         * @param {function} callback The callback will be executed when all entries are extracted successfully or any error is thrown.\n\t         */\n\t        extractAllToAsync: function (targetPath, overwrite, keepOriginalPermission, callback) {\n\t            callback = get_Fun(overwrite, keepOriginalPermission, callback);\n\t            keepOriginalPermission = get_Bool(false, keepOriginalPermission);\n\t            overwrite = get_Bool(false, overwrite);\n\t            if (!callback) {\n\t                return new Promise((resolve, reject) => {\n\t                    this.extractAllToAsync(targetPath, overwrite, keepOriginalPermission, function (err) {\n\t                        if (err) {\n\t                            reject(err);\n\t                        } else {\n\t                            resolve(this);\n\t                        }\n\t                    });\n\t                });\n\t            }\n\t            if (!_zip) {\n\t                callback(Utils.Errors.NO_ZIP());\n\t                return;\n\t            }\n\n\t            targetPath = pth.resolve(targetPath);\n\t            // convert entryName to\n\t            const getPath = (entry) => sanitize(targetPath, pth.normalize(canonical(entry.entryName)));\n\t            const getError = (msg, file) => new Error(msg + ': \"' + file + '\"');\n\n\t            // separate directories from files\n\t            const dirEntries = [];\n\t            const fileEntries = [];\n\t            _zip.entries.forEach((e) => {\n\t                if (e.isDirectory) {\n\t                    dirEntries.push(e);\n\t                } else {\n\t                    fileEntries.push(e);\n\t                }\n\t            });\n\n\t            // Create directory entries first synchronously\n\t            // this prevents race condition and assures folders are there before writing files\n\t            for (const entry of dirEntries) {\n\t                const dirPath = getPath(entry);\n\t                // The reverse operation for attr depend on method addFile()\n\t                const dirAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n\t                try {\n\t                    filetools.makeDir(dirPath);\n\t                    if (dirAttr) filetools.fs.chmodSync(dirPath, dirAttr);\n\t                    // in unix timestamp will change if files are later added to folder, but still\n\t                    filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);\n\t                } catch (er) {\n\t                    callback(getError(\"Unable to create folder\", dirPath));\n\t                }\n\t            }\n\n\t            fileEntries.reverse().reduce(function (next, entry) {\n\t                return function (err) {\n\t                    if (err) {\n\t                        next(err);\n\t                    } else {\n\t                        const entryName = pth.normalize(canonical(entry.entryName));\n\t                        const filePath = sanitize(targetPath, entryName);\n\t                        entry.getDataAsync(function (content, err_1) {\n\t                            if (err_1) {\n\t                                next(err_1);\n\t                            } else if (!content) {\n\t                                next(Utils.Errors.CANT_EXTRACT_FILE());\n\t                            } else {\n\t                                // The reverse operation for attr depend on method addFile()\n\t                                const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n\t                                filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function (succ) {\n\t                                    if (!succ) {\n\t                                        next(getError(\"Unable to write file\", filePath));\n\t                                    }\n\t                                    filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function (err_2) {\n\t                                        if (err_2) {\n\t                                            next(getError(\"Unable to set times\", filePath));\n\t                                        } else {\n\t                                            next();\n\t                                        }\n\t                                    });\n\t                                });\n\t                            }\n\t                        });\n\t                    }\n\t                };\n\t            }, callback)();\n\t        },\n\n\t        /**\n\t         * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\n\t         *\n\t         * @param {string} targetFileName\n\t         * @param {function} callback\n\t         */\n\t        writeZip: function (targetFileName, callback) {\n\t            if (arguments.length === 1) {\n\t                if (typeof targetFileName === \"function\") {\n\t                    callback = targetFileName;\n\t                    targetFileName = \"\";\n\t                }\n\t            }\n\n\t            if (!targetFileName && opts.filename) {\n\t                targetFileName = opts.filename;\n\t            }\n\t            if (!targetFileName) return;\n\n\t            var zipData = _zip.compressToBuffer();\n\t            if (zipData) {\n\t                var ok = filetools.writeFileTo(targetFileName, zipData, true);\n\t                if (typeof callback === \"function\") callback(!ok ? new Error(\"failed\") : null, \"\");\n\t            }\n\t        },\n\n\t        /**\n\t         *\n\t         * @param {string} targetFileName\n\t         * @param {object} [props]\n\t         * @param {boolean} [props.overwrite=true] If the file already exists at the target path, the file will be overwriten if this is true.\n\t         * @param {boolean} [props.perm] The file will be set as the permission from the entry if this is true.\n\n\t         * @returns {Promise<void>}\n\t         */\n\t        writeZipPromise: function (/**String*/ targetFileName, /* object */ props) {\n\t            const { overwrite, perm } = Object.assign({ overwrite: true }, props);\n\n\t            return new Promise((resolve, reject) => {\n\t                // find file name\n\t                if (!targetFileName && opts.filename) targetFileName = opts.filename;\n\t                if (!targetFileName) reject(\"ADM-ZIP: ZIP File Name Missing\");\n\n\t                this.toBufferPromise().then((zipData) => {\n\t                    const ret = (done) => (done ? resolve(done) : reject(\"ADM-ZIP: Wasn't able to write zip file\"));\n\t                    filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);\n\t                }, reject);\n\t            });\n\t        },\n\n\t        /**\n\t         * @returns {Promise<Buffer>} A promise to the Buffer.\n\t         */\n\t        toBufferPromise: function () {\n\t            return new Promise((resolve, reject) => {\n\t                _zip.toAsyncBuffer(resolve, reject);\n\t            });\n\t        },\n\n\t        /**\n\t         * Returns the content of the entire zip file as a Buffer object\n\t         *\n\t         * @prop {function} [onSuccess]\n\t         * @prop {function} [onFail]\n\t         * @prop {function} [onItemStart]\n\t         * @prop {function} [onItemEnd]\n\t         * @returns {Buffer}\n\t         */\n\t        toBuffer: function (onSuccess, onFail, onItemStart, onItemEnd) {\n\t            if (typeof onSuccess === \"function\") {\n\t                _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\n\t                return null;\n\t            }\n\t            return _zip.compressToBuffer();\n\t        }\n\t    };\n\t};\n\treturn admZip$2;\n}\n\nvar admZipExports = requireAdmZip();\nvar admZip = /*@__PURE__*/getDefaultExportFromCjs(admZipExports);\n\nvar admZip$1 = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tdefault: admZip\n});\n\n\n//# sourceMappingURL=adm-zip-86f30d47.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQDBnbGFicy8wZy1zZXJ2aW5nLWJyb2tlci9saWIuZXNtL2FkbS16aXAtODZmMzBkNDcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE4QjtBQUNHO0FBQ0M7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBOztBQUVBLFlBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLEVBQUU7QUFDekMscURBQXFELEVBQUU7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVUsR0FBRyxJQUFJLEdBQUc7QUFDakQsMkNBQTJDLE1BQU07QUFDakQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkNBQVk7QUFDN0IsYUFBYSw2Q0FBYTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EseUVBQXlFLGFBQWE7QUFDdEYsVUFBVTtBQUNWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsc0NBQXNDO0FBQ3RDLGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxVQUFVO0FBQ1YsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxVQUFVO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1YsTUFBTTtBQUNOOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLHNCQUFzQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZDQUFhOztBQUUxQix1REFBdUQsSUFBSTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxxREFBcUQ7QUFDckQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVOztBQUVWLHlDQUF5Qzs7QUFFekMseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdCQUFnQjtBQUNoQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLENBQUMsbUJBQW1COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsS0FBSzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLFNBQVMsVUFBVTs7QUFFbkI7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEU7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLG1EQUFtRCxpRUFBaUU7QUFDcEg7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EOztBQUVwRDs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTtBQUNQLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdDQUFnQzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qjs7O0FBR0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLElBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QixlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixZQUFZO0FBQ1osV0FBVztBQUNYLFlBQVk7QUFDWixZQUFZO0FBQ1osbUJBQW1CO0FBQ25CO0FBQ0EsdUJBQXVCO0FBQ3ZCLFdBQVc7QUFDWCxzQ0FBc0Msa0JBQWtCO0FBQ3hELHFDQUFxQyxtQkFBbUI7QUFDeEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQix3Q0FBd0MsNkJBQTZCO0FBQ3JFLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0M7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksT0FBTztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaLFdBQVc7QUFDWCxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCLGVBQWU7QUFDZixZQUFZO0FBQ1osWUFBWTtBQUNaLG9CQUFvQjtBQUNwQixtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0EsY0FBYztBQUNkLGVBQWU7QUFDZixjQUFjO0FBQ2QsWUFBWTtBQUNaLGVBQWU7QUFDZixlQUFlO0FBQ2YsY0FBYztBQUNkLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixjQUFjO0FBQ2QsY0FBYztBQUNkLGVBQWU7O0FBRWY7Ozs7QUFJQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIseUJBQXlCO0FBQ3pCLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQjtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsc0JBQXNCOztBQUV0QjtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7O0FBRWpCO0FBQ0EsbUJBQW1CO0FBQ25CLG1CQUFtQjs7QUFFbkI7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0EsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QixvQkFBb0I7QUFDcEIscUJBQXFCOztBQUVyQjtBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQixvQkFBb0I7O0FBRXBCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFlBQVk7QUFDWixXQUFXO0FBQ1gsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQSxnQkFBZ0I7QUFDaEIsb0NBQW9DO0FBQ3BDLGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMsV0FBVztBQUNYLFdBQVc7QUFDWCwwQkFBMEI7QUFDMUI7O0FBRUEsU0FBUzs7QUFFVDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixxRUFBcUU7QUFDckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTRELGtDQUFrQzs7QUFFOUY7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsaUJBQWlCLEVBQUUsK0NBQVk7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLHFC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O0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Es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YWJzLzBnLXNlcnZpbmctYnJva2VyL2xpYi5lc20vYWRtLXppcC04NmYzMGQ0Ny5qcz9jZjhkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByZXF1aXJlJCQwJDEgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGhfX2RlZmF1bHQgZnJvbSAncGF0aCc7XG5pbXBvcnQgcmVxdWlyZSQkMCQyIGZyb20gJ2NyeXB0byc7XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbmZ1bmN0aW9uIGdldEF1Z21lbnRlZE5hbWVzcGFjZShuKSB7XG4gIGlmIChuLl9fZXNNb2R1bGUpIHJldHVybiBuO1xuICB2YXIgZiA9IG4uZGVmYXVsdDtcblx0aWYgKHR5cGVvZiBmID09IFwiZnVuY3Rpb25cIikge1xuXHRcdHZhciBhID0gZnVuY3Rpb24gYSAoKSB7XG5cdFx0XHRpZiAodGhpcyBpbnN0YW5jZW9mIGEpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KGYsIGFyZ3VtZW50cywgdGhpcy5jb25zdHJ1Y3Rvcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0YS5wcm90b3R5cGUgPSBmLnByb3RvdHlwZTtcbiAgfSBlbHNlIGEgPSB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsICdfX2VzTW9kdWxlJywge3ZhbHVlOiB0cnVlfSk7XG5cdE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobiwgayk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIGssIGQuZ2V0ID8gZCA6IHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIG5ba107XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gYTtcbn1cblxudmFyIHV0aWwgPSB7ZXhwb3J0czoge319O1xuXG52YXIgY29uc3RhbnRzO1xudmFyIGhhc1JlcXVpcmVkQ29uc3RhbnRzO1xuXG5mdW5jdGlvbiByZXF1aXJlQ29uc3RhbnRzICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ29uc3RhbnRzKSByZXR1cm4gY29uc3RhbnRzO1xuXHRoYXNSZXF1aXJlZENvbnN0YW50cyA9IDE7XG5cdGNvbnN0YW50cyA9IHtcblx0ICAgIC8qIFRoZSBsb2NhbCBmaWxlIGhlYWRlciAqL1xuXHQgICAgTE9DSERSICAgICAgICAgICA6IDMwLCAvLyBMT0MgaGVhZGVyIHNpemVcblx0ICAgIExPQ1NJRyAgICAgICAgICAgOiAweDA0MDM0YjUwLCAvLyBcIlBLXFwwMDNcXDAwNFwiXG5cdCAgICBMT0NWRVIgICAgICAgICAgIDogNCxcdC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3Rcblx0ICAgIExPQ0ZMRyAgICAgICAgICAgOiA2LCAvLyBnZW5lcmFsIHB1cnBvc2UgYml0IGZsYWdcblx0ICAgIExPQ0hPVyAgICAgICAgICAgOiA4LCAvLyBjb21wcmVzc2lvbiBtZXRob2Rcblx0ICAgIExPQ1RJTSAgICAgICAgICAgOiAxMCwgLy8gbW9kaWZpY2F0aW9uIHRpbWUgKDIgYnl0ZXMgdGltZSwgMiBieXRlcyBkYXRlKVxuXHQgICAgTE9DQ1JDICAgICAgICAgICA6IDE0LCAvLyB1bmNvbXByZXNzZWQgZmlsZSBjcmMtMzIgdmFsdWVcblx0ICAgIExPQ1NJWiAgICAgICAgICAgOiAxOCwgLy8gY29tcHJlc3NlZCBzaXplXG5cdCAgICBMT0NMRU4gICAgICAgICAgIDogMjIsIC8vIHVuY29tcHJlc3NlZCBzaXplXG5cdCAgICBMT0NOQU0gICAgICAgICAgIDogMjYsIC8vIGZpbGVuYW1lIGxlbmd0aFxuXHQgICAgTE9DRVhUICAgICAgICAgICA6IDI4LCAvLyBleHRyYSBmaWVsZCBsZW5ndGhcblxuXHQgICAgLyogVGhlIERhdGEgZGVzY3JpcHRvciAqL1xuXHQgICAgRVhUU0lHICAgICAgICAgICA6IDB4MDgwNzRiNTAsIC8vIFwiUEtcXDAwN1xcMDA4XCJcblx0ICAgIEVYVEhEUiAgICAgICAgICAgOiAxNiwgLy8gRVhUIGhlYWRlciBzaXplXG5cdCAgICBFWFRDUkMgICAgICAgICAgIDogNCwgLy8gdW5jb21wcmVzc2VkIGZpbGUgY3JjLTMyIHZhbHVlXG5cdCAgICBFWFRTSVogICAgICAgICAgIDogOCwgLy8gY29tcHJlc3NlZCBzaXplXG5cdCAgICBFWFRMRU4gICAgICAgICAgIDogMTIsIC8vIHVuY29tcHJlc3NlZCBzaXplXG5cblx0ICAgIC8qIFRoZSBjZW50cmFsIGRpcmVjdG9yeSBmaWxlIGhlYWRlciAqL1xuXHQgICAgQ0VOSERSICAgICAgICAgICA6IDQ2LCAvLyBDRU4gaGVhZGVyIHNpemVcblx0ICAgIENFTlNJRyAgICAgICAgICAgOiAweDAyMDE0YjUwLCAvLyBcIlBLXFwwMDFcXDAwMlwiXG5cdCAgICBDRU5WRU0gICAgICAgICAgIDogNCwgLy8gdmVyc2lvbiBtYWRlIGJ5XG5cdCAgICBDRU5WRVIgICAgICAgICAgIDogNiwgLy8gdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuXHQgICAgQ0VORkxHICAgICAgICAgICA6IDgsIC8vIGVuY3J5cHQsIGRlY3J5cHQgZmxhZ3Ncblx0ICAgIENFTkhPVyAgICAgICAgICAgOiAxMCwgLy8gY29tcHJlc3Npb24gbWV0aG9kXG5cdCAgICBDRU5USU0gICAgICAgICAgIDogMTIsIC8vIG1vZGlmaWNhdGlvbiB0aW1lICgyIGJ5dGVzIHRpbWUsIDIgYnl0ZXMgZGF0ZSlcblx0ICAgIENFTkNSQyAgICAgICAgICAgOiAxNiwgLy8gdW5jb21wcmVzc2VkIGZpbGUgY3JjLTMyIHZhbHVlXG5cdCAgICBDRU5TSVogICAgICAgICAgIDogMjAsIC8vIGNvbXByZXNzZWQgc2l6ZVxuXHQgICAgQ0VOTEVOICAgICAgICAgICA6IDI0LCAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuXHQgICAgQ0VOTkFNICAgICAgICAgICA6IDI4LCAvLyBmaWxlbmFtZSBsZW5ndGhcblx0ICAgIENFTkVYVCAgICAgICAgICAgOiAzMCwgLy8gZXh0cmEgZmllbGQgbGVuZ3RoXG5cdCAgICBDRU5DT00gICAgICAgICAgIDogMzIsIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcblx0ICAgIENFTkRTSyAgICAgICAgICAgOiAzNCwgLy8gdm9sdW1lIG51bWJlciBzdGFydFxuXHQgICAgQ0VOQVRUICAgICAgICAgICA6IDM2LCAvLyBpbnRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcblx0ICAgIENFTkFUWCAgICAgICAgICAgOiAzOCwgLy8gZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIChob3N0IHN5c3RlbSBkZXBlbmRlbnQpXG5cdCAgICBDRU5PRkYgICAgICAgICAgIDogNDIsIC8vIExPQyBoZWFkZXIgb2Zmc2V0XG5cblx0ICAgIC8qIFRoZSBlbnRyaWVzIGluIHRoZSBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgKi9cblx0ICAgIEVOREhEUiAgICAgICAgICAgOiAyMiwgLy8gRU5EIGhlYWRlciBzaXplXG5cdCAgICBFTkRTSUcgICAgICAgICAgIDogMHgwNjA1NGI1MCwgLy8gXCJQS1xcMDA1XFwwMDZcIlxuXHQgICAgRU5EU1VCICAgICAgICAgICA6IDgsIC8vIG51bWJlciBvZiBlbnRyaWVzIG9uIHRoaXMgZGlza1xuXHQgICAgRU5EVE9UICAgICAgICAgICA6IDEwLCAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllc1xuXHQgICAgRU5EU0laICAgICAgICAgICA6IDEyLCAvLyBjZW50cmFsIGRpcmVjdG9yeSBzaXplIGluIGJ5dGVzXG5cdCAgICBFTkRPRkYgICAgICAgICAgIDogMTYsIC8vIG9mZnNldCBvZiBmaXJzdCBDRU4gaGVhZGVyXG5cdCAgICBFTkRDT00gICAgICAgICAgIDogMjAsIC8vIHppcCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG5cblx0ICAgIEVORDY0SERSICAgICAgICAgOiAyMCwgLy8gemlwNjQgRU5EIGhlYWRlciBzaXplXG5cdCAgICBFTkQ2NFNJRyAgICAgICAgIDogMHgwNzA2NGI1MCwgLy8gemlwNjQgTG9jYXRvciBzaWduYXR1cmUsIFwiUEtcXDAwNlxcMDA3XCJcblx0ICAgIEVORDY0U1RBUlQgICAgICAgOiA0LCAvLyBudW1iZXIgb2YgdGhlIGRpc2sgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIHppcDY0XG5cdCAgICBFTkQ2NE9GRiAgICAgICAgIDogOCwgLy8gcmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSB6aXA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3Rvcnlcblx0ICAgIEVORDY0TlVNRElTS1MgICAgOiAxNiwgLy8gdG90YWwgbnVtYmVyIG9mIGRpc2tzXG5cblx0ICAgIFpJUDY0U0lHICAgICAgICAgOiAweDA2MDY0YjUwLCAvLyB6aXA2NCBzaWduYXR1cmUsIFwiUEtcXDAwNlxcMDA2XCJcblx0ICAgIFpJUDY0SERSICAgICAgICAgOiA1NiwgLy8gemlwNjQgcmVjb3JkIG1pbmltdW0gc2l6ZVxuXHQgICAgWklQNjRMRUFEICAgICAgICA6IDEyLCAvLyBsZWFkaW5nIGJ5dGVzIGF0IHRoZSBzdGFydCBvZiB0aGUgcmVjb3JkLCBub3QgY291bnRlZCBieSB0aGUgdmFsdWUgc3RvcmVkIGluIFpJUDY0U0laRVxuXHQgICAgWklQNjRTSVpFICAgICAgICA6IDQsIC8vIHppcDY0IHNpemUgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZFxuXHQgICAgWklQNjRWRU0gICAgICAgICA6IDEyLCAvLyB6aXA2NCB2ZXJzaW9uIG1hZGUgYnlcblx0ICAgIFpJUDY0VkVSICAgICAgICAgOiAxNCwgLy8gemlwNjQgdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuXHQgICAgWklQNjREU0sgICAgICAgICA6IDE2LCAvLyB6aXA2NCBudW1iZXIgb2YgdGhpcyBkaXNrXG5cdCAgICBaSVA2NERTS0RJUiAgICAgIDogMjAsIC8vIG51bWJlciBvZiB0aGUgZGlzayB3aXRoIHRoZSBzdGFydCBvZiB0aGUgcmVjb3JkIGRpcmVjdG9yeVxuXHQgICAgWklQNjRTVUIgICAgICAgICA6IDI0LCAvLyBudW1iZXIgb2YgZW50cmllcyBvbiB0aGlzIGRpc2tcblx0ICAgIFpJUDY0VE9UICAgICAgICAgOiAzMiwgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXNcblx0ICAgIFpJUDY0U0laQiAgICAgICAgOiA0MCwgLy8gemlwNjQgY2VudHJhbCBkaXJlY3Rvcnkgc2l6ZSBpbiBieXRlc1xuXHQgICAgWklQNjRPRkYgICAgICAgICA6IDQ4LCAvLyBvZmZzZXQgb2Ygc3RhcnQgb2YgY2VudHJhbCBkaXJlY3Rvcnkgd2l0aCByZXNwZWN0IHRvIHRoZSBzdGFydGluZyBkaXNrIG51bWJlclxuXHQgICAgWklQNjRFWFRSQSAgICAgICA6IDU2LCAvLyBleHRlbnNpYmxlIGRhdGEgc2VjdG9yXG5cblx0ICAgIC8qIENvbXByZXNzaW9uIG1ldGhvZHMgKi9cblx0ICAgIFNUT1JFRCAgICAgICAgICAgOiAwLCAvLyBubyBjb21wcmVzc2lvblxuXHQgICAgU0hSVU5LICAgICAgICAgICA6IDEsIC8vIHNocnVua1xuXHQgICAgUkVEVUNFRDEgICAgICAgICA6IDIsIC8vIHJlZHVjZWQgd2l0aCBjb21wcmVzc2lvbiBmYWN0b3IgMVxuXHQgICAgUkVEVUNFRDIgICAgICAgICA6IDMsIC8vIHJlZHVjZWQgd2l0aCBjb21wcmVzc2lvbiBmYWN0b3IgMlxuXHQgICAgUkVEVUNFRDMgICAgICAgICA6IDQsIC8vIHJlZHVjZWQgd2l0aCBjb21wcmVzc2lvbiBmYWN0b3IgM1xuXHQgICAgUkVEVUNFRDQgICAgICAgICA6IDUsIC8vIHJlZHVjZWQgd2l0aCBjb21wcmVzc2lvbiBmYWN0b3IgNFxuXHQgICAgSU1QTE9ERUQgICAgICAgICA6IDYsIC8vIGltcGxvZGVkXG5cdCAgICAvLyA3IHJlc2VydmVkIGZvciBUb2tlbml6aW5nIGNvbXByZXNzaW9uIGFsZ29yaXRobVxuXHQgICAgREVGTEFURUQgICAgICAgICA6IDgsIC8vIGRlZmxhdGVkXG5cdCAgICBFTkhBTkNFRF9ERUZMQVRFRDogOSwgLy8gZW5oYW5jZWQgZGVmbGF0ZWRcblx0ICAgIFBLV0FSRSAgICAgICAgICAgOiAxMCwvLyBQS1dhcmUgRENMIGltcGxvZGVkXG5cdCAgICAvLyAxMSByZXNlcnZlZCBieSBQS1dBUkVcblx0ICAgIEJaSVAyICAgICAgICAgICAgOiAxMiwgLy8gIGNvbXByZXNzZWQgdXNpbmcgQlpJUDJcblx0ICAgIC8vIDEzIHJlc2VydmVkIGJ5IFBLV0FSRVxuXHQgICAgTFpNQSAgICAgICAgICAgICA6IDE0LCAvLyBMWk1BXG5cdCAgICAvLyAxNS0xNyByZXNlcnZlZCBieSBQS1dBUkVcblx0ICAgIElCTV9URVJTRSAgICAgICAgOiAxOCwgLy8gY29tcHJlc3NlZCB1c2luZyBJQk0gVEVSU0Vcblx0ICAgIElCTV9MWjc3ICAgICAgICAgOiAxOSwgLy8gSUJNIExaNzcgelxuXHQgICAgQUVTX0VOQ1JZUFQgICAgICA6IDk5LCAvLyBXaW5aSVAgQUVTIGVuY3J5cHRpb24gbWV0aG9kXG5cblx0ICAgIC8qIEdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZyAqL1xuXHQgICAgLy8gdmFsdWVzIGNhbiBvYnRhaW5lZCB3aXRoIGV4cHJlc3Npb24gMioqYml0bnJcblx0ICAgIEZMR19FTkMgICAgICAgICAgOiAxLCAgICAvLyBCaXQgMDogZW5jcnlwdGVkIGZpbGVcblx0ICAgIEZMR19DT01QMSAgICAgICAgOiAyLCAgICAvLyBCaXQgMSwgY29tcHJlc3Npb24gb3B0aW9uXG5cdCAgICBGTEdfQ09NUDIgICAgICAgIDogNCwgICAgLy8gQml0IDIsIGNvbXByZXNzaW9uIG9wdGlvblxuXHQgICAgRkxHX0RFU0MgICAgICAgICA6IDgsICAgIC8vIEJpdCAzLCBkYXRhIGRlc2NyaXB0b3Jcblx0ICAgIEZMR19FTkggICAgICAgICAgOiAxNiwgICAvLyBCaXQgNCwgZW5oYW5jZWQgZGVmbGF0aW5nXG5cdCAgICBGTEdfUEFUQ0ggICAgICAgIDogMzIsICAgLy8gQml0IDUsIGluZGljYXRlcyB0aGF0IHRoZSBmaWxlIGlzIGNvbXByZXNzZWQgcGF0Y2hlZCBkYXRhLlxuXHQgICAgRkxHX1NUUiAgICAgICAgICA6IDY0LCAgIC8vIEJpdCA2LCBzdHJvbmcgZW5jcnlwdGlvbiAocGF0ZW50ZWQpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQml0cyA3LTEwOiBDdXJyZW50bHkgdW51c2VkLlxuXHQgICAgRkxHX0VGUyAgICAgICAgICA6IDIwNDgsIC8vIEJpdCAxMTogTGFuZ3VhZ2UgZW5jb2RpbmcgZmxhZyAoRUZTKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJpdCAxMjogUmVzZXJ2ZWQgYnkgUEtXQVJFIGZvciBlbmhhbmNlZCBjb21wcmVzc2lvbi5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCaXQgMTM6IGVuY3J5cHRlZCB0aGUgQ2VudHJhbCBEaXJlY3RvcnkgKHBhdGVudGVkKS5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCaXRzIDE0LTE1OiBSZXNlcnZlZCBieSBQS1dBUkUuXG5cdCAgICBGTEdfTVNLICAgICAgICAgIDogNDA5NiwgLy8gbWFzayBoZWFkZXIgdmFsdWVzXG5cblx0ICAgIC8qIExvYWQgdHlwZSAqL1xuXHQgICAgRklMRSAgICAgICAgICAgICA6IDIsXG5cdCAgICBCVUZGRVIgICAgICAgICAgIDogMSxcblx0ICAgIE5PTkUgICAgICAgICAgICAgOiAwLFxuXG5cdCAgICAvKiA0LjUgRXh0ZW5zaWJsZSBkYXRhIGZpZWxkcyAqL1xuXHQgICAgRUZfSUQgICAgICAgICAgICA6IDAsXG5cdCAgICBFRl9TSVpFICAgICAgICAgIDogMixcblxuXHQgICAgLyogSGVhZGVyIElEcyAqL1xuXHQgICAgSURfWklQNjQgICAgICAgICA6IDB4MDAwMSxcblx0ICAgIElEX0FWSU5GTyAgICAgICAgOiAweDAwMDcsXG5cdCAgICBJRF9QRlMgICAgICAgICAgIDogMHgwMDA4LFxuXHQgICAgSURfT1MyICAgICAgICAgICA6IDB4MDAwOSxcblx0ICAgIElEX05URlMgICAgICAgICAgOiAweDAwMGEsXG5cdCAgICBJRF9PUEVOVk1TICAgICAgIDogMHgwMDBjLFxuXHQgICAgSURfVU5JWCAgICAgICAgICA6IDB4MDAwZCxcblx0ICAgIElEX0ZPUksgICAgICAgICAgOiAweDAwMGUsXG5cdCAgICBJRF9QQVRDSCAgICAgICAgIDogMHgwMDBmLFxuXHQgICAgSURfWDUwOV9QS0NTNyAgICA6IDB4MDAxNCxcblx0ICAgIElEX1g1MDlfQ0VSVElEX0YgOiAweDAwMTUsXG5cdCAgICBJRF9YNTA5X0NFUlRJRF9DIDogMHgwMDE2LFxuXHQgICAgSURfU1RST05HRU5DICAgICA6IDB4MDAxNyxcblx0ICAgIElEX1JFQ09SRF9NR1QgICAgOiAweDAwMTgsXG5cdCAgICBJRF9YNTA5X1BLQ1M3X1JMIDogMHgwMDE5LFxuXHQgICAgSURfSUJNMSAgICAgICAgICA6IDB4MDA2NSxcblx0ICAgIElEX0lCTTIgICAgICAgICAgOiAweDAwNjYsXG5cdCAgICBJRF9QT1NaSVAgICAgICAgIDogMHg0NjkwLFxuXG5cdCAgICBFRl9aSVA2NF9PUl8zMiAgIDogMHhmZmZmZmZmZixcblx0ICAgIEVGX1pJUDY0X09SXzE2ICAgOiAweGZmZmYsXG5cdCAgICBFRl9aSVA2NF9TVU5DT01QIDogMCxcblx0ICAgIEVGX1pJUDY0X1NDT01QICAgOiA4LFxuXHQgICAgRUZfWklQNjRfUkhPICAgICA6IDE2LFxuXHQgICAgRUZfWklQNjRfRFNOICAgICA6IDI0XG5cdH07XG5cdHJldHVybiBjb25zdGFudHM7XG59XG5cbnZhciBlcnJvcnMgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkRXJyb3JzO1xuXG5mdW5jdGlvbiByZXF1aXJlRXJyb3JzICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkRXJyb3JzKSByZXR1cm4gZXJyb3JzO1xuXHRoYXNSZXF1aXJlZEVycm9ycyA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdGNvbnN0IGVycm9ycyA9IHtcblx0XHQgICAgLyogSGVhZGVyIGVycm9yIG1lc3NhZ2VzICovXG5cdFx0ICAgIElOVkFMSURfTE9DOiBcIkludmFsaWQgTE9DIGhlYWRlciAoYmFkIHNpZ25hdHVyZSlcIixcblx0XHQgICAgSU5WQUxJRF9DRU46IFwiSW52YWxpZCBDRU4gaGVhZGVyIChiYWQgc2lnbmF0dXJlKVwiLFxuXHRcdCAgICBJTlZBTElEX0VORDogXCJJbnZhbGlkIEVORCBoZWFkZXIgKGJhZCBzaWduYXR1cmUpXCIsXG5cblx0XHQgICAgLyogRGVzY3JpcHRvciAqL1xuXHRcdCAgICBERVNDUklQVE9SX05PVF9FWElTVDogXCJObyBkZXNjcmlwdG9yIHByZXNlbnRcIixcblx0XHQgICAgREVTQ1JJUFRPUl9VTktOT1dOOiBcIlVua25vd24gZGVzY3JpcHRvciBmb3JtYXRcIixcblx0XHQgICAgREVTQ1JJUFRPUl9GQVVMVFk6IFwiRGVzY3JpcHRvciBkYXRhIGlzIG1hbGZvcm1lZFwiLFxuXG5cdFx0ICAgIC8qIFppcEVudHJ5IGVycm9yIG1lc3NhZ2VzKi9cblx0XHQgICAgTk9fREFUQTogXCJOb3RoaW5nIHRvIGRlY29tcHJlc3NcIixcblx0XHQgICAgQkFEX0NSQzogXCJDUkMzMiBjaGVja3N1bSBmYWlsZWQgezB9XCIsXG5cdFx0ICAgIEZJTEVfSU5fVEhFX1dBWTogXCJUaGVyZSBpcyBhIGZpbGUgaW4gdGhlIHdheTogezB9XCIsXG5cdFx0ICAgIFVOS05PV05fTUVUSE9EOiBcIkludmFsaWQvdW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gbWV0aG9kXCIsXG5cblx0XHQgICAgLyogSW5mbGF0ZXIgZXJyb3IgbWVzc2FnZXMgKi9cblx0XHQgICAgQVZBSUxfREFUQTogXCJpbmZsYXRlOjpBdmFpbGFibGUgaW5mbGF0ZSBkYXRhIGRpZCBub3QgdGVybWluYXRlXCIsXG5cdFx0ICAgIElOVkFMSURfRElTVEFOQ0U6IFwiaW5mbGF0ZTo6SW52YWxpZCBsaXRlcmFsL2xlbmd0aCBvciBkaXN0YW5jZSBjb2RlIGluIGZpeGVkIG9yIGR5bmFtaWMgYmxvY2tcIixcblx0XHQgICAgVE9fTUFOWV9DT0RFUzogXCJpbmZsYXRlOjpEeW5hbWljIGJsb2NrIGNvZGUgZGVzY3JpcHRpb246IHRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBjb2Rlc1wiLFxuXHRcdCAgICBJTlZBTElEX1JFUEVBVF9MRU46IFwiaW5mbGF0ZTo6RHluYW1pYyBibG9jayBjb2RlIGRlc2NyaXB0aW9uOiByZXBlYXQgbW9yZSB0aGFuIHNwZWNpZmllZCBsZW5ndGhzXCIsXG5cdFx0ICAgIElOVkFMSURfUkVQRUFUX0ZJUlNUOiBcImluZmxhdGU6OkR5bmFtaWMgYmxvY2sgY29kZSBkZXNjcmlwdGlvbjogcmVwZWF0IGxlbmd0aHMgd2l0aCBubyBmaXJzdCBsZW5ndGhcIixcblx0XHQgICAgSU5DT01QTEVURV9DT0RFUzogXCJpbmZsYXRlOjpEeW5hbWljIGJsb2NrIGNvZGUgZGVzY3JpcHRpb246IGNvZGUgbGVuZ3RocyBjb2RlcyBpbmNvbXBsZXRlXCIsXG5cdFx0ICAgIElOVkFMSURfRFlOX0RJU1RBTkNFOiBcImluZmxhdGU6OkR5bmFtaWMgYmxvY2sgY29kZSBkZXNjcmlwdGlvbjogaW52YWxpZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHNcIixcblx0XHQgICAgSU5WQUxJRF9DT0RFU19MRU46IFwiaW5mbGF0ZTo6RHluYW1pYyBibG9jayBjb2RlIGRlc2NyaXB0aW9uOiBpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUgbGVuZ3Roc1wiLFxuXHRcdCAgICBJTlZBTElEX1NUT1JFX0JMT0NLOiBcImluZmxhdGU6OlN0b3JlZCBibG9jayBsZW5ndGggZGlkIG5vdCBtYXRjaCBvbmUncyBjb21wbGVtZW50XCIsXG5cdFx0ICAgIElOVkFMSURfQkxPQ0tfVFlQRTogXCJpbmZsYXRlOjpJbnZhbGlkIGJsb2NrIHR5cGUgKHR5cGUgPT0gMylcIixcblxuXHRcdCAgICAvKiBBRE0tWklQIGVycm9yIG1lc3NhZ2VzICovXG5cdFx0ICAgIENBTlRfRVhUUkFDVF9GSUxFOiBcIkNvdWxkIG5vdCBleHRyYWN0IHRoZSBmaWxlXCIsXG5cdFx0ICAgIENBTlRfT1ZFUlJJREU6IFwiVGFyZ2V0IGZpbGUgYWxyZWFkeSBleGlzdHNcIixcblx0XHQgICAgRElTS19FTlRSWV9UT09fTEFSR0U6IFwiTnVtYmVyIG9mIGRpc2sgZW50cmllcyBpcyB0b28gbGFyZ2VcIixcblx0XHQgICAgTk9fWklQOiBcIk5vIHppcCBmaWxlIHdhcyBsb2FkZWRcIixcblx0XHQgICAgTk9fRU5UUlk6IFwiRW50cnkgZG9lc24ndCBleGlzdFwiLFxuXHRcdCAgICBESVJFQ1RPUllfQ09OVEVOVF9FUlJPUjogXCJBIGRpcmVjdG9yeSBjYW5ub3QgaGF2ZSBjb250ZW50XCIsXG5cdFx0ICAgIEZJTEVfTk9UX0ZPVU5EOiAnRmlsZSBub3QgZm91bmQ6IFwiezB9XCInLFxuXHRcdCAgICBOT1RfSU1QTEVNRU5URUQ6IFwiTm90IGltcGxlbWVudGVkXCIsXG5cdFx0ICAgIElOVkFMSURfRklMRU5BTUU6IFwiSW52YWxpZCBmaWxlbmFtZVwiLFxuXHRcdCAgICBJTlZBTElEX0ZPUk1BVDogXCJJbnZhbGlkIG9yIHVuc3VwcG9ydGVkIHppcCBmb3JtYXQuIE5vIEVORCBoZWFkZXIgZm91bmRcIixcblx0XHQgICAgSU5WQUxJRF9QQVNTX1BBUkFNOiBcIkluY29tcGF0aWJsZSBwYXNzd29yZCBwYXJhbWV0ZXJcIixcblx0XHQgICAgV1JPTkdfUEFTU1dPUkQ6IFwiV3JvbmcgUGFzc3dvcmRcIixcblxuXHRcdCAgICAvKiBBRE0tWklQICovXG5cdFx0ICAgIENPTU1FTlRfVE9PX0xPTkc6IFwiQ29tbWVudCBpcyB0b28gbG9uZ1wiLCAvLyBDb21tZW50IGNhbiBiZSBtYXggNjU1MzUgYnl0ZXMgbG9uZyAoTk9URTogc29tZSBub24tVVMgY2hhcmFjdGVycyBtYXkgdGFrZSBtb3JlIHNwYWNlKVxuXHRcdCAgICBFWFRSQV9GSUVMRF9QQVJTRV9FUlJPUjogXCJFeHRyYSBmaWVsZCBwYXJzaW5nIGVycm9yXCJcblx0XHR9O1xuXG5cdFx0Ly8gdGVtcGxhdGVcblx0XHRmdW5jdGlvbiBFKG1lc3NhZ2UpIHtcblx0XHQgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0ICAgICAgICBpZiAoYXJncy5sZW5ndGgpIHsgLy8gQWxsb3cgezB9IC4uIHs5fSBhcmd1bWVudHMgaW4gZXJyb3IgbWVzc2FnZSwgYmFzZWQgb24gYXJndW1lbnQgbnVtYmVyXG5cdFx0ICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgvXFx7KFxcZClcXH0vZywgKF8sIG4pID0+IGFyZ3Nbbl0gfHwgJycpO1xuXHRcdCAgICAgICAgfVxuXG5cdFx0ICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdBRE0tWklQOiAnICsgbWVzc2FnZSk7XG5cdFx0ICAgIH07XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCBlcnJvcnMgd2l0aCB0ZW1wbGF0ZVxuXHRcdGZvciAoY29uc3QgbXNnIG9mIE9iamVjdC5rZXlzKGVycm9ycykpIHtcblx0XHQgICAgZXhwb3J0c1ttc2ddID0gRShlcnJvcnNbbXNnXSk7XG5cdFx0fSBcblx0fSAoZXJyb3JzKSk7XG5cdHJldHVybiBlcnJvcnM7XG59XG5cbnZhciB1dGlscztcbnZhciBoYXNSZXF1aXJlZFV0aWxzO1xuXG5mdW5jdGlvbiByZXF1aXJlVXRpbHMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRVdGlscykgcmV0dXJuIHV0aWxzO1xuXHRoYXNSZXF1aXJlZFV0aWxzID0gMTtcblx0Y29uc3QgZnN5c3RlbSA9IHJlcXVpcmUkJDAkMTtcblx0Y29uc3QgcHRoID0gcGF0aF9fZGVmYXVsdDtcblx0Y29uc3QgQ29uc3RhbnRzID0gcmVxdWlyZUNvbnN0YW50cygpO1xuXHRjb25zdCBFcnJvcnMgPSByZXF1aXJlRXJyb3JzKCk7XG5cdGNvbnN0IGlzV2luID0gdHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgXCJ3aW4zMlwiID09PSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5cdGNvbnN0IGlzX09iaiA9IChvYmopID0+IHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsO1xuXG5cdC8vIGdlbmVyYXRlIENSQzMyIGxvb2t1cCB0YWJsZVxuXHRjb25zdCBjcmNUYWJsZSA9IG5ldyBVaW50MzJBcnJheSgyNTYpLm1hcCgodCwgYykgPT4ge1xuXHQgICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcblx0ICAgICAgICBpZiAoKGMgJiAxKSAhPT0gMCkge1xuXHQgICAgICAgICAgICBjID0gMHhlZGI4ODMyMCBeIChjID4+PiAxKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBjID4+Pj0gMTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYyA+Pj4gMDtcblx0fSk7XG5cblx0Ly8gVVRJTFMgZnVuY3Rpb25zXG5cblx0ZnVuY3Rpb24gVXRpbHMob3B0cykge1xuXHQgICAgdGhpcy5zZXAgPSBwdGguc2VwO1xuXHQgICAgdGhpcy5mcyA9IGZzeXN0ZW07XG5cblx0ICAgIGlmIChpc19PYmoob3B0cykpIHtcblx0ICAgICAgICAvLyBjdXN0b20gZmlsZXN5c3RlbVxuXHQgICAgICAgIGlmIChpc19PYmoob3B0cy5mcykgJiYgdHlwZW9mIG9wdHMuZnMuc3RhdFN5bmMgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICB0aGlzLmZzID0gb3B0cy5mcztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH1cblxuXHR1dGlscyA9IFV0aWxzO1xuXG5cdC8vIElOU1RBTlRJQUJMRSBmdW5jdGlvbnNcblxuXHRVdGlscy5wcm90b3R5cGUubWFrZURpciA9IGZ1bmN0aW9uICgvKlN0cmluZyovIGZvbGRlcikge1xuXHQgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0ICAgIC8vIFN5bmMgLSBtYWtlIGRpcmVjdG9yaWVzIHRyZWVcblx0ICAgIGZ1bmN0aW9uIG1rZGlyU3luYygvKlN0cmluZyovIGZwYXRoKSB7XG5cdCAgICAgICAgbGV0IHJlc29sdmVkUGF0aCA9IGZwYXRoLnNwbGl0KHNlbGYuc2VwKVswXTtcblx0ICAgICAgICBmcGF0aC5zcGxpdChzZWxmLnNlcCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgICAgICBpZiAoIW5hbWUgfHwgbmFtZS5zdWJzdHIoLTEsIDEpID09PSBcIjpcIikgcmV0dXJuO1xuXHQgICAgICAgICAgICByZXNvbHZlZFBhdGggKz0gc2VsZi5zZXAgKyBuYW1lO1xuXHQgICAgICAgICAgICB2YXIgc3RhdDtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHN0YXQgPSBzZWxmLmZzLnN0YXRTeW5jKHJlc29sdmVkUGF0aCk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHNlbGYuZnMubWtkaXJTeW5jKHJlc29sdmVkUGF0aCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHN0YXQgJiYgc3RhdC5pc0ZpbGUoKSkgdGhyb3cgRXJyb3JzLkZJTEVfSU5fVEhFX1dBWShgXCIke3Jlc29sdmVkUGF0aH1cImApO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBta2RpclN5bmMoZm9sZGVyKTtcblx0fTtcblxuXHRVdGlscy5wcm90b3R5cGUud3JpdGVGaWxlVG8gPSBmdW5jdGlvbiAoLypTdHJpbmcqLyBwYXRoLCAvKkJ1ZmZlciovIGNvbnRlbnQsIC8qQm9vbGVhbiovIG92ZXJ3cml0ZSwgLypOdW1iZXIqLyBhdHRyKSB7XG5cdCAgICBjb25zdCBzZWxmID0gdGhpcztcblx0ICAgIGlmIChzZWxmLmZzLmV4aXN0c1N5bmMocGF0aCkpIHtcblx0ICAgICAgICBpZiAoIW92ZXJ3cml0ZSkgcmV0dXJuIGZhbHNlOyAvLyBjYW5ub3Qgb3ZlcndyaXRlXG5cblx0ICAgICAgICB2YXIgc3RhdCA9IHNlbGYuZnMuc3RhdFN5bmMocGF0aCk7XG5cdCAgICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgdmFyIGZvbGRlciA9IHB0aC5kaXJuYW1lKHBhdGgpO1xuXHQgICAgaWYgKCFzZWxmLmZzLmV4aXN0c1N5bmMoZm9sZGVyKSkge1xuXHQgICAgICAgIHNlbGYubWFrZURpcihmb2xkZXIpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZmQ7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGZkID0gc2VsZi5mcy5vcGVuU3luYyhwYXRoLCBcIndcIiwgMG82NjYpOyAvLyAwNjY2XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgc2VsZi5mcy5jaG1vZFN5bmMocGF0aCwgMG82NjYpO1xuXHQgICAgICAgIGZkID0gc2VsZi5mcy5vcGVuU3luYyhwYXRoLCBcIndcIiwgMG82NjYpO1xuXHQgICAgfVxuXHQgICAgaWYgKGZkKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgc2VsZi5mcy53cml0ZVN5bmMoZmQsIGNvbnRlbnQsIDAsIGNvbnRlbnQubGVuZ3RoLCAwKTtcblx0ICAgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgICAgICBzZWxmLmZzLmNsb3NlU3luYyhmZCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgc2VsZi5mcy5jaG1vZFN5bmMocGF0aCwgYXR0ciB8fCAwbzY2Nik7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHRVdGlscy5wcm90b3R5cGUud3JpdGVGaWxlVG9Bc3luYyA9IGZ1bmN0aW9uICgvKlN0cmluZyovIHBhdGgsIC8qQnVmZmVyKi8gY29udGVudCwgLypCb29sZWFuKi8gb3ZlcndyaXRlLCAvKk51bWJlciovIGF0dHIsIC8qRnVuY3Rpb24qLyBjYWxsYmFjaykge1xuXHQgICAgaWYgKHR5cGVvZiBhdHRyID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICBjYWxsYmFjayA9IGF0dHI7XG5cdCAgICAgICAgYXR0ciA9IHVuZGVmaW5lZDtcblx0ICAgIH1cblxuXHQgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0ICAgIHNlbGYuZnMuZXhpc3RzKHBhdGgsIGZ1bmN0aW9uIChleGlzdCkge1xuXHQgICAgICAgIGlmIChleGlzdCAmJiAhb3ZlcndyaXRlKSByZXR1cm4gY2FsbGJhY2soZmFsc2UpO1xuXG5cdCAgICAgICAgc2VsZi5mcy5zdGF0KHBhdGgsIGZ1bmN0aW9uIChlcnIsIHN0YXQpIHtcblx0ICAgICAgICAgICAgaWYgKGV4aXN0ICYmIHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZhbHNlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciBmb2xkZXIgPSBwdGguZGlybmFtZShwYXRoKTtcblx0ICAgICAgICAgICAgc2VsZi5mcy5leGlzdHMoZm9sZGVyLCBmdW5jdGlvbiAoZXhpc3RzKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWV4aXN0cykgc2VsZi5tYWtlRGlyKGZvbGRlcik7XG5cblx0ICAgICAgICAgICAgICAgIHNlbGYuZnMub3BlbihwYXRoLCBcIndcIiwgMG82NjYsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZzLmNobW9kKHBhdGgsIDBvNjY2LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZzLm9wZW4ocGF0aCwgXCJ3XCIsIDBvNjY2LCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZnMud3JpdGUoZmQsIGNvbnRlbnQsIDAsIGNvbnRlbnQubGVuZ3RoLCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZnMuY2xvc2UoZmQsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZnMuY2htb2QocGF0aCwgYXR0ciB8fCAwbzY2NiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mcy53cml0ZShmZCwgY29udGVudCwgMCwgY29udGVudC5sZW5ndGgsIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZnMuY2xvc2UoZmQsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZzLmNobW9kKHBhdGgsIGF0dHIgfHwgMG82NjYsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mcy5jaG1vZChwYXRoLCBhdHRyIHx8IDBvNjY2LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdH07XG5cblx0VXRpbHMucHJvdG90eXBlLmZpbmRGaWxlcyA9IGZ1bmN0aW9uICgvKlN0cmluZyovIHBhdGgpIHtcblx0ICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdCAgICBmdW5jdGlvbiBmaW5kU3luYygvKlN0cmluZyovIGRpciwgLypSZWdFeHAqLyBwYXR0ZXJuLCAvKkJvb2xlYW4qLyByZWN1cnNpdmUpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwiYm9vbGVhblwiKSB7XG5cdCAgICAgICAgICAgIHJlY3Vyc2l2ZSA9IHBhdHRlcm47XG5cdCAgICAgICAgICAgIHBhdHRlcm4gPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGxldCBmaWxlcyA9IFtdO1xuXHQgICAgICAgIHNlbGYuZnMucmVhZGRpclN5bmMoZGlyKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IHBhdGggPSBwdGguam9pbihkaXIsIGZpbGUpO1xuXHQgICAgICAgICAgICBjb25zdCBzdGF0ID0gc2VsZi5mcy5zdGF0U3luYyhwYXRoKTtcblxuXHQgICAgICAgICAgICBpZiAoIXBhdHRlcm4gfHwgcGF0dGVybi50ZXN0KHBhdGgpKSB7XG5cdCAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKHB0aC5ub3JtYWxpemUocGF0aCkgKyAoc3RhdC5pc0RpcmVjdG9yeSgpID8gc2VsZi5zZXAgOiBcIlwiKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpICYmIHJlY3Vyc2l2ZSkgZmlsZXMgPSBmaWxlcy5jb25jYXQoZmluZFN5bmMocGF0aCwgcGF0dGVybiwgcmVjdXJzaXZlKSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIGZpbGVzO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmluZFN5bmMocGF0aCwgdW5kZWZpbmVkLCB0cnVlKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGJhY2sgZm9yIHNob3dpbmcgaWYgZXZlcnl0aGluZyB3YXMgZG9uZS5cblx0ICpcblx0ICogQGNhbGxiYWNrIGZpbGVsaXN0Q2FsbGJhY2tcblx0ICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3Igb2JqZWN0XG5cdCAqIEBwYXJhbSB7c3RyaW5nW119IGxpc3QgLSB3YXMgcmVxdWVzdCBmdWxseSBjb21wbGV0ZWRcblx0ICovXG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBkaXJcblx0ICogQHBhcmFtIHtmaWxlbGlzdENhbGxiYWNrfSBjYlxuXHQgKi9cblx0VXRpbHMucHJvdG90eXBlLmZpbmRGaWxlc0FzeW5jID0gZnVuY3Rpb24gKGRpciwgY2IpIHtcblx0ICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXHQgICAgbGV0IHJlc3VsdHMgPSBbXTtcblx0ICAgIHNlbGYuZnMucmVhZGRpcihkaXIsIGZ1bmN0aW9uIChlcnIsIGxpc3QpIHtcblx0ICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblx0ICAgICAgICBsZXQgbGlzdF9sZW5ndGggPSBsaXN0Lmxlbmd0aDtcblx0ICAgICAgICBpZiAoIWxpc3RfbGVuZ3RoKSByZXR1cm4gY2IobnVsbCwgcmVzdWx0cyk7XG5cdCAgICAgICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG5cdCAgICAgICAgICAgIGZpbGUgPSBwdGguam9pbihkaXIsIGZpbGUpO1xuXHQgICAgICAgICAgICBzZWxmLmZzLnN0YXQoZmlsZSwgZnVuY3Rpb24gKGVyciwgc3RhdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cdCAgICAgICAgICAgICAgICBpZiAoc3RhdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChwdGgubm9ybWFsaXplKGZpbGUpICsgKHN0YXQuaXNEaXJlY3RvcnkoKSA/IHNlbGYuc2VwIDogXCJcIikpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5maW5kRmlsZXNBc3luYyhmaWxlLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIS0tbGlzdF9sZW5ndGgpIGNiKG51bGwsIHJlc3VsdHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIS0tbGlzdF9sZW5ndGgpIGNiKG51bGwsIHJlc3VsdHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9KTtcblx0fTtcblxuXHRVdGlscy5wcm90b3R5cGUuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cdFV0aWxzLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge307XG5cblx0Ly8gU1RBVElDIGZ1bmN0aW9uc1xuXG5cdC8vIGNyYzMyIHNpbmdsZSB1cGRhdGUgKGl0IGlzIHBhcnQgb2YgY3JjMzIpXG5cdFV0aWxzLmNyYzMydXBkYXRlID0gZnVuY3Rpb24gKGNyYywgYnl0ZSkge1xuXHQgICAgcmV0dXJuIGNyY1RhYmxlWyhjcmMgXiBieXRlKSAmIDB4ZmZdIF4gKGNyYyA+Pj4gOCk7XG5cdH07XG5cblx0VXRpbHMuY3JjMzIgPSBmdW5jdGlvbiAoYnVmKSB7XG5cdCAgICBpZiAodHlwZW9mIGJ1ZiA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZiwgXCJ1dGY4XCIpO1xuXHQgICAgfVxuXG5cdCAgICBsZXQgbGVuID0gYnVmLmxlbmd0aDtcblx0ICAgIGxldCBjcmMgPSB+MDtcblx0ICAgIGZvciAobGV0IG9mZiA9IDA7IG9mZiA8IGxlbjsgKSBjcmMgPSBVdGlscy5jcmMzMnVwZGF0ZShjcmMsIGJ1ZltvZmYrK10pO1xuXHQgICAgLy8geG9yIGFuZCBjYXN0IGFzIHVpbnQzMiBudW1iZXJcblx0ICAgIHJldHVybiB+Y3JjID4+PiAwO1xuXHR9O1xuXG5cdFV0aWxzLm1ldGhvZFRvU3RyaW5nID0gZnVuY3Rpb24gKC8qTnVtYmVyKi8gbWV0aG9kKSB7XG5cdCAgICBzd2l0Y2ggKG1ldGhvZCkge1xuXHQgICAgICAgIGNhc2UgQ29uc3RhbnRzLlNUT1JFRDpcblx0ICAgICAgICAgICAgcmV0dXJuIFwiU1RPUkVEIChcIiArIG1ldGhvZCArIFwiKVwiO1xuXHQgICAgICAgIGNhc2UgQ29uc3RhbnRzLkRFRkxBVEVEOlxuXHQgICAgICAgICAgICByZXR1cm4gXCJERUZMQVRFRCAoXCIgKyBtZXRob2QgKyBcIilcIjtcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICByZXR1cm4gXCJVTlNVUFBPUlRFRCAoXCIgKyBtZXRob2QgKyBcIilcIjtcblx0ICAgIH1cblx0fTtcblxuXHQvKipcblx0ICogcmVtb3ZlcyBcIi4uXCIgc3R5bGUgcGF0aCBlbGVtZW50c1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIGZpeGFibGUgcGF0aFxuXHQgKiBAcmV0dXJucyBzdHJpbmcgLSBmaXhlZCBmaWxlcGF0aFxuXHQgKi9cblx0VXRpbHMuY2Fub25pY2FsID0gZnVuY3Rpb24gKC8qc3RyaW5nKi8gcGF0aCkge1xuXHQgICAgaWYgKCFwYXRoKSByZXR1cm4gXCJcIjtcblx0ICAgIC8vIHRyaWNrIG5vcm1hbGl6ZSB0aGluayBwYXRoIGlzIGFic29sdXRlXG5cdCAgICBjb25zdCBzYWZlU3VmZml4ID0gcHRoLnBvc2l4Lm5vcm1hbGl6ZShcIi9cIiArIHBhdGguc3BsaXQoXCJcXFxcXCIpLmpvaW4oXCIvXCIpKTtcblx0ICAgIHJldHVybiBwdGguam9pbihcIi5cIiwgc2FmZVN1ZmZpeCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIGZpeCBmaWxlIG5hbWVzIGluIGFjaGl2ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIGZpeGFibGUgcGF0aFxuXHQgKiBAcmV0dXJucyBzdHJpbmcgLSBmaXhlZCBmaWxlcGF0aFxuXHQgKi9cblxuXHRVdGlscy56aXBuYW1lZml4ID0gZnVuY3Rpb24gKHBhdGgpIHtcblx0ICAgIGlmICghcGF0aCkgcmV0dXJuIFwiXCI7XG5cdCAgICAvLyB0cmljayBub3JtYWxpemUgdGhpbmsgcGF0aCBpcyBhYnNvbHV0ZVxuXHQgICAgY29uc3Qgc2FmZVN1ZmZpeCA9IHB0aC5wb3NpeC5ub3JtYWxpemUoXCIvXCIgKyBwYXRoLnNwbGl0KFwiXFxcXFwiKS5qb2luKFwiL1wiKSk7XG5cdCAgICByZXR1cm4gcHRoLnBvc2l4LmpvaW4oXCIuXCIsIHNhZmVTdWZmaXgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcblx0ICogQHJldHVybnNcblx0ICovXG5cdFV0aWxzLmZpbmRMYXN0ID0gZnVuY3Rpb24gKGFyciwgY2FsbGJhY2spIHtcblx0ICAgIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJyIGlzIG5vdCBhcnJheVwiKTtcblxuXHQgICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aCA+Pj4gMDtcblx0ICAgIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgIGlmIChjYWxsYmFjayhhcnJbaV0sIGksIGFycikpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGFycltpXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdm9pZCAwO1xuXHR9O1xuXG5cdC8vIG1ha2UgYWJvbHV0ZSBwYXRocyB0YWtpbmcgcHJlZml4IGFzIHJvb3QgZm9sZGVyXG5cdFV0aWxzLnNhbml0aXplID0gZnVuY3Rpb24gKC8qc3RyaW5nKi8gcHJlZml4LCAvKnN0cmluZyovIG5hbWUpIHtcblx0ICAgIHByZWZpeCA9IHB0aC5yZXNvbHZlKHB0aC5ub3JtYWxpemUocHJlZml4KSk7XG5cdCAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KFwiL1wiKTtcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIHBhdGggPSBwdGgubm9ybWFsaXplKHB0aC5qb2luKHByZWZpeCwgcGFydHMuc2xpY2UoaSwgbCkuam9pbihwdGguc2VwKSkpO1xuXHQgICAgICAgIGlmIChwYXRoLmluZGV4T2YocHJlZml4KSA9PT0gMCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcGF0aDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcHRoLm5vcm1hbGl6ZShwdGguam9pbihwcmVmaXgsIHB0aC5iYXNlbmFtZShuYW1lKSkpO1xuXHR9O1xuXG5cdC8vIGNvbnZlcnRzIGJ1ZmZlciwgVWludDhBcnJheSwgc3RyaW5nIHR5cGVzIHRvIGJ1ZmZlclxuXHRVdGlscy50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyKC8qYnVmZmVyLCBVaW50OEFycmF5LCBzdHJpbmcqLyBpbnB1dCwgLyogZnVuY3Rpb24gKi8gZW5jb2Rlcikge1xuXHQgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcblx0ICAgICAgICByZXR1cm4gaW5wdXQ7XG5cdCAgICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHQgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShpbnB1dCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vIGV4cGVjdCBzdHJpbmcgYWxsIG90aGVyIHZhbHVlcyBhcmUgaW52YWxpZCBhbmQgcmV0dXJuIGVtcHR5IGJ1ZmZlclxuXHQgICAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyBlbmNvZGVyKGlucHV0KSA6IEJ1ZmZlci5hbGxvYygwKTtcblx0ICAgIH1cblx0fTtcblxuXHRVdGlscy5yZWFkQmlnVUludDY0TEUgPSBmdW5jdGlvbiAoLypCdWZmZXIqLyBidWZmZXIsIC8qaW50Ki8gaW5kZXgpIHtcblx0ICAgIHZhciBzbGljZSA9IEJ1ZmZlci5mcm9tKGJ1ZmZlci5zbGljZShpbmRleCwgaW5kZXggKyA4KSk7XG5cdCAgICBzbGljZS5zd2FwNjQoKTtcblxuXHQgICAgcmV0dXJuIHBhcnNlSW50KGAweCR7c2xpY2UudG9TdHJpbmcoXCJoZXhcIil9YCk7XG5cdH07XG5cblx0VXRpbHMuZnJvbURPUzJEYXRlID0gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgcmV0dXJuIG5ldyBEYXRlKCgodmFsID4+IDI1KSAmIDB4N2YpICsgMTk4MCwgTWF0aC5tYXgoKCh2YWwgPj4gMjEpICYgMHgwZikgLSAxLCAwKSwgTWF0aC5tYXgoKHZhbCA+PiAxNikgJiAweDFmLCAxKSwgKHZhbCA+PiAxMSkgJiAweDFmLCAodmFsID4+IDUpICYgMHgzZiwgKHZhbCAmIDB4MWYpIDw8IDEpO1xuXHR9O1xuXG5cdFV0aWxzLmZyb21EYXRlMkRPUyA9IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgIGxldCBkYXRlID0gMDtcblx0ICAgIGxldCB0aW1lID0gMDtcblx0ICAgIGlmICh2YWwuZ2V0RnVsbFllYXIoKSA+IDE5NzkpIHtcblx0ICAgICAgICBkYXRlID0gKCgodmFsLmdldEZ1bGxZZWFyKCkgLSAxOTgwKSAmIDB4N2YpIDw8IDkpIHwgKCh2YWwuZ2V0TW9udGgoKSArIDEpIDw8IDUpIHwgdmFsLmdldERhdGUoKTtcblx0ICAgICAgICB0aW1lID0gKHZhbC5nZXRIb3VycygpIDw8IDExKSB8ICh2YWwuZ2V0TWludXRlcygpIDw8IDUpIHwgKHZhbC5nZXRTZWNvbmRzKCkgPj4gMSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKGRhdGUgPDwgMTYpIHwgdGltZTtcblx0fTtcblxuXHRVdGlscy5pc1dpbiA9IGlzV2luOyAvLyBEbyB3ZSBoYXZlIHdpbmRvd3Mgc3lzdGVtXG5cdFV0aWxzLmNyY1RhYmxlID0gY3JjVGFibGU7XG5cdHJldHVybiB1dGlscztcbn1cblxudmFyIGZhdHRyO1xudmFyIGhhc1JlcXVpcmVkRmF0dHI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVGYXR0ciAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEZhdHRyKSByZXR1cm4gZmF0dHI7XG5cdGhhc1JlcXVpcmVkRmF0dHIgPSAxO1xuXHRjb25zdCBwdGggPSBwYXRoX19kZWZhdWx0O1xuXG5cdGZhdHRyID0gZnVuY3Rpb24gKC8qU3RyaW5nKi8gcGF0aCwgLypVdGlscyBvYmplY3QqLyB7IGZzIH0pIHtcblx0ICAgIHZhciBfcGF0aCA9IHBhdGggfHwgXCJcIixcblx0ICAgICAgICBfb2JqID0gbmV3QXR0cigpLFxuXHQgICAgICAgIF9zdGF0ID0gbnVsbDtcblxuXHQgICAgZnVuY3Rpb24gbmV3QXR0cigpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBkaXJlY3Rvcnk6IGZhbHNlLFxuXHQgICAgICAgICAgICByZWFkb25seTogZmFsc2UsXG5cdCAgICAgICAgICAgIGhpZGRlbjogZmFsc2UsXG5cdCAgICAgICAgICAgIGV4ZWN1dGFibGU6IGZhbHNlLFxuXHQgICAgICAgICAgICBtdGltZTogMCxcblx0ICAgICAgICAgICAgYXRpbWU6IDBcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoX3BhdGggJiYgZnMuZXhpc3RzU3luYyhfcGF0aCkpIHtcblx0ICAgICAgICBfc3RhdCA9IGZzLnN0YXRTeW5jKF9wYXRoKTtcblx0ICAgICAgICBfb2JqLmRpcmVjdG9yeSA9IF9zdGF0LmlzRGlyZWN0b3J5KCk7XG5cdCAgICAgICAgX29iai5tdGltZSA9IF9zdGF0Lm10aW1lO1xuXHQgICAgICAgIF9vYmouYXRpbWUgPSBfc3RhdC5hdGltZTtcblx0ICAgICAgICBfb2JqLmV4ZWN1dGFibGUgPSAoMG8xMTEgJiBfc3RhdC5tb2RlKSAhPT0gMDsgLy8gZmlsZSBpcyBleGVjdXRhYmxlIHdobyBldmVyIGhhciByaWdodCBub3QganVzdCBvd25lclxuXHQgICAgICAgIF9vYmoucmVhZG9ubHkgPSAoMG8yMDAgJiBfc3RhdC5tb2RlKSA9PT0gMDsgLy8gcmVhZG9ubHkgaWYgb3duZXIgaGFzIG5vIHdyaXRlIHJpZ2h0XG5cdCAgICAgICAgX29iai5oaWRkZW4gPSBwdGguYmFzZW5hbWUoX3BhdGgpWzBdID09PSBcIi5cIjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBwYXRoOiBcIiArIF9wYXRoKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICBnZXQgZGlyZWN0b3J5KCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX29iai5kaXJlY3Rvcnk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCByZWFkT25seSgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9vYmoucmVhZG9ubHk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBoaWRkZW4oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfb2JqLmhpZGRlbjtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZ2V0IG10aW1lKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX29iai5tdGltZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZ2V0IGF0aW1lKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX29iai5hdGltZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZ2V0IGV4ZWN1dGFibGUoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfb2JqLmV4ZWN1dGFibGU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlY29kZUF0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdCAgICAgICAgZW5jb2RlQXR0cmlidXRlczogZnVuY3Rpb24gKCkge30sXG5cblx0ICAgICAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIHBhdGg6IF9wYXRoLFxuXHQgICAgICAgICAgICAgICAgaXNEaXJlY3Rvcnk6IF9vYmouZGlyZWN0b3J5LFxuXHQgICAgICAgICAgICAgICAgaXNSZWFkT25seTogX29iai5yZWFkb25seSxcblx0ICAgICAgICAgICAgICAgIGlzSGlkZGVuOiBfb2JqLmhpZGRlbixcblx0ICAgICAgICAgICAgICAgIGlzRXhlY3V0YWJsZTogX29iai5leGVjdXRhYmxlLFxuXHQgICAgICAgICAgICAgICAgbVRpbWU6IF9vYmoubXRpbWUsXG5cdCAgICAgICAgICAgICAgICBhVGltZTogX29iai5hdGltZVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSwgbnVsbCwgXCJcXHRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0fTtcblx0cmV0dXJuIGZhdHRyO1xufVxuXG52YXIgZGVjb2RlcjtcbnZhciBoYXNSZXF1aXJlZERlY29kZXI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVEZWNvZGVyICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkRGVjb2RlcikgcmV0dXJuIGRlY29kZXI7XG5cdGhhc1JlcXVpcmVkRGVjb2RlciA9IDE7XG5cdGRlY29kZXIgPSB7XG5cdCAgICBlZnM6IHRydWUsXG5cdCAgICBlbmNvZGU6IChkYXRhKSA9PiBCdWZmZXIuZnJvbShkYXRhLCBcInV0ZjhcIiksXG5cdCAgICBkZWNvZGU6IChkYXRhKSA9PiBkYXRhLnRvU3RyaW5nKFwidXRmOFwiKVxuXHR9O1xuXHRyZXR1cm4gZGVjb2Rlcjtcbn1cblxudmFyIGhhc1JlcXVpcmVkVXRpbDtcblxuZnVuY3Rpb24gcmVxdWlyZVV0aWwgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRVdGlsKSByZXR1cm4gdXRpbC5leHBvcnRzO1xuXHRoYXNSZXF1aXJlZFV0aWwgPSAxO1xuXHR1dGlsLmV4cG9ydHMgPSByZXF1aXJlVXRpbHMoKTtcblx0dXRpbC5leHBvcnRzLkNvbnN0YW50cyA9IHJlcXVpcmVDb25zdGFudHMoKTtcblx0dXRpbC5leHBvcnRzLkVycm9ycyA9IHJlcXVpcmVFcnJvcnMoKTtcblx0dXRpbC5leHBvcnRzLkZpbGVBdHRyID0gcmVxdWlyZUZhdHRyKCk7XG5cdHV0aWwuZXhwb3J0cy5kZWNvZGVyID0gcmVxdWlyZURlY29kZXIoKTtcblx0cmV0dXJuIHV0aWwuZXhwb3J0cztcbn1cblxudmFyIGhlYWRlcnMgPSB7fTtcblxudmFyIGVudHJ5SGVhZGVyO1xudmFyIGhhc1JlcXVpcmVkRW50cnlIZWFkZXI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVFbnRyeUhlYWRlciAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEVudHJ5SGVhZGVyKSByZXR1cm4gZW50cnlIZWFkZXI7XG5cdGhhc1JlcXVpcmVkRW50cnlIZWFkZXIgPSAxO1xuXHR2YXIgVXRpbHMgPSByZXF1aXJlVXRpbCgpLFxuXHQgICAgQ29uc3RhbnRzID0gVXRpbHMuQ29uc3RhbnRzO1xuXG5cdC8qIFRoZSBjZW50cmFsIGRpcmVjdG9yeSBmaWxlIGhlYWRlciAqL1xuXHRlbnRyeUhlYWRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBfdmVyTWFkZSA9IDIwLCAvLyB2Mi4wXG5cdCAgICAgICAgX3ZlcnNpb24gPSAxMCwgLy8gdjEuMFxuXHQgICAgICAgIF9mbGFncyA9IDAsXG5cdCAgICAgICAgX21ldGhvZCA9IDAsXG5cdCAgICAgICAgX3RpbWUgPSAwLFxuXHQgICAgICAgIF9jcmMgPSAwLFxuXHQgICAgICAgIF9jb21wcmVzc2VkU2l6ZSA9IDAsXG5cdCAgICAgICAgX3NpemUgPSAwLFxuXHQgICAgICAgIF9mbmFtZUxlbiA9IDAsXG5cdCAgICAgICAgX2V4dHJhTGVuID0gMCxcblx0ICAgICAgICBfY29tTGVuID0gMCxcblx0ICAgICAgICBfZGlza1N0YXJ0ID0gMCxcblx0ICAgICAgICBfaW5hdHRyID0gMCxcblx0ICAgICAgICBfYXR0ciA9IDAsXG5cdCAgICAgICAgX29mZnNldCA9IDA7XG5cblx0ICAgIF92ZXJNYWRlIHw9IFV0aWxzLmlzV2luID8gMHgwYTAwIDogMHgwMzAwO1xuXG5cdCAgICAvLyBTZXQgRUZTIGZsYWcgc2luY2UgZmlsZW5hbWUgYW5kIGNvbW1lbnQgZmllbGRzIGFyZSBhbGwgYnkgZGVmYXVsdCBlbmNvZGVkIHVzaW5nIFVURi04LlxuXHQgICAgLy8gV2l0aG91dCBpdCBmaWxlIG5hbWVzIG1heSBiZSBjb3JydXB0ZWQgZm9yIG90aGVyIGFwcHMgd2hlbiBmaWxlIG5hbWVzIHVzZSB1bmljb2RlIGNoYXJzXG5cdCAgICBfZmxhZ3MgfD0gQ29uc3RhbnRzLkZMR19FRlM7XG5cblx0ICAgIGNvbnN0IF9sb2NhbEhlYWRlciA9IHtcblx0ICAgICAgICBleHRyYUxlbjogMFxuXHQgICAgfTtcblxuXHQgICAgLy8gY2FzdGluZ1xuXHQgICAgY29uc3QgdWludDMyID0gKHZhbCkgPT4gTWF0aC5tYXgoMCwgdmFsKSA+Pj4gMDtcblx0ICAgIGNvbnN0IHVpbnQ4ID0gKHZhbCkgPT4gTWF0aC5tYXgoMCwgdmFsKSAmIDB4ZmY7XG5cblx0ICAgIF90aW1lID0gVXRpbHMuZnJvbURhdGUyRE9TKG5ldyBEYXRlKCkpO1xuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGdldCBtYWRlKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX3Zlck1hZGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQgbWFkZSh2YWwpIHtcblx0ICAgICAgICAgICAgX3Zlck1hZGUgPSB2YWw7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCB2ZXJzaW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX3ZlcnNpb247XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQgdmVyc2lvbih2YWwpIHtcblx0ICAgICAgICAgICAgX3ZlcnNpb24gPSB2YWw7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBmbGFncygpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9mbGFncztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldCBmbGFncyh2YWwpIHtcblx0ICAgICAgICAgICAgX2ZsYWdzID0gdmFsO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXQgZmxhZ3NfZWZzKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gKF9mbGFncyAmIENvbnN0YW50cy5GTEdfRUZTKSA+IDA7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQgZmxhZ3NfZWZzKHZhbCkge1xuXHQgICAgICAgICAgICBpZiAodmFsKSB7XG5cdCAgICAgICAgICAgICAgICBfZmxhZ3MgfD0gQ29uc3RhbnRzLkZMR19FRlM7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBfZmxhZ3MgJj0gfkNvbnN0YW50cy5GTEdfRUZTO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBmbGFnc19kZXNjKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gKF9mbGFncyAmIENvbnN0YW50cy5GTEdfREVTQykgPiAwO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0IGZsYWdzX2Rlc2ModmFsKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWwpIHtcblx0ICAgICAgICAgICAgICAgIF9mbGFncyB8PSBDb25zdGFudHMuRkxHX0RFU0M7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBfZmxhZ3MgJj0gfkNvbnN0YW50cy5GTEdfREVTQztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXQgbWV0aG9kKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX21ldGhvZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldCBtZXRob2QodmFsKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAodmFsKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5TVE9SRUQ6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJzaW9uID0gMTA7XG5cdCAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5ERUZMQVRFRDpcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJzaW9uID0gMjA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgX21ldGhvZCA9IHZhbDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZ2V0IHRpbWUoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBVdGlscy5mcm9tRE9TMkRhdGUodGhpcy50aW1ldmFsKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldCB0aW1lKHZhbCkge1xuXHQgICAgICAgICAgICB0aGlzLnRpbWV2YWwgPSBVdGlscy5mcm9tRGF0ZTJET1ModmFsKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZ2V0IHRpbWV2YWwoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGltZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldCB0aW1ldmFsKHZhbCkge1xuXHQgICAgICAgICAgICBfdGltZSA9IHVpbnQzMih2YWwpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXQgdGltZUhpZ2hCeXRlKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdWludDgoX3RpbWUgPj4+IDgpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0IGNyYygpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9jcmM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQgY3JjKHZhbCkge1xuXHQgICAgICAgICAgICBfY3JjID0gdWludDMyKHZhbCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBjb21wcmVzc2VkU2l6ZSgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9jb21wcmVzc2VkU2l6ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldCBjb21wcmVzc2VkU2l6ZSh2YWwpIHtcblx0ICAgICAgICAgICAgX2NvbXByZXNzZWRTaXplID0gdWludDMyKHZhbCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBzaXplKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX3NpemU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQgc2l6ZSh2YWwpIHtcblx0ICAgICAgICAgICAgX3NpemUgPSB1aW50MzIodmFsKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZ2V0IGZpbGVOYW1lTGVuZ3RoKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX2ZuYW1lTGVuO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0IGZpbGVOYW1lTGVuZ3RoKHZhbCkge1xuXHQgICAgICAgICAgICBfZm5hbWVMZW4gPSB2YWw7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBleHRyYUxlbmd0aCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9leHRyYUxlbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldCBleHRyYUxlbmd0aCh2YWwpIHtcblx0ICAgICAgICAgICAgX2V4dHJhTGVuID0gdmFsO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXQgZXh0cmFMb2NhbExlbmd0aCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9sb2NhbEhlYWRlci5leHRyYUxlbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldCBleHRyYUxvY2FsTGVuZ3RoKHZhbCkge1xuXHQgICAgICAgICAgICBfbG9jYWxIZWFkZXIuZXh0cmFMZW4gPSB2YWw7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBjb21tZW50TGVuZ3RoKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX2NvbUxlbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldCBjb21tZW50TGVuZ3RoKHZhbCkge1xuXHQgICAgICAgICAgICBfY29tTGVuID0gdmFsO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXQgZGlza051bVN0YXJ0KCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX2Rpc2tTdGFydDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldCBkaXNrTnVtU3RhcnQodmFsKSB7XG5cdCAgICAgICAgICAgIF9kaXNrU3RhcnQgPSB1aW50MzIodmFsKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZ2V0IGluQXR0cigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9pbmF0dHI7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQgaW5BdHRyKHZhbCkge1xuXHQgICAgICAgICAgICBfaW5hdHRyID0gdWludDMyKHZhbCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBhdHRyKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX2F0dHI7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQgYXR0cih2YWwpIHtcblx0ICAgICAgICAgICAgX2F0dHIgPSB1aW50MzIodmFsKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLy8gZ2V0IFVuaXggZmlsZSBwZXJtaXNzaW9uc1xuXHQgICAgICAgIGdldCBmaWxlQXR0cigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChfYXR0ciB8fCAwKSA+PiAxNiAmIDB4ZmZmO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXQgb2Zmc2V0KCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX29mZnNldDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldCBvZmZzZXQodmFsKSB7XG5cdCAgICAgICAgICAgIF9vZmZzZXQgPSB1aW50MzIodmFsKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZ2V0IGVuY3J5cHRlZCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChfZmxhZ3MgJiBDb25zdGFudHMuRkxHX0VOQykgPT09IENvbnN0YW50cy5GTEdfRU5DO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXQgY2VudHJhbEhlYWRlclNpemUoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBDb25zdGFudHMuQ0VOSERSICsgX2ZuYW1lTGVuICsgX2V4dHJhTGVuICsgX2NvbUxlbjtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZ2V0IHJlYWxEYXRhT2Zmc2V0KCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX29mZnNldCArIENvbnN0YW50cy5MT0NIRFIgKyBfbG9jYWxIZWFkZXIuZm5hbWVMZW4gKyBfbG9jYWxIZWFkZXIuZXh0cmFMZW47XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBsb2NhbEhlYWRlcigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9sb2NhbEhlYWRlcjtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgbG9hZExvY2FsSGVhZGVyRnJvbUJpbmFyeTogZnVuY3Rpb24gKC8qQnVmZmVyKi8gaW5wdXQpIHtcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSBpbnB1dC5zbGljZShfb2Zmc2V0LCBfb2Zmc2V0ICsgQ29uc3RhbnRzLkxPQ0hEUik7XG5cdCAgICAgICAgICAgIC8vIDMwIGJ5dGVzIGFuZCBzaG91bGQgc3RhcnQgd2l0aCBcIlBLXFwwMDNcXDAwNFwiXG5cdCAgICAgICAgICAgIGlmIChkYXRhLnJlYWRVSW50MzJMRSgwKSAhPT0gQ29uc3RhbnRzLkxPQ1NJRykge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLklOVkFMSURfTE9DKCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyB2ZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0XG5cdCAgICAgICAgICAgIF9sb2NhbEhlYWRlci52ZXJzaW9uID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkxPQ1ZFUik7XG5cdCAgICAgICAgICAgIC8vIGdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZ1xuXHQgICAgICAgICAgICBfbG9jYWxIZWFkZXIuZmxhZ3MgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuTE9DRkxHKTtcblx0ICAgICAgICAgICAgLy8gY29tcHJlc3Npb24gbWV0aG9kXG5cdCAgICAgICAgICAgIF9sb2NhbEhlYWRlci5tZXRob2QgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuTE9DSE9XKTtcblx0ICAgICAgICAgICAgLy8gbW9kaWZpY2F0aW9uIHRpbWUgKDIgYnl0ZXMgdGltZSwgMiBieXRlcyBkYXRlKVxuXHQgICAgICAgICAgICBfbG9jYWxIZWFkZXIudGltZSA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5MT0NUSU0pO1xuXHQgICAgICAgICAgICAvLyB1bmNvbXByZXNzZWQgZmlsZSBjcmMtMzIgdmFsdVxuXHQgICAgICAgICAgICBfbG9jYWxIZWFkZXIuY3JjID0gZGF0YS5yZWFkVUludDMyTEUoQ29uc3RhbnRzLkxPQ0NSQyk7XG5cdCAgICAgICAgICAgIC8vIGNvbXByZXNzZWQgc2l6ZVxuXHQgICAgICAgICAgICBfbG9jYWxIZWFkZXIuY29tcHJlc3NlZFNpemUgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuTE9DU0laKTtcblx0ICAgICAgICAgICAgLy8gdW5jb21wcmVzc2VkIHNpemVcblx0ICAgICAgICAgICAgX2xvY2FsSGVhZGVyLnNpemUgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuTE9DTEVOKTtcblx0ICAgICAgICAgICAgLy8gZmlsZW5hbWUgbGVuZ3RoXG5cdCAgICAgICAgICAgIF9sb2NhbEhlYWRlci5mbmFtZUxlbiA9IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5MT0NOQU0pO1xuXHQgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBsZW5ndGhcblx0ICAgICAgICAgICAgX2xvY2FsSGVhZGVyLmV4dHJhTGVuID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkxPQ0VYVCk7XG5cblx0ICAgICAgICAgICAgLy8gcmVhZCBleHRyYSBkYXRhXG5cdCAgICAgICAgICAgIGNvbnN0IGV4dHJhU3RhcnQgPSBfb2Zmc2V0ICsgQ29uc3RhbnRzLkxPQ0hEUiArIF9sb2NhbEhlYWRlci5mbmFtZUxlbjtcblx0ICAgICAgICAgICAgY29uc3QgZXh0cmFFbmQgPSBleHRyYVN0YXJ0ICsgX2xvY2FsSGVhZGVyLmV4dHJhTGVuO1xuXHQgICAgICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoZXh0cmFTdGFydCwgZXh0cmFFbmQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBsb2FkRnJvbUJpbmFyeTogZnVuY3Rpb24gKC8qQnVmZmVyKi8gZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBkYXRhIHNob3VsZCBiZSA0NiBieXRlcyBhbmQgc3RhcnQgd2l0aCBcIlBLIDAxIDAyXCJcblx0ICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSBDb25zdGFudHMuQ0VOSERSIHx8IGRhdGEucmVhZFVJbnQzMkxFKDApICE9PSBDb25zdGFudHMuQ0VOU0lHKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuSU5WQUxJRF9DRU4oKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyB2ZXJzaW9uIG1hZGUgYnlcblx0ICAgICAgICAgICAgX3Zlck1hZGUgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VOVkVNKTtcblx0ICAgICAgICAgICAgLy8gdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuXHQgICAgICAgICAgICBfdmVyc2lvbiA9IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5DRU5WRVIpO1xuXHQgICAgICAgICAgICAvLyBlbmNyeXB0LCBkZWNyeXB0IGZsYWdzXG5cdCAgICAgICAgICAgIF9mbGFncyA9IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5DRU5GTEcpO1xuXHQgICAgICAgICAgICAvLyBjb21wcmVzc2lvbiBtZXRob2Rcblx0ICAgICAgICAgICAgX21ldGhvZCA9IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5DRU5IT1cpO1xuXHQgICAgICAgICAgICAvLyBtb2RpZmljYXRpb24gdGltZSAoMiBieXRlcyB0aW1lLCAyIGJ5dGVzIGRhdGUpXG5cdCAgICAgICAgICAgIF90aW1lID0gZGF0YS5yZWFkVUludDMyTEUoQ29uc3RhbnRzLkNFTlRJTSk7XG5cdCAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBmaWxlIGNyYy0zMiB2YWx1ZVxuXHQgICAgICAgICAgICBfY3JjID0gZGF0YS5yZWFkVUludDMyTEUoQ29uc3RhbnRzLkNFTkNSQyk7XG5cdCAgICAgICAgICAgIC8vIGNvbXByZXNzZWQgc2l6ZVxuXHQgICAgICAgICAgICBfY29tcHJlc3NlZFNpemUgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuQ0VOU0laKTtcblx0ICAgICAgICAgICAgLy8gdW5jb21wcmVzc2VkIHNpemVcblx0ICAgICAgICAgICAgX3NpemUgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuQ0VOTEVOKTtcblx0ICAgICAgICAgICAgLy8gZmlsZW5hbWUgbGVuZ3RoXG5cdCAgICAgICAgICAgIF9mbmFtZUxlbiA9IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5DRU5OQU0pO1xuXHQgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBsZW5ndGhcblx0ICAgICAgICAgICAgX2V4dHJhTGVuID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkNFTkVYVCk7XG5cdCAgICAgICAgICAgIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcblx0ICAgICAgICAgICAgX2NvbUxlbiA9IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5DRU5DT00pO1xuXHQgICAgICAgICAgICAvLyB2b2x1bWUgbnVtYmVyIHN0YXJ0XG5cdCAgICAgICAgICAgIF9kaXNrU3RhcnQgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VORFNLKTtcblx0ICAgICAgICAgICAgLy8gaW50ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzXG5cdCAgICAgICAgICAgIF9pbmF0dHIgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VOQVRUKTtcblx0ICAgICAgICAgICAgLy8gZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzXG5cdCAgICAgICAgICAgIF9hdHRyID0gZGF0YS5yZWFkVUludDMyTEUoQ29uc3RhbnRzLkNFTkFUWCk7XG5cdCAgICAgICAgICAgIC8vIExPQyBoZWFkZXIgb2Zmc2V0XG5cdCAgICAgICAgICAgIF9vZmZzZXQgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuQ0VOT0ZGKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgbG9jYWxIZWFkZXJUb0JpbmFyeTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBMT0MgaGVhZGVyIHNpemUgKDMwIGJ5dGVzKVxuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IEJ1ZmZlci5hbGxvYyhDb25zdGFudHMuTE9DSERSKTtcblx0ICAgICAgICAgICAgLy8gXCJQS1xcMDAzXFwwMDRcIlxuXHQgICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoQ29uc3RhbnRzLkxPQ1NJRywgMCk7XG5cdCAgICAgICAgICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3Rcblx0ICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF92ZXJzaW9uLCBDb25zdGFudHMuTE9DVkVSKTtcblx0ICAgICAgICAgICAgLy8gZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnXG5cdCAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfZmxhZ3MsIENvbnN0YW50cy5MT0NGTEcpO1xuXHQgICAgICAgICAgICAvLyBjb21wcmVzc2lvbiBtZXRob2Rcblx0ICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF9tZXRob2QsIENvbnN0YW50cy5MT0NIT1cpO1xuXHQgICAgICAgICAgICAvLyBtb2RpZmljYXRpb24gdGltZSAoMiBieXRlcyB0aW1lLCAyIGJ5dGVzIGRhdGUpXG5cdCAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfdGltZSwgQ29uc3RhbnRzLkxPQ1RJTSk7XG5cdCAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBmaWxlIGNyYy0zMiB2YWx1ZVxuXHQgICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX2NyYywgQ29uc3RhbnRzLkxPQ0NSQyk7XG5cdCAgICAgICAgICAgIC8vIGNvbXByZXNzZWQgc2l6ZVxuXHQgICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX2NvbXByZXNzZWRTaXplLCBDb25zdGFudHMuTE9DU0laKTtcblx0ICAgICAgICAgICAgLy8gdW5jb21wcmVzc2VkIHNpemVcblx0ICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkxFKF9zaXplLCBDb25zdGFudHMuTE9DTEVOKTtcblx0ICAgICAgICAgICAgLy8gZmlsZW5hbWUgbGVuZ3RoXG5cdCAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfZm5hbWVMZW4sIENvbnN0YW50cy5MT0NOQU0pO1xuXHQgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBsZW5ndGhcblx0ICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF9sb2NhbEhlYWRlci5leHRyYUxlbiwgQ29uc3RhbnRzLkxPQ0VYVCk7XG5cdCAgICAgICAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjZW50cmFsSGVhZGVyVG9CaW5hcnk6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gQ0VOIGhlYWRlciBzaXplICg0NiBieXRlcylcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSBCdWZmZXIuYWxsb2MoQ29uc3RhbnRzLkNFTkhEUiArIF9mbmFtZUxlbiArIF9leHRyYUxlbiArIF9jb21MZW4pO1xuXHQgICAgICAgICAgICAvLyBcIlBLXFwwMDFcXDAwMlwiXG5cdCAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShDb25zdGFudHMuQ0VOU0lHLCAwKTtcblx0ICAgICAgICAgICAgLy8gdmVyc2lvbiBtYWRlIGJ5XG5cdCAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfdmVyTWFkZSwgQ29uc3RhbnRzLkNFTlZFTSk7XG5cdCAgICAgICAgICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3Rcblx0ICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF92ZXJzaW9uLCBDb25zdGFudHMuQ0VOVkVSKTtcblx0ICAgICAgICAgICAgLy8gZW5jcnlwdCwgZGVjcnlwdCBmbGFnc1xuXHQgICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX2ZsYWdzLCBDb25zdGFudHMuQ0VORkxHKTtcblx0ICAgICAgICAgICAgLy8gY29tcHJlc3Npb24gbWV0aG9kXG5cdCAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfbWV0aG9kLCBDb25zdGFudHMuQ0VOSE9XKTtcblx0ICAgICAgICAgICAgLy8gbW9kaWZpY2F0aW9uIHRpbWUgKDIgYnl0ZXMgdGltZSwgMiBieXRlcyBkYXRlKVxuXHQgICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX3RpbWUsIENvbnN0YW50cy5DRU5USU0pO1xuXHQgICAgICAgICAgICAvLyB1bmNvbXByZXNzZWQgZmlsZSBjcmMtMzIgdmFsdWVcblx0ICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkxFKF9jcmMsIENvbnN0YW50cy5DRU5DUkMpO1xuXHQgICAgICAgICAgICAvLyBjb21wcmVzc2VkIHNpemVcblx0ICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkxFKF9jb21wcmVzc2VkU2l6ZSwgQ29uc3RhbnRzLkNFTlNJWik7XG5cdCAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBzaXplXG5cdCAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfc2l6ZSwgQ29uc3RhbnRzLkNFTkxFTik7XG5cdCAgICAgICAgICAgIC8vIGZpbGVuYW1lIGxlbmd0aFxuXHQgICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX2ZuYW1lTGVuLCBDb25zdGFudHMuQ0VOTkFNKTtcblx0ICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgbGVuZ3RoXG5cdCAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfZXh0cmFMZW4sIENvbnN0YW50cy5DRU5FWFQpO1xuXHQgICAgICAgICAgICAvLyBmaWxlIGNvbW1lbnQgbGVuZ3RoXG5cdCAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfY29tTGVuLCBDb25zdGFudHMuQ0VOQ09NKTtcblx0ICAgICAgICAgICAgLy8gdm9sdW1lIG51bWJlciBzdGFydFxuXHQgICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX2Rpc2tTdGFydCwgQ29uc3RhbnRzLkNFTkRTSyk7XG5cdCAgICAgICAgICAgIC8vIGludGVybmFsIGZpbGUgYXR0cmlidXRlc1xuXHQgICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX2luYXR0ciwgQ29uc3RhbnRzLkNFTkFUVCk7XG5cdCAgICAgICAgICAgIC8vIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlc1xuXHQgICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX2F0dHIsIENvbnN0YW50cy5DRU5BVFgpO1xuXHQgICAgICAgICAgICAvLyBMT0MgaGVhZGVyIG9mZnNldFxuXHQgICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX29mZnNldCwgQ29uc3RhbnRzLkNFTk9GRik7XG5cdCAgICAgICAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBmdW5jdGlvbiAobnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuciArIFwiIGJ5dGVzXCI7XG5cdCAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIG1hZGU6IF92ZXJNYWRlLFxuXHQgICAgICAgICAgICAgICAgdmVyc2lvbjogX3ZlcnNpb24sXG5cdCAgICAgICAgICAgICAgICBmbGFnczogX2ZsYWdzLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBVdGlscy5tZXRob2RUb1N0cmluZyhfbWV0aG9kKSxcblx0ICAgICAgICAgICAgICAgIHRpbWU6IHRoaXMudGltZSxcblx0ICAgICAgICAgICAgICAgIGNyYzogXCIweFwiICsgX2NyYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSxcblx0ICAgICAgICAgICAgICAgIGNvbXByZXNzZWRTaXplOiBieXRlcyhfY29tcHJlc3NlZFNpemUpLFxuXHQgICAgICAgICAgICAgICAgc2l6ZTogYnl0ZXMoX3NpemUpLFxuXHQgICAgICAgICAgICAgICAgZmlsZU5hbWVMZW5ndGg6IGJ5dGVzKF9mbmFtZUxlbiksXG5cdCAgICAgICAgICAgICAgICBleHRyYUxlbmd0aDogYnl0ZXMoX2V4dHJhTGVuKSxcblx0ICAgICAgICAgICAgICAgIGNvbW1lbnRMZW5ndGg6IGJ5dGVzKF9jb21MZW4pLFxuXHQgICAgICAgICAgICAgICAgZGlza051bVN0YXJ0OiBfZGlza1N0YXJ0LFxuXHQgICAgICAgICAgICAgICAgaW5BdHRyOiBfaW5hdHRyLFxuXHQgICAgICAgICAgICAgICAgYXR0cjogX2F0dHIsXG5cdCAgICAgICAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXQsXG5cdCAgICAgICAgICAgICAgICBjZW50cmFsSGVhZGVyU2l6ZTogYnl0ZXMoQ29uc3RhbnRzLkNFTkhEUiArIF9mbmFtZUxlbiArIF9leHRyYUxlbiArIF9jb21MZW4pXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpLCBudWxsLCBcIlxcdFwiKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHR9O1xuXHRyZXR1cm4gZW50cnlIZWFkZXI7XG59XG5cbnZhciBtYWluSGVhZGVyO1xudmFyIGhhc1JlcXVpcmVkTWFpbkhlYWRlcjtcblxuZnVuY3Rpb24gcmVxdWlyZU1haW5IZWFkZXIgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRNYWluSGVhZGVyKSByZXR1cm4gbWFpbkhlYWRlcjtcblx0aGFzUmVxdWlyZWRNYWluSGVhZGVyID0gMTtcblx0dmFyIFV0aWxzID0gcmVxdWlyZVV0aWwoKSxcblx0ICAgIENvbnN0YW50cyA9IFV0aWxzLkNvbnN0YW50cztcblxuXHQvKiBUaGUgZW50cmllcyBpbiB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5ICovXG5cdG1haW5IZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgX3ZvbHVtZUVudHJpZXMgPSAwLFxuXHQgICAgICAgIF90b3RhbEVudHJpZXMgPSAwLFxuXHQgICAgICAgIF9zaXplID0gMCxcblx0ICAgICAgICBfb2Zmc2V0ID0gMCxcblx0ICAgICAgICBfY29tbWVudExlbmd0aCA9IDA7XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgZ2V0IGRpc2tFbnRyaWVzKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX3ZvbHVtZUVudHJpZXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQgZGlza0VudHJpZXMoLypOdW1iZXIqLyB2YWwpIHtcblx0ICAgICAgICAgICAgX3ZvbHVtZUVudHJpZXMgPSBfdG90YWxFbnRyaWVzID0gdmFsO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXQgdG90YWxFbnRyaWVzKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX3RvdGFsRW50cmllcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldCB0b3RhbEVudHJpZXMoLypOdW1iZXIqLyB2YWwpIHtcblx0ICAgICAgICAgICAgX3RvdGFsRW50cmllcyA9IF92b2x1bWVFbnRyaWVzID0gdmFsO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXQgc2l6ZSgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9zaXplO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0IHNpemUoLypOdW1iZXIqLyB2YWwpIHtcblx0ICAgICAgICAgICAgX3NpemUgPSB2YWw7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBvZmZzZXQoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfb2Zmc2V0O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0IG9mZnNldCgvKk51bWJlciovIHZhbCkge1xuXHQgICAgICAgICAgICBfb2Zmc2V0ID0gdmFsO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXQgY29tbWVudExlbmd0aCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9jb21tZW50TGVuZ3RoO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0IGNvbW1lbnRMZW5ndGgoLypOdW1iZXIqLyB2YWwpIHtcblx0ICAgICAgICAgICAgX2NvbW1lbnRMZW5ndGggPSB2YWw7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBtYWluSGVhZGVyU2l6ZSgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIENvbnN0YW50cy5FTkRIRFIgKyBfY29tbWVudExlbmd0aDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgbG9hZEZyb21CaW5hcnk6IGZ1bmN0aW9uICgvKkJ1ZmZlciovIGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gZGF0YSBzaG91bGQgYmUgMjIgYnl0ZXMgYW5kIHN0YXJ0IHdpdGggXCJQSyAwNSAwNlwiXG5cdCAgICAgICAgICAgIC8vIG9yIGJlIDU2KyBieXRlcyBhbmQgc3RhcnQgd2l0aCBcIlBLIDA2IDA2XCIgZm9yIFppcDY0XG5cdCAgICAgICAgICAgIGlmIChcblx0ICAgICAgICAgICAgICAgIChkYXRhLmxlbmd0aCAhPT0gQ29uc3RhbnRzLkVOREhEUiB8fCBkYXRhLnJlYWRVSW50MzJMRSgwKSAhPT0gQ29uc3RhbnRzLkVORFNJRykgJiZcblx0ICAgICAgICAgICAgICAgIChkYXRhLmxlbmd0aCA8IENvbnN0YW50cy5aSVA2NEhEUiB8fCBkYXRhLnJlYWRVSW50MzJMRSgwKSAhPT0gQ29uc3RhbnRzLlpJUDY0U0lHKVxuXHQgICAgICAgICAgICApIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5JTlZBTElEX0VORCgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGRhdGEucmVhZFVJbnQzMkxFKDApID09PSBDb25zdGFudHMuRU5EU0lHKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBudW1iZXIgb2YgZW50cmllcyBvbiB0aGlzIHZvbHVtZVxuXHQgICAgICAgICAgICAgICAgX3ZvbHVtZUVudHJpZXMgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuRU5EU1VCKTtcblx0ICAgICAgICAgICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzXG5cdCAgICAgICAgICAgICAgICBfdG90YWxFbnRyaWVzID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkVORFRPVCk7XG5cdCAgICAgICAgICAgICAgICAvLyBjZW50cmFsIGRpcmVjdG9yeSBzaXplIGluIGJ5dGVzXG5cdCAgICAgICAgICAgICAgICBfc2l6ZSA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5FTkRTSVopO1xuXHQgICAgICAgICAgICAgICAgLy8gb2Zmc2V0IG9mIGZpcnN0IENFTiBoZWFkZXJcblx0ICAgICAgICAgICAgICAgIF9vZmZzZXQgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuRU5ET0ZGKTtcblx0ICAgICAgICAgICAgICAgIC8vIHppcCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG5cdCAgICAgICAgICAgICAgICBfY29tbWVudExlbmd0aCA9IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5FTkRDT00pO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGVudHJpZXMgb24gdGhpcyB2b2x1bWVcblx0ICAgICAgICAgICAgICAgIF92b2x1bWVFbnRyaWVzID0gVXRpbHMucmVhZEJpZ1VJbnQ2NExFKGRhdGEsIENvbnN0YW50cy5aSVA2NFNVQik7XG5cdCAgICAgICAgICAgICAgICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllc1xuXHQgICAgICAgICAgICAgICAgX3RvdGFsRW50cmllcyA9IFV0aWxzLnJlYWRCaWdVSW50NjRMRShkYXRhLCBDb25zdGFudHMuWklQNjRUT1QpO1xuXHQgICAgICAgICAgICAgICAgLy8gY2VudHJhbCBkaXJlY3Rvcnkgc2l6ZSBpbiBieXRlc1xuXHQgICAgICAgICAgICAgICAgX3NpemUgPSBVdGlscy5yZWFkQmlnVUludDY0TEUoZGF0YSwgQ29uc3RhbnRzLlpJUDY0U0laRSk7XG5cdCAgICAgICAgICAgICAgICAvLyBvZmZzZXQgb2YgZmlyc3QgQ0VOIGhlYWRlclxuXHQgICAgICAgICAgICAgICAgX29mZnNldCA9IFV0aWxzLnJlYWRCaWdVSW50NjRMRShkYXRhLCBDb25zdGFudHMuWklQNjRPRkYpO1xuXG5cdCAgICAgICAgICAgICAgICBfY29tbWVudExlbmd0aCA9IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgdG9CaW5hcnk6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGIgPSBCdWZmZXIuYWxsb2MoQ29uc3RhbnRzLkVOREhEUiArIF9jb21tZW50TGVuZ3RoKTtcblx0ICAgICAgICAgICAgLy8gXCJQSyAwNSAwNlwiIHNpZ25hdHVyZVxuXHQgICAgICAgICAgICBiLndyaXRlVUludDMyTEUoQ29uc3RhbnRzLkVORFNJRywgMCk7XG5cdCAgICAgICAgICAgIGIud3JpdGVVSW50MzJMRSgwLCA0KTtcblx0ICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGVudHJpZXMgb24gdGhpcyB2b2x1bWVcblx0ICAgICAgICAgICAgYi53cml0ZVVJbnQxNkxFKF92b2x1bWVFbnRyaWVzLCBDb25zdGFudHMuRU5EU1VCKTtcblx0ICAgICAgICAgICAgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXNcblx0ICAgICAgICAgICAgYi53cml0ZVVJbnQxNkxFKF90b3RhbEVudHJpZXMsIENvbnN0YW50cy5FTkRUT1QpO1xuXHQgICAgICAgICAgICAvLyBjZW50cmFsIGRpcmVjdG9yeSBzaXplIGluIGJ5dGVzXG5cdCAgICAgICAgICAgIGIud3JpdGVVSW50MzJMRShfc2l6ZSwgQ29uc3RhbnRzLkVORFNJWik7XG5cdCAgICAgICAgICAgIC8vIG9mZnNldCBvZiBmaXJzdCBDRU4gaGVhZGVyXG5cdCAgICAgICAgICAgIGIud3JpdGVVSW50MzJMRShfb2Zmc2V0LCBDb25zdGFudHMuRU5ET0ZGKTtcblx0ICAgICAgICAgICAgLy8gemlwIGZpbGUgY29tbWVudCBsZW5ndGhcblx0ICAgICAgICAgICAgYi53cml0ZVVJbnQxNkxFKF9jb21tZW50TGVuZ3RoLCBDb25zdGFudHMuRU5EQ09NKTtcblx0ICAgICAgICAgICAgLy8gZmlsbCBjb21tZW50IG1lbW9yeSB3aXRoIHNwYWNlcyBzbyBubyBnYXJiYWdlIGlzIGxlZnQgdGhlcmVcblx0ICAgICAgICAgICAgYi5maWxsKFwiIFwiLCBDb25zdGFudHMuRU5ESERSKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gYjtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIGNyZWF0ZXMgMHgwMDAwIHN0eWxlIG91dHB1dFxuXHQgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBmdW5jdGlvbiAobnIsIGxlbikge1xuXHQgICAgICAgICAgICAgICAgbGV0IG9mZnMgPSBuci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzLmxlbmd0aCA8IGxlbikgb2ZmcyA9IFwiMFwiICsgb2Zmcztcblx0ICAgICAgICAgICAgICAgIHJldHVybiBcIjB4XCIgKyBvZmZzO1xuXHQgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBkaXNrRW50cmllczogX3ZvbHVtZUVudHJpZXMsXG5cdCAgICAgICAgICAgICAgICB0b3RhbEVudHJpZXM6IF90b3RhbEVudHJpZXMsXG5cdCAgICAgICAgICAgICAgICBzaXplOiBfc2l6ZSArIFwiIGJ5dGVzXCIsXG5cdCAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldChfb2Zmc2V0LCA0KSxcblx0ICAgICAgICAgICAgICAgIGNvbW1lbnRMZW5ndGg6IF9jb21tZW50TGVuZ3RoXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpLCBudWxsLCBcIlxcdFwiKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHR9O1xuXHQvLyBNaXNzcGVsbGVkXG5cdHJldHVybiBtYWluSGVhZGVyO1xufVxuXG52YXIgaGFzUmVxdWlyZWRIZWFkZXJzO1xuXG5mdW5jdGlvbiByZXF1aXJlSGVhZGVycyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEhlYWRlcnMpIHJldHVybiBoZWFkZXJzO1xuXHRoYXNSZXF1aXJlZEhlYWRlcnMgPSAxO1xuXHRoZWFkZXJzLkVudHJ5SGVhZGVyID0gcmVxdWlyZUVudHJ5SGVhZGVyKCk7XG5cdGhlYWRlcnMuTWFpbkhlYWRlciA9IHJlcXVpcmVNYWluSGVhZGVyKCk7XG5cdHJldHVybiBoZWFkZXJzO1xufVxuXG52YXIgbWV0aG9kcyA9IHt9O1xuXG52YXIgZG9tYWluO1xuXG4vLyBUaGlzIGNvbnN0cnVjdG9yIGlzIHVzZWQgdG8gc3RvcmUgZXZlbnQgaGFuZGxlcnMuIEluc3RhbnRpYXRpbmcgdGhpcyBpc1xuLy8gZmFzdGVyIHRoYW4gZXhwbGljaXRseSBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCB0byBnZXQgYSBcImNsZWFuXCIgZW1wdHlcbi8vIG9iamVjdCAodGVzdGVkIHdpdGggdjggdjQuOSkuXG5mdW5jdGlvbiBFdmVudEhhbmRsZXJzKCkge31cbkV2ZW50SGFuZGxlcnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxuXG4vLyBub2RlanMgb2RkaXR5XG4vLyByZXF1aXJlKCdldmVudHMnKSA9PT0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIudXNpbmdEb21haW5zID0gZmFsc2U7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZG9tYWluID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRvbWFpbiA9IG51bGw7XG4gIGlmIChFdmVudEVtaXR0ZXIudXNpbmdEb21haW5zKSB7XG4gICAgLy8gaWYgdGhlcmUgaXMgYW4gYWN0aXZlIGRvbWFpbiwgdGhlbiBhdHRhY2ggdG8gaXQuXG4gICAgaWYgKGRvbWFpbi5hY3RpdmUgKSA7XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm5cIiBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbi8vIFRoZXNlIHN0YW5kYWxvbmUgZW1pdCogZnVuY3Rpb25zIGFyZSB1c2VkIHRvIG9wdGltaXplIGNhbGxpbmcgb2YgZXZlbnRcbi8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2Zcbi8vIGFyZ3VtZW50cyBhbmQgY2FuIGJlIGRlb3B0aW1pemVkIGJlY2F1c2Ugb2YgdGhhdC4gVGhlc2UgZnVuY3Rpb25zIGFsd2F5cyBoYXZlXG4vLyB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCB0aHVzIGRvIG5vdCBnZXQgZGVvcHRpbWl6ZWQsIHNvIHRoZSBjb2RlXG4vLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuXG5mdW5jdGlvbiBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJncykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgZXZlbnRzLCBkb21haW47XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgZG9tYWluID0gdGhpcy5kb21haW47XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChkb21haW4pIHtcbiAgICAgIGlmICghZXIpXG4gICAgICAgIGVyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50Jyk7XG4gICAgICBlci5kb21haW5FbWl0dGVyID0gdGhpcztcbiAgICAgIGVyLmRvbWFpbiA9IGRvbWFpbjtcbiAgICAgIGVyLmRvbWFpblRocm93biA9IGZhbHNlO1xuICAgICAgZG9tYWluLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoIWhhbmRsZXIpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBpc0ZuID0gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbic7XG4gIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHN3aXRjaCAobGVuKSB7XG4gICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIHR5cGUgKyAnIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0Jyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGVtaXRXYXJuaW5nKHcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBlbWl0V2FybmluZyhlKSB7XG4gIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicgPyBjb25zb2xlLndhcm4oZSkgOiBjb25zb2xlLmxvZyhlKTtcbn1cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGZpcmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICByZXR1cm4gZztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgKGxpc3QubGlzdGVuZXIgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBsaXN0WzBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBcbi8vIEFsaWFzIGZvciByZW1vdmVMaXN0ZW5lciBhZGRlZCBpbiBOb2RlSlMgMTAuMFxuLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNldmVudHNfZW1pdHRlcl9vZmZfZXZlbnRuYW1lX2xpc3RlbmVyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKXtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cztcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGtleTsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBkbyB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfSB3aGlsZSAobGlzdGVuZXJzWzBdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICB2YXIgZXZsaXN0ZW5lcjtcbiAgdmFyIHJldDtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoIWV2ZW50cylcbiAgICByZXQgPSBbXTtcbiAgZWxzZSB7XG4gICAgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAoIWV2bGlzdGVuZXIpXG4gICAgICByZXQgPSBbXTtcbiAgICBlbHNlIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHJldCA9IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50JDEuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudCQxO1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCQxKHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdC5vd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKS5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpXG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBpKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbi8vIGJhc2VkIG9mZiBodHRwczovL2dpdGh1Yi5jb20vZGVmdW5jdHpvbWJpZS9ub2RlLXByb2Nlc3MvYmxvYi9tYXN0ZXIvYnJvd3Nlci5qc1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbnZhciBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuaWYgKHR5cGVvZiBnbG9iYWwuc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xufVxuaWYgKHR5cGVvZiBnbG9iYWwuY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xufVxuXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5mdW5jdGlvbiBuZXh0VGljayhmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufVxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnZhciB0aXRsZSA9ICdicm93c2VyJztcbnZhciBwbGF0Zm9ybSA9ICdicm93c2VyJztcbnZhciBicm93c2VyID0gdHJ1ZTtcbnZhciBlbnYgPSB7fTtcbnZhciBhcmd2ID0gW107XG52YXIgdmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xudmFyIHZlcnNpb25zID0ge307XG52YXIgcmVsZWFzZSA9IHt9O1xudmFyIGNvbmZpZyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIG9uID0gbm9vcDtcbnZhciBhZGRMaXN0ZW5lciA9IG5vb3A7XG52YXIgb25jZSA9IG5vb3A7XG52YXIgb2ZmID0gbm9vcDtcbnZhciByZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG52YXIgcmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnZhciBlbWl0ID0gbm9vcDtcblxuZnVuY3Rpb24gYmluZGluZyQxKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbmZ1bmN0aW9uIGN3ZCAoKSB7IHJldHVybiAnLycgfVxuZnVuY3Rpb24gY2hkaXIgKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59ZnVuY3Rpb24gdW1hc2soKSB7IHJldHVybiAwOyB9XG5cbi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2t1bWF2aXMvYnJvd3Nlci1wcm9jZXNzLWhydGltZS9ibG9iL21hc3Rlci9pbmRleC5qc1xudmFyIHBlcmZvcm1hbmNlID0gZ2xvYmFsLnBlcmZvcm1hbmNlIHx8IHt9O1xudmFyIHBlcmZvcm1hbmNlTm93ID1cbiAgcGVyZm9ybWFuY2Uubm93ICAgICAgICB8fFxuICBwZXJmb3JtYW5jZS5tb3pOb3cgICAgIHx8XG4gIHBlcmZvcm1hbmNlLm1zTm93ICAgICAgfHxcbiAgcGVyZm9ybWFuY2Uub05vdyAgICAgICB8fFxuICBwZXJmb3JtYW5jZS53ZWJraXROb3cgIHx8XG4gIGZ1bmN0aW9uKCl7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIH07XG5cbi8vIGdlbmVyYXRlIHRpbWVzdGFtcCBvciBkZWx0YVxuLy8gc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc19wcm9jZXNzX2hydGltZVxuZnVuY3Rpb24gaHJ0aW1lKHByZXZpb3VzVGltZXN0YW1wKXtcbiAgdmFyIGNsb2NrdGltZSA9IHBlcmZvcm1hbmNlTm93LmNhbGwocGVyZm9ybWFuY2UpKjFlLTM7XG4gIHZhciBzZWNvbmRzID0gTWF0aC5mbG9vcihjbG9ja3RpbWUpO1xuICB2YXIgbmFub3NlY29uZHMgPSBNYXRoLmZsb29yKChjbG9ja3RpbWUlMSkqMWU5KTtcbiAgaWYgKHByZXZpb3VzVGltZXN0YW1wKSB7XG4gICAgc2Vjb25kcyA9IHNlY29uZHMgLSBwcmV2aW91c1RpbWVzdGFtcFswXTtcbiAgICBuYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzIC0gcHJldmlvdXNUaW1lc3RhbXBbMV07XG4gICAgaWYgKG5hbm9zZWNvbmRzPDApIHtcbiAgICAgIHNlY29uZHMtLTtcbiAgICAgIG5hbm9zZWNvbmRzICs9IDFlOTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtzZWNvbmRzLG5hbm9zZWNvbmRzXVxufVxuXG52YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbmZ1bmN0aW9uIHVwdGltZSgpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcbiAgdmFyIGRpZiA9IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lO1xuICByZXR1cm4gZGlmIC8gMTAwMDtcbn1cblxudmFyIGJyb3dzZXIkMSA9IHtcbiAgbmV4dFRpY2s6IG5leHRUaWNrLFxuICB0aXRsZTogdGl0bGUsXG4gIGJyb3dzZXI6IGJyb3dzZXIsXG4gIGVudjogZW52LFxuICBhcmd2OiBhcmd2LFxuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICB2ZXJzaW9uczogdmVyc2lvbnMsXG4gIG9uOiBvbixcbiAgYWRkTGlzdGVuZXI6IGFkZExpc3RlbmVyLFxuICBvbmNlOiBvbmNlLFxuICBvZmY6IG9mZixcbiAgcmVtb3ZlTGlzdGVuZXI6IHJlbW92ZUxpc3RlbmVyLFxuICByZW1vdmVBbGxMaXN0ZW5lcnM6IHJlbW92ZUFsbExpc3RlbmVycyxcbiAgZW1pdDogZW1pdCxcbiAgYmluZGluZzogYmluZGluZyQxLFxuICBjd2Q6IGN3ZCxcbiAgY2hkaXI6IGNoZGlyLFxuICB1bWFzazogdW1hc2ssXG4gIGhydGltZTogaHJ0aW1lLFxuICBwbGF0Zm9ybTogcGxhdGZvcm0sXG4gIHJlbGVhc2U6IHJlbGVhc2UsXG4gIGNvbmZpZzogY29uZmlnLFxuICB1cHRpbWU6IHVwdGltZVxufTtcblxudmFyIGluaGVyaXRzO1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKXtcbiAgaW5oZXJpdHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIGluaGVyaXRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgfTtcbn1cbnZhciBpbmhlcml0cyQxID0gaW5oZXJpdHM7XG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmZ1bmN0aW9uIGZvcm1hdChmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChicm93c2VyJDEubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGJyb3dzZXIkMS50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChicm93c2VyJDEudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZnVuY3Rpb24gZGVidWdsb2coc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IGJyb3dzZXIkMS5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSAwO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufVxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBpbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5JDEodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSA7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkkMShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmQob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn1cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBsb29rdXAgPSBbXTtcbnZhciByZXZMb29rdXAgPSBbXTtcbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXk7XG52YXIgaW5pdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbml0ICgpIHtcbiAgaW5pdGVkID0gdHJ1ZTtcbiAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbG9va3VwW2ldID0gY29kZVtpXTtcbiAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gIH1cblxuICByZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjI7XG4gIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2Mztcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFycjtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7XG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHBsYWNlSG9sZGVycyA9IGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDA7XG5cbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuO1xuXG4gIHZhciBMID0gMDtcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGO1xuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMik7XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcDtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSk7XG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIHRtcDtcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aDtcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzOyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MzsgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSk7XG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9ICc9PSc7XG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSk7XG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSAnPSc7XG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dCk7XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIHJlYWQgKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG07XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSAtNztcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMDtcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxO1xuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5mdW5jdGlvbiB3cml0ZSAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApO1xuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpO1xuICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn1cblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cblxudmFyIElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlciQxLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0cnVlO1xuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5rTWF4TGVuZ3RoKCk7XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyJDEucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIkMShsZW5ndGgpO1xuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyJDEgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIkMSkpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlciQxKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIkMS5wb29sU2l6ZSA9IDgxOTI7IC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIkMS5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlciQxLnByb3RvdHlwZTtcbiAgcmV0dXJuIGFyclxufTtcblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIkMS5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn07XG5cbmlmIChCdWZmZXIkMS5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlciQxLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZTtcbiAgQnVmZmVyJDEuX19wcm90b19fID0gVWludDhBcnJheTtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXIkMVtTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlciQxKSA7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKTtcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIkMS5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59O1xuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKTtcbiAgaWYgKCFCdWZmZXIkMS5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyJDEuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn07XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIkMS5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn07XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gIH1cblxuICBpZiAoIUJ1ZmZlciQxLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7XG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1O1xuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoOyAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIkMS5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5O1xuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyJDEucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDA7XG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pO1xuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbik7XG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cbkJ1ZmZlciQxLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5mdW5jdGlvbiBpbnRlcm5hbElzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlciQxLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcihhKSB8fCAhaW50ZXJuYWxJc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59O1xuXG5CdWZmZXIkMS5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuXG5CdWZmZXIkMS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlciQxLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaTtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIkMS5hbGxvY1Vuc2FmZShsZW5ndGgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXJcbn07XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKGludGVybmFsSXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nO1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5CdWZmZXIkMS5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMDtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlciQxLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlO1xuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXTtcbiAgYltuXSA9IGJbbV07XG4gIGJbbV0gPSBpO1xufVxuXG5CdWZmZXIkMS5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpO1xuICB9XG4gIHJldHVybiB0aGlzXG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNik7XG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpO1xuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwO1xuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIkMS5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBtYXggPSBJTlNQRUNUX01BWF9CWVRFUztcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICc7XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwO1xuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDA7XG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDA7XG4gIGVuZCA+Pj49IDA7XG4gIHRoaXNTdGFydCA+Pj49IDA7XG4gIHRoaXNFbmQgPj4+PSAwO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0O1xuICB2YXIgeSA9IGVuZCAtIHN0YXJ0O1xuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSk7XG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpO1xuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV07XG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0O1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmY7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwO1xuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0O1xuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMDtcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIkMS5mcm9tKHZhbCwgZW5jb2RpbmcpO1xuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKGludGVybmFsSXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGOyAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlciQxLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDE7XG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoO1xuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aDtcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDI7XG4gICAgICBhcnJMZW5ndGggLz0gMjtcbiAgICAgIHZhbExlbmd0aCAvPSAyO1xuICAgICAgYnl0ZU9mZnNldCAvPSAyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaTtcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTE7XG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGk7XG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleDtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aDtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIkMS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufTtcblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCk7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDI7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZDtcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMDtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nO1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBmcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcbiAgdmFyIHJlcyA9IFtdO1xuXG4gIHZhciBpID0gc3RhcnQ7XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXTtcbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbDtcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDE7XG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50O1xuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdO1xuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRDtcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkY7XG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KTtcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7XG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDA7XG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7XG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJyc7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlbjtcblxuICB2YXIgb3V0ID0gJyc7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgc3RhcnQgPSB+fnN0YXJ0O1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kO1xuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW47XG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW47XG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDA7XG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDtcblxuICB2YXIgbmV3QnVmO1xuICBpZiAoQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlciQxLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydDtcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyJDEoc2xpY2VMZW4sIHVuZGVmaW5lZCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufTtcblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdO1xuICB2YXIgbXVsID0gMTtcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bDtcbiAgfVxuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF1cbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsO1xuICB9XG4gIG11bCAqPSAweDgwO1xuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpO1xuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGg7XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldO1xuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsO1xuICB9XG4gIG11bCAqPSAweDgwO1xuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpO1xuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KTtcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KTtcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgdmFyIG11bCA9IDE7XG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKTtcbiAgaWYgKCFCdWZmZXIkMS5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDg7XG4gIH1cbn1cblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlciQxLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlciQxLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmO1xuICB9XG59XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICBpZiAoQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICBpZiAoQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSk7XG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCk7XG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIHN1YiA9IDA7XG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxO1xuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MCk7XG4gIGlmICghQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuICBpZiAoQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlciQxLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIGlmIChCdWZmZXIkMS5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICBpZiAoQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0KTtcbiAgfVxuICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpO1xuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgpO1xuICB9XG4gIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOCk7XG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufTtcblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyJDEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMDtcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aDtcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwO1xuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgdmFyIGk7XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIkMS5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGxlblxufTtcblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIkMS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyJDEuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTU7XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDA7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7XG5cbiAgaWYgKCF2YWwpIHZhbCA9IDA7XG5cbiAgdmFyIGk7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IGludGVybmFsSXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlciQxKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpO1xuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59O1xuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZztcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKTtcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nO1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5O1xuICB2YXIgY29kZVBvaW50O1xuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuICB2YXIgYnl0ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbDtcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpO1xuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsbztcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhpID0gYyA+PiA4O1xuICAgIGxvID0gYyAlIDI1NjtcbiAgICBieXRlQXJyYXkucHVzaChsbyk7XG4gICAgYnl0ZUFycmF5LnB1c2goaGkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gdG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuLy8gdGhlIGZvbGxvd2luZyBpcyBmcm9tIGlzLWJ1ZmZlciwgYWxzbyBieSBGZXJvc3MgQWJvdWtoYWRpamVoIGFuZCB3aXRoIHNhbWUgbGlzZW5jZVxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxuZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoISFvYmouX2lzQnVmZmVyIHx8IGlzRmFzdEJ1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopKVxufVxuXG5mdW5jdGlvbiBpc0Zhc3RCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0Zhc3RCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuXG5mdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodikge1xuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgKyt0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAodikge1xuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgKyt0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgLS10aGlzLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHMpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gIH1yZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyJDEuYWxsb2MoMCk7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICB2YXIgcmV0ID0gQnVmZmVyJDEuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChwKSB7XG4gICAgcC5kYXRhLmNvcHkocmV0LCBpKTtcbiAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyJDEuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH07XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyJDEoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59XG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBkZWJ1ZyA9IGRlYnVnbG9nKCdzdHJlYW0nKTtcbmluaGVyaXRzJDEoUmVhZGFibGUsIEV2ZW50RW1pdHRlcik7XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gICAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gICAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAgIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSlcbiAgICAgIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKVxuICAgICAgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtcbiAgICBlbHNlXG4gICAgICBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbiAgfVxufVxuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufVxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIF9lID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgX2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2tpcEFkZDtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICBza2lwQWRkID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgY2h1bmsubGVuZ3RoID09PSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gRG9uJ3QgYWRkIHRvIHRoZSBidWZmZXIgaWYgd2UndmUgZGVjb2RlZCB0byBhbiBlbXB0eSBzdHJpbmcgY2h1bmsgYW5kXG4gICAgICAvLyB3ZSdyZSBub3QgaW4gb2JqZWN0IG1vZGVcbiAgICAgIGlmICghc2tpcEFkZCkge1xuICAgICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgbmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIG5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSk7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBuZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAobGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBzcmMubGlzdGVuZXJzKCdkYXRhJykubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW47IF9pKyspIHtcbiAgICAgIGRlc3RzW19pXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIG5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIG5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24gKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBuZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbmluaGVyaXRzJDEoV3JpdGFibGUsIEV2ZW50RW1pdHRlcik7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdidWZmZXInLCB7XG4gICAgZ2V0OiBkZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nKVxuICB9KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiB3cml0YWJsZVN0YXRlR2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBuZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuICAvLyBBbHdheXMgdGhyb3cgZXJyb3IgaWYgYSBudWxsIGlzIHdyaXR0ZW5cbiAgLy8gaWYgd2UgYXJlIG5vdCBpbiBvYmplY3QgbW9kZSB0aGVuIHRocm93XG4gIC8vIGlmIGl0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBvciB1bmRlZmluZWQuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICghQnVmZmVyJDEuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBuZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKEJ1ZmZlciQxLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyJDEuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gIGlmIChCdWZmZXIkMS5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcbiAgaWYgKHN5bmMpIG5leHRUaWNrKGNiLCBlcik7ZWxzZSBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgICAgbmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBuZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7XG4gICAgX3RoaXMuZW50cnkgPSBudWxsO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVycik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xuICAgIH1cbiAgfTtcbn1cblxuaW5oZXJpdHMkMShEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBPYmplY3Qua2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59XG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBuZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuaW5oZXJpdHMkMShUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0aGlzLndyaXRlZW5jb2RpbmcgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIpIHtcbiAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuXG5pbmhlcml0cyQxKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG5cbmluaGVyaXRzJDEoU3RyZWFtLCBFdmVudEVtaXR0ZXIpO1xuU3RyZWFtLlJlYWRhYmxlID0gUmVhZGFibGU7XG5TdHJlYW0uV3JpdGFibGUgPSBXcml0YWJsZTtcblN0cmVhbS5EdXBsZXggPSBEdXBsZXg7XG5TdHJlYW0uVHJhbnNmb3JtID0gVHJhbnNmb3JtO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gUGFzc1Rocm91Z2g7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG5cbnZhciBtc2cgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG5mdW5jdGlvbiBhcnJheVNldChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgfVxufVxuXG5cbnZhciBCdWY4ID0gVWludDhBcnJheTtcbnZhciBCdWYxNiA9IFVpbnQxNkFycmF5O1xudmFyIEJ1ZjMyID0gSW50MzJBcnJheTtcbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL3ZhciBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy92YXIgWl9STEUgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCQyID0gNDtcbi8vdmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG52YXIgWl9CSU5BUlkkMSA9IDA7XG52YXIgWl9URVhUJDEgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOJDIgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8kMShidWYpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG4gIHdoaWxlICgtLWxlbiA+PSAwKSB7XG4gICAgYnVmW2xlbl0gPSAwO1xuICB9XG59XG5cbi8vIEZyb20genV0aWwuaFxuXG52YXIgU1RPUkVEX0JMT0NLID0gMDtcbnZhciBTVEFUSUNfVFJFRVMgPSAxO1xudmFyIERZTl9UUkVFUyA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG52YXIgTUlOX01BVENIJDEgPSAzO1xudmFyIE1BWF9NQVRDSCQxID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG52YXIgTEVOR1RIX0NPREVTJDEgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgTElURVJBTFMkMSA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG52YXIgTF9DT0RFUyQxID0gTElURVJBTFMkMSArIDEgKyBMRU5HVEhfQ09ERVMkMTtcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgRF9DT0RFUyQxID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxudmFyIEJMX0NPREVTJDEgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG52YXIgSEVBUF9TSVpFJDEgPSAyICogTF9DT0RFUyQxICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbnZhciBNQVhfQklUUyQxID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIEJ1Zl9zaXplID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG52YXIgRU5EX0JMT0NLID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG52YXIgUkVQXzNfNiA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8zXzEwID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xudmFyIGV4dHJhX2xiaXRzID0gLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqLyBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMF07XG5cbnZhciBleHRyYV9kYml0cyA9IC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqLyBbMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzXTtcblxudmFyIGV4dHJhX2JsYml0cyA9IC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAyLCAzLCA3XTtcblxudmFyIGJsX29yZGVyID0gWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxudmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc2RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxudmFyIHN0YXRpY19sdHJlZSA9IG5ldyBBcnJheSgoTF9DT0RFUyQxICsgMikgKiAyKTtcbnplcm8kMShzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG52YXIgc3RhdGljX2R0cmVlID0gbmV3IEFycmF5KERfQ09ERVMkMSAqIDIpO1xuemVybyQxKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbnZhciBfZGlzdF9jb2RlID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyQxKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxudmFyIF9sZW5ndGhfY29kZSA9IG5ldyBBcnJheShNQVhfTUFUQ0gkMSAtIE1JTl9NQVRDSCQxICsgMSk7XG56ZXJvJDEoX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfbGVuZ3RoID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyQxKTtcbnplcm8kMShiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9kaXN0ID0gbmV3IEFycmF5KERfQ09ERVMkMSk7XG56ZXJvJDEoYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSA9IHN0YXRpY190cmVlOyAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyA9IGV4dHJhX2JpdHM7IC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSA9IGV4dHJhX2Jhc2U7IC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyA9IGVsZW1zOyAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCA9IG1heF9sZW5ndGg7IC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxudmFyIHN0YXRpY19sX2Rlc2M7XG52YXIgc3RhdGljX2RfZGVzYztcbnZhciBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHtcbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7XG4gIC8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbiAgLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkge1xuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0gLyouQ29kZSovICwgdHJlZVtjICogMiArIDFdIC8qLkxlbiovICk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5mdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuZnVuY3Rpb24gYmlfZmx1c2gocykge1xuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5mdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpIHtcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbiAgdmFyIHRyZWUgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgbWF4X2NvZGUgPSBkZXNjLm1heF9jb2RlO1xuICB2YXIgc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGV4dHJhID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgdmFyIGJhc2UgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICB2YXIgbWF4X2xlbmd0aCA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIHZhciBoOyAvKiBoZWFwIGluZGV4ICovXG4gIHZhciBuLCBtOyAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7IC8qIGJpdCBsZW5ndGggKi9cbiAgdmFyIHhiaXRzOyAvKiBleHRyYSBiaXRzICovXG4gIHZhciBmOyAvKiBmcmVxdWVuY3kgKi9cbiAgdmFyIG92ZXJmbG93ID0gMDsgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTJDE7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXSAvKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRSQxOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXSAvKi5EYWQqLyAqIDIgKyAxXSAvKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXSAvKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0gLyouRnJlcSovIDtcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0gLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7XG4gICAgICBiaXRzLS07XG4gICAgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdIC8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXSAvKi5MZW4qLyApICogdHJlZVttICogMl0gLyouRnJlcSovIDtcbiAgICAgICAgdHJlZVttICogMiArIDFdIC8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudCkge1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xuXG4gIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMkMSArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICB2YXIgY29kZSA9IDA7IC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICB2YXIgYml0czsgLyogYml0IGluZGV4ICovXG4gIHZhciBuOyAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUyQxOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdIC8qLkxlbiovIDtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXSAvKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5mdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgLyogYml0IGNvdW50ZXIgKi9cbiAgdmFyIGxlbmd0aDsgLyogbGVuZ3RoIHZhbHVlICovXG4gIHZhciBjb2RlOyAvKiBjb2RlIHZhbHVlICovXG4gIHZhciBkaXN0OyAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMkMSArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4gIC8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gICAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICAgIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICAgIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4gICNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTJDEgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVMkMTsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTJDE7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSAvKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdIC8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSAvKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMkMSArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVMkMTsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0gLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0gLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyQxICsgMSwgTF9DT0RFUyQxLCBNQVhfQklUUyQxKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCBEX0NPREVTJDEsIE1BWF9CSVRTJDEpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgQkxfQ09ERVMkMSwgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5mdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUyQxOyBuKyspIHtcbiAgICBzLmR5bl9sdHJlZVtuICogMl0gLyouRnJlcSovID0gMDtcbiAgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUyQxOyBuKyspIHtcbiAgICBzLmR5bl9kdHJlZVtuICogMl0gLyouRnJlcSovID0gMDtcbiAgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVMkMTsgbisrKSB7XG4gICAgcy5ibF90cmVlW24gKiAyXSAvKi5GcmVxKi8gPSAwO1xuICB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0gLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gYmlfd2luZHVwKHMpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpIHtcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xuXG4gIGJpX3dpbmR1cChzKTsgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbiAgLy8gIHdoaWxlIChsZW4tLSkge1xuICAvLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuICAvLyAgfVxuICBhcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XG4gIHZhciBfbjIgPSBuICogMjtcbiAgdmFyIF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXSAvKi5GcmVxKi8gPCB0cmVlW19tMl0gLyouRnJlcSovIHx8XG4gICAgKHRyZWVbX24yXSAvKi5GcmVxKi8gPT09IHRyZWVbX20yXSAvKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgdmFyIHYgPSBzLmhlYXBba107XG4gIHZhciBqID0gayA8PCAxOyAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufVxuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIHZhciBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICB2YXIgZGlzdDsgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxjOyAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgdmFyIGx4ID0gMDsgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICB2YXIgY29kZTsgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICB2YXIgZXh0cmE7IC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyQxICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGVsZW1zID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIHZhciBuLCBtOyAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICB2YXIgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHZhciBub2RlOyAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFJDE7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0gLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXSAvKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdIC8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXSAvKi5MZW4qLyA7XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMSAvKmludCAvMiovICk7IG4gPj0gMTsgbi0tKSB7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCBuKTtcbiAgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7IC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMSAvKlNNQUxMRVNUKi8gXTtcbiAgICBzLmhlYXBbMSAvKlNNQUxMRVNUKi8gXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMSAvKlNNQUxMRVNUKi8gKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxIC8qU01BTExFU1QqLyBdOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXSAvKi5GcmVxKi8gPSB0cmVlW24gKiAyXSAvKi5GcmVxKi8gKyB0cmVlW20gKiAyXSAvKi5GcmVxKi8gO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0gLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0gLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMSAvKlNNQUxMRVNUKi8gXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEgLypTTUFMTEVTVCovICk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxIC8qU01BTExFU1QqLyBdO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5mdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47IC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXSAvKi5MZW4qLyA7IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXSAvKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0gLyouTGVuKi8gO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXSAvKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXSAvKi5GcmVxKi8gKys7XG4gICAgICB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdIC8qLkZyZXEqLyArKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXSAvKi5GcmVxKi8gKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0gLyouRnJlcSovICsrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5mdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0gLyouTGVuKi8gOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7IC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7IC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqL1xuICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdIC8qLkxlbiovIDtcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5mdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHtcbiAgdmFyIG1heF9ibGluZGV4OyAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMkMSAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXSAvKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgdmFyIHJhbms7IC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0gLyouTGVuKi8gLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgdmFyIGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICB2YXIgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXSAvKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlkkMTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0gLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0gLyouRnJlcSovICE9PSAwIHx8XG4gICAgcy5keW5fbHRyZWVbMTMgKiAyXSAvKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUJDE7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUyQxOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdIC8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVCQxO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlkkMTtcbn1cblxuXG52YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gX3RyX2luaXQocykge1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfdHJfYWxpZ24ocykge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5mdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICB2YXIgbWF4X2JsaW5kZXggPSAwOyAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTiQyKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikge1xuICAgICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCQyIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy92YXIgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0gLyouRnJlcSovICsrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07IC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMkMSArIDEpICogMl0gLyouRnJlcSovICsrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdIC8qLkZyZXEqLyArKztcbiAgfVxuXG4gIC8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4gIC8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuICAvLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuICAvLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4gIC8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4gIC8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuICAvLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuICAvLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbiAgLy9cbiAgLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuICAvLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4gIC8vICAgIH1cbiAgLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4gIC8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4gIC8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4gIC8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4gIC8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbiAgLy8gICAgICByZXR1cm4gdHJ1ZTtcbiAgLy8gICAgfVxuICAvLyAgfVxuICAvLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufVxuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBkb2Vzbid0IHdvcnRoIHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25hIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG5mdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCQxID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0gkMSA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCQxID0gMztcbnZhciBaX0ZJTklTSCQyID0gNDtcbnZhciBaX0JMT0NLJDIgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LJDIgPSAwO1xudmFyIFpfU1RSRUFNX0VORCQyID0gMTtcbi8vdmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiQyID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SJDIgPSAtMztcbi8vdmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SJDIgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiQxID0gLTE7XG5cblxudmFyIFpfRklMVEVSRUQkMSA9IDE7XG52YXIgWl9IVUZGTUFOX09OTFkkMSA9IDI7XG52YXIgWl9STEUkMSA9IDM7XG52YXIgWl9GSVhFRCQxID0gNDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuLy92YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbi8vdmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiQxID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEJDIgPSA4O1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBNQVhfTUVNX0xFVkVMID0gOTtcblxuXG52YXIgTEVOR1RIX0NPREVTID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG52YXIgSEVBUF9TSVpFID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbnZhciBNQVhfQklUUyA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG52YXIgQlNfQkxPQ0tfRE9ORSA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1Zikge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcbiAgd2hpbGUgKC0tbGVuID49IDApIHtcbiAgICBidWZbbGVuXSA9IDA7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7XG4gIF90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufVxuXG5cbmZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikge1xuICAvLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuICAvLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHtcbiAgICBsZW4gPSBzaXplO1xuICB9XG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICBhcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9IGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7XG4gIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7IC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxlbjsgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIHZhciBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIHZhciBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwIC8qTklMKi8gO1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgdmFyIHdtYXNrID0gcy53X21hc2s7XG4gIHZhciBwcmV2ID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkge1xuICAgIG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDtcbiAgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAhPT0gc2Nhbl9lbmQgfHxcbiAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgIF93aW5bbWF0Y2hdICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICBfd2luWysrbWF0Y2hdICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5mdW5jdGlvbiBmaWxsX3dpbmRvdyhzKSB7XG4gIHZhciBfd19zaXplID0gcy53X3NpemU7XG4gIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIGFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMucHJldlstLXBdO1xuICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcbiAgICAgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBtb3JlICs9IF93X3NpemU7XG4gICAgfVxuICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qIElmIHRoZXJlIHdhcyBubyBzbGlkaW5nOlxuICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXG4gICAgICogICAgbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIChNSU5fTE9PS0FIRUFELTEgKyBXU0laRSArIE1BWF9ESVNULTEpXG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXG4gICAgICogSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICogICB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAgJiZcbiAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAqIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXG4gICAgICogSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxuICAgICAqL1xuICAgIC8vQXNzZXJ0KG1vcmUgPj0gMiwgXCJtb3JlIDwgMlwiKTtcbiAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTtcbiAgICBzLmxvb2thaGVhZCArPSBuO1xuXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6ICovXG4gICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIC8vI2lmIE1JTl9NQVRDSCAhPSAzXG4gICAgICAvLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbiAgICAgIC8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4gIC8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuICAvLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbiAgLy8gICAgdmFyIGluaXQgPSAwO1xuICAvL1xuICAvLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuICAvLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuICAvLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuICAvLyAgICAgICAqL1xuICAvLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3VycjtcbiAgLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuICAvLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuICAvLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbiAgLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4gIC8vICAgIH1cbiAgLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4gIC8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuICAvLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4gIC8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4gIC8vICAgICAgICovXG4gIC8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbiAgLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbiAgLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4gIC8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuICAvLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbiAgLy8gICAgfVxuICAvLyAgfVxuICAvL1xuICAvLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuICAvLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4gICAgICAvLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4gICAgICAvLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbiAgICAgIC8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4gICAgICAvLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gkMSkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuICAgIC8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQyKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cblxuICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfTkVFRF9NT1JFO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7IC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gkMSkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwIC8qTklMKi8gO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwIC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuICAgIH1cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuXG4gICAgICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaCAvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgLy8jaWYgTUlOX01BVENIICE9IDNcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbiAgICAgICAgLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDIpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7IC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCQxKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAgLypOSUwqLyA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG5cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwIC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgLypNQVhfRElTVChzKSovICkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEJDEgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2IC8qVE9PX0ZBUiovICkpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQyKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7IC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgdmFyIHNjYW4sIHN0cmVuZDsgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCQxKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDIpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIJDEpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQyKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7IC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7IC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7IC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7IC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7IC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEJDI7IC8qIGNhbiBvbmx5IGJlIERFRkxBVEVEICovXG4gIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi9cbiAgdGhpcy53X2JpdHMgPSAwOyAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZSAqL1xuICB0aGlzLmhhc2hfYml0cyA9IDA7IC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7IC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAvKiBsZW5ndGggb2YgYmVzdCBtYXRjaCAqL1xuICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7IC8qIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHMgKi9cbiAgdGhpcy5zdHJzdGFydCA9IDA7IC8qIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnQgKi9cbiAgdGhpcy5tYXRjaF9zdGFydCA9IDA7IC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqL1xuICB0aGlzLmxvb2thaGVhZCA9IDA7IC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7IC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqL1xuICB0aGlzLnN0cmF0ZWd5ID0gMDsgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAvKiB1c2VkIGJ5IGM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgPSBuZXcgQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlID0gbmV3IEJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7XG4gIHRoaXMuYmxfdHJlZSA9IG5ldyBCdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgPSBudWxsOyAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjID0gbnVsbDsgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjID0gbnVsbDsgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IEJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGxcbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyBCdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7IC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IkMik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTiQxO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gICAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIJDE7XG4gIF90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSyQyO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LJDIpIHtcbiAgICBsbV9pbml0KHN0cm0uc3RhdGUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQyO1xuICB9XG4gIHZhciB3cmFwID0gMTtcblxuICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTiQxKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfSBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQkMiB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCQxKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUiQyKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyBCdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyBCdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyBCdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZSQxKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBvbGRfZmx1c2gsIHM7XG4gIHZhciBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0skMiB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUiQyKSA6IFpfU1RSRUFNX0VSUk9SJDI7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIJDIpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IkMiA6IFpfU1RSRUFNX0VSUk9SJDIpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcbiAgICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgICAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkkMSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSQxIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH0gZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCQyICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZJDEgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIGhlYWRlciB8PSBQUkVTRVRfRElDVDtcbiAgICAgIH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4gIC8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYSAvKiAhPSBaX05VTEwqLyApIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lIC8qICE9IFpfTlVMTCovICkge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudCAvKiAhPSBaX05VTEwqLyApIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4gIC8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0skMjtcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCQyKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUiQyKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SJDIpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0gkMSAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIHZhciBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkkMSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSQxID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSyQyO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIJDEpIHtcbiAgICAgICAgX3RyX2FsaWduKHMpO1xuICAgICAgfSBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSyQyKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIF90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gkMSkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LJDI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIJDIpIHtcbiAgICByZXR1cm4gWl9PSyQyO1xuICB9XG4gIGlmIChzLndyYXAgPD0gMCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FTkQkMjtcbiAgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0skMiA6IFpfU1RSRUFNX0VORCQyO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0gLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZSAvKj09IFpfTlVMTCovICkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQyO1xuICB9XG5cbiAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUiQyKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SJDIpIDogWl9PSyQyO1xufVxuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEJDEgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIFRZUEUkMSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cblxuLypcbiAgIERlY29kZSBsaXRlcmFsLCBsZW5ndGgsIGFuZCBkaXN0YW5jZSBjb2RlcyBhbmQgd3JpdGUgb3V0IHRoZSByZXN1bHRpbmdcbiAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpc1xuICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgIFdoZW4gbGFyZ2UgZW5vdWdoIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgc3VwcGxpZWQgdG8gaW5mbGF0ZSgpLCBmb3JcbiAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGVcbiAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLlxuXG4gICBFbnRyeSBhc3N1bXB0aW9uczpcblxuICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU5cbiAgICAgICAgc3RybS5hdmFpbF9pbiA+PSA2XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OFxuICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dFxuICAgICAgICBzdGF0ZS5iaXRzIDwgOFxuXG4gICBPbiByZXR1cm4sIHN0YXRlLm1vZGUgaXMgb25lIG9mOlxuXG4gICAgICAgIExFTiAtLSByYW4gb3V0IG9mIGVub3VnaCBvdXRwdXQgc3BhY2Ugb3IgZW5vdWdoIGF2YWlsYWJsZSBpbnB1dFxuICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9ja1xuICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YVxuXG4gICBOb3RlczpcblxuICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlXG4gICAgICBsZW5ndGggY29kZSwgNSBiaXRzIGZvciB0aGUgbGVuZ3RoIGV4dHJhLCAxNSBiaXRzIGZvciB0aGUgZGlzdGFuY2UgY29kZSxcbiAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuXG4gICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZFxuICAgICAgY2hlY2tpbmcgZm9yIGF2YWlsYWJsZSBpbnB1dCB3aGlsZSBkZWNvZGluZy5cblxuICAgIC0gVGhlIG1heGltdW0gYnl0ZXMgdGhhdCBhIHNpbmdsZSBsZW5ndGgvZGlzdGFuY2UgcGFpciBjYW4gb3V0cHV0IGlzIDI1OFxuICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpXG4gICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3JcbiAgICAgIG91dHB1dCBzcGFjZS5cbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgdmFyIGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB2YXIgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB2YXIgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIHZhciBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIHZhciBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgdmFyIGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuXG5cbiAgdmFyIGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgZGlzdCkpO1xuICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOyAgICAgICAgICAgICAgICAvKiBtYXggZGlzdGFuY2UgaW4gb3V0cHV0ICovXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOyAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEUkMTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn1cblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyQxID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyQxID0gNTkyO1xuLy92YXIgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBDT0RFUyQxID0gMDtcbnZhciBMRU5TJDEgPSAxO1xudmFyIERJU1RTJDEgPSAyO1xuXG52YXIgbGJhc2UgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dO1xuXG52YXIgbGV4dCA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dO1xuXG52YXIgZGJhc2UgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl07XG5cbnZhciBkZXh0ID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl07XG5cbmZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cykge1xuICB2YXIgYml0cyA9IG9wdHMuYml0cztcbiAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICB2YXIgbGVuID0gMDsgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgdmFyIHN5bSA9IDA7IC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICB2YXIgbWluID0gMCxcbiAgICBtYXggPSAwOyAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICB2YXIgcm9vdCA9IDA7IC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIHZhciBjdXJyID0gMDsgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgdmFyIGRyb3AgPSAwOyAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIHZhciBsZWZ0ID0gMDsgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgdmFyIHVzZWQgPSAwOyAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICB2YXIgaHVmZiA9IDA7IC8qIEh1ZmZtYW4gY29kZSAqL1xuICB2YXIgaW5jcjsgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICB2YXIgZmlsbDsgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgdmFyIGxvdzsgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICB2YXIgbWFzazsgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICB2YXIgbmV4dDsgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgdmFyIGJhc2UgPSBudWxsOyAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgYmFzZV9pbmRleCA9IDA7XG4gIC8vICB2YXIgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIHZhciBlbmQ7IC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIHZhciBjb3VudCA9IG5ldyBCdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICB2YXIgb2ZmcyA9IG5ldyBCdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICB2YXIgZXh0cmEgPSBudWxsO1xuICB2YXIgZXh0cmFfaW5kZXggPSAwO1xuXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTJDEgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTJDEpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMkMSkge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7IC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7IC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7IC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyQxICYmIHVzZWQgPiBFTk9VR0hfTEVOUyQxKSB8fFxuICAgICh0eXBlID09PSBESVNUUyQxICYmIHVzZWQgPiBFTk9VR0hfRElTVFMkMSkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfSBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7IC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfCAwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TJDEgJiYgdXNlZCA+IEVOT1VHSF9MRU5TJDEpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyQxICYmIHVzZWQgPiBFTk9VR0hfRElTVFMkMSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwgMDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufVxuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuLy92YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbi8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuLy92YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCQxID0gNDtcbnZhciBaX0JMT0NLJDEgPSA1O1xudmFyIFpfVFJFRVMkMSA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyQxID0gMDtcbnZhciBaX1NUUkVBTV9FTkQkMSA9IDE7XG52YXIgWl9ORUVEX0RJQ1QkMSA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiQxID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SJDEgPSAtMztcbnZhciBaX01FTV9FUlJPUiA9IC00O1xudmFyIFpfQlVGX0VSUk9SJDEgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEJDEgPSA4O1xuXG5cbi8qIFNUQVRFUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBIRUFEID0gMTsgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG52YXIgRkxBR1MgPSAyOyAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xudmFyIFRJTUUgPSAzOyAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbnZhciBPUyA9IDQ7IC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyIEVYTEVOID0gNTsgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xudmFyIEVYVFJBID0gNjsgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG52YXIgTkFNRSA9IDc7IC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG52YXIgQ09NTUVOVCA9IDg7IC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xudmFyIEhDUkMgPSA5OyAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xudmFyIERJQ1RJRCA9IDEwOyAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG52YXIgRElDVCA9IDExOyAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciBUWVBFID0gMTI7IC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciBUWVBFRE8gPSAxMzsgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xudmFyIFNUT1JFRCA9IDE0OyAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xudmFyIENPUFlfID0gMTU7IC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgQ09QWSA9IDE2OyAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xudmFyIFRBQkxFID0gMTc7IC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyIExFTkxFTlMgPSAxODsgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgQ09ERUxFTlMgPSAxOTsgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG52YXIgTEVOXyA9IDIwOyAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyIExFTiA9IDIxOyAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG52YXIgTEVORVhUID0gMjI7IC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG52YXIgRElTVCA9IDIzOyAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG52YXIgRElTVEVYVCA9IDI0OyAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgTUFUQ0ggPSAyNTsgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgTElUID0gMjY7IC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG52YXIgQ0hFQ0sgPSAyNzsgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgTEVOR1RIID0gMjg7IC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgRE9ORSA9IDI5OyAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIEJBRCA9IDMwOyAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgTUVNID0gMzE7IC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgU1lOQyA9IDMyOyAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7IC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7IC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7IC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7IC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7IC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7IC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgQnVmMTYoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgQnVmMTYoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IEJ1ZjMyKEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7IC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7IC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7IC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwgLypaX05VTEwqLyA7XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgQnVmMzIoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgQnVmMzIoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0skMTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciB3cmFwO1xuICB2YXIgc3RhdGU7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH0gZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgcmV0O1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7XG4gIH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbCAvKlpfTlVMTCovIDtcbiAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSyQxKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwgLypaX05VTEwqLyA7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG52YXIgdmlyZ2luID0gdHJ1ZTtcblxudmFyIGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHtcbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIHZhciBzeW07XG5cbiAgICBsZW5maXggPSBuZXcgQnVmMzIoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IEJ1ZjMyKDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7XG4gICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7XG4gICAgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHtcbiAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gOTtcbiAgICB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkge1xuICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA3O1xuICAgIH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7XG4gICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7XG4gICAgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgMCwgc3RhdGUud29yaywge1xuICAgICAgYml0czogOVxuICAgIH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikge1xuICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA1O1xuICAgIH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7XG4gICAgICBiaXRzOiA1XG4gICAgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICBhcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIGFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7XG4gICAgICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7XG4gICAgICAgIHN0YXRlLndoYXZlICs9IGRpc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlJDEoc3RybSwgZmx1c2gpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgaW5wdXQsIG91dHB1dDsgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgdmFyIG5leHQ7IC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgdmFyIHB1dDsgLyogbmV4dCBvdXRwdXQgSU5ERVggKi9cbiAgdmFyIGhhdmUsIGxlZnQ7IC8qIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBob2xkOyAvKiBiaXQgYnVmZmVyICovXG4gIHZhciBiaXRzOyAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi9cbiAgdmFyIF9pbiwgX291dDsgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7IC8qIGN1cnJlbnQgZGVjb2RpbmcgdGFibGUgZW50cnkgKi9cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkIFwiaGVyZVwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIC8vdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIHBhcmVudCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgXCJsYXN0XCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgdmFyIGxlbjsgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAvKiByZXR1cm4gY29kZSAqL1xuICB2YXIgaGJ1ZiA9IG5ldyBCdWY4KDQpOyAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICB2YXIgb3B0cztcblxuICB2YXIgbjsgLy8gdGVtcG9yYXJ5IHZhciBmb3IgTkVFRF9CSVRTXG5cbiAgdmFyIG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovIFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICB9IC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LJDE7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICAgIGZvciAoOzspIHtcbiAgICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgICAgY2FzZSBIRUFEOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHtcbiAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gMCAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi8gO1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAgICgoKGhvbGQgJiAweGZmKSAvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKSAvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCQxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpIC8qQklUUyg0KSovICsgODtcbiAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICAgIH0gZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMSAvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLyA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZMQUdTOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQkMSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRJTUU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7XG4gICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgICAvLz09PVxuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgT1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7XG4gICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYTEVOOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwgLypaX05VTEwqLyA7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYVFJBOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkge1xuICAgICAgICAgICAgY29weSA9IGhhdmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVuZCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJyYXlTZXQoXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOQU1FOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovICkpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT01NRU5UOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovICkpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgSENSQzpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUJDE7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMSAvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLyA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEU6XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyQxIHx8IGZsdXNoID09PSBaX1RSRUVTJDEpIHtcbiAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFRE86XG4gICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7XG4gICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKSAvKkJJVFMoMSkqLyA7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgICBiaXRzIC09IDE7XG4gICAgICAgIC8vLS0tLy9cblxuICAgICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykgLypCSVRTKDIpKi8gKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMkMSkge1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVE9SRUQ6XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHtcbiAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTJDEpIHtcbiAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWTpcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHtcbiAgICAgICAgICAgIGNvcHkgPSBoYXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHtcbiAgICAgICAgICAgIGNvcHkgPSBsZWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICAgIGFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVEFCTEU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE0KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7XG4gICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKSAvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikgLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKSAvKkJJVFMoNCkqLyArIDQ7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyNlbmRpZlxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7IC8vQklUUygzKTtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkge1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICBiaXRzOiBzdGF0ZS5sZW5iaXRzXG4gICAgICAgIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOyAvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOyAvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsgLy9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgYml0czogc3RhdGUubGVuYml0c1xuICAgICAgICB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICBiaXRzOiBzdGF0ZS5kaXN0Yml0c1xuICAgICAgICB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUyQxKSB7XG4gICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgICAgLy8tLS1cblxuICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7XG4gICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7XG4gICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpIC8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVORVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKSAvKkJJVFMoc3RhdGUuZXh0cmEpKi8gO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1Q6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07IC8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpIC8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNURVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKSAvKkJJVFMoc3RhdGUuZXh0cmEpKi8gO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIC8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE1BVENIOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgfVxuICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7IC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbiAgICAgICAgICAgIC8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIC8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuICAgICAgICAgICAgLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4gICAgICAgICAgICAvLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuICAgICAgICAgICAgLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICAgICAgLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgICAvLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgICAvLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICAgIC8vICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4gICAgICAgICAgICAvLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgICAgICAgLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICAgICAgICAvLyAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICAgIH0gZWxzZSB7IC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7XG4gICAgICAgICAgY29weSA9IGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBsZWZ0LS07XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDSEVDSzpcbiAgICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnNkZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vXG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERPTkU6XG4gICAgICAgIHJldCA9IFpfU1RSRUFNX0VORCQxO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SJDE7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgTUVNOlxuICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICAgICAgfVxuICAgIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCQxKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSA7XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArXG4gICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCQxKSAmJiByZXQgPT09IFpfT0skMSkge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SJDE7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8gKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0skMTtcbn1cblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cblxuLy8gaW1wb3J0IGNvbnN0YW50cyBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuLy8gemxpYiBtb2Rlc1xudmFyIE5PTkUgPSAwO1xudmFyIERFRkxBVEUgPSAxO1xudmFyIElORkxBVEUgPSAyO1xudmFyIEdaSVAgPSAzO1xudmFyIEdVTlpJUCA9IDQ7XG52YXIgREVGTEFURVJBVyA9IDU7XG52YXIgSU5GTEFURVJBVyA9IDY7XG52YXIgVU5aSVAgPSA3O1xudmFyIFpfTk9fRkxVU0g9ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIPSAgICAxLFxuICBaX1NZTkNfRkxVU0g9ICAgIDIsXG4gIFpfRlVMTF9GTFVTSD0gICAgICAgMyxcbiAgWl9GSU5JU0g9ICAgICAgIDQsXG4gIFpfQkxPQ0s9ICAgICAgICAgICA1LFxuICBaX1RSRUVTPSAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSz0gICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ9ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUPSAgICAgIDIsXG4gIFpfRVJSTk89ICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUj0gICAtMixcbiAgWl9EQVRBX0VSUk9SPSAgICAtMyxcbiAgLy9aX01FTV9FUlJPUjogICAgIC00LFxuICBaX0JVRl9FUlJPUj0gICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTj0gICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ9ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTj0gICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OPSAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRD0gICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWT0gICAgICAgICAgIDIsXG4gIFpfUkxFPSAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRD0gICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k9ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWT0gICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVD0gICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOPSAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEPSAgICAgICAgICAgICAgIDg7XG5mdW5jdGlvbiBabGliJDEobW9kZSkge1xuICBpZiAobW9kZSA8IERFRkxBVEUgfHwgbW9kZSA+IFVOWklQKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBhcmd1bWVudCcpO1xuXG4gIHRoaXMubW9kZSA9IG1vZGU7XG4gIHRoaXMuaW5pdF9kb25lID0gZmFsc2U7XG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgdGhpcy5wZW5kaW5nX2Nsb3NlID0gZmFsc2U7XG4gIHRoaXMud2luZG93Qml0cyA9IDA7XG4gIHRoaXMubGV2ZWwgPSAwO1xuICB0aGlzLm1lbUxldmVsID0gMDtcbiAgdGhpcy5zdHJhdGVneSA9IDA7XG4gIHRoaXMuZGljdGlvbmFyeSA9IG51bGw7XG59XG5cblpsaWIkMS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHdpbmRvd0JpdHMsIGxldmVsLCBtZW1MZXZlbCwgc3RyYXRlZ3ksIGRpY3Rpb25hcnkpIHtcbiAgdGhpcy53aW5kb3dCaXRzID0gd2luZG93Qml0cztcbiAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICB0aGlzLm1lbUxldmVsID0gbWVtTGV2ZWw7XG4gIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgLy8gZGljdGlvbmFyeSBub3Qgc3VwcG9ydGVkLlxuXG4gIGlmICh0aGlzLm1vZGUgPT09IEdaSVAgfHwgdGhpcy5tb2RlID09PSBHVU5aSVApXG4gICAgdGhpcy53aW5kb3dCaXRzICs9IDE2O1xuXG4gIGlmICh0aGlzLm1vZGUgPT09IFVOWklQKVxuICAgIHRoaXMud2luZG93Qml0cyArPSAzMjtcblxuICBpZiAodGhpcy5tb2RlID09PSBERUZMQVRFUkFXIHx8IHRoaXMubW9kZSA9PT0gSU5GTEFURVJBVylcbiAgICB0aGlzLndpbmRvd0JpdHMgPSAtdGhpcy53aW5kb3dCaXRzO1xuXG4gIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7XG4gIHZhciBzdGF0dXM7XG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gIGNhc2UgREVGTEFURTpcbiAgY2FzZSBHWklQOlxuICBjYXNlIERFRkxBVEVSQVc6XG4gICAgc3RhdHVzID0gZGVmbGF0ZUluaXQyKFxuICAgICAgdGhpcy5zdHJtLFxuICAgICAgdGhpcy5sZXZlbCxcbiAgICAgIFpfREVGTEFURUQsXG4gICAgICB0aGlzLndpbmRvd0JpdHMsXG4gICAgICB0aGlzLm1lbUxldmVsLFxuICAgICAgdGhpcy5zdHJhdGVneVxuICAgICk7XG4gICAgYnJlYWs7XG4gIGNhc2UgSU5GTEFURTpcbiAgY2FzZSBHVU5aSVA6XG4gIGNhc2UgSU5GTEFURVJBVzpcbiAgY2FzZSBVTlpJUDpcbiAgICBzdGF0dXMgID0gaW5mbGF0ZUluaXQyKFxuICAgICAgdGhpcy5zdHJtLFxuICAgICAgdGhpcy53aW5kb3dCaXRzXG4gICAgKTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbW9kZSAnICsgdGhpcy5tb2RlKTtcbiAgfVxuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aGlzLl9lcnJvcihzdGF0dXMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgdGhpcy5pbml0X2RvbmUgPSB0cnVlO1xufTtcblxuWmxpYiQxLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdkZWZsYXRlUGFyYW1zIE5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cblpsaWIkMS5wcm90b3R5cGUuX3dyaXRlQ2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmluaXRfZG9uZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRlIGJlZm9yZSBpbml0Jyk7XG5cbiAgaWYgKHRoaXMubW9kZSA9PT0gTk9ORSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscmVhZHkgZmluYWxpemVkJyk7XG5cbiAgaWYgKHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MpXG4gICAgdGhyb3cgbmV3IEVycm9yKCd3cml0ZSBhbHJlYWR5IGluIHByb2dyZXNzJyk7XG5cbiAgaWYgKHRoaXMucGVuZGluZ19jbG9zZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsb3NlIGlzIHBlbmRpbmcnKTtcbn07XG5cblpsaWIkMS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pIHtcbiAgdGhpcy5fd3JpdGVDaGVjaygpO1xuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gdHJ1ZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgc2VsZi53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICAgIHZhciByZXMgPSBzZWxmLl93cml0ZShmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pO1xuICAgIHNlbGYuY2FsbGJhY2socmVzWzBdLCByZXNbMV0pO1xuXG4gICAgaWYgKHNlbGYucGVuZGluZ19jbG9zZSlcbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgbWV0aG9kIGZvciBOb2RlIGJ1ZmZlcnMsIHVzZWQgYnkgcGFrb1xuZnVuY3Rpb24gYnVmZmVyU2V0KGRhdGEsIG9mZnNldCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gZGF0YVtpXTtcbiAgfVxufVxuXG5abGliJDEucHJvdG90eXBlLndyaXRlU3luYyA9IGZ1bmN0aW9uKGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbikge1xuICB0aGlzLl93cml0ZUNoZWNrKCk7XG4gIHJldHVybiB0aGlzLl93cml0ZShmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pO1xufTtcblxuWmxpYiQxLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pIHtcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IHRydWU7XG5cbiAgaWYgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmXG4gICAgICBmbHVzaCAhPT0gWl9QQVJUSUFMX0ZMVVNIICYmXG4gICAgICBmbHVzaCAhPT0gWl9TWU5DX0ZMVVNIICYmXG4gICAgICBmbHVzaCAhPT0gWl9GVUxMX0ZMVVNIICYmXG4gICAgICBmbHVzaCAhPT0gWl9GSU5JU0ggJiZcbiAgICAgIGZsdXNoICE9PSBaX0JMT0NLKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZsdXNoIHZhbHVlJyk7XG4gIH1cblxuICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgIGlucHV0ID0gbmV3IEJ1ZmZlcigwKTtcbiAgICBpbl9sZW4gPSAwO1xuICAgIGluX29mZiA9IDA7XG4gIH1cblxuICBpZiAob3V0Ll9zZXQpXG4gICAgb3V0LnNldCA9IG91dC5fc2V0O1xuICBlbHNlXG4gICAgb3V0LnNldCA9IGJ1ZmZlclNldDtcblxuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgc3RybS5hdmFpbF9pbiA9IGluX2xlbjtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLm5leHRfaW4gPSBpbl9vZmY7XG4gIHN0cm0uYXZhaWxfb3V0ID0gb3V0X2xlbjtcbiAgc3RybS5vdXRwdXQgPSBvdXQ7XG4gIHN0cm0ubmV4dF9vdXQgPSBvdXRfb2ZmO1xuICB2YXIgc3RhdHVzO1xuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICBjYXNlIERFRkxBVEU6XG4gIGNhc2UgR1pJUDpcbiAgY2FzZSBERUZMQVRFUkFXOlxuICAgIHN0YXR1cyA9IGRlZmxhdGUkMShzdHJtLCBmbHVzaCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgVU5aSVA6XG4gIGNhc2UgSU5GTEFURTpcbiAgY2FzZSBHVU5aSVA6XG4gIGNhc2UgSU5GTEFURVJBVzpcbiAgICBzdGF0dXMgPSBpbmZsYXRlJDEoc3RybSwgZmx1c2gpO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtb2RlICcgKyB0aGlzLm1vZGUpO1xuICB9XG5cbiAgaWYgKCF0aGlzLl9jaGVja0Vycm9yKHN0YXR1cywgc3RybSwgZmx1c2gpKSB7XG4gICAgdGhpcy5fZXJyb3Ioc3RhdHVzKTtcbiAgfVxuXG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgcmV0dXJuIFtzdHJtLmF2YWlsX2luLCBzdHJtLmF2YWlsX291dF07XG59O1xuXG5abGliJDEucHJvdG90eXBlLl9jaGVja0Vycm9yID0gZnVuY3Rpb24gKHN0YXR1cywgc3RybSwgZmx1c2gpIHtcbiAgLy8gQWNjZXB0YWJsZSBlcnJvciBzdGF0ZXMgZGVwZW5kIG9uIHRoZSB0eXBlIG9mIHpsaWIgc3RyZWFtLlxuICBzd2l0Y2ggKHN0YXR1cykge1xuICAgIGNhc2UgWl9PSzpcbiAgICBjYXNlIFpfQlVGX0VSUk9SOlxuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ICE9PSAwICYmIGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSBaX1NUUkVBTV9FTkQ6XG4gICAgICAvLyBub3JtYWwgc3RhdHVzZXMsIG5vdCBmYXRhbFxuICAgICAgYnJlYWtcbiAgICBjYXNlIFpfTkVFRF9ESUNUOlxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn07XG5cblpsaWIkMS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MpIHtcbiAgICB0aGlzLnBlbmRpbmdfY2xvc2UgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMucGVuZGluZ19jbG9zZSA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLm1vZGUgPT09IERFRkxBVEUgfHwgdGhpcy5tb2RlID09PSBHWklQIHx8IHRoaXMubW9kZSA9PT0gREVGTEFURVJBVykge1xuICAgIGRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgfSBlbHNlIHtcbiAgICBpbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gIH1cblxuICB0aGlzLm1vZGUgPSBOT05FO1xufTtcbnZhciBzdGF0dXM7XG5abGliJDEucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gIGNhc2UgREVGTEFURTpcbiAgY2FzZSBERUZMQVRFUkFXOlxuICAgIHN0YXR1cyA9IGRlZmxhdGVSZXNldCh0aGlzLnN0cm0pO1xuICAgIGJyZWFrO1xuICBjYXNlIElORkxBVEU6XG4gIGNhc2UgSU5GTEFURVJBVzpcbiAgICBzdGF0dXMgPSBpbmZsYXRlUmVzZXQodGhpcy5zdHJtKTtcbiAgICBicmVhaztcbiAgfVxuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aGlzLl9lcnJvcihzdGF0dXMpO1xuICB9XG59O1xuXG5abGliJDEucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKHN0YXR1cykge1xuICB0aGlzLm9uZXJyb3IobXNnW3N0YXR1c10gKyAnOiAnICsgdGhpcy5zdHJtLm1zZywgc3RhdHVzKTtcblxuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG4gIGlmICh0aGlzLnBlbmRpbmdfY2xvc2UpXG4gICAgdGhpcy5jbG9zZSgpO1xufTtcblxudmFyIF9iaW5kaW5nID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdERFRkxBVEU6IERFRkxBVEUsXG5cdERFRkxBVEVSQVc6IERFRkxBVEVSQVcsXG5cdEdVTlpJUDogR1VOWklQLFxuXHRHWklQOiBHWklQLFxuXHRJTkZMQVRFOiBJTkZMQVRFLFxuXHRJTkZMQVRFUkFXOiBJTkZMQVRFUkFXLFxuXHROT05FOiBOT05FLFxuXHRVTlpJUDogVU5aSVAsXG5cdFpfQkVTVF9DT01QUkVTU0lPTjogWl9CRVNUX0NPTVBSRVNTSU9OLFxuXHRaX0JFU1RfU1BFRUQ6IFpfQkVTVF9TUEVFRCxcblx0Wl9CSU5BUlk6IFpfQklOQVJZLFxuXHRaX0JMT0NLOiBaX0JMT0NLLFxuXHRaX0JVRl9FUlJPUjogWl9CVUZfRVJST1IsXG5cdFpfREFUQV9FUlJPUjogWl9EQVRBX0VSUk9SLFxuXHRaX0RFRkFVTFRfQ09NUFJFU1NJT046IFpfREVGQVVMVF9DT01QUkVTU0lPTixcblx0Wl9ERUZBVUxUX1NUUkFURUdZOiBaX0RFRkFVTFRfU1RSQVRFR1ksXG5cdFpfREVGTEFURUQ6IFpfREVGTEFURUQsXG5cdFpfRVJSTk86IFpfRVJSTk8sXG5cdFpfRklMVEVSRUQ6IFpfRklMVEVSRUQsXG5cdFpfRklOSVNIOiBaX0ZJTklTSCxcblx0Wl9GSVhFRDogWl9GSVhFRCxcblx0Wl9GVUxMX0ZMVVNIOiBaX0ZVTExfRkxVU0gsXG5cdFpfSFVGRk1BTl9PTkxZOiBaX0hVRkZNQU5fT05MWSxcblx0Wl9ORUVEX0RJQ1Q6IFpfTkVFRF9ESUNULFxuXHRaX05PX0NPTVBSRVNTSU9OOiBaX05PX0NPTVBSRVNTSU9OLFxuXHRaX05PX0ZMVVNIOiBaX05PX0ZMVVNILFxuXHRaX09LOiBaX09LLFxuXHRaX1BBUlRJQUxfRkxVU0g6IFpfUEFSVElBTF9GTFVTSCxcblx0Wl9STEU6IFpfUkxFLFxuXHRaX1NUUkVBTV9FTkQ6IFpfU1RSRUFNX0VORCxcblx0Wl9TVFJFQU1fRVJST1I6IFpfU1RSRUFNX0VSUk9SLFxuXHRaX1NZTkNfRkxVU0g6IFpfU1lOQ19GTFVTSCxcblx0Wl9URVhUOiBaX1RFWFQsXG5cdFpfVFJFRVM6IFpfVFJFRVMsXG5cdFpfVU5LTk9XTjogWl9VTktOT1dOLFxuXHRabGliOiBabGliJDFcbn0pO1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gYXNzZXJ0IChhLCBtc2cpIHtcbiAgaWYgKCFhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbnZhciBiaW5kaW5nID0ge307XG5PYmplY3Qua2V5cyhfYmluZGluZykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGJpbmRpbmdba2V5XSA9IF9iaW5kaW5nW2tleV07XG59KTtcbi8vIHpsaWIgZG9lc24ndCBwcm92aWRlIHRoZXNlLCBzbyBrbHVkZ2UgdGhlbSBpbiBmb2xsb3dpbmcgdGhlIHNhbWVcbi8vIGNvbnN0IG5hbWluZyBzY2hlbWUgemxpYiB1c2VzLlxuYmluZGluZy5aX01JTl9XSU5ET1dCSVRTID0gODtcbmJpbmRpbmcuWl9NQVhfV0lORE9XQklUUyA9IDE1O1xuYmluZGluZy5aX0RFRkFVTFRfV0lORE9XQklUUyA9IDE1O1xuXG4vLyBmZXdlciB0aGFuIDY0IGJ5dGVzIHBlciBjaHVuayBpcyBzdHVwaWQuXG4vLyB0ZWNobmljYWxseSBpdCBjb3VsZCB3b3JrIHdpdGggYXMgZmV3IGFzIDgsIGJ1dCBldmVuIDY0IGJ5dGVzXG4vLyBpcyBhYnN1cmRseSBsb3cuICBVc3VhbGx5IGEgTUIgb3IgbW9yZSBpcyBiZXN0LlxuYmluZGluZy5aX01JTl9DSFVOSyA9IDY0O1xuYmluZGluZy5aX01BWF9DSFVOSyA9IEluZmluaXR5O1xuYmluZGluZy5aX0RFRkFVTFRfQ0hVTksgPSAoMTYgKiAxMDI0KTtcblxuYmluZGluZy5aX01JTl9NRU1MRVZFTCA9IDE7XG5iaW5kaW5nLlpfTUFYX01FTUxFVkVMID0gOTtcbmJpbmRpbmcuWl9ERUZBVUxUX01FTUxFVkVMID0gODtcblxuYmluZGluZy5aX01JTl9MRVZFTCA9IC0xO1xuYmluZGluZy5aX01BWF9MRVZFTCA9IDk7XG5iaW5kaW5nLlpfREVGQVVMVF9MRVZFTCA9IGJpbmRpbmcuWl9ERUZBVUxUX0NPTVBSRVNTSU9OO1xuXG5cbi8vIHRyYW5zbGF0aW9uIHRhYmxlIGZvciByZXR1cm4gY29kZXMuXG52YXIgY29kZXMgPSB7XG4gIFpfT0s6IGJpbmRpbmcuWl9PSyxcbiAgWl9TVFJFQU1fRU5EOiBiaW5kaW5nLlpfU1RSRUFNX0VORCxcbiAgWl9ORUVEX0RJQ1Q6IGJpbmRpbmcuWl9ORUVEX0RJQ1QsXG4gIFpfRVJSTk86IGJpbmRpbmcuWl9FUlJOTyxcbiAgWl9TVFJFQU1fRVJST1I6IGJpbmRpbmcuWl9TVFJFQU1fRVJST1IsXG4gIFpfREFUQV9FUlJPUjogYmluZGluZy5aX0RBVEFfRVJST1IsXG4gIFpfTUVNX0VSUk9SOiBiaW5kaW5nLlpfTUVNX0VSUk9SLFxuICBaX0JVRl9FUlJPUjogYmluZGluZy5aX0JVRl9FUlJPUixcbiAgWl9WRVJTSU9OX0VSUk9SOiBiaW5kaW5nLlpfVkVSU0lPTl9FUlJPUlxufTtcblxuT2JqZWN0LmtleXMoY29kZXMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBjb2Rlc1tjb2Rlc1trXV0gPSBrO1xufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmxhdGUobykge1xuICByZXR1cm4gbmV3IERlZmxhdGUobyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluZmxhdGUobykge1xuICByZXR1cm4gbmV3IEluZmxhdGUobyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmxhdGVSYXcobykge1xuICByZXR1cm4gbmV3IERlZmxhdGVSYXcobyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluZmxhdGVSYXcobykge1xuICByZXR1cm4gbmV3IEluZmxhdGVSYXcobyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUd6aXAobykge1xuICByZXR1cm4gbmV3IEd6aXAobyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUd1bnppcChvKSB7XG4gIHJldHVybiBuZXcgR3VuemlwKG8pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVbnppcChvKSB7XG4gIHJldHVybiBuZXcgVW56aXAobyk7XG59XG5cblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kcy5cbi8vIGNvbXByZXNzL2RlY29tcHJlc3MgYSBzdHJpbmcgb3IgYnVmZmVyIGluIG9uZSBzdGVwLlxuZnVuY3Rpb24gZGVmbGF0ZShidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IERlZmxhdGUob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlU3luYyhidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBEZWZsYXRlKG9wdHMpLCBidWZmZXIpO1xufVxuXG5mdW5jdGlvbiBnemlwKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgR3ppcChvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGd6aXBTeW5jKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IEd6aXAob3B0cyksIGJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBEZWZsYXRlUmF3KG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZVJhd1N5bmMoYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgRGVmbGF0ZVJhdyhvcHRzKSwgYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gdW56aXAoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBVbnppcChvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHVuemlwU3luYyhidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBVbnppcChvcHRzKSwgYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZShidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEluZmxhdGUob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU3luYyhidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBJbmZsYXRlKG9wdHMpLCBidWZmZXIpO1xufVxuXG5mdW5jdGlvbiBndW56aXAoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBHdW56aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBndW56aXBTeW5jKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IEd1bnppcChvcHRzKSwgYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJhdyhidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEluZmxhdGVSYXcob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmF3U3luYyhidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBJbmZsYXRlUmF3KG9wdHMpLCBidWZmZXIpO1xufVxuXG5mdW5jdGlvbiB6bGliQnVmZmVyKGVuZ2luZSwgYnVmZmVyLCBjYWxsYmFjaykge1xuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgbnJlYWQgPSAwO1xuXG4gIGVuZ2luZS5vbignZXJyb3InLCBvbkVycm9yKTtcbiAgZW5naW5lLm9uKCdlbmQnLCBvbkVuZCk7XG5cbiAgZW5naW5lLmVuZChidWZmZXIpO1xuICBmbG93KCk7XG5cbiAgZnVuY3Rpb24gZmxvdygpIHtcbiAgICB2YXIgY2h1bms7XG4gICAgd2hpbGUgKG51bGwgIT09IChjaHVuayA9IGVuZ2luZS5yZWFkKCkpKSB7XG4gICAgICBidWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgbnJlYWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgICBlbmdpbmUub25jZSgncmVhZGFibGUnLCBmbG93KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgZW5naW5lLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkVuZCk7XG4gICAgZW5naW5lLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIGZsb3cpO1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVuZCgpIHtcbiAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBucmVhZCk7XG4gICAgYnVmZmVycyA9IFtdO1xuICAgIGNhbGxiYWNrKG51bGwsIGJ1Zik7XG4gICAgZW5naW5lLmNsb3NlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gemxpYkJ1ZmZlclN5bmMoZW5naW5lLCBidWZmZXIpIHtcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKVxuICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoYnVmZmVyKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBzdHJpbmcgb3IgYnVmZmVyJyk7XG5cbiAgdmFyIGZsdXNoRmxhZyA9IGJpbmRpbmcuWl9GSU5JU0g7XG5cbiAgcmV0dXJuIGVuZ2luZS5fcHJvY2Vzc0NodW5rKGJ1ZmZlciwgZmx1c2hGbGFnKTtcbn1cblxuLy8gZ2VuZXJpYyB6bGliXG4vLyBtaW5pbWFsIDItYnl0ZSBoZWFkZXJcbmZ1bmN0aW9uIERlZmxhdGUob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuREVGTEFURSk7XG59XG5cbmZ1bmN0aW9uIEluZmxhdGUob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuSU5GTEFURSk7XG59XG5cblxuXG4vLyBnemlwIC0gYmlnZ2VyIGhlYWRlciwgc2FtZSBkZWZsYXRlIGNvbXByZXNzaW9uXG5mdW5jdGlvbiBHemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEd6aXApKSByZXR1cm4gbmV3IEd6aXAob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkdaSVApO1xufVxuXG5mdW5jdGlvbiBHdW56aXAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR3VuemlwKSkgcmV0dXJuIG5ldyBHdW56aXAob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkdVTlpJUCk7XG59XG5cblxuXG4vLyByYXcgLSBubyBoZWFkZXJcbmZ1bmN0aW9uIERlZmxhdGVSYXcob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZVJhdykpIHJldHVybiBuZXcgRGVmbGF0ZVJhdyhvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuREVGTEFURVJBVyk7XG59XG5cbmZ1bmN0aW9uIEluZmxhdGVSYXcob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZVJhdykpIHJldHVybiBuZXcgSW5mbGF0ZVJhdyhvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuSU5GTEFURVJBVyk7XG59XG5cblxuLy8gYXV0by1kZXRlY3QgaGVhZGVyLlxuZnVuY3Rpb24gVW56aXAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVW56aXApKSByZXR1cm4gbmV3IFVuemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5VTlpJUCk7XG59XG5cblxuLy8gdGhlIFpsaWIgY2xhc3MgdGhleSBhbGwgaW5oZXJpdCBmcm9tXG4vLyBUaGlzIHRoaW5nIG1hbmFnZXMgdGhlIHF1ZXVlIG9mIHJlcXVlc3RzLCBhbmQgcmV0dXJuc1xuLy8gdHJ1ZSBvciBmYWxzZSBpZiB0aGVyZSBpcyBhbnl0aGluZyBpbiB0aGUgcXVldWUgd2hlblxuLy8geW91IGNhbGwgdGhlIC53cml0ZSgpIG1ldGhvZC5cblxuZnVuY3Rpb24gWmxpYihvcHRzLCBtb2RlKSB7XG4gIHRoaXMuX29wdHMgPSBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5fY2h1bmtTaXplID0gb3B0cy5jaHVua1NpemUgfHwgYmluZGluZy5aX0RFRkFVTFRfQ0hVTks7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgaWYgKG9wdHMuZmx1c2gpIHtcbiAgICBpZiAob3B0cy5mbHVzaCAhPT0gYmluZGluZy5aX05PX0ZMVVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9QQVJUSUFMX0ZMVVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9TWU5DX0ZMVVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9GVUxMX0ZMVVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9GSU5JU0ggJiZcbiAgICAgICAgb3B0cy5mbHVzaCAhPT0gYmluZGluZy5aX0JMT0NLKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZmx1c2ggZmxhZzogJyArIG9wdHMuZmx1c2gpO1xuICAgIH1cbiAgfVxuICB0aGlzLl9mbHVzaEZsYWcgPSBvcHRzLmZsdXNoIHx8IGJpbmRpbmcuWl9OT19GTFVTSDtcblxuICBpZiAob3B0cy5jaHVua1NpemUpIHtcbiAgICBpZiAob3B0cy5jaHVua1NpemUgPCBiaW5kaW5nLlpfTUlOX0NIVU5LIHx8XG4gICAgICAgIG9wdHMuY2h1bmtTaXplID4gYmluZGluZy5aX01BWF9DSFVOSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNodW5rIHNpemU6ICcgKyBvcHRzLmNodW5rU2l6ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMud2luZG93Qml0cykge1xuICAgIGlmIChvcHRzLndpbmRvd0JpdHMgPCBiaW5kaW5nLlpfTUlOX1dJTkRPV0JJVFMgfHxcbiAgICAgICAgb3B0cy53aW5kb3dCaXRzID4gYmluZGluZy5aX01BWF9XSU5ET1dCSVRTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgd2luZG93Qml0czogJyArIG9wdHMud2luZG93Qml0cyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMubGV2ZWwpIHtcbiAgICBpZiAob3B0cy5sZXZlbCA8IGJpbmRpbmcuWl9NSU5fTEVWRUwgfHxcbiAgICAgICAgb3B0cy5sZXZlbCA+IGJpbmRpbmcuWl9NQVhfTEVWRUwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb21wcmVzc2lvbiBsZXZlbDogJyArIG9wdHMubGV2ZWwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLm1lbUxldmVsKSB7XG4gICAgaWYgKG9wdHMubWVtTGV2ZWwgPCBiaW5kaW5nLlpfTUlOX01FTUxFVkVMIHx8XG4gICAgICAgIG9wdHMubWVtTGV2ZWwgPiBiaW5kaW5nLlpfTUFYX01FTUxFVkVMKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWVtTGV2ZWw6ICcgKyBvcHRzLm1lbUxldmVsKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5zdHJhdGVneSkge1xuICAgIGlmIChvcHRzLnN0cmF0ZWd5ICE9IGJpbmRpbmcuWl9GSUxURVJFRCAmJlxuICAgICAgICBvcHRzLnN0cmF0ZWd5ICE9IGJpbmRpbmcuWl9IVUZGTUFOX09OTFkgJiZcbiAgICAgICAgb3B0cy5zdHJhdGVneSAhPSBiaW5kaW5nLlpfUkxFICYmXG4gICAgICAgIG9wdHMuc3RyYXRlZ3kgIT0gYmluZGluZy5aX0ZJWEVEICYmXG4gICAgICAgIG9wdHMuc3RyYXRlZ3kgIT0gYmluZGluZy5aX0RFRkFVTFRfU1RSQVRFR1kpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJhdGVneTogJyArIG9wdHMuc3RyYXRlZ3kpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLmRpY3Rpb25hcnkpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvcHRzLmRpY3Rpb25hcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGljdGlvbmFyeTogaXQgc2hvdWxkIGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fYmluZGluZyA9IG5ldyBiaW5kaW5nLlpsaWIobW9kZSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9oYWRFcnJvciA9IGZhbHNlO1xuICB0aGlzLl9iaW5kaW5nLm9uZXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlLCBlcnJubykge1xuICAgIC8vIHRoZXJlIGlzIG5vIHdheSB0byBjbGVhbmx5IHJlY292ZXIuXG4gICAgLy8gY29udGludWluZyBvbmx5IG9ic2N1cmVzIHByb2JsZW1zLlxuICAgIHNlbGYuX2JpbmRpbmcgPSBudWxsO1xuICAgIHNlbGYuX2hhZEVycm9yID0gdHJ1ZTtcblxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlcnJvci5lcnJubyA9IGVycm5vO1xuICAgIGVycm9yLmNvZGUgPSBjb2Rlc1tlcnJub107XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgfTtcblxuICB2YXIgbGV2ZWwgPSBiaW5kaW5nLlpfREVGQVVMVF9DT01QUkVTU0lPTjtcbiAgaWYgKHR5cGVvZiBvcHRzLmxldmVsID09PSAnbnVtYmVyJykgbGV2ZWwgPSBvcHRzLmxldmVsO1xuXG4gIHZhciBzdHJhdGVneSA9IGJpbmRpbmcuWl9ERUZBVUxUX1NUUkFURUdZO1xuICBpZiAodHlwZW9mIG9wdHMuc3RyYXRlZ3kgPT09ICdudW1iZXInKSBzdHJhdGVneSA9IG9wdHMuc3RyYXRlZ3k7XG5cbiAgdGhpcy5fYmluZGluZy5pbml0KG9wdHMud2luZG93Qml0cyB8fCBiaW5kaW5nLlpfREVGQVVMVF9XSU5ET1dCSVRTLFxuICAgICAgICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICBvcHRzLm1lbUxldmVsIHx8IGJpbmRpbmcuWl9ERUZBVUxUX01FTUxFVkVMLFxuICAgICAgICAgICAgICAgICAgICAgc3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgICBvcHRzLmRpY3Rpb25hcnkpO1xuXG4gIHRoaXMuX2J1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5fY2h1bmtTaXplKTtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gIHRoaXMuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCB0aGlzLmNsb3NlKTtcbn1cblxuaW5oZXJpdHMkMShabGliLCBUcmFuc2Zvcm0pO1xuXG5abGliLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbihsZXZlbCwgc3RyYXRlZ3ksIGNhbGxiYWNrKSB7XG4gIGlmIChsZXZlbCA8IGJpbmRpbmcuWl9NSU5fTEVWRUwgfHxcbiAgICAgIGxldmVsID4gYmluZGluZy5aX01BWF9MRVZFTCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGNvbXByZXNzaW9uIGxldmVsOiAnICsgbGV2ZWwpO1xuICB9XG4gIGlmIChzdHJhdGVneSAhPSBiaW5kaW5nLlpfRklMVEVSRUQgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGJpbmRpbmcuWl9IVUZGTUFOX09OTFkgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGJpbmRpbmcuWl9STEUgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGJpbmRpbmcuWl9GSVhFRCAmJlxuICAgICAgc3RyYXRlZ3kgIT0gYmluZGluZy5aX0RFRkFVTFRfU1RSQVRFR1kpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0cmF0ZWd5OiAnICsgc3RyYXRlZ3kpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2xldmVsICE9PSBsZXZlbCB8fCB0aGlzLl9zdHJhdGVneSAhPT0gc3RyYXRlZ3kpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5mbHVzaChiaW5kaW5nLlpfU1lOQ19GTFVTSCwgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9iaW5kaW5nLnBhcmFtcyhsZXZlbCwgc3RyYXRlZ3kpO1xuICAgICAgaWYgKCFzZWxmLl9oYWRFcnJvcikge1xuICAgICAgICBzZWxmLl9sZXZlbCA9IGxldmVsO1xuICAgICAgICBzZWxmLl9zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG4gIH1cbn07XG5cblpsaWIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9iaW5kaW5nLnJlc2V0KCk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBfZmx1c2ggZnVuY3Rpb24gY2FsbGVkIGJ5IHRoZSB0cmFuc2Zvcm0gY2xhc3MsXG4vLyBpbnRlcm5hbGx5LCB3aGVuIHRoZSBsYXN0IGNodW5rIGhhcyBiZWVuIHdyaXR0ZW4uXG5abGliLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB0aGlzLl90cmFuc2Zvcm0obmV3IEJ1ZmZlcigwKSwgJycsIGNhbGxiYWNrKTtcbn07XG5cblpsaWIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oa2luZCwgY2FsbGJhY2spIHtcbiAgdmFyIHdzID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGtpbmQgPT09ICdmdW5jdGlvbicgfHwgKGtpbmQgPT09IHZvaWQgMCAmJiAhY2FsbGJhY2spKSB7XG4gICAgY2FsbGJhY2sgPSBraW5kO1xuICAgIGtpbmQgPSBiaW5kaW5nLlpfRlVMTF9GTFVTSDtcbiAgfVxuXG4gIGlmICh3cy5lbmRlZCkge1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHdzLmVuZGluZykge1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgIHRoaXMub25jZSgnZW5kJywgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHdzLm5lZWREcmFpbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmZsdXNoKGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9mbHVzaEZsYWcgPSBraW5kO1xuICAgIHRoaXMud3JpdGUobmV3IEJ1ZmZlcigwKSwgJycsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2spXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG5cbiAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICByZXR1cm47XG5cbiAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcblxuICB0aGlzLl9iaW5kaW5nLmNsb3NlKCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5abGliLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgZmx1c2hGbGFnO1xuICB2YXIgd3MgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgZW5kaW5nID0gd3MuZW5kaW5nIHx8IHdzLmVuZGVkO1xuICB2YXIgbGFzdCA9IGVuZGluZyAmJiAoIWNodW5rIHx8IHdzLmxlbmd0aCA9PT0gY2h1bmsubGVuZ3RoKTtcblxuICBpZiAoIWNodW5rID09PSBudWxsICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQnKSk7XG5cbiAgLy8gSWYgaXQncyB0aGUgbGFzdCBjaHVuaywgb3IgYSBmaW5hbCBmbHVzaCwgd2UgdXNlIHRoZSBaX0ZJTklTSCBmbHVzaCBmbGFnLlxuICAvLyBJZiBpdCdzIGV4cGxpY2l0bHkgZmx1c2hpbmcgYXQgc29tZSBvdGhlciB0aW1lLCB0aGVuIHdlIHVzZVxuICAvLyBaX0ZVTExfRkxVU0guIE90aGVyd2lzZSwgdXNlIFpfTk9fRkxVU0ggZm9yIG1heGltdW0gY29tcHJlc3Npb25cbiAgLy8gZ29vZG5lc3MuXG4gIGlmIChsYXN0KVxuICAgIGZsdXNoRmxhZyA9IGJpbmRpbmcuWl9GSU5JU0g7XG4gIGVsc2Uge1xuICAgIGZsdXNoRmxhZyA9IHRoaXMuX2ZsdXNoRmxhZztcbiAgICAvLyBvbmNlIHdlJ3ZlIGZsdXNoZWQgdGhlIGxhc3Qgb2YgdGhlIHF1ZXVlLCBzdG9wIGZsdXNoaW5nIGFuZFxuICAgIC8vIGdvIGJhY2sgdG8gdGhlIG5vcm1hbCBiZWhhdmlvci5cbiAgICBpZiAoY2h1bmsubGVuZ3RoID49IHdzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fZmx1c2hGbGFnID0gdGhpcy5fb3B0cy5mbHVzaCB8fCBiaW5kaW5nLlpfTk9fRkxVU0g7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fcHJvY2Vzc0NodW5rKGNodW5rLCBmbHVzaEZsYWcsIGNiKTtcbn07XG5cblpsaWIucHJvdG90eXBlLl9wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbihjaHVuaywgZmx1c2hGbGFnLCBjYikge1xuICB2YXIgYXZhaWxJbkJlZm9yZSA9IGNodW5rICYmIGNodW5rLmxlbmd0aDtcbiAgdmFyIGF2YWlsT3V0QmVmb3JlID0gdGhpcy5fY2h1bmtTaXplIC0gdGhpcy5fb2Zmc2V0O1xuICB2YXIgaW5PZmYgPSAwO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgYXN5bmMgPSB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbic7XG5cbiAgaWYgKCFhc3luYykge1xuICAgIHZhciBidWZmZXJzID0gW107XG4gICAgdmFyIG5yZWFkID0gMDtcblxuICAgIHZhciBlcnJvcjtcbiAgICB0aGlzLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVyKSB7XG4gICAgICBlcnJvciA9IGVyO1xuICAgIH0pO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIHJlcyA9IHRoaXMuX2JpbmRpbmcud3JpdGVTeW5jKGZsdXNoRmxhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuaywgLy8gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbk9mZiwgLy8gaW5fb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxJbkJlZm9yZSwgLy8gaW5fbGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyLCAvLyBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQsIC8vb3V0X29mZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsT3V0QmVmb3JlKTsgLy8gb3V0X2xlblxuICAgIH0gd2hpbGUgKCF0aGlzLl9oYWRFcnJvciAmJiBjYWxsYmFjayhyZXNbMF0sIHJlc1sxXSkpO1xuXG4gICAgaWYgKHRoaXMuX2hhZEVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBucmVhZCk7XG4gICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHZhciByZXEgPSB0aGlzLl9iaW5kaW5nLndyaXRlKGZsdXNoRmxhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmssIC8vIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluT2ZmLCAvLyBpbl9vZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxJbkJlZm9yZSwgLy8gaW5fbGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlciwgLy8gb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCwgLy9vdXRfb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsT3V0QmVmb3JlKTsgLy8gb3V0X2xlblxuXG4gIHJlcS5idWZmZXIgPSBjaHVuaztcbiAgcmVxLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgZnVuY3Rpb24gY2FsbGJhY2soYXZhaWxJbkFmdGVyLCBhdmFpbE91dEFmdGVyKSB7XG4gICAgaWYgKHNlbGYuX2hhZEVycm9yKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIGhhdmUgPSBhdmFpbE91dEJlZm9yZSAtIGF2YWlsT3V0QWZ0ZXI7XG4gICAgYXNzZXJ0KGhhdmUgPj0gMCwgJ2hhdmUgc2hvdWxkIG5vdCBnbyBkb3duJyk7XG5cbiAgICBpZiAoaGF2ZSA+IDApIHtcbiAgICAgIHZhciBvdXQgPSBzZWxmLl9idWZmZXIuc2xpY2Uoc2VsZi5fb2Zmc2V0LCBzZWxmLl9vZmZzZXQgKyBoYXZlKTtcbiAgICAgIHNlbGYuX29mZnNldCArPSBoYXZlO1xuICAgICAgLy8gc2VydmUgc29tZSBvdXRwdXQgdG8gdGhlIGNvbnN1bWVyLlxuICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgIHNlbGYucHVzaChvdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVycy5wdXNoKG91dCk7XG4gICAgICAgIG5yZWFkICs9IG91dC5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXhoYXVzdGVkIHRoZSBvdXRwdXQgYnVmZmVyLCBvciB1c2VkIGFsbCB0aGUgaW5wdXQgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICBpZiAoYXZhaWxPdXRBZnRlciA9PT0gMCB8fCBzZWxmLl9vZmZzZXQgPj0gc2VsZi5fY2h1bmtTaXplKSB7XG4gICAgICBhdmFpbE91dEJlZm9yZSA9IHNlbGYuX2NodW5rU2l6ZTtcbiAgICAgIHNlbGYuX29mZnNldCA9IDA7XG4gICAgICBzZWxmLl9idWZmZXIgPSBuZXcgQnVmZmVyKHNlbGYuX2NodW5rU2l6ZSk7XG4gICAgfVxuXG4gICAgaWYgKGF2YWlsT3V0QWZ0ZXIgPT09IDApIHtcbiAgICAgIC8vIE5vdCBhY3R1YWxseSBkb25lLiAgTmVlZCB0byByZXByb2Nlc3MuXG4gICAgICAvLyBBbHNvLCB1cGRhdGUgdGhlIGF2YWlsSW5CZWZvcmUgdG8gdGhlIGF2YWlsSW5BZnRlciB2YWx1ZSxcbiAgICAgIC8vIHNvIHRoYXQgaWYgd2UgaGF2ZSB0byBoaXQgaXQgYSB0aGlyZCAoZm91cnRoLCBldGMuKSB0aW1lLFxuICAgICAgLy8gaXQnbGwgaGF2ZSB0aGUgY29ycmVjdCBieXRlIGNvdW50cy5cbiAgICAgIGluT2ZmICs9IChhdmFpbEluQmVmb3JlIC0gYXZhaWxJbkFmdGVyKTtcbiAgICAgIGF2YWlsSW5CZWZvcmUgPSBhdmFpbEluQWZ0ZXI7XG5cbiAgICAgIGlmICghYXN5bmMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICB2YXIgbmV3UmVxID0gc2VsZi5fYmluZGluZy53cml0ZShmbHVzaEZsYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluT2ZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxJbkJlZm9yZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2J1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2NodW5rU2l6ZSk7XG4gICAgICBuZXdSZXEuY2FsbGJhY2sgPSBjYWxsYmFjazsgLy8gdGhpcyBzYW1lIGZ1bmN0aW9uXG4gICAgICBuZXdSZXEuYnVmZmVyID0gY2h1bms7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFhc3luYylcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIC8vIGZpbmlzaGVkIHdpdGggdGhlIGNodW5rLlxuICAgIGNiKCk7XG4gIH1cbn07XG5cbmluaGVyaXRzJDEoRGVmbGF0ZSwgWmxpYik7XG5pbmhlcml0cyQxKEluZmxhdGUsIFpsaWIpO1xuaW5oZXJpdHMkMShHemlwLCBabGliKTtcbmluaGVyaXRzJDEoR3VuemlwLCBabGliKTtcbmluaGVyaXRzJDEoRGVmbGF0ZVJhdywgWmxpYik7XG5pbmhlcml0cyQxKEluZmxhdGVSYXcsIFpsaWIpO1xuaW5oZXJpdHMkMShVbnppcCwgWmxpYik7XG52YXIgX3BvbHlmaWxsTm9kZV96bGliID0ge1xuICBjb2RlczogY29kZXMsXG4gIGNyZWF0ZURlZmxhdGU6IGNyZWF0ZURlZmxhdGUsXG4gIGNyZWF0ZUluZmxhdGU6IGNyZWF0ZUluZmxhdGUsXG4gIGNyZWF0ZURlZmxhdGVSYXc6IGNyZWF0ZURlZmxhdGVSYXcsXG4gIGNyZWF0ZUluZmxhdGVSYXc6IGNyZWF0ZUluZmxhdGVSYXcsXG4gIGNyZWF0ZUd6aXA6IGNyZWF0ZUd6aXAsXG4gIGNyZWF0ZUd1bnppcDogY3JlYXRlR3VuemlwLFxuICBjcmVhdGVVbnppcDogY3JlYXRlVW56aXAsXG4gIGRlZmxhdGU6IGRlZmxhdGUsXG4gIGRlZmxhdGVTeW5jOiBkZWZsYXRlU3luYyxcbiAgZ3ppcDogZ3ppcCxcbiAgZ3ppcFN5bmM6IGd6aXBTeW5jLFxuICBkZWZsYXRlUmF3OiBkZWZsYXRlUmF3LFxuICBkZWZsYXRlUmF3U3luYzogZGVmbGF0ZVJhd1N5bmMsXG4gIHVuemlwOiB1bnppcCxcbiAgdW56aXBTeW5jOiB1bnppcFN5bmMsXG4gIGluZmxhdGU6IGluZmxhdGUsXG4gIGluZmxhdGVTeW5jOiBpbmZsYXRlU3luYyxcbiAgZ3VuemlwOiBndW56aXAsXG4gIGd1bnppcFN5bmM6IGd1bnppcFN5bmMsXG4gIGluZmxhdGVSYXc6IGluZmxhdGVSYXcsXG4gIGluZmxhdGVSYXdTeW5jOiBpbmZsYXRlUmF3U3luYyxcbiAgRGVmbGF0ZTogRGVmbGF0ZSxcbiAgSW5mbGF0ZTogSW5mbGF0ZSxcbiAgR3ppcDogR3ppcCxcbiAgR3VuemlwOiBHdW56aXAsXG4gIERlZmxhdGVSYXc6IERlZmxhdGVSYXcsXG4gIEluZmxhdGVSYXc6IEluZmxhdGVSYXcsXG4gIFVuemlwOiBVbnppcCxcbiAgWmxpYjogWmxpYlxufTtcblxudmFyIF9wb2x5ZmlsbE5vZGVfemxpYiQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdERlZmxhdGU6IERlZmxhdGUsXG5cdERlZmxhdGVSYXc6IERlZmxhdGVSYXcsXG5cdEd1bnppcDogR3VuemlwLFxuXHRHemlwOiBHemlwLFxuXHRJbmZsYXRlOiBJbmZsYXRlLFxuXHRJbmZsYXRlUmF3OiBJbmZsYXRlUmF3LFxuXHRVbnppcDogVW56aXAsXG5cdFpsaWI6IFpsaWIsXG5cdGNvZGVzOiBjb2Rlcyxcblx0Y3JlYXRlRGVmbGF0ZTogY3JlYXRlRGVmbGF0ZSxcblx0Y3JlYXRlRGVmbGF0ZVJhdzogY3JlYXRlRGVmbGF0ZVJhdyxcblx0Y3JlYXRlR3VuemlwOiBjcmVhdGVHdW56aXAsXG5cdGNyZWF0ZUd6aXA6IGNyZWF0ZUd6aXAsXG5cdGNyZWF0ZUluZmxhdGU6IGNyZWF0ZUluZmxhdGUsXG5cdGNyZWF0ZUluZmxhdGVSYXc6IGNyZWF0ZUluZmxhdGVSYXcsXG5cdGNyZWF0ZVVuemlwOiBjcmVhdGVVbnppcCxcblx0ZGVmYXVsdDogX3BvbHlmaWxsTm9kZV96bGliLFxuXHRkZWZsYXRlOiBkZWZsYXRlLFxuXHRkZWZsYXRlUmF3OiBkZWZsYXRlUmF3LFxuXHRkZWZsYXRlUmF3U3luYzogZGVmbGF0ZVJhd1N5bmMsXG5cdGRlZmxhdGVTeW5jOiBkZWZsYXRlU3luYyxcblx0Z3VuemlwOiBndW56aXAsXG5cdGd1bnppcFN5bmM6IGd1bnppcFN5bmMsXG5cdGd6aXA6IGd6aXAsXG5cdGd6aXBTeW5jOiBnemlwU3luYyxcblx0aW5mbGF0ZTogaW5mbGF0ZSxcblx0aW5mbGF0ZVJhdzogaW5mbGF0ZVJhdyxcblx0aW5mbGF0ZVJhd1N5bmM6IGluZmxhdGVSYXdTeW5jLFxuXHRpbmZsYXRlU3luYzogaW5mbGF0ZVN5bmMsXG5cdHVuemlwOiB1bnppcCxcblx0dW56aXBTeW5jOiB1bnppcFN5bmNcbn0pO1xuXG52YXIgcmVxdWlyZSQkMCA9IC8qQF9fUFVSRV9fKi9nZXRBdWdtZW50ZWROYW1lc3BhY2UoX3BvbHlmaWxsTm9kZV96bGliJDEpO1xuXG52YXIgZGVmbGF0ZXI7XG52YXIgaGFzUmVxdWlyZWREZWZsYXRlcjtcblxuZnVuY3Rpb24gcmVxdWlyZURlZmxhdGVyICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkRGVmbGF0ZXIpIHJldHVybiBkZWZsYXRlcjtcblx0aGFzUmVxdWlyZWREZWZsYXRlciA9IDE7XG5cdGRlZmxhdGVyID0gZnVuY3Rpb24gKC8qQnVmZmVyKi8gaW5idWYpIHtcblx0ICAgIHZhciB6bGliID0gcmVxdWlyZSQkMDtcblxuXHQgICAgdmFyIG9wdHMgPSB7IGNodW5rU2l6ZTogKHBhcnNlSW50KGluYnVmLmxlbmd0aCAvIDEwMjQpICsgMSkgKiAxMDI0IH07XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgZGVmbGF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gemxpYi5kZWZsYXRlUmF3U3luYyhpbmJ1Ziwgb3B0cyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlZmxhdGVBc3luYzogZnVuY3Rpb24gKC8qRnVuY3Rpb24qLyBjYWxsYmFjaykge1xuXHQgICAgICAgICAgICB2YXIgdG1wID0gemxpYi5jcmVhdGVEZWZsYXRlUmF3KG9wdHMpLFxuXHQgICAgICAgICAgICAgICAgcGFydHMgPSBbXSxcblx0ICAgICAgICAgICAgICAgIHRvdGFsID0gMDtcblx0ICAgICAgICAgICAgdG1wLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAgICAgcGFydHMucHVzaChkYXRhKTtcblx0ICAgICAgICAgICAgICAgIHRvdGFsICs9IGRhdGEubGVuZ3RoO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdG1wLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2ModG90YWwpLFxuXHQgICAgICAgICAgICAgICAgICAgIHdyaXR0ZW4gPSAwO1xuXHQgICAgICAgICAgICAgICAgYnVmLmZpbGwoMCk7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJ0LmNvcHkoYnVmLCB3cml0dGVuKTtcblx0ICAgICAgICAgICAgICAgICAgICB3cml0dGVuICs9IHBhcnQubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soYnVmKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRtcC5lbmQoaW5idWYpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdH07XG5cdHJldHVybiBkZWZsYXRlcjtcbn1cblxudmFyIGluZmxhdGVyO1xudmFyIGhhc1JlcXVpcmVkSW5mbGF0ZXI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbmZsYXRlciAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEluZmxhdGVyKSByZXR1cm4gaW5mbGF0ZXI7XG5cdGhhc1JlcXVpcmVkSW5mbGF0ZXIgPSAxO1xuXHRjb25zdCB2ZXJzaW9uID0gKyhwcm9jZXNzLnZlcnNpb25zID8gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlIDogXCJcIikuc3BsaXQoXCIuXCIpWzBdIHx8IDA7XG5cblx0aW5mbGF0ZXIgPSBmdW5jdGlvbiAoLypCdWZmZXIqLyBpbmJ1ZiwgLypudW1iZXIqLyBleHBlY3RlZExlbmd0aCkge1xuXHQgICAgdmFyIHpsaWIgPSByZXF1aXJlJCQwO1xuXHQgICAgY29uc3Qgb3B0aW9uID0gdmVyc2lvbiA+PSAxNSAmJiBleHBlY3RlZExlbmd0aCA+IDAgPyB7IG1heE91dHB1dExlbmd0aDogZXhwZWN0ZWRMZW5ndGggfSA6IHt9O1xuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGluZmxhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHpsaWIuaW5mbGF0ZVJhd1N5bmMoaW5idWYsIG9wdGlvbik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGluZmxhdGVBc3luYzogZnVuY3Rpb24gKC8qRnVuY3Rpb24qLyBjYWxsYmFjaykge1xuXHQgICAgICAgICAgICB2YXIgdG1wID0gemxpYi5jcmVhdGVJbmZsYXRlUmF3KG9wdGlvbiksXG5cdCAgICAgICAgICAgICAgICBwYXJ0cyA9IFtdLFxuXHQgICAgICAgICAgICAgICAgdG90YWwgPSAwO1xuXHQgICAgICAgICAgICB0bXAub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGRhdGEpO1xuXHQgICAgICAgICAgICAgICAgdG90YWwgKz0gZGF0YS5sZW5ndGg7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0bXAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyh0b3RhbCksXG5cdCAgICAgICAgICAgICAgICAgICAgd3JpdHRlbiA9IDA7XG5cdCAgICAgICAgICAgICAgICBidWYuZmlsbCgwKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIHBhcnQuY29weShidWYsIHdyaXR0ZW4pO1xuXHQgICAgICAgICAgICAgICAgICAgIHdyaXR0ZW4gKz0gcGFydC5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhidWYpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdG1wLmVuZChpbmJ1Zik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0fTtcblx0cmV0dXJuIGluZmxhdGVyO1xufVxuXG52YXIgemlwY3J5cHRvO1xudmFyIGhhc1JlcXVpcmVkWmlwY3J5cHRvO1xuXG5mdW5jdGlvbiByZXF1aXJlWmlwY3J5cHRvICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkWmlwY3J5cHRvKSByZXR1cm4gemlwY3J5cHRvO1xuXHRoYXNSZXF1aXJlZFppcGNyeXB0byA9IDE7XG5cblx0Ly8gbm9kZSBjcnlwdCwgd2UgdXNlIGl0IGZvciBnZW5lcmF0ZSBzYWx0XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcblx0Y29uc3QgeyByYW5kb21GaWxsU3luYyB9ID0gcmVxdWlyZSQkMCQyO1xuXHRjb25zdCBFcnJvcnMgPSByZXF1aXJlRXJyb3JzKCk7XG5cblx0Ly8gZ2VuZXJhdGUgQ1JDMzIgbG9va3VwIHRhYmxlXG5cdGNvbnN0IGNyY3RhYmxlID0gbmV3IFVpbnQzMkFycmF5KDI1NikubWFwKCh0LCBjcmMpID0+IHtcblx0ICAgIGZvciAobGV0IGogPSAwOyBqIDwgODsgaisrKSB7XG5cdCAgICAgICAgaWYgKDAgIT09IChjcmMgJiAxKSkge1xuXHQgICAgICAgICAgICBjcmMgPSAoY3JjID4+PiAxKSBeIDB4ZWRiODgzMjA7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgY3JjID4+Pj0gMTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JjID4+PiAwO1xuXHR9KTtcblxuXHQvLyBDLXN0eWxlIHVJbnQzMiBNdWx0aXBseSAoZGlzY2FyZHMgaGlnaGVyIGJpdHMsIHdoZW4gSlMgbXVsdGlwbHkgZGlzY2FyZHMgbG93ZXIgYml0cylcblx0Y29uc3QgdU11bCA9IChhLCBiKSA9PiBNYXRoLmltdWwoYSwgYikgPj4+IDA7XG5cblx0Ly8gY3JjMzIgYnl0ZSBzaW5nbGUgdXBkYXRlIChhY3R1YWxseSBzYW1lIGZ1bmN0aW9uIGlzIHBhcnQgb2YgdXRpbHMuY3JjMzIgZnVuY3Rpb24gOikgKVxuXHRjb25zdCBjcmMzMnVwZGF0ZSA9IChwQ3JjMzIsIGJ2YWwpID0+IHtcblx0ICAgIHJldHVybiBjcmN0YWJsZVsocENyYzMyIF4gYnZhbCkgJiAweGZmXSBeIChwQ3JjMzIgPj4+IDgpO1xuXHR9O1xuXG5cdC8vIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIHNhbHQgZm9yIGVuY3J5dGlvbiBoZWFkZXJcblx0Y29uc3QgZ2VuU2FsdCA9ICgpID0+IHtcblx0ICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByYW5kb21GaWxsU3luYykge1xuXHQgICAgICAgIHJldHVybiByYW5kb21GaWxsU3luYyhCdWZmZXIuYWxsb2MoMTIpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gZmFsbGJhY2sgaWYgZnVuY3Rpb24gaXMgbm90IGRlZmluZWRcblx0ICAgICAgICByZXR1cm4gZ2VuU2FsdC5ub2RlKCk7XG5cdCAgICB9XG5cdH07XG5cblx0Ly8gc2FsdCBnZW5lcmF0aW9uIHdpdGggbm9kZSByYW5kb20gZnVuY3Rpb24gKG1haW5seSBhcyBmYWxsYmFjaylcblx0Z2VuU2FsdC5ub2RlID0gKCkgPT4ge1xuXHQgICAgY29uc3Qgc2FsdCA9IEJ1ZmZlci5hbGxvYygxMik7XG5cdCAgICBjb25zdCBsZW4gPSBzYWx0Lmxlbmd0aDtcblx0ICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHNhbHRbaV0gPSAoTWF0aC5yYW5kb20oKSAqIDI1NikgJiAweGZmO1xuXHQgICAgcmV0dXJuIHNhbHQ7XG5cdH07XG5cblx0Ly8gZ2VuZXJhbCBjb25maWdcblx0Y29uc3QgY29uZmlnID0ge1xuXHQgICAgZ2VuU2FsdFxuXHR9O1xuXG5cdC8vIENsYXNzIEluaXRrZXlzIGhhbmRsZXMgc2FtZSBiYXNpYyBvcHMgd2l0aCBrZXlzXG5cdGZ1bmN0aW9uIEluaXRrZXlzKHB3KSB7XG5cdCAgICBjb25zdCBwYXNzID0gQnVmZmVyLmlzQnVmZmVyKHB3KSA/IHB3IDogQnVmZmVyLmZyb20ocHcpO1xuXHQgICAgdGhpcy5rZXlzID0gbmV3IFVpbnQzMkFycmF5KFsweDEyMzQ1Njc4LCAweDIzNDU2Nzg5LCAweDM0NTY3ODkwXSk7XG5cdCAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhc3MubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLnVwZGF0ZUtleXMocGFzc1tpXSk7XG5cdCAgICB9XG5cdH1cblxuXHRJbml0a2V5cy5wcm90b3R5cGUudXBkYXRlS2V5cyA9IGZ1bmN0aW9uIChieXRlVmFsdWUpIHtcblx0ICAgIGNvbnN0IGtleXMgPSB0aGlzLmtleXM7XG5cdCAgICBrZXlzWzBdID0gY3JjMzJ1cGRhdGUoa2V5c1swXSwgYnl0ZVZhbHVlKTtcblx0ICAgIGtleXNbMV0gKz0ga2V5c1swXSAmIDB4ZmY7XG5cdCAgICBrZXlzWzFdID0gdU11bChrZXlzWzFdLCAxMzQ3NzU4MTMpICsgMTtcblx0ICAgIGtleXNbMl0gPSBjcmMzMnVwZGF0ZShrZXlzWzJdLCBrZXlzWzFdID4+PiAyNCk7XG5cdCAgICByZXR1cm4gYnl0ZVZhbHVlO1xuXHR9O1xuXG5cdEluaXRrZXlzLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgY29uc3QgayA9ICh0aGlzLmtleXNbMl0gfCAyKSA+Pj4gMDsgLy8ga2V5XG5cdCAgICByZXR1cm4gKHVNdWwoaywgayBeIDEpID4+IDgpICYgMHhmZjsgLy8gZGVjb2RlXG5cdH07XG5cblx0ZnVuY3Rpb24gbWFrZV9kZWNyeXB0ZXIoLypCdWZmZXIqLyBwd2QpIHtcblx0ICAgIC8vIDEuIFN0YWdlIGluaXRpYWxpemUga2V5XG5cdCAgICBjb25zdCBrZXlzID0gbmV3IEluaXRrZXlzKHB3ZCk7XG5cblx0ICAgIC8vIHJldHVybiBkZWNyeXB0ZXIgZnVuY3Rpb25cblx0ICAgIHJldHVybiBmdW5jdGlvbiAoLypCdWZmZXIqLyBkYXRhKSB7XG5cdCAgICAgICAgLy8gcmVzdWx0IC0gd2UgY3JlYXRlIG5ldyBCdWZmZXIgZm9yIHJlc3VsdHNcblx0ICAgICAgICBjb25zdCByZXN1bHQgPSBCdWZmZXIuYWxsb2MoZGF0YS5sZW5ndGgpO1xuXHQgICAgICAgIGxldCBwb3MgPSAwO1xuXHQgICAgICAgIC8vIHByb2Nlc3MgaW5wdXQgZGF0YVxuXHQgICAgICAgIGZvciAobGV0IGMgb2YgZGF0YSkge1xuXHQgICAgICAgICAgICAvL2MgXj0ga2V5cy5uZXh0KCk7XG5cdCAgICAgICAgICAgIC8vcmVzdWx0W3BvcysrXSA9IGM7IC8vIGRlY29kZSAmIFNhdmUgVmFsdWVcblx0ICAgICAgICAgICAgcmVzdWx0W3BvcysrXSA9IGtleXMudXBkYXRlS2V5cyhjIF4ga2V5cy5uZXh0KCkpOyAvLyB1cGRhdGUga2V5cyB3aXRoIGRlY29kZWQgYnl0ZVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VfZW5jcnlwdGVyKC8qQnVmZmVyKi8gcHdkKSB7XG5cdCAgICAvLyAxLiBTdGFnZSBpbml0aWFsaXplIGtleVxuXHQgICAgY29uc3Qga2V5cyA9IG5ldyBJbml0a2V5cyhwd2QpO1xuXG5cdCAgICAvLyByZXR1cm4gZW5jcnlwdGluZyBmdW5jdGlvbiwgcmVzdWx0IGFuZCBwb3MgaXMgaGVyZSBzbyB3ZSBkb250IGhhdmUgdG8gbWVyZ2UgYnVmZmVycyBsYXRlclxuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICgvKkJ1ZmZlciovIGRhdGEsIC8qQnVmZmVyKi8gcmVzdWx0LCAvKiBOdW1iZXIgKi8gcG9zID0gMCkge1xuXHQgICAgICAgIC8vIHJlc3VsdCAtIHdlIGNyZWF0ZSBuZXcgQnVmZmVyIGZvciByZXN1bHRzXG5cdCAgICAgICAgaWYgKCFyZXN1bHQpIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhkYXRhLmxlbmd0aCk7XG5cdCAgICAgICAgLy8gcHJvY2VzcyBpbnB1dCBkYXRhXG5cdCAgICAgICAgZm9yIChsZXQgYyBvZiBkYXRhKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IGsgPSBrZXlzLm5leHQoKTsgLy8gc2F2ZSBrZXkgYnl0ZVxuXHQgICAgICAgICAgICByZXN1bHRbcG9zKytdID0gYyBeIGs7IC8vIHNhdmUgdmFsXG5cdCAgICAgICAgICAgIGtleXMudXBkYXRlS2V5cyhjKTsgLy8gdXBkYXRlIGtleXMgd2l0aCBkZWNvZGVkIGJ5dGVcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNyeXB0KC8qQnVmZmVyKi8gZGF0YSwgLypPYmplY3QqLyBoZWFkZXIsIC8qU3RyaW5nLCBCdWZmZXIqLyBwd2QpIHtcblx0ICAgIGlmICghZGF0YSB8fCAhQnVmZmVyLmlzQnVmZmVyKGRhdGEpIHx8IGRhdGEubGVuZ3RoIDwgMTIpIHtcblx0ICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuXHQgICAgfVxuXG5cdCAgICAvLyAxLiBXZSBJbml0aWFsaXplIGFuZCBnZW5lcmF0ZSBkZWNyeXB0aW5nIGZ1bmN0aW9uXG5cdCAgICBjb25zdCBkZWNyeXB0ZXIgPSBtYWtlX2RlY3J5cHRlcihwd2QpO1xuXG5cdCAgICAvLyAyLiBkZWNyeXB0IHNhbHQgd2hhdCBpcyBhbHdheXMgMTIgYnl0ZXMgYW5kIGlzIGEgcGFydCBvZiBmaWxlIGNvbnRlbnRcblx0ICAgIGNvbnN0IHNhbHQgPSBkZWNyeXB0ZXIoZGF0YS5zbGljZSgwLCAxMikpO1xuXG5cdCAgICAvLyBpZiBiaXQgMyAoMHgwOCkgb2YgdGhlIGdlbmVyYWwtcHVycG9zZSBmbGFncyBmaWVsZCBpcyBzZXQsIGNoZWNrIHNhbHRbMTFdIHdpdGggdGhlIGhpZ2ggYnl0ZSBvZiB0aGUgaGVhZGVyIHRpbWVcblx0ICAgIC8vIDIgYnl0ZSBkYXRhIGJsb2NrIChhcyBwZXIgSW5mby1aaXAgc3BlYyksIG90aGVyd2lzZSBjaGVjayB3aXRoIHRoZSBoaWdoIGJ5dGUgb2YgdGhlIGhlYWRlciBlbnRyeVxuXHQgICAgY29uc3QgdmVyaWZ5Qnl0ZSA9IChoZWFkZXIuZmxhZ3MgJiAweDgpID09PSAweDggPyBoZWFkZXIudGltZUhpZ2hCeXRlIDogaGVhZGVyLmNyYyA+Pj4gMjQ7XG5cblx0ICAgIC8vMy4gZG9lcyBwYXNzd29yZCBtZWV0IGV4cGVjdGF0aW9uc1xuXHQgICAgaWYgKHNhbHRbMTFdICE9PSB2ZXJpZnlCeXRlKSB7XG5cdCAgICAgICAgdGhyb3cgRXJyb3JzLldST05HX1BBU1NXT1JEKCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIDQuIGRlY29kZSBjb250ZW50XG5cdCAgICByZXR1cm4gZGVjcnlwdGVyKGRhdGEuc2xpY2UoMTIpKTtcblx0fVxuXG5cdC8vIGxldHMgYWRkIHdheSB0byBwb3B1bGF0ZSBzYWx0LCBOT1QgUkVDT01NRU5ERUQgZm9yIHByb2R1Y3Rpb24gYnV0IG1heWJlIHVzZWZ1bCBmb3IgdGVzdGluZyBnZW5lcmFsIGZ1bmN0aW9uYWxpdHlcblx0ZnVuY3Rpb24gX3NhbHRlcihkYXRhKSB7XG5cdCAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpICYmIGRhdGEubGVuZ3RoID49IDEyKSB7XG5cdCAgICAgICAgLy8gYmUgYXdhcmUgLSBjdXJyZW50bHkgc2FsdGluZyBidWZmZXIgZGF0YSBpcyBtb2RpZmllZFxuXHQgICAgICAgIGNvbmZpZy5nZW5TYWx0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZGF0YS5zbGljZSgwLCAxMik7XG5cdCAgICAgICAgfTtcblx0ICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gXCJub2RlXCIpIHtcblx0ICAgICAgICAvLyB0ZXN0IHNhbHQgZ2VuZXJhdGlvbiB3aXRoIG5vZGUgcmFuZG9tIGZ1bmN0aW9uXG5cdCAgICAgICAgY29uZmlnLmdlblNhbHQgPSBnZW5TYWx0Lm5vZGU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vIGlmIHZhbHVlIGlzIG5vdCBhY2NlcHRhYmxlIGNvbmZpZyBnZXRzIHJlc2V0LlxuXHQgICAgICAgIGNvbmZpZy5nZW5TYWx0ID0gZ2VuU2FsdDtcblx0ICAgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGVuY3J5cHQoLypCdWZmZXIqLyBkYXRhLCAvKk9iamVjdCovIGhlYWRlciwgLypTdHJpbmcsIEJ1ZmZlciovIHB3ZCwgLypCb29sZWFuKi8gb2xkbGlrZSA9IGZhbHNlKSB7XG5cdCAgICAvLyAxLiB0ZXN0IGRhdGEgaWYgZGF0YSBpcyBub3QgQnVmZmVyIHdlIG1ha2UgYnVmZmVyIGZyb20gaXRcblx0ICAgIGlmIChkYXRhID09IG51bGwpIGRhdGEgPSBCdWZmZXIuYWxsb2MoMCk7XG5cdCAgICAvLyBpZiBkYXRhIGlzIG5vdCBidWZmZXIgYmUgbWFrZSBidWZmZXIgZnJvbSBpdFxuXHQgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLnRvU3RyaW5nKCkpO1xuXG5cdCAgICAvLyAyLiBXZSBJbml0aWFsaXplIGFuZCBnZW5lcmF0ZSBlbmNyeXB0aW5nIGZ1bmN0aW9uXG5cdCAgICBjb25zdCBlbmNyeXB0ZXIgPSBtYWtlX2VuY3J5cHRlcihwd2QpO1xuXG5cdCAgICAvLyAzLiBnZW5lcmF0ZSBzYWx0ICgxMi1ieXRlcyBvZiByYW5kb20gZGF0YSlcblx0ICAgIGNvbnN0IHNhbHQgPSBjb25maWcuZ2VuU2FsdCgpO1xuXHQgICAgc2FsdFsxMV0gPSAoaGVhZGVyLmNyYyA+Pj4gMjQpICYgMHhmZjtcblxuXHQgICAgLy8gb2xkIGltcGxlbWVudGF0aW9ucyAoYmVmb3JlIFBLWmlwIDIuMDRnKSB1c2VkIHR3byBieXRlIGNoZWNrXG5cdCAgICBpZiAob2xkbGlrZSkgc2FsdFsxMF0gPSAoaGVhZGVyLmNyYyA+Pj4gMTYpICYgMHhmZjtcblxuXHQgICAgLy8gNC4gY3JlYXRlIG91dHB1dFxuXHQgICAgY29uc3QgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKGRhdGEubGVuZ3RoICsgMTIpO1xuXHQgICAgZW5jcnlwdGVyKHNhbHQsIHJlc3VsdCk7XG5cblx0ICAgIC8vIGZpbmFsbHkgZW5jb2RlIGNvbnRlbnRcblx0ICAgIHJldHVybiBlbmNyeXB0ZXIoZGF0YSwgcmVzdWx0LCAxMik7XG5cdH1cblxuXHR6aXBjcnlwdG8gPSB7IGRlY3J5cHQsIGVuY3J5cHQsIF9zYWx0ZXIgfTtcblx0cmV0dXJuIHppcGNyeXB0bztcbn1cblxudmFyIGhhc1JlcXVpcmVkTWV0aG9kcztcblxuZnVuY3Rpb24gcmVxdWlyZU1ldGhvZHMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRNZXRob2RzKSByZXR1cm4gbWV0aG9kcztcblx0aGFzUmVxdWlyZWRNZXRob2RzID0gMTtcblx0bWV0aG9kcy5EZWZsYXRlciA9IHJlcXVpcmVEZWZsYXRlcigpO1xuXHRtZXRob2RzLkluZmxhdGVyID0gcmVxdWlyZUluZmxhdGVyKCk7XG5cdG1ldGhvZHMuWmlwQ3J5cHRvID0gcmVxdWlyZVppcGNyeXB0bygpO1xuXHRyZXR1cm4gbWV0aG9kcztcbn1cblxudmFyIHppcEVudHJ5O1xudmFyIGhhc1JlcXVpcmVkWmlwRW50cnk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVaaXBFbnRyeSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFppcEVudHJ5KSByZXR1cm4gemlwRW50cnk7XG5cdGhhc1JlcXVpcmVkWmlwRW50cnkgPSAxO1xuXHR2YXIgVXRpbHMgPSByZXF1aXJlVXRpbCgpLFxuXHQgICAgSGVhZGVycyA9IHJlcXVpcmVIZWFkZXJzKCksXG5cdCAgICBDb25zdGFudHMgPSBVdGlscy5Db25zdGFudHMsXG5cdCAgICBNZXRob2RzID0gcmVxdWlyZU1ldGhvZHMoKTtcblxuXHR6aXBFbnRyeSA9IGZ1bmN0aW9uICgvKiogb2JqZWN0ICovIG9wdGlvbnMsIC8qQnVmZmVyKi8gaW5wdXQpIHtcblx0ICAgIHZhciBfY2VudHJhbEhlYWRlciA9IG5ldyBIZWFkZXJzLkVudHJ5SGVhZGVyKCksXG5cdCAgICAgICAgX2VudHJ5TmFtZSA9IEJ1ZmZlci5hbGxvYygwKSxcblx0ICAgICAgICBfY29tbWVudCA9IEJ1ZmZlci5hbGxvYygwKSxcblx0ICAgICAgICBfaXNEaXJlY3RvcnkgPSBmYWxzZSxcblx0ICAgICAgICB1bmNvbXByZXNzZWREYXRhID0gbnVsbCxcblx0ICAgICAgICBfZXh0cmEgPSBCdWZmZXIuYWxsb2MoMCksXG5cdCAgICAgICAgX2V4dHJhbG9jYWwgPSBCdWZmZXIuYWxsb2MoMCksXG5cdCAgICAgICAgX2VmcyA9IHRydWU7XG5cblx0ICAgIC8vIGFzc2lnbiBvcHRpb25zXG5cdCAgICBjb25zdCBvcHRzID0gb3B0aW9ucztcblxuXHQgICAgY29uc3QgZGVjb2RlciA9IHR5cGVvZiBvcHRzLmRlY29kZXIgPT09IFwib2JqZWN0XCIgPyBvcHRzLmRlY29kZXIgOiBVdGlscy5kZWNvZGVyO1xuXHQgICAgX2VmcyA9IGRlY29kZXIuaGFzT3duUHJvcGVydHkoXCJlZnNcIikgPyBkZWNvZGVyLmVmcyA6IGZhbHNlO1xuXG5cdCAgICBmdW5jdGlvbiBnZXRDb21wcmVzc2VkRGF0YUZyb21aaXAoKSB7XG5cdCAgICAgICAgLy9pZiAoIWlucHV0IHx8ICFCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG5cdCAgICAgICAgaWYgKCFpbnB1dCB8fCAhKGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX2V4dHJhbG9jYWwgPSBfY2VudHJhbEhlYWRlci5sb2FkTG9jYWxIZWFkZXJGcm9tQmluYXJ5KGlucHV0KTtcblx0ICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoX2NlbnRyYWxIZWFkZXIucmVhbERhdGFPZmZzZXQsIF9jZW50cmFsSGVhZGVyLnJlYWxEYXRhT2Zmc2V0ICsgX2NlbnRyYWxIZWFkZXIuY29tcHJlc3NlZFNpemUpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjcmMzMk9LKGRhdGEpIHtcblx0ICAgICAgICAvLyBpZiBiaXQgMyAoMHgwOCkgb2YgdGhlIGdlbmVyYWwtcHVycG9zZSBmbGFncyBmaWVsZCBpcyBzZXQsIHRoZW4gdGhlIENSQy0zMiBhbmQgZmlsZSBzaXplcyBhcmUgbm90IGtub3duIHdoZW4gdGhlIGxvY2FsIGhlYWRlciBpcyB3cml0dGVuXG5cdCAgICAgICAgaWYgKCFfY2VudHJhbEhlYWRlci5mbGFnc19kZXNjKSB7XG5cdCAgICAgICAgICAgIGlmIChVdGlscy5jcmMzMihkYXRhKSAhPT0gX2NlbnRyYWxIZWFkZXIubG9jYWxIZWFkZXIuY3JjKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0ge307XG5cdCAgICAgICAgICAgIGNvbnN0IGRhdGFFbmRPZmZzZXQgPSBfY2VudHJhbEhlYWRlci5yZWFsRGF0YU9mZnNldCArIF9jZW50cmFsSGVhZGVyLmNvbXByZXNzZWRTaXplO1xuXHQgICAgICAgICAgICAvLyBubyBkZXNjcmlwdG9yIGFmdGVyIGNvbXByZXNzZWQgZGF0YSwgaW5zdGVhZCBuZXcgbG9jYWwgaGVhZGVyXG5cdCAgICAgICAgICAgIGlmIChpbnB1dC5yZWFkVUludDMyTEUoZGF0YUVuZE9mZnNldCkgPT0gQ29uc3RhbnRzLkxPQ1NJRyB8fCBpbnB1dC5yZWFkVUludDMyTEUoZGF0YUVuZE9mZnNldCkgPT0gQ29uc3RhbnRzLkNFTlNJRykge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLkRFU0NSSVBUT1JfTk9UX0VYSVNUKCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBnZXQgZGVjcmlwdG9yIGRhdGFcblx0ICAgICAgICAgICAgaWYgKGlucHV0LnJlYWRVSW50MzJMRShkYXRhRW5kT2Zmc2V0KSA9PSBDb25zdGFudHMuRVhUU0lHKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBkZXNjcmlwdG9yIHdpdGggc2lnbmF0dXJlXG5cdCAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNyYyA9IGlucHV0LnJlYWRVSW50MzJMRShkYXRhRW5kT2Zmc2V0ICsgQ29uc3RhbnRzLkVYVENSQyk7XG5cdCAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbXByZXNzZWRTaXplID0gaW5wdXQucmVhZFVJbnQzMkxFKGRhdGFFbmRPZmZzZXQgKyBDb25zdGFudHMuRVhUU0laKTtcblx0ICAgICAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2l6ZSA9IGlucHV0LnJlYWRVSW50MzJMRShkYXRhRW5kT2Zmc2V0ICsgQ29uc3RhbnRzLkVYVExFTik7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQucmVhZFVJbnQxNkxFKGRhdGFFbmRPZmZzZXQgKyAxMikgPT09IDB4NGI1MCkge1xuXHQgICAgICAgICAgICAgICAgLy8gZGVzY3JpcHRvciB3aXRob3V0IHNpZ25hdHVyZSAod2UgY2hlY2sgaXMgbmV3IGhlYWRlciBzdGFydGluZyB3aGVyZSB3ZSBleHBlY3QpXG5cdCAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNyYyA9IGlucHV0LnJlYWRVSW50MzJMRShkYXRhRW5kT2Zmc2V0ICsgQ29uc3RhbnRzLkVYVENSQyAtIDQpO1xuXHQgICAgICAgICAgICAgICAgZGVzY3JpcHRvci5jb21wcmVzc2VkU2l6ZSA9IGlucHV0LnJlYWRVSW50MzJMRShkYXRhRW5kT2Zmc2V0ICsgQ29uc3RhbnRzLkVYVFNJWiAtIDQpO1xuXHQgICAgICAgICAgICAgICAgZGVzY3JpcHRvci5zaXplID0gaW5wdXQucmVhZFVJbnQzMkxFKGRhdGFFbmRPZmZzZXQgKyBDb25zdGFudHMuRVhUTEVOIC0gNCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuREVTQ1JJUFRPUl9VTktOT1dOKCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBjaGVjayBkYXRhIGludGVncml0eVxuXHQgICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5jb21wcmVzc2VkU2l6ZSAhPT0gX2NlbnRyYWxIZWFkZXIuY29tcHJlc3NlZFNpemUgfHwgZGVzY3JpcHRvci5zaXplICE9PSBfY2VudHJhbEhlYWRlci5zaXplIHx8IGRlc2NyaXB0b3IuY3JjICE9PSBfY2VudHJhbEhlYWRlci5jcmMpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5ERVNDUklQVE9SX0ZBVUxUWSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChVdGlscy5jcmMzMihkYXRhKSAhPT0gZGVzY3JpcHRvci5jcmMpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEBUT0RPOiB6aXA2NCBiaXQgZGVzY3JpcHRvciBmaWVsZHNcblx0ICAgICAgICAgICAgLy8gaWYgYml0IDMgaXMgc2V0IGFuZCBhbnkgdmFsdWUgaW4gbG9jYWwgaGVhZGVyIFwiemlwNjQgRXh0ZW5kZWQgaW5mb3JtYXRpb25cIiBleHRyYSBmaWVsZCBhcmUgc2V0IDAgKHBsYWNlIGhvbGRlcilcblx0ICAgICAgICAgICAgLy8gdGhlbiA2NC1iaXQgZGVzY3JpcHRvciBmb3JtYXQgaXMgdXNlZCBpbnN0ZWFkIG9mIDMyLWJpdFxuXHQgICAgICAgICAgICAvLyBjZW50cmFsIGhlYWRlciAtIFwiemlwNjQgRXh0ZW5kZWQgaW5mb3JtYXRpb25cIiBleHRyYSBmaWVsZCBzaG91bGQgc3RvcmUgcmVhbCB2YWx1ZXMgYW5kIG5vdCBwbGFjZSBob2xkZXJzXG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBkZWNvbXByZXNzKC8qQm9vbGVhbiovIGFzeW5jLCAvKkZ1bmN0aW9uKi8gY2FsbGJhY2ssIC8qU3RyaW5nLCBCdWZmZXIqLyBwYXNzKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgYXN5bmMgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgcGFzcyA9IGFzeW5jO1xuXHQgICAgICAgICAgICBhc3luYyA9IHZvaWQgMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKF9pc0RpcmVjdG9yeSkge1xuXHQgICAgICAgICAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgICAgIGNhbGxiYWNrKEJ1ZmZlci5hbGxvYygwKSwgVXRpbHMuRXJyb3JzLkRJUkVDVE9SWV9DT05URU5UX0VSUk9SKCkpOyAvL3NpIGFkZGVkIGVycm9yLlxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGNvbXByZXNzZWREYXRhID0gZ2V0Q29tcHJlc3NlZERhdGFGcm9tWmlwKCk7XG5cblx0ICAgICAgICBpZiAoY29tcHJlc3NlZERhdGEubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbGUgaXMgZW1wdHksIG5vdGhpbmcgdG8gZGVjb21wcmVzcy5cblx0ICAgICAgICAgICAgaWYgKGFzeW5jICYmIGNhbGxiYWNrKSBjYWxsYmFjayhjb21wcmVzc2VkRGF0YSk7XG5cdCAgICAgICAgICAgIHJldHVybiBjb21wcmVzc2VkRGF0YTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoX2NlbnRyYWxIZWFkZXIuZW5jcnlwdGVkKSB7XG5cdCAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2YgcGFzcyAmJiAhQnVmZmVyLmlzQnVmZmVyKHBhc3MpKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuSU5WQUxJRF9QQVNTX1BBUkFNKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY29tcHJlc3NlZERhdGEgPSBNZXRob2RzLlppcENyeXB0by5kZWNyeXB0KGNvbXByZXNzZWREYXRhLCBfY2VudHJhbEhlYWRlciwgcGFzcyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGRhdGEgPSBCdWZmZXIuYWxsb2MoX2NlbnRyYWxIZWFkZXIuc2l6ZSk7XG5cblx0ICAgICAgICBzd2l0Y2ggKF9jZW50cmFsSGVhZGVyLm1ldGhvZCkge1xuXHQgICAgICAgICAgICBjYXNlIFV0aWxzLkNvbnN0YW50cy5TVE9SRUQ6XG5cdCAgICAgICAgICAgICAgICBjb21wcmVzc2VkRGF0YS5jb3B5KGRhdGEpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFjcmMzMk9LKGRhdGEpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFzeW5jICYmIGNhbGxiYWNrKSBjYWxsYmFjayhkYXRhLCBVdGlscy5FcnJvcnMuQkFEX0NSQygpKTsgLy9zaSBhZGRlZCBlcnJvclxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5CQURfQ1JDKCk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vc2kgYWRkZWQgb3RoZXJ3aXNlIGRpZCBub3Qgc2VlbSB0byByZXR1cm4gZGF0YS5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIGNhbGxiYWNrKGRhdGEpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXNlIFV0aWxzLkNvbnN0YW50cy5ERUZMQVRFRDpcblx0ICAgICAgICAgICAgICAgIHZhciBpbmZsYXRlciA9IG5ldyBNZXRob2RzLkluZmxhdGVyKGNvbXByZXNzZWREYXRhLCBfY2VudHJhbEhlYWRlci5zaXplKTtcblx0ICAgICAgICAgICAgICAgIGlmICghYXN5bmMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbmZsYXRlci5pbmZsYXRlKGRhdGEpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb3B5KGRhdGEsIDApO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghY3JjMzJPSyhkYXRhKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuQkFEX0NSQyhgXCIke2RlY29kZXIuZGVjb2RlKF9lbnRyeU5hbWUpfVwiYCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbmZsYXRlci5pbmZsYXRlQXN5bmMoZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29weShyZXN1bHQsIDApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3JjMzJPSyhyZXN1bHQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0LCBVdGlscy5FcnJvcnMuQkFEX0NSQygpKTsgLy9zaSBhZGRlZCBlcnJvclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGlmIChhc3luYyAmJiBjYWxsYmFjaykgY2FsbGJhY2soQnVmZmVyLmFsbG9jKDApLCBVdGlscy5FcnJvcnMuVU5LTk9XTl9NRVRIT0QoKSk7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuVU5LTk9XTl9NRVRIT0QoKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNvbXByZXNzKC8qQm9vbGVhbiovIGFzeW5jLCAvKkZ1bmN0aW9uKi8gY2FsbGJhY2spIHtcblx0ICAgICAgICBpZiAoKCF1bmNvbXByZXNzZWREYXRhIHx8ICF1bmNvbXByZXNzZWREYXRhLmxlbmd0aCkgJiYgQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuXHQgICAgICAgICAgICAvLyBubyBkYXRhIHNldCBvciB0aGUgZGF0YSB3YXNuJ3QgY2hhbmdlZCB0byByZXF1aXJlIHJlY29tcHJlc3Npb25cblx0ICAgICAgICAgICAgaWYgKGFzeW5jICYmIGNhbGxiYWNrKSBjYWxsYmFjayhnZXRDb21wcmVzc2VkRGF0YUZyb21aaXAoKSk7XG5cdCAgICAgICAgICAgIHJldHVybiBnZXRDb21wcmVzc2VkRGF0YUZyb21aaXAoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodW5jb21wcmVzc2VkRGF0YS5sZW5ndGggJiYgIV9pc0RpcmVjdG9yeSkge1xuXHQgICAgICAgICAgICB2YXIgY29tcHJlc3NlZERhdGE7XG5cdCAgICAgICAgICAgIC8vIExvY2FsIGZpbGUgaGVhZGVyXG5cdCAgICAgICAgICAgIHN3aXRjaCAoX2NlbnRyYWxIZWFkZXIubWV0aG9kKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFV0aWxzLkNvbnN0YW50cy5TVE9SRUQ6XG5cdCAgICAgICAgICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuY29tcHJlc3NlZFNpemUgPSBfY2VudHJhbEhlYWRlci5zaXplO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgY29tcHJlc3NlZERhdGEgPSBCdWZmZXIuYWxsb2ModW5jb21wcmVzc2VkRGF0YS5sZW5ndGgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHVuY29tcHJlc3NlZERhdGEuY29weShjb21wcmVzc2VkRGF0YSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIGNhbGxiYWNrKGNvbXByZXNzZWREYXRhKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcHJlc3NlZERhdGE7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgY2FzZSBVdGlscy5Db25zdGFudHMuREVGTEFURUQ6XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmxhdGVyID0gbmV3IE1ldGhvZHMuRGVmbGF0ZXIodW5jb21wcmVzc2VkRGF0YSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFhc3luYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmbGF0ZWQgPSBkZWZsYXRlci5kZWZsYXRlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmNvbXByZXNzZWRTaXplID0gZGVmbGF0ZWQubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmbGF0ZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVmbGF0ZXIuZGVmbGF0ZUFzeW5jKGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2VkRGF0YSA9IEJ1ZmZlci5hbGxvYyhkYXRhLmxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY2VudHJhbEhlYWRlci5jb21wcmVzc2VkU2l6ZSA9IGRhdGEubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jb3B5KGNvbXByZXNzZWREYXRhKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNvbXByZXNzZWREYXRhKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGRlZmxhdGVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgY2FsbGJhY2soQnVmZmVyLmFsbG9jKDApKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcmVhZFVJbnQ2NExFKGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdCAgICAgICAgcmV0dXJuIChidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDQpIDw8IDQpICsgYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBwYXJzZUV4dHJhKGRhdGEpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcblx0ICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSwgc2l6ZSwgcGFydDtcblx0ICAgICAgICAgICAgd2hpbGUgKG9mZnNldCArIDQgPCBkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gZGF0YS5yZWFkVUludDE2TEUob2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIG9mZnNldCArPSAyO1xuXHQgICAgICAgICAgICAgICAgc2l6ZSA9IGRhdGEucmVhZFVJbnQxNkxFKG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMjtcblx0ICAgICAgICAgICAgICAgIHBhcnQgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSk7XG5cdCAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc2l6ZTtcblx0ICAgICAgICAgICAgICAgIGlmIChDb25zdGFudHMuSURfWklQNjQgPT09IHNpZ25hdHVyZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHBhcnNlWmlwNjRFeHRlbmRlZEluZm9ybWF0aW9uKHBhcnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLkVYVFJBX0ZJRUxEX1BBUlNFX0VSUk9SKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICAvL092ZXJyaWRlIGhlYWRlciBmaWVsZCB2YWx1ZXMgd2l0aCB2YWx1ZXMgZnJvbSB0aGUgWklQNjQgZXh0cmEgZmllbGRcblx0ICAgIGZ1bmN0aW9uIHBhcnNlWmlwNjRFeHRlbmRlZEluZm9ybWF0aW9uKGRhdGEpIHtcblx0ICAgICAgICB2YXIgc2l6ZSwgY29tcHJlc3NlZFNpemUsIG9mZnNldCwgZGlza051bVN0YXJ0O1xuXG5cdCAgICAgICAgaWYgKGRhdGEubGVuZ3RoID49IENvbnN0YW50cy5FRl9aSVA2NF9TQ09NUCkge1xuXHQgICAgICAgICAgICBzaXplID0gcmVhZFVJbnQ2NExFKGRhdGEsIENvbnN0YW50cy5FRl9aSVA2NF9TVU5DT01QKTtcblx0ICAgICAgICAgICAgaWYgKF9jZW50cmFsSGVhZGVyLnNpemUgPT09IENvbnN0YW50cy5FRl9aSVA2NF9PUl8zMikge1xuXHQgICAgICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuc2l6ZSA9IHNpemU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGRhdGEubGVuZ3RoID49IENvbnN0YW50cy5FRl9aSVA2NF9SSE8pIHtcblx0ICAgICAgICAgICAgY29tcHJlc3NlZFNpemUgPSByZWFkVUludDY0TEUoZGF0YSwgQ29uc3RhbnRzLkVGX1pJUDY0X1NDT01QKTtcblx0ICAgICAgICAgICAgaWYgKF9jZW50cmFsSGVhZGVyLmNvbXByZXNzZWRTaXplID09PSBDb25zdGFudHMuRUZfWklQNjRfT1JfMzIpIHtcblx0ICAgICAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmNvbXByZXNzZWRTaXplID0gY29tcHJlc3NlZFNpemU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGRhdGEubGVuZ3RoID49IENvbnN0YW50cy5FRl9aSVA2NF9EU04pIHtcblx0ICAgICAgICAgICAgb2Zmc2V0ID0gcmVhZFVJbnQ2NExFKGRhdGEsIENvbnN0YW50cy5FRl9aSVA2NF9SSE8pO1xuXHQgICAgICAgICAgICBpZiAoX2NlbnRyYWxIZWFkZXIub2Zmc2V0ID09PSBDb25zdGFudHMuRUZfWklQNjRfT1JfMzIpIHtcblx0ICAgICAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLm9mZnNldCA9IG9mZnNldDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZGF0YS5sZW5ndGggPj0gQ29uc3RhbnRzLkVGX1pJUDY0X0RTTiArIDQpIHtcblx0ICAgICAgICAgICAgZGlza051bVN0YXJ0ID0gZGF0YS5yZWFkVUludDMyTEUoQ29uc3RhbnRzLkVGX1pJUDY0X0RTTik7XG5cdCAgICAgICAgICAgIGlmIChfY2VudHJhbEhlYWRlci5kaXNrTnVtU3RhcnQgPT09IENvbnN0YW50cy5FRl9aSVA2NF9PUl8xNikge1xuXHQgICAgICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuZGlza051bVN0YXJ0ID0gZGlza051bVN0YXJ0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGdldCBlbnRyeU5hbWUoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShfZW50cnlOYW1lKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldCByYXdFbnRyeU5hbWUoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfZW50cnlOYW1lO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0IGVudHJ5TmFtZSh2YWwpIHtcblx0ICAgICAgICAgICAgX2VudHJ5TmFtZSA9IFV0aWxzLnRvQnVmZmVyKHZhbCwgZGVjb2Rlci5lbmNvZGUpO1xuXHQgICAgICAgICAgICB2YXIgbGFzdENoYXIgPSBfZW50cnlOYW1lW19lbnRyeU5hbWUubGVuZ3RoIC0gMV07XG5cdCAgICAgICAgICAgIF9pc0RpcmVjdG9yeSA9IGxhc3RDaGFyID09PSA0NyB8fCBsYXN0Q2hhciA9PT0gOTI7XG5cdCAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmZpbGVOYW1lTGVuZ3RoID0gX2VudHJ5TmFtZS5sZW5ndGg7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBlZnMoKSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgX2VmcyA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX2Vmcyh0aGlzLmVudHJ5TmFtZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX2Vmcztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXQgZXh0cmEoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfZXh0cmE7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQgZXh0cmEodmFsKSB7XG5cdCAgICAgICAgICAgIF9leHRyYSA9IHZhbDtcblx0ICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuZXh0cmFMZW5ndGggPSB2YWwubGVuZ3RoO1xuXHQgICAgICAgICAgICBwYXJzZUV4dHJhKHZhbCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBjb21tZW50KCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoX2NvbW1lbnQpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0IGNvbW1lbnQodmFsKSB7XG5cdCAgICAgICAgICAgIF9jb21tZW50ID0gVXRpbHMudG9CdWZmZXIodmFsLCBkZWNvZGVyLmVuY29kZSk7XG5cdCAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmNvbW1lbnRMZW5ndGggPSBfY29tbWVudC5sZW5ndGg7XG5cdCAgICAgICAgICAgIGlmIChfY29tbWVudC5sZW5ndGggPiAweGZmZmYpIHRocm93IFV0aWxzLkVycm9ycy5DT01NRU5UX1RPT19MT05HKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBuYW1lKCkge1xuXHQgICAgICAgICAgICB2YXIgbiA9IGRlY29kZXIuZGVjb2RlKF9lbnRyeU5hbWUpO1xuXHQgICAgICAgICAgICByZXR1cm4gX2lzRGlyZWN0b3J5XG5cdCAgICAgICAgICAgICAgICA/IG5cblx0ICAgICAgICAgICAgICAgICAgICAgIC5zdWJzdHIobi5sZW5ndGggLSAxKVxuXHQgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KFwiL1wiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgLnBvcCgpXG5cdCAgICAgICAgICAgICAgICA6IG4uc3BsaXQoXCIvXCIpLnBvcCgpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0IGlzRGlyZWN0b3J5KCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX2lzRGlyZWN0b3J5O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXRDb21wcmVzc2VkRGF0YTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gY29tcHJlc3MoZmFsc2UsIG51bGwpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXRDb21wcmVzc2VkRGF0YUFzeW5jOiBmdW5jdGlvbiAoLypGdW5jdGlvbiovIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIGNvbXByZXNzKHRydWUsIGNhbGxiYWNrKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgc2V0RGF0YTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHVuY29tcHJlc3NlZERhdGEgPSBVdGlscy50b0J1ZmZlcih2YWx1ZSwgVXRpbHMuZGVjb2Rlci5lbmNvZGUpO1xuXHQgICAgICAgICAgICBpZiAoIV9pc0RpcmVjdG9yeSAmJiB1bmNvbXByZXNzZWREYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuc2l6ZSA9IHVuY29tcHJlc3NlZERhdGEubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIubWV0aG9kID0gVXRpbHMuQ29uc3RhbnRzLkRFRkxBVEVEO1xuXHQgICAgICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuY3JjID0gVXRpbHMuY3JjMzIodmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuY2hhbmdlZCA9IHRydWU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBmb2xkZXJzIGFuZCBibGFuayBmaWxlcyBzaG91bGQgYmUgc3RvcmVkXG5cdCAgICAgICAgICAgICAgICBfY2VudHJhbEhlYWRlci5tZXRob2QgPSBVdGlscy5Db25zdGFudHMuU1RPUkVEO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldERhdGE6IGZ1bmN0aW9uIChwYXNzKSB7XG5cdCAgICAgICAgICAgIGlmIChfY2VudHJhbEhlYWRlci5jaGFuZ2VkKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdW5jb21wcmVzc2VkRGF0YTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBkZWNvbXByZXNzKGZhbHNlLCBudWxsLCBwYXNzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXREYXRhQXN5bmM6IGZ1bmN0aW9uICgvKkZ1bmN0aW9uKi8gY2FsbGJhY2ssIHBhc3MpIHtcblx0ICAgICAgICAgICAgaWYgKF9jZW50cmFsSGVhZGVyLmNoYW5nZWQpIHtcblx0ICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuY29tcHJlc3NlZERhdGEpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZGVjb21wcmVzcyh0cnVlLCBjYWxsYmFjaywgcGFzcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgc2V0IGF0dHIoYXR0cikge1xuXHQgICAgICAgICAgICBfY2VudHJhbEhlYWRlci5hdHRyID0gYXR0cjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldCBhdHRyKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX2NlbnRyYWxIZWFkZXIuYXR0cjtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgc2V0IGhlYWRlcigvKkJ1ZmZlciovIGRhdGEpIHtcblx0ICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIubG9hZEZyb21CaW5hcnkoZGF0YSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldCBoZWFkZXIoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfY2VudHJhbEhlYWRlcjtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcGFja0NlbnRyYWxIZWFkZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuZmxhZ3NfZWZzID0gdGhpcy5lZnM7XG5cdCAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmV4dHJhTGVuZ3RoID0gX2V4dHJhLmxlbmd0aDtcblx0ICAgICAgICAgICAgLy8gMS4gY3JlYXRlIGhlYWRlciAoYnVmZmVyKVxuXHQgICAgICAgICAgICB2YXIgaGVhZGVyID0gX2NlbnRyYWxIZWFkZXIuY2VudHJhbEhlYWRlclRvQmluYXJ5KCk7XG5cdCAgICAgICAgICAgIHZhciBhZGRwb3MgPSBVdGlscy5Db25zdGFudHMuQ0VOSERSO1xuXHQgICAgICAgICAgICAvLyAyLiBhZGQgZmlsZSBuYW1lXG5cdCAgICAgICAgICAgIF9lbnRyeU5hbWUuY29weShoZWFkZXIsIGFkZHBvcyk7XG5cdCAgICAgICAgICAgIGFkZHBvcyArPSBfZW50cnlOYW1lLmxlbmd0aDtcblx0ICAgICAgICAgICAgLy8gMy4gYWRkIGV4dHJhIGRhdGFcblx0ICAgICAgICAgICAgX2V4dHJhLmNvcHkoaGVhZGVyLCBhZGRwb3MpO1xuXHQgICAgICAgICAgICBhZGRwb3MgKz0gX2NlbnRyYWxIZWFkZXIuZXh0cmFMZW5ndGg7XG5cdCAgICAgICAgICAgIC8vIDQuIGFkZCBmaWxlIGNvbW1lbnRcblx0ICAgICAgICAgICAgX2NvbW1lbnQuY29weShoZWFkZXIsIGFkZHBvcyk7XG5cdCAgICAgICAgICAgIHJldHVybiBoZWFkZXI7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHBhY2tMb2NhbEhlYWRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBsZXQgYWRkcG9zID0gMDtcblx0ICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuZmxhZ3NfZWZzID0gdGhpcy5lZnM7XG5cdCAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmV4dHJhTG9jYWxMZW5ndGggPSBfZXh0cmFsb2NhbC5sZW5ndGg7XG5cdCAgICAgICAgICAgIC8vIDEuIGNvbnN0cnVjdCBsb2NhbCBoZWFkZXIgQnVmZmVyXG5cdCAgICAgICAgICAgIGNvbnN0IGxvY2FsSGVhZGVyQnVmID0gX2NlbnRyYWxIZWFkZXIubG9jYWxIZWFkZXJUb0JpbmFyeSgpO1xuXHQgICAgICAgICAgICAvLyAyLiBsb2NhbEhlYWRlciAtIGNyYXRlIGhlYWRlciBidWZmZXJcblx0ICAgICAgICAgICAgY29uc3QgbG9jYWxIZWFkZXIgPSBCdWZmZXIuYWxsb2MobG9jYWxIZWFkZXJCdWYubGVuZ3RoICsgX2VudHJ5TmFtZS5sZW5ndGggKyBfY2VudHJhbEhlYWRlci5leHRyYUxvY2FsTGVuZ3RoKTtcblx0ICAgICAgICAgICAgLy8gMi4xIGFkZCBsb2NhbGhlYWRlclxuXHQgICAgICAgICAgICBsb2NhbEhlYWRlckJ1Zi5jb3B5KGxvY2FsSGVhZGVyLCBhZGRwb3MpO1xuXHQgICAgICAgICAgICBhZGRwb3MgKz0gbG9jYWxIZWFkZXJCdWYubGVuZ3RoO1xuXHQgICAgICAgICAgICAvLyAyLjIgYWRkIGZpbGUgbmFtZVxuXHQgICAgICAgICAgICBfZW50cnlOYW1lLmNvcHkobG9jYWxIZWFkZXIsIGFkZHBvcyk7XG5cdCAgICAgICAgICAgIGFkZHBvcyArPSBfZW50cnlOYW1lLmxlbmd0aDtcblx0ICAgICAgICAgICAgLy8gMi4zIGFkZCBleHRyYSBmaWVsZFxuXHQgICAgICAgICAgICBfZXh0cmFsb2NhbC5jb3B5KGxvY2FsSGVhZGVyLCBhZGRwb3MpO1xuXHQgICAgICAgICAgICBhZGRwb3MgKz0gX2V4dHJhbG9jYWwubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBsb2NhbEhlYWRlcjtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZnVuY3Rpb24gKG5yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gXCI8XCIgKyAoKG5yICYmIG5yLmxlbmd0aCArIFwiIGJ5dGVzIGJ1ZmZlclwiKSB8fCBcIm51bGxcIikgKyBcIj5cIjtcblx0ICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgZW50cnlOYW1lOiB0aGlzLmVudHJ5TmFtZSxcblx0ICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcblx0ICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHRoaXMuY29tbWVudCxcblx0ICAgICAgICAgICAgICAgIGlzRGlyZWN0b3J5OiB0aGlzLmlzRGlyZWN0b3J5LFxuXHQgICAgICAgICAgICAgICAgaGVhZGVyOiBfY2VudHJhbEhlYWRlci50b0pTT04oKSxcblx0ICAgICAgICAgICAgICAgIGNvbXByZXNzZWREYXRhOiBieXRlcyhpbnB1dCksXG5cdCAgICAgICAgICAgICAgICBkYXRhOiBieXRlcyh1bmNvbXByZXNzZWREYXRhKVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSwgbnVsbCwgXCJcXHRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0fTtcblx0cmV0dXJuIHppcEVudHJ5O1xufVxuXG52YXIgemlwRmlsZTtcbnZhciBoYXNSZXF1aXJlZFppcEZpbGU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVaaXBGaWxlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkWmlwRmlsZSkgcmV0dXJuIHppcEZpbGU7XG5cdGhhc1JlcXVpcmVkWmlwRmlsZSA9IDE7XG5cdGNvbnN0IFppcEVudHJ5ID0gcmVxdWlyZVppcEVudHJ5KCk7XG5cdGNvbnN0IEhlYWRlcnMgPSByZXF1aXJlSGVhZGVycygpO1xuXHRjb25zdCBVdGlscyA9IHJlcXVpcmVVdGlsKCk7XG5cblx0emlwRmlsZSA9IGZ1bmN0aW9uICgvKkJ1ZmZlcnxudWxsKi8gaW5CdWZmZXIsIC8qKiBvYmplY3QgKi8gb3B0aW9ucykge1xuXHQgICAgdmFyIGVudHJ5TGlzdCA9IFtdLFxuXHQgICAgICAgIGVudHJ5VGFibGUgPSB7fSxcblx0ICAgICAgICBfY29tbWVudCA9IEJ1ZmZlci5hbGxvYygwKSxcblx0ICAgICAgICBtYWluSGVhZGVyID0gbmV3IEhlYWRlcnMuTWFpbkhlYWRlcigpLFxuXHQgICAgICAgIGxvYWRlZEVudHJpZXMgPSBmYWxzZTtcblx0ICAgIGNvbnN0IHRlbXBvcmFyeSA9IG5ldyBTZXQoKTtcblxuXHQgICAgLy8gYXNzaWduIG9wdGlvbnNcblx0ICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zO1xuXG5cdCAgICBjb25zdCB7IG5vU29ydCwgZGVjb2RlciB9ID0gb3B0cztcblxuXHQgICAgaWYgKGluQnVmZmVyKSB7XG5cdCAgICAgICAgLy8gaXMgYSBtZW1vcnkgYnVmZmVyXG5cdCAgICAgICAgcmVhZE1haW5IZWFkZXIob3B0cy5yZWFkRW50cmllcyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vIG5vbmUuIGlzIGEgbmV3IGZpbGVcblx0ICAgICAgICBsb2FkZWRFbnRyaWVzID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gbWFrZVRlbXBvcmFyeUZvbGRlcnMoKSB7XG5cdCAgICAgICAgY29uc3QgZm9sZGVyc0xpc3QgPSBuZXcgU2V0KCk7XG5cblx0ICAgICAgICAvLyBNYWtlIGxpc3Qgb2YgYWxsIGZvbGRlcnMgaW4gZmlsZVxuXHQgICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBPYmplY3Qua2V5cyhlbnRyeVRhYmxlKSkge1xuXHQgICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGVsZW0uc3BsaXQoXCIvXCIpO1xuXHQgICAgICAgICAgICBlbGVtZW50cy5wb3AoKTsgLy8gZmlsZW5hbWVcblx0ICAgICAgICAgICAgaWYgKCFlbGVtZW50cy5sZW5ndGgpIGNvbnRpbnVlOyAvLyBubyBmb2xkZXJzXG5cdCAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGNvbnN0IHN1YiA9IGVsZW1lbnRzLnNsaWNlKDAsIGkgKyAxKS5qb2luKFwiL1wiKSArIFwiL1wiO1xuXHQgICAgICAgICAgICAgICAgZm9sZGVyc0xpc3QuYWRkKHN1Yik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBjcmVhdGUgbWlzc2luZyBmb2xkZXJzIGFzIHRlbXBvcmFyeVxuXHQgICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBmb2xkZXJzTGlzdCkge1xuXHQgICAgICAgICAgICBpZiAoIShlbGVtIGluIGVudHJ5VGFibGUpKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zdCB0ZW1wZm9sZGVyID0gbmV3IFppcEVudHJ5KG9wdHMpO1xuXHQgICAgICAgICAgICAgICAgdGVtcGZvbGRlci5lbnRyeU5hbWUgPSBlbGVtO1xuXHQgICAgICAgICAgICAgICAgdGVtcGZvbGRlci5hdHRyID0gMHgxMDtcblx0ICAgICAgICAgICAgICAgIHRlbXBmb2xkZXIudGVtcG9yYXJ5ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIGVudHJ5TGlzdC5wdXNoKHRlbXBmb2xkZXIpO1xuXHQgICAgICAgICAgICAgICAgZW50cnlUYWJsZVt0ZW1wZm9sZGVyLmVudHJ5TmFtZV0gPSB0ZW1wZm9sZGVyO1xuXHQgICAgICAgICAgICAgICAgdGVtcG9yYXJ5LmFkZCh0ZW1wZm9sZGVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcmVhZEVudHJpZXMoKSB7XG5cdCAgICAgICAgbG9hZGVkRW50cmllcyA9IHRydWU7XG5cdCAgICAgICAgZW50cnlUYWJsZSA9IHt9O1xuXHQgICAgICAgIGlmIChtYWluSGVhZGVyLmRpc2tFbnRyaWVzID4gKGluQnVmZmVyLmxlbmd0aCAtIG1haW5IZWFkZXIub2Zmc2V0KSAvIFV0aWxzLkNvbnN0YW50cy5DRU5IRFIpIHtcblx0ICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLkRJU0tfRU5UUllfVE9PX0xBUkdFKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVudHJ5TGlzdCA9IG5ldyBBcnJheShtYWluSGVhZGVyLmRpc2tFbnRyaWVzKTsgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXNcblx0ICAgICAgICB2YXIgaW5kZXggPSBtYWluSGVhZGVyLm9mZnNldDsgLy8gb2Zmc2V0IG9mIGZpcnN0IENFTiBoZWFkZXJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJ5TGlzdC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgdG1wID0gaW5kZXgsXG5cdCAgICAgICAgICAgICAgICBlbnRyeSA9IG5ldyBaaXBFbnRyeShvcHRzLCBpbkJ1ZmZlcik7XG5cdCAgICAgICAgICAgIGVudHJ5LmhlYWRlciA9IGluQnVmZmVyLnNsaWNlKHRtcCwgKHRtcCArPSBVdGlscy5Db25zdGFudHMuQ0VOSERSKSk7XG5cblx0ICAgICAgICAgICAgZW50cnkuZW50cnlOYW1lID0gaW5CdWZmZXIuc2xpY2UodG1wLCAodG1wICs9IGVudHJ5LmhlYWRlci5maWxlTmFtZUxlbmd0aCkpO1xuXG5cdCAgICAgICAgICAgIGlmIChlbnRyeS5oZWFkZXIuZXh0cmFMZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIGVudHJ5LmV4dHJhID0gaW5CdWZmZXIuc2xpY2UodG1wLCAodG1wICs9IGVudHJ5LmhlYWRlci5leHRyYUxlbmd0aCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGVudHJ5LmhlYWRlci5jb21tZW50TGVuZ3RoKSBlbnRyeS5jb21tZW50ID0gaW5CdWZmZXIuc2xpY2UodG1wLCB0bXAgKyBlbnRyeS5oZWFkZXIuY29tbWVudExlbmd0aCk7XG5cblx0ICAgICAgICAgICAgaW5kZXggKz0gZW50cnkuaGVhZGVyLmNlbnRyYWxIZWFkZXJTaXplO1xuXG5cdCAgICAgICAgICAgIGVudHJ5TGlzdFtpXSA9IGVudHJ5O1xuXHQgICAgICAgICAgICBlbnRyeVRhYmxlW2VudHJ5LmVudHJ5TmFtZV0gPSBlbnRyeTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGVtcG9yYXJ5LmNsZWFyKCk7XG5cdCAgICAgICAgbWFrZVRlbXBvcmFyeUZvbGRlcnMoKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcmVhZE1haW5IZWFkZXIoLypCb29sZWFuKi8gcmVhZE5vdykge1xuXHQgICAgICAgIHZhciBpID0gaW5CdWZmZXIubGVuZ3RoIC0gVXRpbHMuQ29uc3RhbnRzLkVOREhEUiwgLy8gRU5EIGhlYWRlciBzaXplXG5cdCAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KDAsIGkgLSAweGZmZmYpLCAvLyAweEZGRkYgaXMgdGhlIG1heCB6aXAgZmlsZSBjb21tZW50IGxlbmd0aFxuXHQgICAgICAgICAgICBuID0gbWF4LFxuXHQgICAgICAgICAgICBlbmRTdGFydCA9IGluQnVmZmVyLmxlbmd0aCxcblx0ICAgICAgICAgICAgZW5kT2Zmc2V0ID0gLTEsIC8vIFN0YXJ0IG9mZnNldCBvZiB0aGUgRU5EIGhlYWRlclxuXHQgICAgICAgICAgICBjb21tZW50RW5kID0gMDtcblxuXHQgICAgICAgIC8vIG9wdGlvbiB0byBzZWFyY2ggaGVhZGVyIGZvcm0gZW50aXJlIGZpbGVcblx0ICAgICAgICBjb25zdCB0cmFpbGluZ1NwYWNlID0gdHlwZW9mIG9wdHMudHJhaWxpbmdTcGFjZSA9PT0gXCJib29sZWFuXCIgPyBvcHRzLnRyYWlsaW5nU3BhY2UgOiBmYWxzZTtcblx0ICAgICAgICBpZiAodHJhaWxpbmdTcGFjZSkgbWF4ID0gMDtcblxuXHQgICAgICAgIGZvciAoaTsgaSA+PSBuOyBpLS0pIHtcblx0ICAgICAgICAgICAgaWYgKGluQnVmZmVyW2ldICE9PSAweDUwKSBjb250aW51ZTsgLy8gcXVpY2sgY2hlY2sgdGhhdCB0aGUgYnl0ZSBpcyAnUCdcblx0ICAgICAgICAgICAgaWYgKGluQnVmZmVyLnJlYWRVSW50MzJMRShpKSA9PT0gVXRpbHMuQ29uc3RhbnRzLkVORFNJRykge1xuXHQgICAgICAgICAgICAgICAgLy8gXCJQS1xcMDA1XFwwMDZcIlxuXHQgICAgICAgICAgICAgICAgZW5kT2Zmc2V0ID0gaTtcblx0ICAgICAgICAgICAgICAgIGNvbW1lbnRFbmQgPSBpO1xuXHQgICAgICAgICAgICAgICAgZW5kU3RhcnQgPSBpICsgVXRpbHMuQ29uc3RhbnRzLkVOREhEUjtcblx0ICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgZm91bmQgYSByZWd1bGFyIHNpZ25hdHVyZSwgbGV0J3MgbG9vayBqdXN0IGEgYml0IGZ1cnRoZXIgdG8gY2hlY2sgaWYgdGhlcmUncyBhbnkgemlwNjQgc2lnbmF0dXJlXG5cdCAgICAgICAgICAgICAgICBuID0gaSAtIFV0aWxzLkNvbnN0YW50cy5FTkQ2NEhEUjtcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGluQnVmZmVyLnJlYWRVSW50MzJMRShpKSA9PT0gVXRpbHMuQ29uc3RhbnRzLkVORDY0U0lHKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIHppcDY0IHNpZ25hdHVyZSwgbGV0J3MgY29udGludWUgcmVhZGluZyB0aGUgd2hvbGUgemlwNjQgcmVjb3JkXG5cdCAgICAgICAgICAgICAgICBuID0gbWF4O1xuXHQgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoaW5CdWZmZXIucmVhZFVJbnQzMkxFKGkpID09PSBVdGlscy5Db25zdGFudHMuWklQNjRTSUcpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEZvdW5kIHRoZSB6aXA2NCByZWNvcmQsIGxldCdzIGRldGVybWluZSBpdCdzIHNpemVcblx0ICAgICAgICAgICAgICAgIGVuZE9mZnNldCA9IGk7XG5cdCAgICAgICAgICAgICAgICBlbmRTdGFydCA9IGkgKyBVdGlscy5yZWFkQmlnVUludDY0TEUoaW5CdWZmZXIsIGkgKyBVdGlscy5Db25zdGFudHMuWklQNjRTSVpFKSArIFV0aWxzLkNvbnN0YW50cy5aSVA2NExFQUQ7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChlbmRPZmZzZXQgPT0gLTEpIHRocm93IFV0aWxzLkVycm9ycy5JTlZBTElEX0ZPUk1BVCgpO1xuXG5cdCAgICAgICAgbWFpbkhlYWRlci5sb2FkRnJvbUJpbmFyeShpbkJ1ZmZlci5zbGljZShlbmRPZmZzZXQsIGVuZFN0YXJ0KSk7XG5cdCAgICAgICAgaWYgKG1haW5IZWFkZXIuY29tbWVudExlbmd0aCkge1xuXHQgICAgICAgICAgICBfY29tbWVudCA9IGluQnVmZmVyLnNsaWNlKGNvbW1lbnRFbmQgKyBVdGlscy5Db25zdGFudHMuRU5ESERSKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHJlYWROb3cpIHJlYWRFbnRyaWVzKCk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHNvcnRFbnRyaWVzKCkge1xuXHQgICAgICAgIGlmIChlbnRyeUxpc3QubGVuZ3RoID4gMSAmJiAhbm9Tb3J0KSB7XG5cdCAgICAgICAgICAgIGVudHJ5TGlzdC5zb3J0KChhLCBiKSA9PiBhLmVudHJ5TmFtZS50b0xvd2VyQ2FzZSgpLmxvY2FsZUNvbXBhcmUoYi5lbnRyeU5hbWUudG9Mb3dlckNhc2UoKSkpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIFppcEVudHJ5IG9iamVjdHMgZXhpc3RlbnQgaW4gdGhlIGN1cnJlbnQgb3BlbmVkIGFyY2hpdmVcblx0ICAgICAgICAgKiBAcmV0dXJuIEFycmF5XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZ2V0IGVudHJpZXMoKSB7XG5cdCAgICAgICAgICAgIGlmICghbG9hZGVkRW50cmllcykge1xuXHQgICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZW50cnlMaXN0LmZpbHRlcigoZSkgPT4gIXRlbXBvcmFyeS5oYXMoZSkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBcmNoaXZlIGNvbW1lbnRcblx0ICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZ2V0IGNvbW1lbnQoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShfY29tbWVudCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQgY29tbWVudCh2YWwpIHtcblx0ICAgICAgICAgICAgX2NvbW1lbnQgPSBVdGlscy50b0J1ZmZlcih2YWwsIGRlY29kZXIuZW5jb2RlKTtcblx0ICAgICAgICAgICAgbWFpbkhlYWRlci5jb21tZW50TGVuZ3RoID0gX2NvbW1lbnQubGVuZ3RoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXRFbnRyeUNvdW50OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICghbG9hZGVkRW50cmllcykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1haW5IZWFkZXIuZGlza0VudHJpZXM7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZW50cnlMaXN0Lmxlbmd0aDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZm9yRWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZW50cmllcy5mb3JFYWNoKGNhbGxiYWNrKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgZW50cnkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBvciBudWxsIGlmIGVudHJ5IGlzIGluZXhpc3RlbnRcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSBlbnRyeU5hbWVcblx0ICAgICAgICAgKiBAcmV0dXJuIFppcEVudHJ5XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZ2V0RW50cnk6IGZ1bmN0aW9uICgvKlN0cmluZyovIGVudHJ5TmFtZSkge1xuXHQgICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcblx0ICAgICAgICAgICAgICAgIHJlYWRFbnRyaWVzKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGVudHJ5VGFibGVbZW50cnlOYW1lXSB8fCBudWxsO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIHRoZSBnaXZlbiBlbnRyeSB0byB0aGUgZW50cnkgbGlzdFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIGVudHJ5XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc2V0RW50cnk6IGZ1bmN0aW9uICgvKlppcEVudHJ5Ki8gZW50cnkpIHtcblx0ICAgICAgICAgICAgaWYgKCFsb2FkZWRFbnRyaWVzKSB7XG5cdCAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVudHJ5TGlzdC5wdXNoKGVudHJ5KTtcblx0ICAgICAgICAgICAgZW50cnlUYWJsZVtlbnRyeS5lbnRyeU5hbWVdID0gZW50cnk7XG5cdCAgICAgICAgICAgIG1haW5IZWFkZXIudG90YWxFbnRyaWVzID0gZW50cnlMaXN0Lmxlbmd0aDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVtb3ZlcyB0aGUgZmlsZSB3aXRoIHRoZSBnaXZlbiBuYW1lIGZyb20gdGhlIGVudHJ5IGxpc3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBJZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIHRoZW4gYWxsIG5lc3RlZCBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgd2lsbCBiZSByZW1vdmVkXG5cdCAgICAgICAgICogQHBhcmFtIGVudHJ5TmFtZVxuXHQgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRlbGV0ZUZpbGU6IGZ1bmN0aW9uICgvKlN0cmluZyovIGVudHJ5TmFtZSwgd2l0aHN1YmZvbGRlcnMgPSB0cnVlKSB7XG5cdCAgICAgICAgICAgIGlmICghbG9hZGVkRW50cmllcykge1xuXHQgICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGVudHJ5VGFibGVbZW50cnlOYW1lXTtcblx0ICAgICAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuZ2V0RW50cnlDaGlsZHJlbihlbnRyeSwgd2l0aHN1YmZvbGRlcnMpLm1hcCgoY2hpbGQpID0+IGNoaWxkLmVudHJ5TmFtZSk7XG5cblx0ICAgICAgICAgICAgbGlzdC5mb3JFYWNoKHRoaXMuZGVsZXRlRW50cnkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZW1vdmVzIHRoZSBlbnRyeSB3aXRoIHRoZSBnaXZlbiBuYW1lIGZyb20gdGhlIGVudHJ5IGxpc3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW50cnlOYW1lXG5cdCAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZGVsZXRlRW50cnk6IGZ1bmN0aW9uICgvKlN0cmluZyovIGVudHJ5TmFtZSkge1xuXHQgICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcblx0ICAgICAgICAgICAgICAgIHJlYWRFbnRyaWVzKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyeVRhYmxlW2VudHJ5TmFtZV07XG5cdCAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZW50cnlMaXN0LmluZGV4T2YoZW50cnkpO1xuXHQgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgZW50cnlMaXN0LnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgZW50cnlUYWJsZVtlbnRyeU5hbWVdO1xuXHQgICAgICAgICAgICAgICAgbWFpbkhlYWRlci50b3RhbEVudHJpZXMgPSBlbnRyeUxpc3QubGVuZ3RoO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqICBJdGVyYXRlcyBhbmQgcmV0dXJucyBhbGwgbmVzdGVkIGZpbGVzIGFuZCBkaXJlY3RvcmllcyBvZiB0aGUgZ2l2ZW4gZW50cnlcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSBlbnRyeVxuXHQgICAgICAgICAqIEByZXR1cm4gQXJyYXlcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBnZXRFbnRyeUNoaWxkcmVuOiBmdW5jdGlvbiAoLypaaXBFbnRyeSovIGVudHJ5LCBzdWJmb2xkZXJzID0gdHJ1ZSkge1xuXHQgICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcblx0ICAgICAgICAgICAgICAgIHJlYWRFbnRyaWVzKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5ICYmIHN1YmZvbGRlcnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGVudHJ5LmVudHJ5TmFtZTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgemlwRW50cnkgb2YgZW50cnlMaXN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6aXBFbnRyeS5lbnRyeU5hbWUuc3RhcnRzV2l0aChuYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKHppcEVudHJ5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlbnRyeV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiAgSG93IG1hbnkgY2hpbGQgZWxlbWVudHMgZW50cnkgaGFzXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1ppcEVudHJ5fSBlbnRyeVxuXHQgICAgICAgICAqIEByZXR1cm4ge2ludGVnZXJ9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZ2V0Q2hpbGRDb3VudDogZnVuY3Rpb24gKGVudHJ5KSB7XG5cdCAgICAgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5pc0RpcmVjdG9yeSkge1xuXHQgICAgICAgICAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuZ2V0RW50cnlDaGlsZHJlbihlbnRyeSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGlzdC5pbmNsdWRlcyhlbnRyeSkgPyBsaXN0Lmxlbmd0aCAtIDEgOiBsaXN0Lmxlbmd0aDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyB0aGUgemlwIGZpbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4gQnVmZmVyXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29tcHJlc3NUb0J1ZmZlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcblx0ICAgICAgICAgICAgICAgIHJlYWRFbnRyaWVzKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgc29ydEVudHJpZXMoKTtcblxuXHQgICAgICAgICAgICBjb25zdCBkYXRhQmxvY2sgPSBbXTtcblx0ICAgICAgICAgICAgY29uc3QgaGVhZGVyQmxvY2tzID0gW107XG5cdCAgICAgICAgICAgIGxldCB0b3RhbFNpemUgPSAwO1xuXHQgICAgICAgICAgICBsZXQgZGluZGV4ID0gMDtcblxuXHQgICAgICAgICAgICBtYWluSGVhZGVyLnNpemUgPSAwO1xuXHQgICAgICAgICAgICBtYWluSGVhZGVyLm9mZnNldCA9IDA7XG5cdCAgICAgICAgICAgIGxldCB0b3RhbEVudHJpZXMgPSAwO1xuXG5cdCAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5lbnRyaWVzKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBjb21wcmVzcyBkYXRhIGFuZCBzZXQgbG9jYWwgYW5kIGVudHJ5IGhlYWRlciBhY2NvcmRpbmdseS4gUmVhc29uIHdoeSBpcyBjYWxsZWQgZmlyc3Rcblx0ICAgICAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzZWREYXRhID0gZW50cnkuZ2V0Q29tcHJlc3NlZERhdGEoKTtcblx0ICAgICAgICAgICAgICAgIGVudHJ5LmhlYWRlci5vZmZzZXQgPSBkaW5kZXg7XG5cblx0ICAgICAgICAgICAgICAgIC8vIDEuIGNvbnN0cnVjdCBsb2NhbCBoZWFkZXJcblx0ICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsSGVhZGVyID0gZW50cnkucGFja0xvY2FsSGVhZGVyKCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIDIuIG9mZnNldHNcblx0ICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBsb2NhbEhlYWRlci5sZW5ndGggKyBjb21wcmVzc2VkRGF0YS5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICBkaW5kZXggKz0gZGF0YUxlbmd0aDtcblxuXHQgICAgICAgICAgICAgICAgLy8gMy4gc3RvcmUgdmFsdWVzIGluIHNlcXVlbmNlXG5cdCAgICAgICAgICAgICAgICBkYXRhQmxvY2sucHVzaChsb2NhbEhlYWRlcik7XG5cdCAgICAgICAgICAgICAgICBkYXRhQmxvY2sucHVzaChjb21wcmVzc2VkRGF0YSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIDQuIGNvbnN0cnVjdCBjZW50cmFsIGhlYWRlclxuXHQgICAgICAgICAgICAgICAgY29uc3QgY2VudHJhbEhlYWRlciA9IGVudHJ5LnBhY2tDZW50cmFsSGVhZGVyKCk7XG5cdCAgICAgICAgICAgICAgICBoZWFkZXJCbG9ja3MucHVzaChjZW50cmFsSGVhZGVyKTtcblx0ICAgICAgICAgICAgICAgIC8vIDUuIHVwZGF0ZSBtYWluIGhlYWRlclxuXHQgICAgICAgICAgICAgICAgbWFpbkhlYWRlci5zaXplICs9IGNlbnRyYWxIZWFkZXIubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgdG90YWxTaXplICs9IGRhdGFMZW5ndGggKyBjZW50cmFsSGVhZGVyLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIHRvdGFsRW50cmllcysrO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdG90YWxTaXplICs9IG1haW5IZWFkZXIubWFpbkhlYWRlclNpemU7IC8vIGFsc28gaW5jbHVkZXMgemlwIGZpbGUgY29tbWVudCBsZW5ndGhcblx0ICAgICAgICAgICAgLy8gcG9pbnQgdG8gZW5kIG9mIGRhdGEgYW5kIGJlZ2lubmluZyBvZiBjZW50cmFsIGRpcmVjdG9yeSBmaXJzdCByZWNvcmRcblx0ICAgICAgICAgICAgbWFpbkhlYWRlci5vZmZzZXQgPSBkaW5kZXg7XG5cdCAgICAgICAgICAgIG1haW5IZWFkZXIudG90YWxFbnRyaWVzID0gdG90YWxFbnRyaWVzO1xuXG5cdCAgICAgICAgICAgIGRpbmRleCA9IDA7XG5cdCAgICAgICAgICAgIGNvbnN0IG91dEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyh0b3RhbFNpemUpO1xuXHQgICAgICAgICAgICAvLyB3cml0ZSBkYXRhIGJsb2Nrc1xuXHQgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgZGF0YUJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICBjb250ZW50LmNvcHkob3V0QnVmZmVyLCBkaW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgZGluZGV4ICs9IGNvbnRlbnQubGVuZ3RoO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gd3JpdGUgY2VudHJhbCBkaXJlY3RvcnkgZW50cmllc1xuXHQgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgaGVhZGVyQmxvY2tzKSB7XG5cdCAgICAgICAgICAgICAgICBjb250ZW50LmNvcHkob3V0QnVmZmVyLCBkaW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgZGluZGV4ICs9IGNvbnRlbnQubGVuZ3RoO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gd3JpdGUgbWFpbiBoZWFkZXJcblx0ICAgICAgICAgICAgY29uc3QgbWggPSBtYWluSGVhZGVyLnRvQmluYXJ5KCk7XG5cdCAgICAgICAgICAgIGlmIChfY29tbWVudCkge1xuXHQgICAgICAgICAgICAgICAgX2NvbW1lbnQuY29weShtaCwgVXRpbHMuQ29uc3RhbnRzLkVOREhEUik7IC8vIGFkZCB6aXAgZmlsZSBjb21tZW50XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbWguY29weShvdXRCdWZmZXIsIGRpbmRleCk7XG5cblx0ICAgICAgICAgICAgLy8gU2luY2Ugd2UgdXBkYXRlIGVudHJ5IGFuZCBtYWluIGhlYWRlciBvZmZzZXRzLFxuXHQgICAgICAgICAgICAvLyB0aGV5IGFyZSBubyBsb25nZXIgdmFsaWQgYW5kIHdlIGhhdmUgdG8gcmVzZXQgY29udGVudFxuXHQgICAgICAgICAgICAvLyAoSXNzdWUgNjQpXG5cblx0ICAgICAgICAgICAgaW5CdWZmZXIgPSBvdXRCdWZmZXI7XG5cdCAgICAgICAgICAgIGxvYWRlZEVudHJpZXMgPSBmYWxzZTtcblxuXHQgICAgICAgICAgICByZXR1cm4gb3V0QnVmZmVyO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICB0b0FzeW5jQnVmZmVyOiBmdW5jdGlvbiAoLypGdW5jdGlvbiovIG9uU3VjY2VzcywgLypGdW5jdGlvbiovIG9uRmFpbCwgLypGdW5jdGlvbiovIG9uSXRlbVN0YXJ0LCAvKkZ1bmN0aW9uKi8gb25JdGVtRW5kKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgc29ydEVudHJpZXMoKTtcblxuXHQgICAgICAgICAgICAgICAgY29uc3QgZGF0YUJsb2NrID0gW107XG5cdCAgICAgICAgICAgICAgICBjb25zdCBjZW50cmFsSGVhZGVycyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgbGV0IHRvdGFsU2l6ZSA9IDA7XG5cdCAgICAgICAgICAgICAgICBsZXQgZGluZGV4ID0gMDtcblx0ICAgICAgICAgICAgICAgIGxldCB0b3RhbEVudHJpZXMgPSAwO1xuXG5cdCAgICAgICAgICAgICAgICBtYWluSGVhZGVyLnNpemUgPSAwO1xuXHQgICAgICAgICAgICAgICAgbWFpbkhlYWRlci5vZmZzZXQgPSAwO1xuXG5cdCAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzczJCdWZmZXIgPSBmdW5jdGlvbiAoZW50cnlMaXN0cykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeUxpc3RzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyeUxpc3RzLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlbnRyeS5lbnRyeU5hbWUgKyBlbnRyeS5leHRyYS50b1N0cmluZygpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25JdGVtU3RhcnQpIG9uSXRlbVN0YXJ0KG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5nZXRDb21wcmVzc2VkRGF0YUFzeW5jKGZ1bmN0aW9uIChjb21wcmVzc2VkRGF0YSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uSXRlbUVuZCkgb25JdGVtRW5kKG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuaGVhZGVyLm9mZnNldCA9IGRpbmRleDtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS4gY29uc3RydWN0IGxvY2FsIGhlYWRlclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxIZWFkZXIgPSBlbnRyeS5wYWNrTG9jYWxIZWFkZXIoKTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi4gb2Zmc2V0c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGxvY2FsSGVhZGVyLmxlbmd0aCArIGNvbXByZXNzZWREYXRhLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbmRleCArPSBkYXRhTGVuZ3RoO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzLiBzdG9yZSB2YWx1ZXMgaW4gc2VxdWVuY2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFCbG9jay5wdXNoKGxvY2FsSGVhZGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFCbG9jay5wdXNoKGNvbXByZXNzZWREYXRhKTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2VudHJhbCBoZWFkZXJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRhbEhlYWRlciA9IGVudHJ5LnBhY2tDZW50cmFsSGVhZGVyKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50cmFsSGVhZGVycy5wdXNoKGNlbnRhbEhlYWRlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluSGVhZGVyLnNpemUgKz0gY2VudGFsSGVhZGVyLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBkYXRhTGVuZ3RoICsgY2VudGFsSGVhZGVyLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsRW50cmllcysrO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzczJCdWZmZXIoZW50cnlMaXN0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBtYWluSGVhZGVyLm1haW5IZWFkZXJTaXplOyAvLyBhbHNvIGluY2x1ZGVzIHppcCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50IHRvIGVuZCBvZiBkYXRhIGFuZCBiZWdpbm5pbmcgb2YgY2VudHJhbCBkaXJlY3RvcnkgZmlyc3QgcmVjb3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1haW5IZWFkZXIub2Zmc2V0ID0gZGluZGV4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtYWluSGVhZGVyLnRvdGFsRW50cmllcyA9IHRvdGFsRW50cmllcztcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaW5kZXggPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRCdWZmZXIgPSBCdWZmZXIuYWxsb2ModG90YWxTaXplKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUJsb2NrLmZvckVhY2goZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuY29weShvdXRCdWZmZXIsIGRpbmRleCk7IC8vIHdyaXRlIGRhdGEgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW5kZXggKz0gY29udGVudC5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjZW50cmFsSGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LmNvcHkob3V0QnVmZmVyLCBkaW5kZXgpOyAvLyB3cml0ZSBjZW50cmFsIGRpcmVjdG9yeSBlbnRyaWVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW5kZXggKz0gY29udGVudC5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1oID0gbWFpbkhlYWRlci50b0JpbmFyeSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbW1lbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb21tZW50LmNvcHkobWgsIFV0aWxzLkNvbnN0YW50cy5FTkRIRFIpOyAvLyBhZGQgemlwIGZpbGUgY29tbWVudFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWguY29weShvdXRCdWZmZXIsIGRpbmRleCk7IC8vIHdyaXRlIG1haW4gaGVhZGVyXG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugd2UgdXBkYXRlIGVudHJ5IGFuZCBtYWluIGhlYWRlciBvZmZzZXRzLCB0aGV5IGFyZSBub1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb25nZXIgdmFsaWQgYW5kIHdlIGhhdmUgdG8gcmVzZXQgY29udGVudCB1c2luZyBvdXIgbmV3IGJ1ZmZlclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyAoSXNzdWUgNjQpXG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5CdWZmZXIgPSBvdXRCdWZmZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZEVudHJpZXMgPSBmYWxzZTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3Mob3V0QnVmZmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgICAgICBjb21wcmVzczJCdWZmZXIoQXJyYXkuZnJvbSh0aGlzLmVudHJpZXMpKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgb25GYWlsKGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0fTtcblx0cmV0dXJuIHppcEZpbGU7XG59XG5cbnZhciBhZG1aaXAkMjtcbnZhciBoYXNSZXF1aXJlZEFkbVppcDtcblxuZnVuY3Rpb24gcmVxdWlyZUFkbVppcCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEFkbVppcCkgcmV0dXJuIGFkbVppcCQyO1xuXHRoYXNSZXF1aXJlZEFkbVppcCA9IDE7XG5cdGNvbnN0IFV0aWxzID0gcmVxdWlyZVV0aWwoKTtcblx0Y29uc3QgcHRoID0gcGF0aF9fZGVmYXVsdDtcblx0Y29uc3QgWmlwRW50cnkgPSByZXF1aXJlWmlwRW50cnkoKTtcblx0Y29uc3QgWmlwRmlsZSA9IHJlcXVpcmVaaXBGaWxlKCk7XG5cblx0Y29uc3QgZ2V0X0Jvb2wgPSAoLi4udmFsKSA9PiBVdGlscy5maW5kTGFzdCh2YWwsIChjKSA9PiB0eXBlb2YgYyA9PT0gXCJib29sZWFuXCIpO1xuXHRjb25zdCBnZXRfU3RyID0gKC4uLnZhbCkgPT4gVXRpbHMuZmluZExhc3QodmFsLCAoYykgPT4gdHlwZW9mIGMgPT09IFwic3RyaW5nXCIpO1xuXHRjb25zdCBnZXRfRnVuID0gKC4uLnZhbCkgPT4gVXRpbHMuZmluZExhc3QodmFsLCAoYykgPT4gdHlwZW9mIGMgPT09IFwiZnVuY3Rpb25cIik7XG5cblx0Y29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdCAgICAvLyBvcHRpb24gXCJub1NvcnRcIiA6IGlmIHRydWUgaXQgZGlzYWJsZXMgZmlsZXMgc29ydGluZ1xuXHQgICAgbm9Tb3J0OiBmYWxzZSxcblx0ICAgIC8vIHJlYWQgZW50cmllcyBkdXJpbmcgbG9hZCAoaW5pdGlhbCBsb2FkaW5nIG1heSBiZSBzbG93ZXIpXG5cdCAgICByZWFkRW50cmllczogZmFsc2UsXG5cdCAgICAvLyBkZWZhdWx0IG1ldGhvZCBpcyBub25lXG5cdCAgICBtZXRob2Q6IFV0aWxzLkNvbnN0YW50cy5OT05FLFxuXHQgICAgLy8gZmlsZSBzeXN0ZW1cblx0ICAgIGZzOiBudWxsXG5cdH07XG5cblx0YWRtWmlwJDIgPSBmdW5jdGlvbiAoLyoqU3RyaW5nKi8gaW5wdXQsIC8qKiBvYmplY3QgKi8gb3B0aW9ucykge1xuXHQgICAgbGV0IGluQnVmZmVyID0gbnVsbDtcblxuXHQgICAgLy8gY3JlYXRlIG9iamVjdCBiYXNlZCBkZWZhdWx0IG9wdGlvbnMsIGFsbG93aW5nIHRoZW0gdG8gYmUgb3ZlcndyaXR0ZW5cblx0ICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGRlZmF1bHRPcHRpb25zKTtcblxuXHQgICAgLy8gdGVzdCBpbnB1dCB2YXJpYWJsZVxuXHQgICAgaWYgKGlucHV0ICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiBpbnB1dCkge1xuXHQgICAgICAgIC8vIGlmIHZhbHVlIGlzIG5vdCBidWZmZXIgd2UgYWNjZXB0IGl0IHRvIGJlIG9iamVjdCB3aXRoIG9wdGlvbnNcblx0ICAgICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG5cdCAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywgaW5wdXQpO1xuXHQgICAgICAgICAgICBpbnB1dCA9IG9wdHMuaW5wdXQgPyBvcHRzLmlucHV0IDogdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICBpZiAob3B0cy5pbnB1dCkgZGVsZXRlIG9wdHMuaW5wdXQ7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gaWYgaW5wdXQgaXMgYnVmZmVyXG5cdCAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcblx0ICAgICAgICAgICAgaW5CdWZmZXIgPSBpbnB1dDtcblx0ICAgICAgICAgICAgb3B0cy5tZXRob2QgPSBVdGlscy5Db25zdGFudHMuQlVGRkVSO1xuXHQgICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vIGFzc2lnbiBvcHRpb25zXG5cdCAgICBPYmplY3QuYXNzaWduKG9wdHMsIG9wdGlvbnMpO1xuXG5cdCAgICAvLyBpbnN0YW5jaWF0ZSB1dGlscyBmaWxlc3lzdGVtXG5cdCAgICBjb25zdCBmaWxldG9vbHMgPSBuZXcgVXRpbHMob3B0cyk7XG5cblx0ICAgIGlmICh0eXBlb2Ygb3B0cy5kZWNvZGVyICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvcHRzLmRlY29kZXIuZW5jb2RlICE9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIG9wdHMuZGVjb2Rlci5kZWNvZGUgIT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgIG9wdHMuZGVjb2RlciA9IFV0aWxzLmRlY29kZXI7XG5cdCAgICB9XG5cblx0ICAgIC8vIGlmIGlucHV0IGlzIGZpbGUgbmFtZSB3ZSByZXRyaWV2ZSBpdHMgY29udGVudFxuXHQgICAgaWYgKGlucHV0ICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnB1dCkge1xuXHQgICAgICAgIC8vIGxvYWQgemlwIGZpbGVcblx0ICAgICAgICBpZiAoZmlsZXRvb2xzLmZzLmV4aXN0c1N5bmMoaW5wdXQpKSB7XG5cdCAgICAgICAgICAgIG9wdHMubWV0aG9kID0gVXRpbHMuQ29uc3RhbnRzLkZJTEU7XG5cdCAgICAgICAgICAgIG9wdHMuZmlsZW5hbWUgPSBpbnB1dDtcblx0ICAgICAgICAgICAgaW5CdWZmZXIgPSBmaWxldG9vbHMuZnMucmVhZEZpbGVTeW5jKGlucHV0KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuSU5WQUxJRF9GSUxFTkFNRSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gY3JlYXRlIHZhcmlhYmxlXG5cdCAgICBjb25zdCBfemlwID0gbmV3IFppcEZpbGUoaW5CdWZmZXIsIG9wdHMpO1xuXG5cdCAgICBjb25zdCB7IGNhbm9uaWNhbCwgc2FuaXRpemUsIHppcG5hbWVmaXggfSA9IFV0aWxzO1xuXG5cdCAgICBmdW5jdGlvbiBnZXRFbnRyeSgvKipPYmplY3QqLyBlbnRyeSkge1xuXHQgICAgICAgIGlmIChlbnRyeSAmJiBfemlwKSB7XG5cdCAgICAgICAgICAgIHZhciBpdGVtO1xuXHQgICAgICAgICAgICAvLyBJZiBlbnRyeSB3YXMgZ2l2ZW4gYXMgYSBmaWxlIG5hbWVcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gXCJzdHJpbmdcIikgaXRlbSA9IF96aXAuZ2V0RW50cnkocHRoLnBvc2l4Lm5vcm1hbGl6ZShlbnRyeSkpO1xuXHQgICAgICAgICAgICAvLyBpZiBlbnRyeSB3YXMgZ2l2ZW4gYXMgYSBaaXBFbnRyeSBvYmplY3Rcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZW50cnkuZW50cnlOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBlbnRyeS5oZWFkZXIgIT09IFwidW5kZWZpbmVkXCIpIGl0ZW0gPSBfemlwLmdldEVudHJ5KGVudHJ5LmVudHJ5TmFtZSk7XG5cblx0ICAgICAgICAgICAgaWYgKGl0ZW0pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmaXhQYXRoKHppcFBhdGgpIHtcblx0ICAgICAgICBjb25zdCB7IGpvaW4sIG5vcm1hbGl6ZSwgc2VwIH0gPSBwdGgucG9zaXg7XG5cdCAgICAgICAgLy8gY29udmVydCB3aW5kb3dzIGZpbGUgc2VwYXJhdG9ycyBhbmQgbm9ybWFsaXplXG5cdCAgICAgICAgcmV0dXJuIGpvaW4oXCIuXCIsIG5vcm1hbGl6ZShzZXAgKyB6aXBQYXRoLnNwbGl0KFwiXFxcXFwiKS5qb2luKHNlcCkgKyBzZXApKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZmlsZW5hbWVGaWx0ZXIoZmlsdGVyZm4pIHtcblx0ICAgICAgICBpZiAoZmlsdGVyZm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0ICAgICAgICAgICAgLy8gaWYgZmlsdGVyIGlzIFJlZ0V4cCB3cmFwIGl0XG5cdCAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHJ4KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4LnRlc3QoZmlsZW5hbWUpO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSkoZmlsdGVyZm4pO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgZmlsdGVyZm4pIHtcblx0ICAgICAgICAgICAgLy8gaWYgZmlsdGVyIGlzIG5vdCBmdW5jdGlvbiB3ZSB3aWxsIHJlcGxhY2UgaXRcblx0ICAgICAgICAgICAgcmV0dXJuICgpID0+IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBmaWx0ZXJmbjtcblx0ICAgIH1cblxuXHQgICAgLy8ga2VlcCBsYXN0IGNoYXJhY3RlciBvbiBmb2xkZXJzXG5cdCAgICBjb25zdCByZWxhdGl2ZVBhdGggPSAobG9jYWwsIGVudHJ5KSA9PiB7XG5cdCAgICAgICAgbGV0IGxhc3RDaGFyID0gZW50cnkuc2xpY2UoLTEpO1xuXHQgICAgICAgIGxhc3RDaGFyID0gbGFzdENoYXIgPT09IGZpbGV0b29scy5zZXAgPyBmaWxldG9vbHMuc2VwIDogXCJcIjtcblx0ICAgICAgICByZXR1cm4gcHRoLnJlbGF0aXZlKGxvY2FsLCBlbnRyeSkgKyBsYXN0Q2hhcjtcblx0ICAgIH07XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRXh0cmFjdHMgdGhlIGdpdmVuIGVudHJ5IGZyb20gdGhlIGFyY2hpdmUgYW5kIHJldHVybnMgdGhlIGNvbnRlbnQgYXMgYSBCdWZmZXIgb2JqZWN0XG5cdCAgICAgICAgICogQHBhcmFtIHtaaXBFbnRyeXxzdHJpbmd9IGVudHJ5IFppcEVudHJ5IG9iamVjdCBvciBTdHJpbmcgd2l0aCB0aGUgZnVsbCBwYXRoIG9mIHRoZSBlbnRyeVxuXHQgICAgICAgICAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gW3Bhc3NdIC0gcGFzc3dvcmRcblx0ICAgICAgICAgKiBAcmV0dXJuIEJ1ZmZlciBvciBOdWxsIGluIGNhc2Ugb2YgZXJyb3Jcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZWFkRmlsZTogZnVuY3Rpb24gKGVudHJ5LCBwYXNzKSB7XG5cdCAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuXHQgICAgICAgICAgICByZXR1cm4gKGl0ZW0gJiYgaXRlbS5nZXREYXRhKHBhc3MpKSB8fCBudWxsO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIGhvdyBtYW55IGNoaWxkIGVsZW1lbnRzIGhhcyBvbiBlbnRyeSAoZGlyZWN0b3JpZXMpIG9uIGZpbGVzIGl0IGlzIGFsd2F5cyAwXG5cdCAgICAgICAgICogQHBhcmFtIHtaaXBFbnRyeXxzdHJpbmd9IGVudHJ5IFppcEVudHJ5IG9iamVjdCBvciBTdHJpbmcgd2l0aCB0aGUgZnVsbCBwYXRoIG9mIHRoZSBlbnRyeVxuXHQgICAgICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNoaWxkQ291bnQ6IGZ1bmN0aW9uIChlbnRyeSkge1xuXHQgICAgICAgICAgICBjb25zdCBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuXHQgICAgICAgICAgICBpZiAoaXRlbSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIF96aXAuZ2V0Q2hpbGRDb3VudChpdGVtKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBc3luY2hyb25vdXMgcmVhZEZpbGVcblx0ICAgICAgICAgKiBAcGFyYW0ge1ppcEVudHJ5fHN0cmluZ30gZW50cnkgWmlwRW50cnkgb2JqZWN0IG9yIFN0cmluZyB3aXRoIHRoZSBmdWxsIHBhdGggb2YgdGhlIGVudHJ5XG5cdCAgICAgICAgICogQHBhcmFtIHtjYWxsYmFja30gY2FsbGJhY2tcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4gQnVmZmVyIG9yIE51bGwgaW4gY2FzZSBvZiBlcnJvclxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlYWRGaWxlQXN5bmM6IGZ1bmN0aW9uIChlbnRyeSwgY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRFbnRyeShlbnRyeSk7XG5cdCAgICAgICAgICAgIGlmIChpdGVtKSB7XG5cdCAgICAgICAgICAgICAgICBpdGVtLmdldERhdGFBc3luYyhjYWxsYmFjayk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBcImdldEVudHJ5IGZhaWxlZCBmb3I6XCIgKyBlbnRyeSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRXh0cmFjdHMgdGhlIGdpdmVuIGVudHJ5IGZyb20gdGhlIGFyY2hpdmUgYW5kIHJldHVybnMgdGhlIGNvbnRlbnQgYXMgcGxhaW4gdGV4dCBpbiB0aGUgZ2l2ZW4gZW5jb2Rpbmdcblx0ICAgICAgICAgKiBAcGFyYW0ge1ppcEVudHJ5fHN0cmluZ30gZW50cnkgLSBaaXBFbnRyeSBvYmplY3Qgb3IgU3RyaW5nIHdpdGggdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZW50cnlcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgLSBPcHRpb25hbC4gSWYgbm8gZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHV0ZjggaXMgdXNlZFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiBTdHJpbmdcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZWFkQXNUZXh0OiBmdW5jdGlvbiAoZW50cnksIGVuY29kaW5nKSB7XG5cdCAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuXHQgICAgICAgICAgICBpZiAoaXRlbSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBpdGVtLmdldERhdGEoKTtcblx0ICAgICAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoZW5jb2RpbmcgfHwgXCJ1dGY4XCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBcIlwiO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBc3luY2hyb25vdXMgcmVhZEFzVGV4dFxuXHQgICAgICAgICAqIEBwYXJhbSB7WmlwRW50cnl8c3RyaW5nfSBlbnRyeSBaaXBFbnRyeSBvYmplY3Qgb3IgU3RyaW5nIHdpdGggdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZW50cnlcblx0ICAgICAgICAgKiBAcGFyYW0ge2NhbGxiYWNrfSBjYWxsYmFja1xuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2RpbmddIC0gT3B0aW9uYWwuIElmIG5vIGVuY29kaW5nIGlzIHNwZWNpZmllZCB1dGY4IGlzIHVzZWRcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4gU3RyaW5nXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVhZEFzVGV4dEFzeW5jOiBmdW5jdGlvbiAoZW50cnksIGNhbGxiYWNrLCBlbmNvZGluZykge1xuXHQgICAgICAgICAgICB2YXIgaXRlbSA9IGdldEVudHJ5KGVudHJ5KTtcblx0ICAgICAgICAgICAgaWYgKGl0ZW0pIHtcblx0ICAgICAgICAgICAgICAgIGl0ZW0uZ2V0RGF0YUFzeW5jKGZ1bmN0aW9uIChkYXRhLCBlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEsIGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhLnRvU3RyaW5nKGVuY29kaW5nIHx8IFwidXRmOFwiKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soXCJcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjayhcIlwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZW1vdmUgdGhlIGVudHJ5IGZyb20gdGhlIGZpbGUgb3IgdGhlIGVudHJ5IGFuZCBhbGwgaXQncyBuZXN0ZWQgZGlyZWN0b3JpZXMgYW5kIGZpbGVzIGlmIHRoZSBnaXZlbiBlbnRyeSBpcyBhIGRpcmVjdG9yeVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtaaXBFbnRyeXxzdHJpbmd9IGVudHJ5XG5cdCAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZGVsZXRlRmlsZTogZnVuY3Rpb24gKGVudHJ5LCB3aXRoc3ViZm9sZGVycyA9IHRydWUpIHtcblx0ICAgICAgICAgICAgLy8gQFRPRE86IHRlc3QgZGVsZXRlRmlsZVxuXHQgICAgICAgICAgICB2YXIgaXRlbSA9IGdldEVudHJ5KGVudHJ5KTtcblx0ICAgICAgICAgICAgaWYgKGl0ZW0pIHtcblx0ICAgICAgICAgICAgICAgIF96aXAuZGVsZXRlRmlsZShpdGVtLmVudHJ5TmFtZSwgd2l0aHN1YmZvbGRlcnMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlbW92ZSB0aGUgZW50cnkgZnJvbSB0aGUgZmlsZSBvciBkaXJlY3Rvcnkgd2l0aG91dCBhZmZlY3RpbmcgYW55IG5lc3RlZCBlbnRyaWVzXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1ppcEVudHJ5fHN0cmluZ30gZW50cnlcblx0ICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBkZWxldGVFbnRyeTogZnVuY3Rpb24gKGVudHJ5KSB7XG5cdCAgICAgICAgICAgIC8vIEBUT0RPOiB0ZXN0IGRlbGV0ZUVudHJ5XG5cdCAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuXHQgICAgICAgICAgICBpZiAoaXRlbSkge1xuXHQgICAgICAgICAgICAgICAgX3ppcC5kZWxldGVFbnRyeShpdGVtLmVudHJ5TmFtZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBhIGNvbW1lbnQgdG8gdGhlIHppcC4gVGhlIHppcCBtdXN0IGJlIHJld3JpdHRlbiBhZnRlciBhZGRpbmcgdGhlIGNvbW1lbnQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tbWVudFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGFkZFppcENvbW1lbnQ6IGZ1bmN0aW9uIChjb21tZW50KSB7XG5cdCAgICAgICAgICAgIC8vIEBUT0RPOiB0ZXN0IGFkZFppcENvbW1lbnRcblx0ICAgICAgICAgICAgX3ppcC5jb21tZW50ID0gY29tbWVudDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyB0aGUgemlwIGNvbW1lbnRcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4gU3RyaW5nXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZ2V0WmlwQ29tbWVudDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX3ppcC5jb21tZW50IHx8IFwiXCI7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgYSBjb21tZW50IHRvIGEgc3BlY2lmaWVkIHppcEVudHJ5LiBUaGUgemlwIG11c3QgYmUgcmV3cml0dGVuIGFmdGVyIGFkZGluZyB0aGUgY29tbWVudFxuXHQgICAgICAgICAqIFRoZSBjb21tZW50IGNhbm5vdCBleGNlZWQgNjU1MzUgY2hhcmFjdGVycyBpbiBsZW5ndGhcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7WmlwRW50cnl9IGVudHJ5XG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbW1lbnRcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBhZGRaaXBFbnRyeUNvbW1lbnQ6IGZ1bmN0aW9uIChlbnRyeSwgY29tbWVudCkge1xuXHQgICAgICAgICAgICB2YXIgaXRlbSA9IGdldEVudHJ5KGVudHJ5KTtcblx0ICAgICAgICAgICAgaWYgKGl0ZW0pIHtcblx0ICAgICAgICAgICAgICAgIGl0ZW0uY29tbWVudCA9IGNvbW1lbnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyB0aGUgY29tbWVudCBvZiB0aGUgc3BlY2lmaWVkIGVudHJ5XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1ppcEVudHJ5fSBlbnRyeVxuXHQgICAgICAgICAqIEByZXR1cm4gU3RyaW5nXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZ2V0WmlwRW50cnlDb21tZW50OiBmdW5jdGlvbiAoZW50cnkpIHtcblx0ICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRFbnRyeShlbnRyeSk7XG5cdCAgICAgICAgICAgIGlmIChpdGVtKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5jb21tZW50IHx8IFwiXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhlIGNvbnRlbnQgb2YgYW4gZXhpc3RpbmcgZW50cnkgaW5zaWRlIHRoZSBhcmNoaXZlLiBUaGUgemlwIG11c3QgYmUgcmV3cml0dGVuIGFmdGVyIHVwZGF0aW5nIHRoZSBjb250ZW50XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1ppcEVudHJ5fSBlbnRyeVxuXHQgICAgICAgICAqIEBwYXJhbSB7QnVmZmVyfSBjb250ZW50XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlRmlsZTogZnVuY3Rpb24gKGVudHJ5LCBjb250ZW50KSB7XG5cdCAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuXHQgICAgICAgICAgICBpZiAoaXRlbSkge1xuXHQgICAgICAgICAgICAgICAgaXRlbS5zZXREYXRhKGNvbnRlbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgYSBmaWxlIGZyb20gdGhlIGRpc2sgdG8gdGhlIGFyY2hpdmVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbFBhdGggRmlsZSB0byBhZGQgdG8gemlwXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt6aXBQYXRoXSBPcHRpb25hbCBwYXRoIGluc2lkZSB0aGUgemlwXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt6aXBOYW1lXSBPcHRpb25hbCBuYW1lIGZvciB0aGUgZmlsZVxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gT3B0aW9uYWwgZmlsZSBjb21tZW50XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgYWRkTG9jYWxGaWxlOiBmdW5jdGlvbiAobG9jYWxQYXRoLCB6aXBQYXRoLCB6aXBOYW1lLCBjb21tZW50KSB7XG5cdCAgICAgICAgICAgIGlmIChmaWxldG9vbHMuZnMuZXhpc3RzU3luYyhsb2NhbFBhdGgpKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBmaXggWmlwUGF0aFxuXHQgICAgICAgICAgICAgICAgemlwUGF0aCA9IHppcFBhdGggPyBmaXhQYXRoKHppcFBhdGgpIDogXCJcIjtcblxuXHQgICAgICAgICAgICAgICAgLy8gcCAtIGxvY2FsIGZpbGUgbmFtZVxuXHQgICAgICAgICAgICAgICAgY29uc3QgcCA9IHB0aC53aW4zMi5iYXNlbmFtZShwdGgud2luMzIubm9ybWFsaXplKGxvY2FsUGF0aCkpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBhZGQgZmlsZSBuYW1lIGludG8gemlwcGF0aFxuXHQgICAgICAgICAgICAgICAgemlwUGF0aCArPSB6aXBOYW1lID8gemlwTmFtZSA6IHA7XG5cblx0ICAgICAgICAgICAgICAgIC8vIHJlYWQgZmlsZSBhdHRyaWJ1dGVzXG5cdCAgICAgICAgICAgICAgICBjb25zdCBfYXR0ciA9IGZpbGV0b29scy5mcy5zdGF0U3luYyhsb2NhbFBhdGgpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBnZXQgZmlsZSBjb250ZW50XG5cdCAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gX2F0dHIuaXNGaWxlKCkgPyBmaWxldG9vbHMuZnMucmVhZEZpbGVTeW5jKGxvY2FsUGF0aCkgOiBCdWZmZXIuYWxsb2MoMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIGlmIGZvbGRlclxuXHQgICAgICAgICAgICAgICAgaWYgKF9hdHRyLmlzRGlyZWN0b3J5KCkpIHppcFBhdGggKz0gZmlsZXRvb2xzLnNlcDtcblxuXHQgICAgICAgICAgICAgICAgLy8gYWRkIGZpbGUgaW50byB6aXAgZmlsZVxuXHQgICAgICAgICAgICAgICAgdGhpcy5hZGRGaWxlKHppcFBhdGgsIGRhdGEsIGNvbW1lbnQsIF9hdHRyKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5GSUxFX05PVF9GT1VORChsb2NhbFBhdGgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENhbGxiYWNrIGZvciBzaG93aW5nIGlmIGV2ZXJ5dGhpbmcgd2FzIGRvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAY2FsbGJhY2sgZG9uZUNhbGxiYWNrXG5cdCAgICAgICAgICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3Igb2JqZWN0XG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkb25lIC0gd2FzIHJlcXVlc3QgZnVsbHkgY29tcGxldGVkXG5cdCAgICAgICAgICovXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIGEgZmlsZSBmcm9tIHRoZSBkaXNrIHRvIHRoZSBhcmNoaXZlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0geyhvYmplY3R8c3RyaW5nKX0gb3B0aW9ucyAtIG9wdGlvbnMgb2JqZWN0LCBpZiBpdCBpcyBzdHJpbmcgaXQgdXMgdXNlZCBhcyBsb2NhbFBhdGguXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxQYXRoIC0gTG9jYWwgcGF0aCB0byB0aGUgZmlsZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29tbWVudF0gLSBPcHRpb25hbCBmaWxlIGNvbW1lbnQuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnppcFBhdGhdIC0gT3B0aW9uYWwgcGF0aCBpbnNpZGUgdGhlIHppcFxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy56aXBOYW1lXSAtIE9wdGlvbmFsIG5hbWUgZm9yIHRoZSBmaWxlXG5cdCAgICAgICAgICogQHBhcmFtIHtkb25lQ2FsbGJhY2t9IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRoYXQgaGFuZGxlcyB0aGUgcmVzcG9uc2UuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgYWRkTG9jYWxGaWxlQXN5bmM6IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuXHQgICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zIDogeyBsb2NhbFBhdGg6IG9wdGlvbnMgfTtcblx0ICAgICAgICAgICAgY29uc3QgbG9jYWxQYXRoID0gcHRoLnJlc29sdmUob3B0aW9ucy5sb2NhbFBhdGgpO1xuXHQgICAgICAgICAgICBjb25zdCB7IGNvbW1lbnQgfSA9IG9wdGlvbnM7XG5cdCAgICAgICAgICAgIGxldCB7IHppcFBhdGgsIHppcE5hbWUgfSA9IG9wdGlvbnM7XG5cdCAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgIGZpbGV0b29scy5mcy5zdGF0KGxvY2FsUGF0aCwgZnVuY3Rpb24gKGVyciwgc3RhdHMpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIsIGZhbHNlKTtcblx0ICAgICAgICAgICAgICAgIC8vIGZpeCBaaXBQYXRoXG5cdCAgICAgICAgICAgICAgICB6aXBQYXRoID0gemlwUGF0aCA/IGZpeFBhdGgoemlwUGF0aCkgOiBcIlwiO1xuXHQgICAgICAgICAgICAgICAgLy8gcCAtIGxvY2FsIGZpbGUgbmFtZVxuXHQgICAgICAgICAgICAgICAgY29uc3QgcCA9IHB0aC53aW4zMi5iYXNlbmFtZShwdGgud2luMzIubm9ybWFsaXplKGxvY2FsUGF0aCkpO1xuXHQgICAgICAgICAgICAgICAgLy8gYWRkIGZpbGUgbmFtZSBpbnRvIHppcHBhdGhcblx0ICAgICAgICAgICAgICAgIHppcFBhdGggKz0gemlwTmFtZSA/IHppcE5hbWUgOiBwO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoc3RhdHMuaXNGaWxlKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmaWxldG9vbHMuZnMucmVhZEZpbGUobG9jYWxQYXRoLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIsIGZhbHNlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRGaWxlKHppcFBhdGgsIGRhdGEsIGNvbW1lbnQsIHN0YXRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjaywgdW5kZWZpbmVkLCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHppcFBhdGggKz0gZmlsZXRvb2xzLnNlcDtcblx0ICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZEZpbGUoemlwUGF0aCwgQnVmZmVyLmFsbG9jKDApLCBjb21tZW50LCBzdGF0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjaywgdW5kZWZpbmVkLCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgYSBsb2NhbCBkaXJlY3RvcnkgYW5kIGFsbCBpdHMgbmVzdGVkIGZpbGVzIGFuZCBkaXJlY3RvcmllcyB0byB0aGUgYXJjaGl2ZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsUGF0aCAtIGxvY2FsIHBhdGggdG8gdGhlIGZvbGRlclxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbemlwUGF0aF0gLSBvcHRpb25hbCBwYXRoIGluc2lkZSB6aXBcblx0ICAgICAgICAgKiBAcGFyYW0geyhSZWdFeHB8ZnVuY3Rpb24pfSBbZmlsdGVyXSAtIG9wdGlvbmFsIFJlZ0V4cCBvciBGdW5jdGlvbiBpZiBmaWxlcyBtYXRjaCB3aWxsIGJlIGluY2x1ZGVkLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGFkZExvY2FsRm9sZGVyOiBmdW5jdGlvbiAobG9jYWxQYXRoLCB6aXBQYXRoLCBmaWx0ZXIpIHtcblx0ICAgICAgICAgICAgLy8gUHJlcGFyZSBmaWx0ZXJcblx0ICAgICAgICAgICAgZmlsdGVyID0gZmlsZW5hbWVGaWx0ZXIoZmlsdGVyKTtcblxuXHQgICAgICAgICAgICAvLyBmaXggWmlwUGF0aFxuXHQgICAgICAgICAgICB6aXBQYXRoID0gemlwUGF0aCA/IGZpeFBhdGgoemlwUGF0aCkgOiBcIlwiO1xuXG5cdCAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgcGF0aCBmaXJzdFxuXHQgICAgICAgICAgICBsb2NhbFBhdGggPSBwdGgubm9ybWFsaXplKGxvY2FsUGF0aCk7XG5cblx0ICAgICAgICAgICAgaWYgKGZpbGV0b29scy5mcy5leGlzdHNTeW5jKGxvY2FsUGF0aCkpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gZmlsZXRvb2xzLmZpbmRGaWxlcyhsb2NhbFBhdGgpO1xuXHQgICAgICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpbGVwYXRoIG9mIGl0ZW1zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwdGguam9pbih6aXBQYXRoLCByZWxhdGl2ZVBhdGgobG9jYWxQYXRoLCBmaWxlcGF0aCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKHApKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZExvY2FsRmlsZShmaWxlcGF0aCwgcHRoLmRpcm5hbWUocCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLkZJTEVfTk9UX0ZPVU5EKGxvY2FsUGF0aCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQXN5bmNocm9ub3VzIGFkZExvY2FsRm9sZGVyXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsUGF0aFxuXHQgICAgICAgICAqIEBwYXJhbSB7Y2FsbGJhY2t9IGNhbGxiYWNrXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt6aXBQYXRoXSBvcHRpb25hbCBwYXRoIGluc2lkZSB6aXBcblx0ICAgICAgICAgKiBAcGFyYW0ge1JlZ0V4cHxmdW5jdGlvbn0gW2ZpbHRlcl0gb3B0aW9uYWwgUmVnRXhwIG9yIEZ1bmN0aW9uIGlmIGZpbGVzIG1hdGNoIHdpbGxcblx0ICAgICAgICAgKiAgICAgICAgICAgICAgIGJlIGluY2x1ZGVkLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGFkZExvY2FsRm9sZGVyQXN5bmM6IGZ1bmN0aW9uIChsb2NhbFBhdGgsIGNhbGxiYWNrLCB6aXBQYXRoLCBmaWx0ZXIpIHtcblx0ICAgICAgICAgICAgLy8gUHJlcGFyZSBmaWx0ZXJcblx0ICAgICAgICAgICAgZmlsdGVyID0gZmlsZW5hbWVGaWx0ZXIoZmlsdGVyKTtcblxuXHQgICAgICAgICAgICAvLyBmaXggWmlwUGF0aFxuXHQgICAgICAgICAgICB6aXBQYXRoID0gemlwUGF0aCA/IGZpeFBhdGgoemlwUGF0aCkgOiBcIlwiO1xuXG5cdCAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgcGF0aCBmaXJzdFxuXHQgICAgICAgICAgICBsb2NhbFBhdGggPSBwdGgubm9ybWFsaXplKGxvY2FsUGF0aCk7XG5cblx0ICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgICAgICAgICBmaWxldG9vbHMuZnMub3Blbihsb2NhbFBhdGgsIFwiclwiLCBmdW5jdGlvbiAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCBVdGlscy5FcnJvcnMuRklMRV9OT1RfRk9VTkQobG9jYWxQYXRoKSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgZXJyKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gZmlsZXRvb2xzLmZpbmRGaWxlcyhsb2NhbFBhdGgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpID0gLTE7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGl0ZW1zLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVwYXRoID0gaXRlbXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHJlbGF0aXZlUGF0aChsb2NhbFBhdGgsIGZpbGVwYXRoKS5zcGxpdChcIlxcXFxcIikuam9pbihcIi9cIik7IC8vd2luZG93cyBmaXhcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5vcm1hbGl6ZShcIk5GRFwiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1MDMwMC1cXHUwMzZmXS9nLCBcIlwiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXlxceDIwLVxceDdFXS9nLCBcIlwiKTsgLy8gYWNjZW50IGZpeFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcihwKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy5mcy5zdGF0KGZpbGVwYXRoLCBmdW5jdGlvbiAoZXIwLCBzdGF0cykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXIwKSBjYWxsYmFjayh1bmRlZmluZWQsIGVyMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0cy5pc0ZpbGUoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLmZzLnJlYWRGaWxlKGZpbGVwYXRoLCBmdW5jdGlvbiAoZXIxLCBkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIGVyMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRGaWxlKHppcFBhdGggKyBwLCBkYXRhLCBcIlwiLCBzdGF0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkRmlsZSh6aXBQYXRoICsgcCArIFwiL1wiLCBCdWZmZXIuYWxsb2MoMCksIFwiXCIsIHN0YXRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSwgdW5kZWZpbmVkKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIGEgbG9jYWwgZGlyZWN0b3J5IGFuZCBhbGwgaXRzIG5lc3RlZCBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgdG8gdGhlIGFyY2hpdmVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0IHwgc3RyaW5nfSBvcHRpb25zIC0gb3B0aW9ucyBvYmplY3QsIGlmIGl0IGlzIHN0cmluZyBpdCB1cyB1c2VkIGFzIGxvY2FsUGF0aC5cblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbFBhdGggLSBMb2NhbCBwYXRoIHRvIHRoZSBmb2xkZXIuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnppcFBhdGhdIC0gb3B0aW9uYWwgcGF0aCBpbnNpZGUgemlwLlxuXHQgICAgICAgICAqIEBwYXJhbSB7UmVnRXhwfGZ1bmN0aW9ufSBbb3B0aW9ucy5maWx0ZXJdIC0gb3B0aW9uYWwgUmVnRXhwIG9yIEZ1bmN0aW9uIGlmIGZpbGVzIG1hdGNoIHdpbGwgYmUgaW5jbHVkZWQuXG5cdCAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbnxzdHJpbmd9IFtvcHRpb25zLm5hbWVmaXhdIC0gb3B0aW9uYWwgZnVuY3Rpb24gdG8gaGVscCBmaXggZmlsZW5hbWVcblx0ICAgICAgICAgKiBAcGFyYW0ge2RvbmVDYWxsYmFja30gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdGhhdCBoYW5kbGVzIHRoZSByZXNwb25zZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGFkZExvY2FsRm9sZGVyQXN5bmMyOiBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMgOiB7IGxvY2FsUGF0aDogb3B0aW9ucyB9O1xuXHQgICAgICAgICAgICBsb2NhbFBhdGggPSBwdGgucmVzb2x2ZShmaXhQYXRoKG9wdGlvbnMubG9jYWxQYXRoKSk7XG5cdCAgICAgICAgICAgIGxldCB7IHppcFBhdGgsIGZpbHRlciwgbmFtZWZpeCB9ID0gb3B0aW9ucztcblxuXHQgICAgICAgICAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdCAgICAgICAgICAgICAgICBmaWx0ZXIgPSAoZnVuY3Rpb24gKHJ4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcngudGVzdChmaWxlbmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH0pKGZpbHRlcik7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgZmlsdGVyKSB7XG5cdCAgICAgICAgICAgICAgICBmaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gZml4IFppcFBhdGhcblx0ICAgICAgICAgICAgemlwUGF0aCA9IHppcFBhdGggPyBmaXhQYXRoKHppcFBhdGgpIDogXCJcIjtcblxuXHQgICAgICAgICAgICAvLyBDaGVjayBOYW1lZml4IGZ1bmN0aW9uXG5cdCAgICAgICAgICAgIGlmIChuYW1lZml4ID09IFwibGF0aW4xXCIpIHtcblx0ICAgICAgICAgICAgICAgIG5hbWVmaXggPSAoc3RyKSA9PlxuXHQgICAgICAgICAgICAgICAgICAgIHN0clxuXHQgICAgICAgICAgICAgICAgICAgICAgICAubm9ybWFsaXplKFwiTkZEXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1MDMwMC1cXHUwMzZmXS9nLCBcIlwiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW15cXHgyMC1cXHg3RV0vZywgXCJcIik7IC8vIGFjY2VudCBmaXggKGxhdGluMSBjaGFyYWNlcnMgb25seSlcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZWZpeCAhPT0gXCJmdW5jdGlvblwiKSBuYW1lZml4ID0gKHN0cikgPT4gc3RyO1xuXG5cdCAgICAgICAgICAgIC8vIGludGVybmFsLCBjcmVhdGUgcmVsYXRpdmUgcGF0aCArIGZpeCB0aGUgbmFtZVxuXHQgICAgICAgICAgICBjb25zdCByZWxQYXRoRml4ID0gKGVudHJ5KSA9PiBwdGguam9pbih6aXBQYXRoLCBuYW1lZml4KHJlbGF0aXZlUGF0aChsb2NhbFBhdGgsIGVudHJ5KSkpO1xuXHQgICAgICAgICAgICBjb25zdCBmaWxlTmFtZUZpeCA9IChlbnRyeSkgPT4gcHRoLndpbjMyLmJhc2VuYW1lKHB0aC53aW4zMi5ub3JtYWxpemUobmFtZWZpeChlbnRyeSkpKTtcblxuXHQgICAgICAgICAgICBmaWxldG9vbHMuZnMub3Blbihsb2NhbFBhdGgsIFwiclwiLCBmdW5jdGlvbiAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCBVdGlscy5FcnJvcnMuRklMRV9OT1RfRk9VTkQobG9jYWxQYXRoKSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgZXJyKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLmZpbmRGaWxlc0FzeW5jKGxvY2FsUGF0aCwgZnVuY3Rpb24gKGVyciwgZmlsZUVudHJpZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVFbnRyaWVzID0gZmlsZUVudHJpZXMuZmlsdGVyKChkaXIpID0+IGZpbHRlcihyZWxQYXRoRml4KGRpcikpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlRW50cmllcy5sZW5ndGgpIGNhbGxiYWNrKHVuZGVmaW5lZCwgZmFsc2UpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVFbnRyaWVzLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKG5leHQsIGVudHJ5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIGRvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciB8fCBkb25lID09PSBmYWxzZSkgcmV0dXJuIHNldEltbWVkaWF0ZShuZXh0LCBlcnIsIGZhbHNlKTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZExvY2FsRmlsZUFzeW5jKFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGF0aDogZW50cnksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemlwUGF0aDogcHRoLmRpcm5hbWUocmVsUGF0aEZpeChlbnRyeSkpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHppcE5hbWU6IGZpbGVOYW1lRml4KGVudHJ5KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2FsbGJhY2spXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIGEgbG9jYWwgZGlyZWN0b3J5IGFuZCBhbGwgaXRzIG5lc3RlZCBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgdG8gdGhlIGFyY2hpdmVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbFBhdGggLSBwYXRoIHdoZXJlIGZpbGVzIHdpbGwgYmUgZXh0cmFjdGVkXG5cdCAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gb3B0aW9uYWwgcHJvcGVydGllc1xuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMuemlwUGF0aF0gLSBvcHRpb25hbCBwYXRoIGluc2lkZSB6aXBcblx0ICAgICAgICAgKiBAcGFyYW0ge1JlZ0V4cHxmdW5jdGlvbn0gW3Byb3BzLmZpbHRlcl0gLSBvcHRpb25hbCBSZWdFeHAgb3IgRnVuY3Rpb24gaWYgZmlsZXMgbWF0Y2ggd2lsbCBiZSBpbmNsdWRlZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufHN0cmluZ30gW3Byb3BzLm5hbWVmaXhdIC0gb3B0aW9uYWwgZnVuY3Rpb24gdG8gaGVscCBmaXggZmlsZW5hbWVcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBhZGRMb2NhbEZvbGRlclByb21pc2U6IGZ1bmN0aW9uIChsb2NhbFBhdGgsIHByb3BzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFkZExvY2FsRm9sZGVyQXN5bmMyKE9iamVjdC5hc3NpZ24oeyBsb2NhbFBhdGggfSwgcHJvcHMpLCAoZXJyLCBkb25lKSA9PiB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHJlc29sdmUodGhpcyk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFsbG93cyB5b3UgdG8gY3JlYXRlIGEgZW50cnkgKGZpbGUgb3IgZGlyZWN0b3J5KSBpbiB0aGUgemlwIGZpbGUuXG5cdCAgICAgICAgICogSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgZGlyZWN0b3J5IHRoZSBlbnRyeU5hbWUgbXVzdCBlbmQgaW4gLyBhbmQgYSBudWxsIGJ1ZmZlciBzaG91bGQgYmUgcHJvdmlkZWQuXG5cdCAgICAgICAgICogQ29tbWVudCBhbmQgYXR0cmlidXRlcyBhcmUgb3B0aW9uYWxcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeU5hbWVcblx0ICAgICAgICAgKiBAcGFyYW0ge0J1ZmZlciB8IHN0cmluZ30gY29udGVudCAtIGZpbGUgY29udGVudCBhcyBidWZmZXIgb3IgdXRmOCBjb2RlZCBzdHJpbmdcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIC0gZmlsZSBjb21tZW50XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXIgfCBvYmplY3R9IFthdHRyXSAtIG51bWJlciBhcyB1bml4IGZpbGUgcGVybWlzc2lvbnMsIG9iamVjdCBhcyBmaWxlc3lzdGVtIFN0YXRzIG9iamVjdFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGFkZEZpbGU6IGZ1bmN0aW9uIChlbnRyeU5hbWUsIGNvbnRlbnQsIGNvbW1lbnQsIGF0dHIpIHtcblx0ICAgICAgICAgICAgZW50cnlOYW1lID0gemlwbmFtZWZpeChlbnRyeU5hbWUpO1xuXHQgICAgICAgICAgICBsZXQgZW50cnkgPSBnZXRFbnRyeShlbnRyeU5hbWUpO1xuXHQgICAgICAgICAgICBjb25zdCB1cGRhdGUgPSBlbnRyeSAhPSBudWxsO1xuXG5cdCAgICAgICAgICAgIC8vIHByZXBhcmUgbmV3IGVudHJ5XG5cdCAgICAgICAgICAgIGlmICghdXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICBlbnRyeSA9IG5ldyBaaXBFbnRyeShvcHRzKTtcblx0ICAgICAgICAgICAgICAgIGVudHJ5LmVudHJ5TmFtZSA9IGVudHJ5TmFtZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbnRyeS5jb21tZW50ID0gY29tbWVudCB8fCBcIlwiO1xuXG5cdCAgICAgICAgICAgIGNvbnN0IGlzU3RhdCA9IFwib2JqZWN0XCIgPT09IHR5cGVvZiBhdHRyICYmIGF0dHIgaW5zdGFuY2VvZiBmaWxldG9vbHMuZnMuU3RhdHM7XG5cblx0ICAgICAgICAgICAgLy8gbGFzdCBtb2RpZmljYXRpb24gdGltZSBmcm9tIGZpbGUgc3RhdHNcblx0ICAgICAgICAgICAgaWYgKGlzU3RhdCkge1xuXHQgICAgICAgICAgICAgICAgZW50cnkuaGVhZGVyLnRpbWUgPSBhdHRyLm10aW1lO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGZpbGUgYXR0cmlidXRlXG5cdCAgICAgICAgICAgIHZhciBmaWxlYXR0ciA9IGVudHJ5LmlzRGlyZWN0b3J5ID8gMHgxMCA6IDA7IC8vIChNUy1ET1MgZGlyZWN0b3J5IGZsYWcpXG5cblx0ICAgICAgICAgICAgLy8gZXh0ZW5kZWQgYXR0cmlidXRlcyBmaWVsZCBmb3IgVW5peFxuXHQgICAgICAgICAgICAvLyBzZXQgZmlsZSB0eXBlIGVpdGhlciBTX0lGRElSIC8gU19JRlJFR1xuXHQgICAgICAgICAgICBsZXQgdW5peCA9IGVudHJ5LmlzRGlyZWN0b3J5ID8gMHg0MDAwIDogMHg4MDAwO1xuXG5cdCAgICAgICAgICAgIGlmIChpc1N0YXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEZpbGUgYXR0cmlidXRlcyBmcm9tIGZpbGUgc3RhdHNcblx0ICAgICAgICAgICAgICAgIHVuaXggfD0gMHhmZmYgJiBhdHRyLm1vZGU7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIGF0dHIpIHtcblx0ICAgICAgICAgICAgICAgIC8vIGF0dHIgZnJvbSBnaXZlbiBhdHRyIHZhbHVlc1xuXHQgICAgICAgICAgICAgICAgdW5peCB8PSAweGZmZiAmIGF0dHI7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHZhbHVlczpcblx0ICAgICAgICAgICAgICAgIHVuaXggfD0gZW50cnkuaXNEaXJlY3RvcnkgPyAwbzc1NSA6IDBvNjQ0OyAvLyBwZXJtaXNzaW9ucyAoZHJ3eHIteHIteCkgb3IgKC1yLXdyLS1yLS0pXG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBmaWxlYXR0ciA9IChmaWxlYXR0ciB8ICh1bml4IDw8IDE2KSkgPj4+IDA7IC8vIGFkZCBhdHRyaWJ1dGVzXG5cblx0ICAgICAgICAgICAgZW50cnkuYXR0ciA9IGZpbGVhdHRyO1xuXG5cdCAgICAgICAgICAgIGVudHJ5LnNldERhdGEoY29udGVudCk7XG5cdCAgICAgICAgICAgIGlmICghdXBkYXRlKSBfemlwLnNldEVudHJ5KGVudHJ5KTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZW50cnk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgWmlwRW50cnkgb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGZpbGVzIGFuZCBmb2xkZXJzIGluc2lkZSB0aGUgYXJjaGl2ZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXNzd29yZF1cblx0ICAgICAgICAgKiBAcmV0dXJucyBBcnJheVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGdldEVudHJpZXM6IGZ1bmN0aW9uIChwYXNzd29yZCkge1xuXHQgICAgICAgICAgICBfemlwLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG5cdCAgICAgICAgICAgIHJldHVybiBfemlwID8gX3ppcC5lbnRyaWVzIDogW107XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgYSBaaXBFbnRyeSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBmaWxlIG9yIGZvbGRlciBzcGVjaWZpZWQgYnkgYGBuYW1lYGAuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgICAgICAgICAqIEByZXR1cm4gWmlwRW50cnlcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBnZXRFbnRyeTogZnVuY3Rpb24gKC8qKlN0cmluZyovIG5hbWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGdldEVudHJ5KG5hbWUpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXRFbnRyeUNvdW50OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfemlwLmdldEVudHJ5Q291bnQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZm9yRWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfemlwLmZvckVhY2goY2FsbGJhY2spO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFeHRyYWN0cyB0aGUgZ2l2ZW4gZW50cnkgdG8gdGhlIGdpdmVuIHRhcmdldFBhdGhcblx0ICAgICAgICAgKiBJZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnkgaW5zaWRlIHRoZSBhcmNoaXZlLCB0aGUgZW50aXJlIGRpcmVjdG9yeSBhbmQgaXQncyBzdWJkaXJlY3RvcmllcyB3aWxsIGJlIGV4dHJhY3RlZFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8WmlwRW50cnl9IGVudHJ5IC0gWmlwRW50cnkgb2JqZWN0IG9yIFN0cmluZyB3aXRoIHRoZSBmdWxsIHBhdGggb2YgdGhlIGVudHJ5XG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFBhdGggLSBUYXJnZXQgZm9sZGVyIHdoZXJlIHRvIHdyaXRlIHRoZSBmaWxlXG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbbWFpbnRhaW5FbnRyeVBhdGg9dHJ1ZV0gLSBJZiBtYWludGFpbkVudHJ5UGF0aCBpcyB0cnVlIGFuZCB0aGUgZW50cnkgaXMgaW5zaWRlIGEgZm9sZGVyLCB0aGUgZW50cnkgZm9sZGVyIHdpbGwgYmUgY3JlYXRlZCBpbiB0YXJnZXRQYXRoIGFzIHdlbGwuIERlZmF1bHQgaXMgVFJVRVxuXHQgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV0gLSBJZiB0aGUgZmlsZSBhbHJlYWR5IGV4aXN0cyBhdCB0aGUgdGFyZ2V0IHBhdGgsIHRoZSBmaWxlIHdpbGwgYmUgb3ZlcndyaXRlbiBpZiB0aGlzIGlzIHRydWUuXG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBba2VlcE9yaWdpbmFsUGVybWlzc2lvbj1mYWxzZV0gLSBUaGUgZmlsZSB3aWxsIGJlIHNldCBhcyB0aGUgcGVybWlzc2lvbiBmcm9tIHRoZSBlbnRyeSBpZiB0aGlzIGlzIHRydWUuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvdXRGaWxlTmFtZV0gLSBTdHJpbmcgSWYgc2V0IHdpbGwgb3ZlcnJpZGUgdGhlIGZpbGVuYW1lIG9mIHRoZSBleHRyYWN0ZWQgZmlsZSAoT25seSB3b3JrcyBpZiB0aGUgZW50cnkgaXMgYSBmaWxlKVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiBCb29sZWFuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZXh0cmFjdEVudHJ5VG86IGZ1bmN0aW9uIChlbnRyeSwgdGFyZ2V0UGF0aCwgbWFpbnRhaW5FbnRyeVBhdGgsIG92ZXJ3cml0ZSwga2VlcE9yaWdpbmFsUGVybWlzc2lvbiwgb3V0RmlsZU5hbWUpIHtcblx0ICAgICAgICAgICAgb3ZlcndyaXRlID0gZ2V0X0Jvb2woZmFsc2UsIG92ZXJ3cml0ZSk7XG5cdCAgICAgICAgICAgIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPSBnZXRfQm9vbChmYWxzZSwga2VlcE9yaWdpbmFsUGVybWlzc2lvbik7XG5cdCAgICAgICAgICAgIG1haW50YWluRW50cnlQYXRoID0gZ2V0X0Jvb2wodHJ1ZSwgbWFpbnRhaW5FbnRyeVBhdGgpO1xuXHQgICAgICAgICAgICBvdXRGaWxlTmFtZSA9IGdldF9TdHIoa2VlcE9yaWdpbmFsUGVybWlzc2lvbiwgb3V0RmlsZU5hbWUpO1xuXG5cdCAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuXHQgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5OT19FTlRSWSgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIGVudHJ5TmFtZSA9IGNhbm9uaWNhbChpdGVtLmVudHJ5TmFtZSk7XG5cblx0ICAgICAgICAgICAgdmFyIHRhcmdldCA9IHNhbml0aXplKHRhcmdldFBhdGgsIG91dEZpbGVOYW1lICYmICFpdGVtLmlzRGlyZWN0b3J5ID8gb3V0RmlsZU5hbWUgOiBtYWludGFpbkVudHJ5UGF0aCA/IGVudHJ5TmFtZSA6IHB0aC5iYXNlbmFtZShlbnRyeU5hbWUpKTtcblxuXHQgICAgICAgICAgICBpZiAoaXRlbS5pc0RpcmVjdG9yeSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gX3ppcC5nZXRFbnRyeUNoaWxkcmVuKGl0ZW0pO1xuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaXNEaXJlY3RvcnkpIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGNoaWxkLmdldERhdGEoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLkNBTlRfRVhUUkFDVF9GSUxFKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gY2Fub25pY2FsKGNoaWxkLmVudHJ5TmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkTmFtZSA9IHNhbml0aXplKHRhcmdldFBhdGgsIG1haW50YWluRW50cnlQYXRoID8gbmFtZSA6IHB0aC5iYXNlbmFtZShuYW1lKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJldmVyc2Ugb3BlcmF0aW9uIGZvciBhdHRyIGRlcGVuZCBvbiBtZXRob2QgYWRkRmlsZSgpXG5cdCAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZUF0dHIgPSBrZWVwT3JpZ2luYWxQZXJtaXNzaW9uID8gY2hpbGQuaGVhZGVyLmZpbGVBdHRyIDogdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy53cml0ZUZpbGVUbyhjaGlsZE5hbWUsIGNvbnRlbnQsIG92ZXJ3cml0ZSwgZmlsZUF0dHIpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciBjb250ZW50ID0gaXRlbS5nZXREYXRhKF96aXAucGFzc3dvcmQpO1xuXHQgICAgICAgICAgICBpZiAoIWNvbnRlbnQpIHRocm93IFV0aWxzLkVycm9ycy5DQU5UX0VYVFJBQ1RfRklMRSgpO1xuXG5cdCAgICAgICAgICAgIGlmIChmaWxldG9vbHMuZnMuZXhpc3RzU3luYyh0YXJnZXQpICYmICFvdmVyd3JpdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5DQU5UX09WRVJSSURFKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gVGhlIHJldmVyc2Ugb3BlcmF0aW9uIGZvciBhdHRyIGRlcGVuZCBvbiBtZXRob2QgYWRkRmlsZSgpXG5cdCAgICAgICAgICAgIGNvbnN0IGZpbGVBdHRyID0ga2VlcE9yaWdpbmFsUGVybWlzc2lvbiA/IGVudHJ5LmhlYWRlci5maWxlQXR0ciA6IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgZmlsZXRvb2xzLndyaXRlRmlsZVRvKHRhcmdldCwgY29udGVudCwgb3ZlcndyaXRlLCBmaWxlQXR0cik7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFRlc3QgdGhlIGFyY2hpdmVcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3Bhc3NdXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdGVzdDogZnVuY3Rpb24gKHBhc3MpIHtcblx0ICAgICAgICAgICAgaWYgKCFfemlwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBmb3IgKHZhciBlbnRyeSBpbiBfemlwLmVudHJpZXMpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IF96aXAuZW50cmllc1tlbnRyeV0uZ2V0RGF0YShwYXNzKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRXh0cmFjdHMgdGhlIGVudGlyZSBhcmNoaXZlIHRvIHRoZSBnaXZlbiBsb2NhdGlvblxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFBhdGggVGFyZ2V0IGxvY2F0aW9uXG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXSBJZiB0aGUgZmlsZSBhbHJlYWR5IGV4aXN0cyBhdCB0aGUgdGFyZ2V0IHBhdGgsIHRoZSBmaWxlIHdpbGwgYmUgb3ZlcndyaXRlbiBpZiB0aGlzIGlzIHRydWUuXG5cdCAgICAgICAgICogICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIEZBTFNFXG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBba2VlcE9yaWdpbmFsUGVybWlzc2lvbj1mYWxzZV0gVGhlIGZpbGUgd2lsbCBiZSBzZXQgYXMgdGhlIHBlcm1pc3Npb24gZnJvbSB0aGUgZW50cnkgaWYgdGhpcyBpcyB0cnVlLlxuXHQgICAgICAgICAqICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyBGQUxTRVxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gW3Bhc3NdIHBhc3N3b3JkXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZXh0cmFjdEFsbFRvOiBmdW5jdGlvbiAodGFyZ2V0UGF0aCwgb3ZlcndyaXRlLCBrZWVwT3JpZ2luYWxQZXJtaXNzaW9uLCBwYXNzKSB7XG5cdCAgICAgICAgICAgIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPSBnZXRfQm9vbChmYWxzZSwga2VlcE9yaWdpbmFsUGVybWlzc2lvbik7XG5cdCAgICAgICAgICAgIHBhc3MgPSBnZXRfU3RyKGtlZXBPcmlnaW5hbFBlcm1pc3Npb24sIHBhc3MpO1xuXHQgICAgICAgICAgICBvdmVyd3JpdGUgPSBnZXRfQm9vbChmYWxzZSwgb3ZlcndyaXRlKTtcblx0ICAgICAgICAgICAgaWYgKCFfemlwKSB0aHJvdyBVdGlscy5FcnJvcnMuTk9fWklQKCk7XG5cblx0ICAgICAgICAgICAgX3ppcC5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZW50cnlOYW1lID0gc2FuaXRpemUodGFyZ2V0UGF0aCwgY2Fub25pY2FsKGVudHJ5LmVudHJ5TmFtZSkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLm1ha2VEaXIoZW50cnlOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGVudHJ5LmdldERhdGEocGFzcyk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuQ0FOVF9FWFRSQUNUX0ZJTEUoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIFRoZSByZXZlcnNlIG9wZXJhdGlvbiBmb3IgYXR0ciBkZXBlbmQgb24gbWV0aG9kIGFkZEZpbGUoKVxuXHQgICAgICAgICAgICAgICAgY29uc3QgZmlsZUF0dHIgPSBrZWVwT3JpZ2luYWxQZXJtaXNzaW9uID8gZW50cnkuaGVhZGVyLmZpbGVBdHRyIDogdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgZmlsZXRvb2xzLndyaXRlRmlsZVRvKGVudHJ5TmFtZSwgY29udGVudCwgb3ZlcndyaXRlLCBmaWxlQXR0cik7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy5mcy51dGltZXNTeW5jKGVudHJ5TmFtZSwgZW50cnkuaGVhZGVyLnRpbWUsIGVudHJ5LmhlYWRlci50aW1lKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5DQU5UX0VYVFJBQ1RfRklMRSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQXN5bmNocm9ub3VzIGV4dHJhY3RBbGxUb1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFBhdGggVGFyZ2V0IGxvY2F0aW9uXG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXSBJZiB0aGUgZmlsZSBhbHJlYWR5IGV4aXN0cyBhdCB0aGUgdGFyZ2V0IHBhdGgsIHRoZSBmaWxlIHdpbGwgYmUgb3ZlcndyaXRlbiBpZiB0aGlzIGlzIHRydWUuXG5cdCAgICAgICAgICogICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIEZBTFNFXG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBba2VlcE9yaWdpbmFsUGVybWlzc2lvbj1mYWxzZV0gVGhlIGZpbGUgd2lsbCBiZSBzZXQgYXMgdGhlIHBlcm1pc3Npb24gZnJvbSB0aGUgZW50cnkgaWYgdGhpcyBpcyB0cnVlLlxuXHQgICAgICAgICAqICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyBGQUxTRVxuXHQgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYWxsIGVudHJpZXMgYXJlIGV4dHJhY3RlZCBzdWNjZXNzZnVsbHkgb3IgYW55IGVycm9yIGlzIHRocm93bi5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBleHRyYWN0QWxsVG9Bc3luYzogZnVuY3Rpb24gKHRhcmdldFBhdGgsIG92ZXJ3cml0ZSwga2VlcE9yaWdpbmFsUGVybWlzc2lvbiwgY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgY2FsbGJhY2sgPSBnZXRfRnVuKG92ZXJ3cml0ZSwga2VlcE9yaWdpbmFsUGVybWlzc2lvbiwgY2FsbGJhY2spO1xuXHQgICAgICAgICAgICBrZWVwT3JpZ2luYWxQZXJtaXNzaW9uID0gZ2V0X0Jvb2woZmFsc2UsIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24pO1xuXHQgICAgICAgICAgICBvdmVyd3JpdGUgPSBnZXRfQm9vbChmYWxzZSwgb3ZlcndyaXRlKTtcblx0ICAgICAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4dHJhY3RBbGxUb0FzeW5jKHRhcmdldFBhdGgsIG92ZXJ3cml0ZSwga2VlcE9yaWdpbmFsUGVybWlzc2lvbiwgZnVuY3Rpb24gKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghX3ppcCkge1xuXHQgICAgICAgICAgICAgICAgY2FsbGJhY2soVXRpbHMuRXJyb3JzLk5PX1pJUCgpKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRhcmdldFBhdGggPSBwdGgucmVzb2x2ZSh0YXJnZXRQYXRoKTtcblx0ICAgICAgICAgICAgLy8gY29udmVydCBlbnRyeU5hbWUgdG9cblx0ICAgICAgICAgICAgY29uc3QgZ2V0UGF0aCA9IChlbnRyeSkgPT4gc2FuaXRpemUodGFyZ2V0UGF0aCwgcHRoLm5vcm1hbGl6ZShjYW5vbmljYWwoZW50cnkuZW50cnlOYW1lKSkpO1xuXHQgICAgICAgICAgICBjb25zdCBnZXRFcnJvciA9IChtc2csIGZpbGUpID0+IG5ldyBFcnJvcihtc2cgKyAnOiBcIicgKyBmaWxlICsgJ1wiJyk7XG5cblx0ICAgICAgICAgICAgLy8gc2VwYXJhdGUgZGlyZWN0b3JpZXMgZnJvbSBmaWxlc1xuXHQgICAgICAgICAgICBjb25zdCBkaXJFbnRyaWVzID0gW107XG5cdCAgICAgICAgICAgIGNvbnN0IGZpbGVFbnRyaWVzID0gW107XG5cdCAgICAgICAgICAgIF96aXAuZW50cmllcy5mb3JFYWNoKChlKSA9PiB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZS5pc0RpcmVjdG9yeSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRpckVudHJpZXMucHVzaChlKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZmlsZUVudHJpZXMucHVzaChlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIGRpcmVjdG9yeSBlbnRyaWVzIGZpcnN0IHN5bmNocm9ub3VzbHlcblx0ICAgICAgICAgICAgLy8gdGhpcyBwcmV2ZW50cyByYWNlIGNvbmRpdGlvbiBhbmQgYXNzdXJlcyBmb2xkZXJzIGFyZSB0aGVyZSBiZWZvcmUgd3JpdGluZyBmaWxlc1xuXHQgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGRpckVudHJpZXMpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnN0IGRpclBhdGggPSBnZXRQYXRoKGVudHJ5KTtcblx0ICAgICAgICAgICAgICAgIC8vIFRoZSByZXZlcnNlIG9wZXJhdGlvbiBmb3IgYXR0ciBkZXBlbmQgb24gbWV0aG9kIGFkZEZpbGUoKVxuXHQgICAgICAgICAgICAgICAgY29uc3QgZGlyQXR0ciA9IGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPyBlbnRyeS5oZWFkZXIuZmlsZUF0dHIgOiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy5tYWtlRGlyKGRpclBhdGgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkaXJBdHRyKSBmaWxldG9vbHMuZnMuY2htb2RTeW5jKGRpclBhdGgsIGRpckF0dHIpO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIGluIHVuaXggdGltZXN0YW1wIHdpbGwgY2hhbmdlIGlmIGZpbGVzIGFyZSBsYXRlciBhZGRlZCB0byBmb2xkZXIsIGJ1dCBzdGlsbFxuXHQgICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy5mcy51dGltZXNTeW5jKGRpclBhdGgsIGVudHJ5LmhlYWRlci50aW1lLCBlbnRyeS5oZWFkZXIudGltZSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcikge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGdldEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSBmb2xkZXJcIiwgZGlyUGF0aCkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZmlsZUVudHJpZXMucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAobmV4dCwgZW50cnkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnlOYW1lID0gcHRoLm5vcm1hbGl6ZShjYW5vbmljYWwoZW50cnkuZW50cnlOYW1lKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gc2FuaXRpemUodGFyZ2V0UGF0aCwgZW50cnlOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuZ2V0RGF0YUFzeW5jKGZ1bmN0aW9uIChjb250ZW50LCBlcnJfMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycl8xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dChlcnJfMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFjb250ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dChVdGlscy5FcnJvcnMuQ0FOVF9FWFRSQUNUX0ZJTEUoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXZlcnNlIG9wZXJhdGlvbiBmb3IgYXR0ciBkZXBlbmQgb24gbWV0aG9kIGFkZEZpbGUoKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVBdHRyID0ga2VlcE9yaWdpbmFsUGVybWlzc2lvbiA/IGVudHJ5LmhlYWRlci5maWxlQXR0ciA6IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxldG9vbHMud3JpdGVGaWxlVG9Bc3luYyhmaWxlUGF0aCwgY29udGVudCwgb3ZlcndyaXRlLCBmaWxlQXR0ciwgZnVuY3Rpb24gKHN1Y2MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWNjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KGdldEVycm9yKFwiVW5hYmxlIHRvIHdyaXRlIGZpbGVcIiwgZmlsZVBhdGgpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxldG9vbHMuZnMudXRpbWVzKGZpbGVQYXRoLCBlbnRyeS5oZWFkZXIudGltZSwgZW50cnkuaGVhZGVyLnRpbWUsIGZ1bmN0aW9uIChlcnJfMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycl8yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dChnZXRFcnJvcihcIlVuYWJsZSB0byBzZXQgdGltZXNcIiwgZmlsZVBhdGgpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSwgY2FsbGJhY2spKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFdyaXRlcyB0aGUgbmV3bHkgY3JlYXRlZCB6aXAgZmlsZSB0byBkaXNrIGF0IHRoZSBzcGVjaWZpZWQgbG9jYXRpb24gb3IgaWYgYSB6aXAgd2FzIG9wZW5lZCBhbmQgbm8gYGB0YXJnZXRGaWxlTmFtZWBgIGlzIHByb3ZpZGVkLCBpdCB3aWxsIG92ZXJ3cml0ZSB0aGUgb3BlbmVkIHppcFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldEZpbGVOYW1lXG5cdCAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB3cml0ZVppcDogZnVuY3Rpb24gKHRhcmdldEZpbGVOYW1lLCBjYWxsYmFjaykge1xuXHQgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRGaWxlTmFtZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0YXJnZXRGaWxlTmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICB0YXJnZXRGaWxlTmFtZSA9IFwiXCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoIXRhcmdldEZpbGVOYW1lICYmIG9wdHMuZmlsZW5hbWUpIHtcblx0ICAgICAgICAgICAgICAgIHRhcmdldEZpbGVOYW1lID0gb3B0cy5maWxlbmFtZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoIXRhcmdldEZpbGVOYW1lKSByZXR1cm47XG5cblx0ICAgICAgICAgICAgdmFyIHppcERhdGEgPSBfemlwLmNvbXByZXNzVG9CdWZmZXIoKTtcblx0ICAgICAgICAgICAgaWYgKHppcERhdGEpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvayA9IGZpbGV0b29scy53cml0ZUZpbGVUbyh0YXJnZXRGaWxlTmFtZSwgemlwRGF0YSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIGNhbGxiYWNrKCFvayA/IG5ldyBFcnJvcihcImZhaWxlZFwiKSA6IG51bGwsIFwiXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldEZpbGVOYW1lXG5cdCAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtwcm9wc11cblx0ICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vdmVyd3JpdGU9dHJ1ZV0gSWYgdGhlIGZpbGUgYWxyZWFkeSBleGlzdHMgYXQgdGhlIHRhcmdldCBwYXRoLCB0aGUgZmlsZSB3aWxsIGJlIG92ZXJ3cml0ZW4gaWYgdGhpcyBpcyB0cnVlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLnBlcm1dIFRoZSBmaWxlIHdpbGwgYmUgc2V0IGFzIHRoZSBwZXJtaXNzaW9uIGZyb20gdGhlIGVudHJ5IGlmIHRoaXMgaXMgdHJ1ZS5cblxuXHQgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHdyaXRlWmlwUHJvbWlzZTogZnVuY3Rpb24gKC8qKlN0cmluZyovIHRhcmdldEZpbGVOYW1lLCAvKiBvYmplY3QgKi8gcHJvcHMpIHtcblx0ICAgICAgICAgICAgY29uc3QgeyBvdmVyd3JpdGUsIHBlcm0gfSA9IE9iamVjdC5hc3NpZ24oeyBvdmVyd3JpdGU6IHRydWUgfSwgcHJvcHMpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdCAgICAgICAgICAgICAgICAvLyBmaW5kIGZpbGUgbmFtZVxuXHQgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRGaWxlTmFtZSAmJiBvcHRzLmZpbGVuYW1lKSB0YXJnZXRGaWxlTmFtZSA9IG9wdHMuZmlsZW5hbWU7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXRhcmdldEZpbGVOYW1lKSByZWplY3QoXCJBRE0tWklQOiBaSVAgRmlsZSBOYW1lIE1pc3NpbmdcIik7XG5cblx0ICAgICAgICAgICAgICAgIHRoaXMudG9CdWZmZXJQcm9taXNlKCkudGhlbigoemlwRGF0YSkgPT4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IChkb25lKSA9PiAoZG9uZSA/IHJlc29sdmUoZG9uZSkgOiByZWplY3QoXCJBRE0tWklQOiBXYXNuJ3QgYWJsZSB0byB3cml0ZSB6aXAgZmlsZVwiKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLndyaXRlRmlsZVRvQXN5bmModGFyZ2V0RmlsZU5hbWUsIHppcERhdGEsIG92ZXJ3cml0ZSwgcGVybSwgcmV0KTtcblx0ICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXI+fSBBIHByb21pc2UgdG8gdGhlIEJ1ZmZlci5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b0J1ZmZlclByb21pc2U6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0ICAgICAgICAgICAgICAgIF96aXAudG9Bc3luY0J1ZmZlcihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgZW50aXJlIHppcCBmaWxlIGFzIGEgQnVmZmVyIG9iamVjdFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3Age2Z1bmN0aW9ufSBbb25TdWNjZXNzXVxuXHQgICAgICAgICAqIEBwcm9wIHtmdW5jdGlvbn0gW29uRmFpbF1cblx0ICAgICAgICAgKiBAcHJvcCB7ZnVuY3Rpb259IFtvbkl0ZW1TdGFydF1cblx0ICAgICAgICAgKiBAcHJvcCB7ZnVuY3Rpb259IFtvbkl0ZW1FbmRdXG5cdCAgICAgICAgICogQHJldHVybnMge0J1ZmZlcn1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b0J1ZmZlcjogZnVuY3Rpb24gKG9uU3VjY2Vzcywgb25GYWlsLCBvbkl0ZW1TdGFydCwgb25JdGVtRW5kKSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Ygb25TdWNjZXNzID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgICAgIF96aXAudG9Bc3luY0J1ZmZlcihvblN1Y2Nlc3MsIG9uRmFpbCwgb25JdGVtU3RhcnQsIG9uSXRlbUVuZCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gX3ppcC5jb21wcmVzc1RvQnVmZmVyKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0fTtcblx0cmV0dXJuIGFkbVppcCQyO1xufVxuXG52YXIgYWRtWmlwRXhwb3J0cyA9IHJlcXVpcmVBZG1aaXAoKTtcbnZhciBhZG1aaXAgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYWRtWmlwRXhwb3J0cyk7XG5cbnZhciBhZG1aaXAkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRkZWZhdWx0OiBhZG1aaXBcbn0pO1xuXG5leHBvcnQgeyBhZG1aaXAkMSBhcyBhIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZG0temlwLTg2ZjMwZDQ3LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@0glabs/0g-serving-broker/lib.esm/adm-zip-86f30d47.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@0glabs/0g-serving-broker/lib.esm/index-1e77a467.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@0glabs/0g-serving-broker/lib.esm/index-1e77a467.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ AccountProcessor),\n/* harmony export */   F: () => (/* binding */ FineTuningBroker),\n/* harmony export */   I: () => (/* binding */ InferenceBroker),\n/* harmony export */   L: () => (/* binding */ LedgerBroker),\n/* harmony export */   M: () => (/* binding */ ModelProcessor$1),\n/* harmony export */   R: () => (/* binding */ RequestProcessor),\n/* harmony export */   V: () => (/* binding */ Verifier),\n/* harmony export */   Z: () => (/* binding */ ZGComputeNetworkBroker),\n/* harmony export */   a: () => (/* binding */ ResponseProcessor),\n/* harmony export */   b: () => (/* binding */ createFineTuningBroker),\n/* harmony export */   c: () => (/* binding */ createInferenceBroker),\n/* harmony export */   d: () => (/* binding */ download),\n/* harmony export */   e: () => (/* binding */ createLedgerBroker),\n/* harmony export */   f: () => (/* binding */ createZGComputeNetworkBroker),\n/* harmony export */   g: () => (/* binding */ isNode),\n/* harmony export */   h: () => (/* binding */ isWebWorker),\n/* harmony export */   i: () => (/* binding */ isBrowser),\n/* harmony export */   j: () => (/* binding */ hasWebCrypto),\n/* harmony export */   k: () => (/* binding */ getCryptoAdapter),\n/* harmony export */   l: () => (/* binding */ bigintToBytes),\n/* harmony export */   m: () => (/* binding */ genKeyPair),\n/* harmony export */   n: () => (/* binding */ Request$1),\n/* harmony export */   p: () => (/* binding */ pedersenHash),\n/* harmony export */   s: () => (/* binding */ signData),\n/* harmony export */   u: () => (/* binding */ upload)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/sha2.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/hash/solidity.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/contract/factory.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/hash/message.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/wallet/wallet.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-js */ \"(ssr)/./node_modules/crypto-js/index.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var circomlibjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! circomlibjs */ \"(ssr)/./node_modules/circomlibjs/main.js\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n\n\n\nclass Extractor {\n}\n\nclass ChatBot extends Extractor {\n    svcInfo;\n    constructor(svcInfo) {\n        super();\n        this.svcInfo = svcInfo;\n    }\n    getSvcInfo() {\n        return Promise.resolve(this.svcInfo);\n    }\n    async getInputCount(content) {\n        if (!content) {\n            return 0;\n        }\n        const utf8Encoder = new TextEncoder();\n        const encoded = utf8Encoder.encode(content);\n        return encoded.length;\n    }\n    async getOutputCount(content) {\n        if (!content) {\n            return 0;\n        }\n        const utf8Encoder = new TextEncoder();\n        const encoded = utf8Encoder.encode(content);\n        return encoded.length;\n    }\n}\n\n/**\n * MESSAGE_FOR_ENCRYPTION_KEY is a fixed message used to derive the encryption key.\n *\n * Background:\n * To ensure a consistent and unique encryption key can be generated from a user's Ethereum wallet,\n * we utilize a fixed message combined with a signing mechanism.\n *\n * Purpose:\n * - This string is provided to the Ethereum signing function to generate a digital signature based on the user's private key.\n * - The produced signature is then hashed (using SHA-256) to create a consistent 256-bit encryption key from the same wallet.\n * - This process offers a way to protect data without storing additional keys.\n *\n * Note:\n * - The uniqueness and stability of this message are crucial; do not change it unless you fully understand the impact\n *   on the key derivation and encryption process.\n * - Because the signature is derived from the wallet's private key, it ensures that different wallets cannot produce the same key.\n */\nconst MESSAGE_FOR_ENCRYPTION_KEY = 'MESSAGE_FOR_ENCRYPTION_KEY';\n// Define which errors to retry on\nconst RETRY_ERROR_SUBSTRINGS = [\n    'transaction underpriced',\n    'replacement transaction underpriced',\n    'fee too low',\n    'mempool',\n];\n\nvar dist = {};\n\nvar utils$5 = {};\n\nvar _assert$1 = {};\n\nvar hasRequired_assert$1;\n\nfunction require_assert$1 () {\n\tif (hasRequired_assert$1) return _assert$1;\n\thasRequired_assert$1 = 1;\n\t/**\n\t * Internal assertion helpers.\n\t * @module\n\t */\n\tObject.defineProperty(_assert$1, \"__esModule\", { value: true });\n\t_assert$1.abool = abool;\n\t_assert$1.abytes = abytes;\n\t_assert$1.aexists = aexists;\n\t_assert$1.ahash = ahash;\n\t_assert$1.anumber = anumber;\n\t_assert$1.aoutput = aoutput;\n\t_assert$1.isBytes = isBytes;\n\tfunction anumber(n) {\n\t    if (!Number.isSafeInteger(n) || n < 0)\n\t        throw new Error('positive integer expected, got ' + n);\n\t}\n\t// copied from utils\n\tfunction isBytes(a) {\n\t    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n\t}\n\tfunction abytes(b, ...lengths) {\n\t    if (!isBytes(b))\n\t        throw new Error('Uint8Array expected');\n\t    if (lengths.length > 0 && !lengths.includes(b.length))\n\t        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n\t}\n\tfunction ahash(h) {\n\t    if (typeof h !== 'function' || typeof h.create !== 'function')\n\t        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n\t    anumber(h.outputLen);\n\t    anumber(h.blockLen);\n\t}\n\tfunction aexists(instance, checkFinished = true) {\n\t    if (instance.destroyed)\n\t        throw new Error('Hash instance has been destroyed');\n\t    if (checkFinished && instance.finished)\n\t        throw new Error('Hash#digest() has already been called');\n\t}\n\tfunction aoutput(out, instance) {\n\t    abytes(out);\n\t    const min = instance.outputLen;\n\t    if (out.length < min) {\n\t        throw new Error('digestInto() expects output buffer of length at least ' + min);\n\t    }\n\t}\n\tfunction abool(b) {\n\t    if (typeof b !== 'boolean')\n\t        throw new Error(`boolean expected, not ${b}`);\n\t}\n\t\n\treturn _assert$1;\n}\n\nvar hasRequiredUtils$3;\n\nfunction requireUtils$3 () {\n\tif (hasRequiredUtils$3) return utils$5;\n\thasRequiredUtils$3 = 1;\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.wrapCipher = exports.Hash = exports.nextTick = exports.isLE = exports.createView = exports.u32 = exports.u8 = void 0;\n\t\texports.bytesToHex = bytesToHex;\n\t\texports.hexToBytes = hexToBytes;\n\t\texports.hexToNumber = hexToNumber;\n\t\texports.bytesToNumberBE = bytesToNumberBE;\n\t\texports.numberToBytesBE = numberToBytesBE;\n\t\texports.utf8ToBytes = utf8ToBytes;\n\t\texports.bytesToUtf8 = bytesToUtf8;\n\t\texports.toBytes = toBytes;\n\t\texports.overlapBytes = overlapBytes;\n\t\texports.complexOverlapBytes = complexOverlapBytes;\n\t\texports.concatBytes = concatBytes;\n\t\texports.checkOpts = checkOpts;\n\t\texports.equalBytes = equalBytes;\n\t\texports.getOutput = getOutput;\n\t\texports.setBigUint64 = setBigUint64;\n\t\texports.u64Lengths = u64Lengths;\n\t\texports.isAligned32 = isAligned32;\n\t\texports.copyBytes = copyBytes;\n\t\texports.clean = clean;\n\t\t/**\n\t\t * Utilities for hex, bytes, CSPRNG.\n\t\t * @module\n\t\t */\n\t\t/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n\t\tconst _assert_js_1 = /*@__PURE__*/ require_assert$1();\n\t\t// Cast array to different type\n\t\tconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n\t\texports.u8 = u8;\n\t\tconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\t\texports.u32 = u32;\n\t\t// Cast array to view\n\t\tconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\t\texports.createView = createView;\n\t\t// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n\t\t// early-throw an error because we don't support BE yet.\n\t\texports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n\t\tif (!exports.isLE)\n\t\t    throw new Error('Non little-endian hardware is not supported');\n\t\t// Array where index 0xf0 (240) is mapped to string 'f0'\n\t\tconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n\t\t/**\n\t\t * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n\t\t */\n\t\tfunction bytesToHex(bytes) {\n\t\t    (0, _assert_js_1.abytes)(bytes);\n\t\t    // pre-caching improves the speed 6x\n\t\t    let hex = '';\n\t\t    for (let i = 0; i < bytes.length; i++) {\n\t\t        hex += hexes[bytes[i]];\n\t\t    }\n\t\t    return hex;\n\t\t}\n\t\t// We use optimized technique to convert hex string to byte array\n\t\tconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\n\t\tfunction asciiToBase16(ch) {\n\t\t    if (ch >= asciis._0 && ch <= asciis._9)\n\t\t        return ch - asciis._0; // '2' => 50-48\n\t\t    if (ch >= asciis.A && ch <= asciis.F)\n\t\t        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n\t\t    if (ch >= asciis.a && ch <= asciis.f)\n\t\t        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n\t\t    return;\n\t\t}\n\t\t/**\n\t\t * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n\t\t */\n\t\tfunction hexToBytes(hex) {\n\t\t    if (typeof hex !== 'string')\n\t\t        throw new Error('hex string expected, got ' + typeof hex);\n\t\t    const hl = hex.length;\n\t\t    const al = hl / 2;\n\t\t    if (hl % 2)\n\t\t        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n\t\t    const array = new Uint8Array(al);\n\t\t    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n\t\t        const n1 = asciiToBase16(hex.charCodeAt(hi));\n\t\t        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n\t\t        if (n1 === undefined || n2 === undefined) {\n\t\t            const char = hex[hi] + hex[hi + 1];\n\t\t            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n\t\t        }\n\t\t        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n\t\t    }\n\t\t    return array;\n\t\t}\n\t\tfunction hexToNumber(hex) {\n\t\t    if (typeof hex !== 'string')\n\t\t        throw new Error('hex string expected, got ' + typeof hex);\n\t\t    return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n\t\t}\n\t\t// BE: Big Endian, LE: Little Endian\n\t\tfunction bytesToNumberBE(bytes) {\n\t\t    return hexToNumber(bytesToHex(bytes));\n\t\t}\n\t\tfunction numberToBytesBE(n, len) {\n\t\t    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n\t\t}\n\t\t// There is no setImmediate in browser and setTimeout is slow.\n\t\t// call of async fn will return Promise, which will be fullfiled only on\n\t\t// next scheduler queue processing step and this is exactly what we need.\n\t\tconst nextTick = async () => { };\n\t\texports.nextTick = nextTick;\n\t\t/**\n\t\t * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n\t\t */\n\t\tfunction utf8ToBytes(str) {\n\t\t    if (typeof str !== 'string')\n\t\t        throw new Error('string expected');\n\t\t    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n\t\t}\n\t\t/**\n\t\t * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n\t\t */\n\t\tfunction bytesToUtf8(bytes) {\n\t\t    return new TextDecoder().decode(bytes);\n\t\t}\n\t\t/**\n\t\t * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n\t\t * Warning: when Uint8Array is passed, it would NOT get copied.\n\t\t * Keep in mind for future mutable operations.\n\t\t */\n\t\tfunction toBytes(data) {\n\t\t    if (typeof data === 'string')\n\t\t        data = utf8ToBytes(data);\n\t\t    else if ((0, _assert_js_1.isBytes)(data))\n\t\t        data = copyBytes(data);\n\t\t    else\n\t\t        throw new Error('Uint8Array expected, got ' + typeof data);\n\t\t    return data;\n\t\t}\n\t\t/**\n\t\t * Checks if two U8A use same underlying buffer and overlaps (will corrupt and break if input and output same)\n\t\t */\n\t\tfunction overlapBytes(a, b) {\n\t\t    return (a.buffer === b.buffer && // probably will fail with some obscure proxies, but this is best we can do\n\t\t        a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n\t\t        b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n\t\t    );\n\t\t}\n\t\t/**\n\t\t * If input and output overlap and input starts before output, we will overwrite end of input before\n\t\t * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n\t\t */\n\t\tfunction complexOverlapBytes(input, output) {\n\t\t    // This is very cursed. It works somehow, but I'm completely unsure,\n\t\t    // reasoning about overlapping aligned windows is very hard.\n\t\t    if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n\t\t        throw new Error('complex overlap of input and output is not supported');\n\t\t}\n\t\t/**\n\t\t * Copies several Uint8Arrays into one.\n\t\t */\n\t\tfunction concatBytes(...arrays) {\n\t\t    let sum = 0;\n\t\t    for (let i = 0; i < arrays.length; i++) {\n\t\t        const a = arrays[i];\n\t\t        (0, _assert_js_1.abytes)(a);\n\t\t        sum += a.length;\n\t\t    }\n\t\t    const res = new Uint8Array(sum);\n\t\t    for (let i = 0, pad = 0; i < arrays.length; i++) {\n\t\t        const a = arrays[i];\n\t\t        res.set(a, pad);\n\t\t        pad += a.length;\n\t\t    }\n\t\t    return res;\n\t\t}\n\t\tfunction checkOpts(defaults, opts) {\n\t\t    if (opts == null || typeof opts !== 'object')\n\t\t        throw new Error('options must be defined');\n\t\t    const merged = Object.assign(defaults, opts);\n\t\t    return merged;\n\t\t}\n\t\t// Compares 2 u8a-s in kinda constant time\n\t\tfunction equalBytes(a, b) {\n\t\t    if (a.length !== b.length)\n\t\t        return false;\n\t\t    let diff = 0;\n\t\t    for (let i = 0; i < a.length; i++)\n\t\t        diff |= a[i] ^ b[i];\n\t\t    return diff === 0;\n\t\t}\n\t\t// For runtime check if class implements interface\n\t\tclass Hash {\n\t\t}\n\t\texports.Hash = Hash;\n\t\t/**\n\t\t * @__NO_SIDE_EFFECTS__\n\t\t */\n\t\tconst wrapCipher = (params, constructor) => {\n\t\t    function wrappedCipher(key, ...args) {\n\t\t        // Validate key\n\t\t        (0, _assert_js_1.abytes)(key);\n\t\t        // Validate nonce if nonceLength is present\n\t\t        if (params.nonceLength !== undefined) {\n\t\t            const nonce = args[0];\n\t\t            if (!nonce)\n\t\t                throw new Error('nonce / iv required');\n\t\t            if (params.varSizeNonce)\n\t\t                (0, _assert_js_1.abytes)(nonce);\n\t\t            else\n\t\t                (0, _assert_js_1.abytes)(nonce, params.nonceLength);\n\t\t        }\n\t\t        // Validate AAD if tagLength present\n\t\t        const tagl = params.tagLength;\n\t\t        if (tagl && args[1] !== undefined) {\n\t\t            (0, _assert_js_1.abytes)(args[1]);\n\t\t        }\n\t\t        const cipher = constructor(key, ...args);\n\t\t        const checkOutput = (fnLength, output) => {\n\t\t            if (output !== undefined) {\n\t\t                if (fnLength !== 2)\n\t\t                    throw new Error('cipher output not supported');\n\t\t                (0, _assert_js_1.abytes)(output);\n\t\t            }\n\t\t        };\n\t\t        // Create wrapped cipher with validation and single-use encryption\n\t\t        let called = false;\n\t\t        const wrCipher = {\n\t\t            encrypt(data, output) {\n\t\t                if (called)\n\t\t                    throw new Error('cannot encrypt() twice with same key + nonce');\n\t\t                called = true;\n\t\t                (0, _assert_js_1.abytes)(data);\n\t\t                checkOutput(cipher.encrypt.length, output);\n\t\t                return cipher.encrypt(data, output);\n\t\t            },\n\t\t            decrypt(data, output) {\n\t\t                (0, _assert_js_1.abytes)(data);\n\t\t                if (tagl && data.length < tagl)\n\t\t                    throw new Error('invalid ciphertext length: smaller than tagLength=' + tagl);\n\t\t                checkOutput(cipher.decrypt.length, output);\n\t\t                return cipher.decrypt(data, output);\n\t\t            },\n\t\t        };\n\t\t        return wrCipher;\n\t\t    }\n\t\t    Object.assign(wrappedCipher, params);\n\t\t    return wrappedCipher;\n\t\t};\n\t\texports.wrapCipher = wrapCipher;\n\t\tfunction getOutput(expectedLength, out, onlyAligned = true) {\n\t\t    if (out === undefined)\n\t\t        return new Uint8Array(expectedLength);\n\t\t    if (out.length !== expectedLength)\n\t\t        throw new Error('invalid output length, expected ' + expectedLength + ', got: ' + out.length);\n\t\t    if (onlyAligned && !isAligned32(out))\n\t\t        throw new Error('invalid output, must be aligned');\n\t\t    return out;\n\t\t}\n\t\t// Polyfill for Safari 14\n\t\tfunction setBigUint64(view, byteOffset, value, isLE) {\n\t\t    if (typeof view.setBigUint64 === 'function')\n\t\t        return view.setBigUint64(byteOffset, value, isLE);\n\t\t    const _32n = BigInt(32);\n\t\t    const _u32_max = BigInt(0xffffffff);\n\t\t    const wh = Number((value >> _32n) & _u32_max);\n\t\t    const wl = Number(value & _u32_max);\n\t\t    const h = isLE ? 4 : 0;\n\t\t    const l = isLE ? 0 : 4;\n\t\t    view.setUint32(byteOffset + h, wh, isLE);\n\t\t    view.setUint32(byteOffset + l, wl, isLE);\n\t\t}\n\t\tfunction u64Lengths(ciphertext, AAD) {\n\t\t    const num = new Uint8Array(16);\n\t\t    const view = (0, exports.createView)(num);\n\t\t    setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n\t\t    setBigUint64(view, 8, BigInt(ciphertext.length), true);\n\t\t    return num;\n\t\t}\n\t\t// Is byte array aligned to 4 byte offset (u32)?\n\t\tfunction isAligned32(bytes) {\n\t\t    return bytes.byteOffset % 4 === 0;\n\t\t}\n\t\t// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\n\t\tfunction copyBytes(bytes) {\n\t\t    return Uint8Array.from(bytes);\n\t\t}\n\t\tfunction clean(...arrays) {\n\t\t    for (let i = 0; i < arrays.length; i++) {\n\t\t        arrays[i].fill(0);\n\t\t    }\n\t\t}\n\t\t\n\t} (utils$5));\n\treturn utils$5;\n}\n\nvar config = {};\n\nvar consts = {};\n\nvar hasRequiredConsts;\n\nfunction requireConsts () {\n\tif (hasRequiredConsts) return consts;\n\thasRequiredConsts = 1;\n\tObject.defineProperty(consts, \"__esModule\", { value: true });\n\tconsts.AEAD_TAG_LENGTH = consts.XCHACHA20_NONCE_LENGTH = consts.CURVE25519_PUBLIC_KEY_SIZE = consts.ETH_PUBLIC_KEY_SIZE = consts.UNCOMPRESSED_PUBLIC_KEY_SIZE = consts.COMPRESSED_PUBLIC_KEY_SIZE = consts.SECRET_KEY_LENGTH = void 0;\n\t// elliptic\n\tconsts.SECRET_KEY_LENGTH = 32;\n\tconsts.COMPRESSED_PUBLIC_KEY_SIZE = 33;\n\tconsts.UNCOMPRESSED_PUBLIC_KEY_SIZE = 65;\n\tconsts.ETH_PUBLIC_KEY_SIZE = 64;\n\tconsts.CURVE25519_PUBLIC_KEY_SIZE = 32;\n\t// symmetric\n\tconsts.XCHACHA20_NONCE_LENGTH = 24;\n\tconsts.AEAD_TAG_LENGTH = 16;\n\treturn consts;\n}\n\nvar hasRequiredConfig;\n\nfunction requireConfig () {\n\tif (hasRequiredConfig) return config;\n\thasRequiredConfig = 1;\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.ephemeralKeySize = exports.symmetricNonceLength = exports.symmetricAlgorithm = exports.isHkdfKeyCompressed = exports.isEphemeralKeyCompressed = exports.ellipticCurve = exports.ECIES_CONFIG = void 0;\n\t\tvar consts_1 = requireConsts();\n\t\tvar Config = /** @class */ (function () {\n\t\t    function Config() {\n\t\t        this.ellipticCurve = \"secp256k1\";\n\t\t        this.isEphemeralKeyCompressed = false; // secp256k1 only\n\t\t        this.isHkdfKeyCompressed = false; // secp256k1 only\n\t\t        this.symmetricAlgorithm = \"aes-256-gcm\";\n\t\t        this.symmetricNonceLength = 16; // aes-256-gcm only\n\t\t    }\n\t\t    return Config;\n\t\t}());\n\t\texports.ECIES_CONFIG = new Config();\n\t\tvar ellipticCurve = function () { return exports.ECIES_CONFIG.ellipticCurve; };\n\t\texports.ellipticCurve = ellipticCurve;\n\t\tvar isEphemeralKeyCompressed = function () { return exports.ECIES_CONFIG.isEphemeralKeyCompressed; };\n\t\texports.isEphemeralKeyCompressed = isEphemeralKeyCompressed;\n\t\tvar isHkdfKeyCompressed = function () { return exports.ECIES_CONFIG.isHkdfKeyCompressed; };\n\t\texports.isHkdfKeyCompressed = isHkdfKeyCompressed;\n\t\tvar symmetricAlgorithm = function () { return exports.ECIES_CONFIG.symmetricAlgorithm; };\n\t\texports.symmetricAlgorithm = symmetricAlgorithm;\n\t\tvar symmetricNonceLength = function () { return exports.ECIES_CONFIG.symmetricNonceLength; };\n\t\texports.symmetricNonceLength = symmetricNonceLength;\n\t\tvar ephemeralKeySize = function () {\n\t\t    var mapping = {\n\t\t        secp256k1: exports.ECIES_CONFIG.isEphemeralKeyCompressed\n\t\t            ? consts_1.COMPRESSED_PUBLIC_KEY_SIZE\n\t\t            : consts_1.UNCOMPRESSED_PUBLIC_KEY_SIZE,\n\t\t        x25519: consts_1.CURVE25519_PUBLIC_KEY_SIZE,\n\t\t        ed25519: consts_1.CURVE25519_PUBLIC_KEY_SIZE,\n\t\t    };\n\t\t    if (exports.ECIES_CONFIG.ellipticCurve in mapping) {\n\t\t        return mapping[exports.ECIES_CONFIG.ellipticCurve];\n\t\t    } /* v8 ignore next 2 */\n\t\t    else {\n\t\t        throw new Error(\"Not implemented\");\n\t\t    }\n\t\t};\n\t\texports.ephemeralKeySize = ephemeralKeySize; \n\t} (config));\n\treturn config;\n}\n\nvar keys = {};\n\nvar PrivateKey = {};\n\nvar utils$4 = {};\n\nvar elliptic = {};\n\nvar webcrypto = {};\n\nvar crypto$2 = {};\n\nvar hasRequiredCrypto$1;\n\nfunction requireCrypto$1 () {\n\tif (hasRequiredCrypto$1) return crypto$2;\n\thasRequiredCrypto$1 = 1;\n\tObject.defineProperty(crypto$2, \"__esModule\", { value: true });\n\tcrypto$2.crypto = void 0;\n\tcrypto$2.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n\t\n\treturn crypto$2;\n}\n\nvar hasRequiredWebcrypto;\n\nfunction requireWebcrypto () {\n\tif (hasRequiredWebcrypto) return webcrypto;\n\thasRequiredWebcrypto = 1;\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.gcm = exports.ctr = exports.cbc = exports.utils = void 0;\n\t\texports.randomBytes = randomBytes;\n\t\texports.getWebcryptoSubtle = getWebcryptoSubtle;\n\t\texports.managedNonce = managedNonce;\n\t\t/**\n\t\t * WebCrypto-based AES gcm/ctr/cbc, `managedNonce` and `randomBytes`.\n\t\t * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n\t\t * node.js versions earlier than v19 don't declare it in global scope.\n\t\t * For node.js, package.js on#exports field mapping rewrites import\n\t\t * from `crypto` to `cryptoNode`, which imports native module.\n\t\t * Makes the utils un-importable in browsers without a bundler.\n\t\t * Once node.js 18 is deprecated, we can just drop the import.\n\t\t * @module\n\t\t */\n\t\t// Use full path so that Node.js can rewrite it to `cryptoNode.js`.\n\t\tconst crypto_1 = requireCrypto$1();\n\t\tconst _assert_js_1 = /*@__PURE__*/ require_assert$1();\n\t\tconst utils_js_1 = /*@__PURE__*/ requireUtils$3();\n\t\t/**\n\t\t * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n\t\t */\n\t\tfunction randomBytes(bytesLength = 32) {\n\t\t    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n\t\t        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n\t\t    }\n\t\t    // Legacy Node.js compatibility\n\t\t    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {\n\t\t        return crypto_1.crypto.randomBytes(bytesLength);\n\t\t    }\n\t\t    throw new Error('crypto.getRandomValues must be defined');\n\t\t}\n\t\tfunction getWebcryptoSubtle() {\n\t\t    if (crypto_1.crypto && typeof crypto_1.crypto.subtle === 'object' && crypto_1.crypto.subtle != null)\n\t\t        return crypto_1.crypto.subtle;\n\t\t    throw new Error('crypto.subtle must be defined');\n\t\t}\n\t\t/**\n\t\t * Uses CSPRG for nonce, nonce injected in ciphertext.\n\t\t * @example\n\t\t * const gcm = managedNonce(aes.gcm);\n\t\t * const ciphr = gcm(key).encrypt(data);\n\t\t * const plain = gcm(key).decrypt(ciph);\n\t\t */\n\t\tfunction managedNonce(fn) {\n\t\t    const { nonceLength } = fn;\n\t\t    (0, _assert_js_1.anumber)(nonceLength);\n\t\t    return ((key, ...args) => ({\n\t\t        encrypt(plaintext, ...argsEnc) {\n\t\t            const nonce = randomBytes(nonceLength);\n\t\t            const ciphertext = fn(key, nonce, ...args).encrypt(plaintext, ...argsEnc);\n\t\t            const out = (0, utils_js_1.concatBytes)(nonce, ciphertext);\n\t\t            ciphertext.fill(0);\n\t\t            return out;\n\t\t        },\n\t\t        decrypt(ciphertext, ...argsDec) {\n\t\t            const nonce = ciphertext.subarray(0, nonceLength);\n\t\t            const data = ciphertext.subarray(nonceLength);\n\t\t            return fn(key, nonce, ...args).decrypt(data, ...argsDec);\n\t\t        },\n\t\t    }));\n\t\t}\n\t\t// Overridable\n\t\t// @TODO\n\t\texports.utils = {\n\t\t    async encrypt(key, keyParams, cryptParams, plaintext) {\n\t\t        const cr = getWebcryptoSubtle();\n\t\t        const iKey = await cr.importKey('raw', key, keyParams, true, ['encrypt']);\n\t\t        const ciphertext = await cr.encrypt(cryptParams, iKey, plaintext);\n\t\t        return new Uint8Array(ciphertext);\n\t\t    },\n\t\t    async decrypt(key, keyParams, cryptParams, ciphertext) {\n\t\t        const cr = getWebcryptoSubtle();\n\t\t        const iKey = await cr.importKey('raw', key, keyParams, true, ['decrypt']);\n\t\t        const plaintext = await cr.decrypt(cryptParams, iKey, ciphertext);\n\t\t        return new Uint8Array(plaintext);\n\t\t    },\n\t\t};\n\t\tconst mode = {\n\t\t    CBC: 'AES-CBC',\n\t\t    CTR: 'AES-CTR',\n\t\t    GCM: 'AES-GCM',\n\t\t};\n\t\tfunction getCryptParams(algo, nonce, AAD) {\n\t\t    if (algo === mode.CBC)\n\t\t        return { name: mode.CBC, iv: nonce };\n\t\t    if (algo === mode.CTR)\n\t\t        return { name: mode.CTR, counter: nonce, length: 64 };\n\t\t    if (algo === mode.GCM) {\n\t\t        if (AAD)\n\t\t            return { name: mode.GCM, iv: nonce, additionalData: AAD };\n\t\t        else\n\t\t            return { name: mode.GCM, iv: nonce };\n\t\t    }\n\t\t    throw new Error('unknown aes block mode');\n\t\t}\n\t\tfunction generate(algo) {\n\t\t    return (key, nonce, AAD) => {\n\t\t        (0, _assert_js_1.abytes)(key);\n\t\t        (0, _assert_js_1.abytes)(nonce);\n\t\t        const keyParams = { name: algo, length: key.length * 8 };\n\t\t        const cryptParams = getCryptParams(algo, nonce, AAD);\n\t\t        let consumed = false;\n\t\t        return {\n\t\t            // keyLength,\n\t\t            encrypt(plaintext) {\n\t\t                (0, _assert_js_1.abytes)(plaintext);\n\t\t                if (consumed)\n\t\t                    throw new Error('Cannot encrypt() twice with same key / nonce');\n\t\t                consumed = true;\n\t\t                return exports.utils.encrypt(key, keyParams, cryptParams, plaintext);\n\t\t            },\n\t\t            decrypt(ciphertext) {\n\t\t                (0, _assert_js_1.abytes)(ciphertext);\n\t\t                return exports.utils.decrypt(key, keyParams, cryptParams, ciphertext);\n\t\t            },\n\t\t        };\n\t\t    };\n\t\t}\n\t\t/** AES-CBC, native webcrypto version */\n\t\texports.cbc = (() => generate(mode.CBC))();\n\t\t/** AES-CTR, native webcrypto version */\n\t\texports.ctr = (() => generate(mode.CTR))();\n\t\t/** AES-GCM, native webcrypto version */\n\t\texports.gcm = \n\t\t/* @__PURE__ */ (() => generate(mode.GCM))();\n\t\t// // Type tests\n\t\t// import { siv, gcm, ctr, ecb, cbc } from '../aes.js';\n\t\t// import { xsalsa20poly1305 } from '../salsa.js';\n\t\t// import { chacha20poly1305, xchacha20poly1305 } from '../chacha.js';\n\t\t// const wsiv = managedNonce(siv);\n\t\t// const wgcm = managedNonce(gcm);\n\t\t// const wctr = managedNonce(ctr);\n\t\t// const wcbc = managedNonce(cbc);\n\t\t// const wsalsapoly = managedNonce(xsalsa20poly1305);\n\t\t// const wchacha = managedNonce(chacha20poly1305);\n\t\t// const wxchacha = managedNonce(xchacha20poly1305);\n\t\t// // should fail\n\t\t// const wcbc2 = managedNonce(managedNonce(cbc));\n\t\t// const wctr = managedNonce(ctr);\n\t\t\n\t} (webcrypto));\n\treturn webcrypto;\n}\n\nvar ed25519 = {};\n\nvar sha512 = {};\n\nvar _md = {};\n\nvar _assert = {};\n\nvar hasRequired_assert;\n\nfunction require_assert () {\n\tif (hasRequired_assert) return _assert;\n\thasRequired_assert = 1;\n\t/**\n\t * Internal assertion helpers.\n\t * @module\n\t */\n\tObject.defineProperty(_assert, \"__esModule\", { value: true });\n\t_assert.anumber = anumber;\n\t_assert.abytes = abytes;\n\t_assert.ahash = ahash;\n\t_assert.aexists = aexists;\n\t_assert.aoutput = aoutput;\n\t/** Asserts something is positive integer. */\n\tfunction anumber(n) {\n\t    if (!Number.isSafeInteger(n) || n < 0)\n\t        throw new Error('positive integer expected, got ' + n);\n\t}\n\t/** Is number an Uint8Array? Copied from utils for perf. */\n\tfunction isBytes(a) {\n\t    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n\t}\n\t/** Asserts something is Uint8Array. */\n\tfunction abytes(b, ...lengths) {\n\t    if (!isBytes(b))\n\t        throw new Error('Uint8Array expected');\n\t    if (lengths.length > 0 && !lengths.includes(b.length))\n\t        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n\t}\n\t/** Asserts something is hash */\n\tfunction ahash(h) {\n\t    if (typeof h !== 'function' || typeof h.create !== 'function')\n\t        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n\t    anumber(h.outputLen);\n\t    anumber(h.blockLen);\n\t}\n\t/** Asserts a hash instance has not been destroyed / finished */\n\tfunction aexists(instance, checkFinished = true) {\n\t    if (instance.destroyed)\n\t        throw new Error('Hash instance has been destroyed');\n\t    if (checkFinished && instance.finished)\n\t        throw new Error('Hash#digest() has already been called');\n\t}\n\t/** Asserts output is properly-sized byte array */\n\tfunction aoutput(out, instance) {\n\t    abytes(out);\n\t    const min = instance.outputLen;\n\t    if (out.length < min) {\n\t        throw new Error('digestInto() expects output buffer of length at least ' + min);\n\t    }\n\t}\n\t\n\treturn _assert;\n}\n\nvar utils$3 = {};\n\nvar crypto$1 = {};\n\nvar hasRequiredCrypto;\n\nfunction requireCrypto () {\n\tif (hasRequiredCrypto) return crypto$1;\n\thasRequiredCrypto = 1;\n\tObject.defineProperty(crypto$1, \"__esModule\", { value: true });\n\tcrypto$1.crypto = void 0;\n\tcrypto$1.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n\t\n\treturn crypto$1;\n}\n\nvar hasRequiredUtils$2;\n\nfunction requireUtils$2 () {\n\tif (hasRequiredUtils$2) return utils$3;\n\thasRequiredUtils$2 = 1;\n\t(function (exports) {\n\t\t/**\n\t\t * Utilities for hex, bytes, CSPRNG.\n\t\t * @module\n\t\t */\n\t\t/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.isLE = void 0;\n\t\texports.isBytes = isBytes;\n\t\texports.u8 = u8;\n\t\texports.u32 = u32;\n\t\texports.createView = createView;\n\t\texports.rotr = rotr;\n\t\texports.rotl = rotl;\n\t\texports.byteSwap = byteSwap;\n\t\texports.byteSwap32 = byteSwap32;\n\t\texports.bytesToHex = bytesToHex;\n\t\texports.hexToBytes = hexToBytes;\n\t\texports.asyncLoop = asyncLoop;\n\t\texports.utf8ToBytes = utf8ToBytes;\n\t\texports.toBytes = toBytes;\n\t\texports.concatBytes = concatBytes;\n\t\texports.checkOpts = checkOpts;\n\t\texports.wrapConstructor = wrapConstructor;\n\t\texports.wrapConstructorWithOpts = wrapConstructorWithOpts;\n\t\texports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n\t\texports.randomBytes = randomBytes;\n\t\t// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n\t\t// node.js versions earlier than v19 don't declare it in global scope.\n\t\t// For node.js, package.json#exports field mapping rewrites import\n\t\t// from `crypto` to `cryptoNode`, which imports native module.\n\t\t// Makes the utils un-importable in browsers without a bundler.\n\t\t// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\t\tconst crypto_1 = requireCrypto();\n\t\tconst _assert_js_1 = /*@__PURE__*/ require_assert();\n\t\t// export { isBytes } from './_assert.js';\n\t\t// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\n\t\tfunction isBytes(a) {\n\t\t    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n\t\t}\n\t\t// Cast array to different type\n\t\tfunction u8(arr) {\n\t\t    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n\t\t}\n\t\tfunction u32(arr) {\n\t\t    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\t\t}\n\t\t// Cast array to view\n\t\tfunction createView(arr) {\n\t\t    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\t\t}\n\t\t/** The rotate right (circular right shift) operation for uint32 */\n\t\tfunction rotr(word, shift) {\n\t\t    return (word << (32 - shift)) | (word >>> shift);\n\t\t}\n\t\t/** The rotate left (circular left shift) operation for uint32 */\n\t\tfunction rotl(word, shift) {\n\t\t    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n\t\t}\n\t\t/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\n\t\texports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\t\t// The byte swap operation for uint32\n\t\tfunction byteSwap(word) {\n\t\t    return (((word << 24) & 0xff000000) |\n\t\t        ((word << 8) & 0xff0000) |\n\t\t        ((word >>> 8) & 0xff00) |\n\t\t        ((word >>> 24) & 0xff));\n\t\t}\n\t\t/** Conditionally byte swap if on a big-endian platform */\n\t\texports.byteSwapIfBE = exports.isLE\n\t\t    ? (n) => n\n\t\t    : (n) => byteSwap(n);\n\t\t/** In place byte swap for Uint32Array */\n\t\tfunction byteSwap32(arr) {\n\t\t    for (let i = 0; i < arr.length; i++) {\n\t\t        arr[i] = byteSwap(arr[i]);\n\t\t    }\n\t\t}\n\t\t// Array where index 0xf0 (240) is mapped to string 'f0'\n\t\tconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n\t\t/**\n\t\t * Convert byte array to hex string.\n\t\t * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n\t\t */\n\t\tfunction bytesToHex(bytes) {\n\t\t    (0, _assert_js_1.abytes)(bytes);\n\t\t    // pre-caching improves the speed 6x\n\t\t    let hex = '';\n\t\t    for (let i = 0; i < bytes.length; i++) {\n\t\t        hex += hexes[bytes[i]];\n\t\t    }\n\t\t    return hex;\n\t\t}\n\t\t// We use optimized technique to convert hex string to byte array\n\t\tconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\n\t\tfunction asciiToBase16(ch) {\n\t\t    if (ch >= asciis._0 && ch <= asciis._9)\n\t\t        return ch - asciis._0; // '2' => 50-48\n\t\t    if (ch >= asciis.A && ch <= asciis.F)\n\t\t        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n\t\t    if (ch >= asciis.a && ch <= asciis.f)\n\t\t        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n\t\t    return;\n\t\t}\n\t\t/**\n\t\t * Convert hex string to byte array.\n\t\t * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n\t\t */\n\t\tfunction hexToBytes(hex) {\n\t\t    if (typeof hex !== 'string')\n\t\t        throw new Error('hex string expected, got ' + typeof hex);\n\t\t    const hl = hex.length;\n\t\t    const al = hl / 2;\n\t\t    if (hl % 2)\n\t\t        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n\t\t    const array = new Uint8Array(al);\n\t\t    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n\t\t        const n1 = asciiToBase16(hex.charCodeAt(hi));\n\t\t        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n\t\t        if (n1 === undefined || n2 === undefined) {\n\t\t            const char = hex[hi] + hex[hi + 1];\n\t\t            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n\t\t        }\n\t\t        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n\t\t    }\n\t\t    return array;\n\t\t}\n\t\t/**\n\t\t * There is no setImmediate in browser and setTimeout is slow.\n\t\t * Call of async fn will return Promise, which will be fullfiled only on\n\t\t * next scheduler queue processing step and this is exactly what we need.\n\t\t */\n\t\tconst nextTick = async () => { };\n\t\texports.nextTick = nextTick;\n\t\t/** Returns control to thread each 'tick' ms to avoid blocking. */\n\t\tasync function asyncLoop(iters, tick, cb) {\n\t\t    let ts = Date.now();\n\t\t    for (let i = 0; i < iters; i++) {\n\t\t        cb(i);\n\t\t        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n\t\t        const diff = Date.now() - ts;\n\t\t        if (diff >= 0 && diff < tick)\n\t\t            continue;\n\t\t        await (0, exports.nextTick)();\n\t\t        ts += diff;\n\t\t    }\n\t\t}\n\t\t/**\n\t\t * Convert JS string to byte array.\n\t\t * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n\t\t */\n\t\tfunction utf8ToBytes(str) {\n\t\t    if (typeof str !== 'string')\n\t\t        throw new Error('utf8ToBytes expected string, got ' + typeof str);\n\t\t    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n\t\t}\n\t\t/**\n\t\t * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n\t\t * Warning: when Uint8Array is passed, it would NOT get copied.\n\t\t * Keep in mind for future mutable operations.\n\t\t */\n\t\tfunction toBytes(data) {\n\t\t    if (typeof data === 'string')\n\t\t        data = utf8ToBytes(data);\n\t\t    (0, _assert_js_1.abytes)(data);\n\t\t    return data;\n\t\t}\n\t\t/**\n\t\t * Copies several Uint8Arrays into one.\n\t\t */\n\t\tfunction concatBytes(...arrays) {\n\t\t    let sum = 0;\n\t\t    for (let i = 0; i < arrays.length; i++) {\n\t\t        const a = arrays[i];\n\t\t        (0, _assert_js_1.abytes)(a);\n\t\t        sum += a.length;\n\t\t    }\n\t\t    const res = new Uint8Array(sum);\n\t\t    for (let i = 0, pad = 0; i < arrays.length; i++) {\n\t\t        const a = arrays[i];\n\t\t        res.set(a, pad);\n\t\t        pad += a.length;\n\t\t    }\n\t\t    return res;\n\t\t}\n\t\t/** For runtime check if class implements interface */\n\t\tclass Hash {\n\t\t    // Safe version that clones internal state\n\t\t    clone() {\n\t\t        return this._cloneInto();\n\t\t    }\n\t\t}\n\t\texports.Hash = Hash;\n\t\tfunction checkOpts(defaults, opts) {\n\t\t    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n\t\t        throw new Error('Options should be object or undefined');\n\t\t    const merged = Object.assign(defaults, opts);\n\t\t    return merged;\n\t\t}\n\t\t/** Wraps hash function, creating an interface on top of it */\n\t\tfunction wrapConstructor(hashCons) {\n\t\t    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n\t\t    const tmp = hashCons();\n\t\t    hashC.outputLen = tmp.outputLen;\n\t\t    hashC.blockLen = tmp.blockLen;\n\t\t    hashC.create = () => hashCons();\n\t\t    return hashC;\n\t\t}\n\t\tfunction wrapConstructorWithOpts(hashCons) {\n\t\t    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n\t\t    const tmp = hashCons({});\n\t\t    hashC.outputLen = tmp.outputLen;\n\t\t    hashC.blockLen = tmp.blockLen;\n\t\t    hashC.create = (opts) => hashCons(opts);\n\t\t    return hashC;\n\t\t}\n\t\tfunction wrapXOFConstructorWithOpts(hashCons) {\n\t\t    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n\t\t    const tmp = hashCons({});\n\t\t    hashC.outputLen = tmp.outputLen;\n\t\t    hashC.blockLen = tmp.blockLen;\n\t\t    hashC.create = (opts) => hashCons(opts);\n\t\t    return hashC;\n\t\t}\n\t\t/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\n\t\tfunction randomBytes(bytesLength = 32) {\n\t\t    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n\t\t        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n\t\t    }\n\t\t    // Legacy Node.js compatibility\n\t\t    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {\n\t\t        return crypto_1.crypto.randomBytes(bytesLength);\n\t\t    }\n\t\t    throw new Error('crypto.getRandomValues must be defined');\n\t\t}\n\t\t\n\t} (utils$3));\n\treturn utils$3;\n}\n\nvar hasRequired_md;\n\nfunction require_md () {\n\tif (hasRequired_md) return _md;\n\thasRequired_md = 1;\n\tObject.defineProperty(_md, \"__esModule\", { value: true });\n\t_md.HashMD = void 0;\n\t_md.setBigUint64 = setBigUint64;\n\t_md.Chi = Chi;\n\t_md.Maj = Maj;\n\t/**\n\t * Internal Merkle-Damgard hash utils.\n\t * @module\n\t */\n\tconst _assert_js_1 = /*@__PURE__*/ require_assert();\n\tconst utils_js_1 = /*@__PURE__*/ requireUtils$2();\n\t/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\n\tfunction setBigUint64(view, byteOffset, value, isLE) {\n\t    if (typeof view.setBigUint64 === 'function')\n\t        return view.setBigUint64(byteOffset, value, isLE);\n\t    const _32n = BigInt(32);\n\t    const _u32_max = BigInt(0xffffffff);\n\t    const wh = Number((value >> _32n) & _u32_max);\n\t    const wl = Number(value & _u32_max);\n\t    const h = isLE ? 4 : 0;\n\t    const l = isLE ? 0 : 4;\n\t    view.setUint32(byteOffset + h, wh, isLE);\n\t    view.setUint32(byteOffset + l, wl, isLE);\n\t}\n\t/** Choice: a ? b : c */\n\tfunction Chi(a, b, c) {\n\t    return (a & b) ^ (~a & c);\n\t}\n\t/** Majority function, true if any two inputs is true. */\n\tfunction Maj(a, b, c) {\n\t    return (a & b) ^ (a & c) ^ (b & c);\n\t}\n\t/**\n\t * Merkle-Damgard hash construction base class.\n\t * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n\t */\n\tclass HashMD extends utils_js_1.Hash {\n\t    constructor(blockLen, outputLen, padOffset, isLE) {\n\t        super();\n\t        this.blockLen = blockLen;\n\t        this.outputLen = outputLen;\n\t        this.padOffset = padOffset;\n\t        this.isLE = isLE;\n\t        this.finished = false;\n\t        this.length = 0;\n\t        this.pos = 0;\n\t        this.destroyed = false;\n\t        this.buffer = new Uint8Array(blockLen);\n\t        this.view = (0, utils_js_1.createView)(this.buffer);\n\t    }\n\t    update(data) {\n\t        (0, _assert_js_1.aexists)(this);\n\t        const { view, buffer, blockLen } = this;\n\t        data = (0, utils_js_1.toBytes)(data);\n\t        const len = data.length;\n\t        for (let pos = 0; pos < len;) {\n\t            const take = Math.min(blockLen - this.pos, len - pos);\n\t            // Fast path: we have at least one block in input, cast it to view and process\n\t            if (take === blockLen) {\n\t                const dataView = (0, utils_js_1.createView)(data);\n\t                for (; blockLen <= len - pos; pos += blockLen)\n\t                    this.process(dataView, pos);\n\t                continue;\n\t            }\n\t            buffer.set(data.subarray(pos, pos + take), this.pos);\n\t            this.pos += take;\n\t            pos += take;\n\t            if (this.pos === blockLen) {\n\t                this.process(view, 0);\n\t                this.pos = 0;\n\t            }\n\t        }\n\t        this.length += data.length;\n\t        this.roundClean();\n\t        return this;\n\t    }\n\t    digestInto(out) {\n\t        (0, _assert_js_1.aexists)(this);\n\t        (0, _assert_js_1.aoutput)(out, this);\n\t        this.finished = true;\n\t        // Padding\n\t        // We can avoid allocation of buffer for padding completely if it\n\t        // was previously not allocated here. But it won't change performance.\n\t        const { buffer, view, blockLen, isLE } = this;\n\t        let { pos } = this;\n\t        // append the bit '1' to the message\n\t        buffer[pos++] = 0b10000000;\n\t        this.buffer.subarray(pos).fill(0);\n\t        // we have less than padOffset left in buffer, so we cannot put length in\n\t        // current block, need process it and pad again\n\t        if (this.padOffset > blockLen - pos) {\n\t            this.process(view, 0);\n\t            pos = 0;\n\t        }\n\t        // Pad until full block byte with zeros\n\t        for (let i = pos; i < blockLen; i++)\n\t            buffer[i] = 0;\n\t        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n\t        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n\t        // So we just write lowest 64 bits of that value.\n\t        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n\t        this.process(view, 0);\n\t        const oview = (0, utils_js_1.createView)(out);\n\t        const len = this.outputLen;\n\t        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n\t        if (len % 4)\n\t            throw new Error('_sha2: outputLen should be aligned to 32bit');\n\t        const outLen = len / 4;\n\t        const state = this.get();\n\t        if (outLen > state.length)\n\t            throw new Error('_sha2: outputLen bigger than state');\n\t        for (let i = 0; i < outLen; i++)\n\t            oview.setUint32(4 * i, state[i], isLE);\n\t    }\n\t    digest() {\n\t        const { buffer, outputLen } = this;\n\t        this.digestInto(buffer);\n\t        const res = buffer.slice(0, outputLen);\n\t        this.destroy();\n\t        return res;\n\t    }\n\t    _cloneInto(to) {\n\t        to || (to = new this.constructor());\n\t        to.set(...this.get());\n\t        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n\t        to.length = length;\n\t        to.pos = pos;\n\t        to.finished = finished;\n\t        to.destroyed = destroyed;\n\t        if (length % blockLen)\n\t            to.buffer.set(buffer);\n\t        return to;\n\t    }\n\t}\n\t_md.HashMD = HashMD;\n\t\n\treturn _md;\n}\n\nvar _u64 = {};\n\nvar hasRequired_u64;\n\nfunction require_u64 () {\n\tif (hasRequired_u64) return _u64;\n\thasRequired_u64 = 1;\n\tObject.defineProperty(_u64, \"__esModule\", { value: true });\n\t_u64.add5L = _u64.add5H = _u64.add4H = _u64.add4L = _u64.add3H = _u64.add3L = _u64.rotlBL = _u64.rotlBH = _u64.rotlSL = _u64.rotlSH = _u64.rotr32L = _u64.rotr32H = _u64.rotrBL = _u64.rotrBH = _u64.rotrSL = _u64.rotrSH = _u64.shrSL = _u64.shrSH = _u64.toBig = void 0;\n\t_u64.fromBig = fromBig;\n\t_u64.split = split;\n\t_u64.add = add;\n\t/**\n\t * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n\t * @todo re-check https://issues.chromium.org/issues/42212588\n\t * @module\n\t */\n\tconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\n\tconst _32n = /* @__PURE__ */ BigInt(32);\n\tfunction fromBig(n, le = false) {\n\t    if (le)\n\t        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n\t    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n\t}\n\tfunction split(lst, le = false) {\n\t    let Ah = new Uint32Array(lst.length);\n\t    let Al = new Uint32Array(lst.length);\n\t    for (let i = 0; i < lst.length; i++) {\n\t        const { h, l } = fromBig(lst[i], le);\n\t        [Ah[i], Al[i]] = [h, l];\n\t    }\n\t    return [Ah, Al];\n\t}\n\tconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n\t_u64.toBig = toBig;\n\t// for Shift in [0, 32)\n\tconst shrSH = (h, _l, s) => h >>> s;\n\t_u64.shrSH = shrSH;\n\tconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n\t_u64.shrSL = shrSL;\n\t// Right rotate for Shift in [1, 32)\n\tconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\n\t_u64.rotrSH = rotrSH;\n\tconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n\t_u64.rotrSL = rotrSL;\n\t// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\n\tconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\n\t_u64.rotrBH = rotrBH;\n\tconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n\t_u64.rotrBL = rotrBL;\n\t// Right rotate for shift===32 (just swaps l&h)\n\tconst rotr32H = (_h, l) => l;\n\t_u64.rotr32H = rotr32H;\n\tconst rotr32L = (h, _l) => h;\n\t_u64.rotr32L = rotr32L;\n\t// Left rotate for Shift in [1, 32)\n\tconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\n\t_u64.rotlSH = rotlSH;\n\tconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n\t_u64.rotlSL = rotlSL;\n\t// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\n\tconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\n\t_u64.rotlBH = rotlBH;\n\tconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n\t_u64.rotlBL = rotlBL;\n\t// JS uses 32-bit signed integers for bitwise operations which means we cannot\n\t// simple take carry out of low bit sum by shift, we need to use division.\n\tfunction add(Ah, Al, Bh, Bl) {\n\t    const l = (Al >>> 0) + (Bl >>> 0);\n\t    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n\t}\n\t// Addition with more than 2 elements\n\tconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\n\t_u64.add3L = add3L;\n\tconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\n\t_u64.add3H = add3H;\n\tconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\n\t_u64.add4L = add4L;\n\tconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\n\t_u64.add4H = add4H;\n\tconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\n\t_u64.add5L = add5L;\n\tconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\t_u64.add5H = add5H;\n\t// prettier-ignore\n\tconst u64 = {\n\t    fromBig, split, toBig,\n\t    shrSH, shrSL,\n\t    rotrSH, rotrSL, rotrBH, rotrBL,\n\t    rotr32H, rotr32L,\n\t    rotlSH, rotlSL, rotlBH, rotlBL,\n\t    add, add3L, add3H, add4L, add4H, add5H, add5L,\n\t};\n\t_u64.default = u64;\n\t\n\treturn _u64;\n}\n\nvar hasRequiredSha512;\n\nfunction requireSha512 () {\n\tif (hasRequiredSha512) return sha512;\n\thasRequiredSha512 = 1;\n\tObject.defineProperty(sha512, \"__esModule\", { value: true });\n\tsha512.sha384 = sha512.sha512_256 = sha512.sha512_224 = sha512.sha512 = sha512.SHA384 = sha512.SHA512_256 = sha512.SHA512_224 = sha512.SHA512 = void 0;\n\t/**\n\t * SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.\n\t *\n\t * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n\t * [the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).\n\t * @module\n\t */\n\tconst _md_js_1 = /*@__PURE__*/ require_md();\n\tconst _u64_js_1 = /*@__PURE__*/ require_u64();\n\tconst utils_js_1 = /*@__PURE__*/ requireUtils$2();\n\t// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n\t// prettier-ignore\n\tconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js_1.default.split([\n\t    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n\t    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n\t    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n\t    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n\t    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n\t    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n\t    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n\t    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n\t    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n\t    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n\t    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n\t    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n\t    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n\t    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n\t    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n\t    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n\t    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n\t    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n\t    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n\t    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n\t].map(n => BigInt(n))))();\n\t// Temporary buffer, not used to store anything between runs\n\tconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\n\tconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\tclass SHA512 extends _md_js_1.HashMD {\n\t    constructor() {\n\t        super(128, 64, 16, false);\n\t        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n\t        // Also looks cleaner and easier to verify with spec.\n\t        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n\t        // h -- high 32 bits, l -- low 32 bits\n\t        this.Ah = 0x6a09e667 | 0;\n\t        this.Al = 0xf3bcc908 | 0;\n\t        this.Bh = 0xbb67ae85 | 0;\n\t        this.Bl = 0x84caa73b | 0;\n\t        this.Ch = 0x3c6ef372 | 0;\n\t        this.Cl = 0xfe94f82b | 0;\n\t        this.Dh = 0xa54ff53a | 0;\n\t        this.Dl = 0x5f1d36f1 | 0;\n\t        this.Eh = 0x510e527f | 0;\n\t        this.El = 0xade682d1 | 0;\n\t        this.Fh = 0x9b05688c | 0;\n\t        this.Fl = 0x2b3e6c1f | 0;\n\t        this.Gh = 0x1f83d9ab | 0;\n\t        this.Gl = 0xfb41bd6b | 0;\n\t        this.Hh = 0x5be0cd19 | 0;\n\t        this.Hl = 0x137e2179 | 0;\n\t    }\n\t    // prettier-ignore\n\t    get() {\n\t        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n\t        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n\t    }\n\t    // prettier-ignore\n\t    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n\t        this.Ah = Ah | 0;\n\t        this.Al = Al | 0;\n\t        this.Bh = Bh | 0;\n\t        this.Bl = Bl | 0;\n\t        this.Ch = Ch | 0;\n\t        this.Cl = Cl | 0;\n\t        this.Dh = Dh | 0;\n\t        this.Dl = Dl | 0;\n\t        this.Eh = Eh | 0;\n\t        this.El = El | 0;\n\t        this.Fh = Fh | 0;\n\t        this.Fl = Fl | 0;\n\t        this.Gh = Gh | 0;\n\t        this.Gl = Gl | 0;\n\t        this.Hh = Hh | 0;\n\t        this.Hl = Hl | 0;\n\t    }\n\t    process(view, offset) {\n\t        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n\t        for (let i = 0; i < 16; i++, offset += 4) {\n\t            SHA512_W_H[i] = view.getUint32(offset);\n\t            SHA512_W_L[i] = view.getUint32((offset += 4));\n\t        }\n\t        for (let i = 16; i < 80; i++) {\n\t            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n\t            const W15h = SHA512_W_H[i - 15] | 0;\n\t            const W15l = SHA512_W_L[i - 15] | 0;\n\t            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);\n\t            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);\n\t            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n\t            const W2h = SHA512_W_H[i - 2] | 0;\n\t            const W2l = SHA512_W_L[i - 2] | 0;\n\t            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);\n\t            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);\n\t            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n\t            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n\t            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n\t            SHA512_W_H[i] = SUMh | 0;\n\t            SHA512_W_L[i] = SUMl | 0;\n\t        }\n\t        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n\t        // Compression function main loop, 80 rounds\n\t        for (let i = 0; i < 80; i++) {\n\t            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n\t            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);\n\t            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);\n\t            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n\t            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n\t            const CHIl = (El & Fl) ^ (~El & Gl);\n\t            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n\t            // prettier-ignore\n\t            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n\t            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n\t            const T1l = T1ll | 0;\n\t            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n\t            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);\n\t            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);\n\t            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n\t            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n\t            Hh = Gh | 0;\n\t            Hl = Gl | 0;\n\t            Gh = Fh | 0;\n\t            Gl = Fl | 0;\n\t            Fh = Eh | 0;\n\t            Fl = El | 0;\n\t            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n\t            Dh = Ch | 0;\n\t            Dl = Cl | 0;\n\t            Ch = Bh | 0;\n\t            Cl = Bl | 0;\n\t            Bh = Ah | 0;\n\t            Bl = Al | 0;\n\t            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);\n\t            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);\n\t            Al = All | 0;\n\t        }\n\t        // Add the compressed chunk to the current hash value\n\t        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n\t        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n\t        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n\t        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n\t        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n\t        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n\t        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n\t        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n\t        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n\t    }\n\t    roundClean() {\n\t        SHA512_W_H.fill(0);\n\t        SHA512_W_L.fill(0);\n\t    }\n\t    destroy() {\n\t        this.buffer.fill(0);\n\t        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\t    }\n\t}\n\tsha512.SHA512 = SHA512;\n\tclass SHA512_224 extends SHA512 {\n\t    constructor() {\n\t        super();\n\t        // h -- high 32 bits, l -- low 32 bits\n\t        this.Ah = 0x8c3d37c8 | 0;\n\t        this.Al = 0x19544da2 | 0;\n\t        this.Bh = 0x73e19966 | 0;\n\t        this.Bl = 0x89dcd4d6 | 0;\n\t        this.Ch = 0x1dfab7ae | 0;\n\t        this.Cl = 0x32ff9c82 | 0;\n\t        this.Dh = 0x679dd514 | 0;\n\t        this.Dl = 0x582f9fcf | 0;\n\t        this.Eh = 0x0f6d2b69 | 0;\n\t        this.El = 0x7bd44da8 | 0;\n\t        this.Fh = 0x77e36f73 | 0;\n\t        this.Fl = 0x04c48942 | 0;\n\t        this.Gh = 0x3f9d85a8 | 0;\n\t        this.Gl = 0x6a1d36c8 | 0;\n\t        this.Hh = 0x1112e6ad | 0;\n\t        this.Hl = 0x91d692a1 | 0;\n\t        this.outputLen = 28;\n\t    }\n\t}\n\tsha512.SHA512_224 = SHA512_224;\n\tclass SHA512_256 extends SHA512 {\n\t    constructor() {\n\t        super();\n\t        // h -- high 32 bits, l -- low 32 bits\n\t        this.Ah = 0x22312194 | 0;\n\t        this.Al = 0xfc2bf72c | 0;\n\t        this.Bh = 0x9f555fa3 | 0;\n\t        this.Bl = 0xc84c64c2 | 0;\n\t        this.Ch = 0x2393b86b | 0;\n\t        this.Cl = 0x6f53b151 | 0;\n\t        this.Dh = 0x96387719 | 0;\n\t        this.Dl = 0x5940eabd | 0;\n\t        this.Eh = 0x96283ee2 | 0;\n\t        this.El = 0xa88effe3 | 0;\n\t        this.Fh = 0xbe5e1e25 | 0;\n\t        this.Fl = 0x53863992 | 0;\n\t        this.Gh = 0x2b0199fc | 0;\n\t        this.Gl = 0x2c85b8aa | 0;\n\t        this.Hh = 0x0eb72ddc | 0;\n\t        this.Hl = 0x81c52ca2 | 0;\n\t        this.outputLen = 32;\n\t    }\n\t}\n\tsha512.SHA512_256 = SHA512_256;\n\tclass SHA384 extends SHA512 {\n\t    constructor() {\n\t        super();\n\t        // h -- high 32 bits, l -- low 32 bits\n\t        this.Ah = 0xcbbb9d5d | 0;\n\t        this.Al = 0xc1059ed8 | 0;\n\t        this.Bh = 0x629a292a | 0;\n\t        this.Bl = 0x367cd507 | 0;\n\t        this.Ch = 0x9159015a | 0;\n\t        this.Cl = 0x3070dd17 | 0;\n\t        this.Dh = 0x152fecd8 | 0;\n\t        this.Dl = 0xf70e5939 | 0;\n\t        this.Eh = 0x67332667 | 0;\n\t        this.El = 0xffc00b31 | 0;\n\t        this.Fh = 0x8eb44a87 | 0;\n\t        this.Fl = 0x68581511 | 0;\n\t        this.Gh = 0xdb0c2e0d | 0;\n\t        this.Gl = 0x64f98fa7 | 0;\n\t        this.Hh = 0x47b5481d | 0;\n\t        this.Hl = 0xbefa4fa4 | 0;\n\t        this.outputLen = 48;\n\t    }\n\t}\n\tsha512.SHA384 = SHA384;\n\t/** SHA2-512 hash function. */\n\tsha512.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());\n\t/** SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks. */\n\tsha512.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());\n\t/** SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks. */\n\tsha512.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());\n\t/** SHA2-384 hash function. */\n\tsha512.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());\n\t\n\treturn sha512;\n}\n\nvar curve = {};\n\nvar modular = {};\n\nvar utils$2 = {};\n\nvar hasRequiredUtils$1;\n\nfunction requireUtils$1 () {\n\tif (hasRequiredUtils$1) return utils$2;\n\thasRequiredUtils$1 = 1;\n\t/**\n\t * Hex, bytes and number utilities.\n\t * @module\n\t */\n\t/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\tObject.defineProperty(utils$2, \"__esModule\", { value: true });\n\tutils$2.notImplemented = utils$2.bitMask = void 0;\n\tutils$2.isBytes = isBytes;\n\tutils$2.abytes = abytes;\n\tutils$2.abool = abool;\n\tutils$2.bytesToHex = bytesToHex;\n\tutils$2.numberToHexUnpadded = numberToHexUnpadded;\n\tutils$2.hexToNumber = hexToNumber;\n\tutils$2.hexToBytes = hexToBytes;\n\tutils$2.bytesToNumberBE = bytesToNumberBE;\n\tutils$2.bytesToNumberLE = bytesToNumberLE;\n\tutils$2.numberToBytesBE = numberToBytesBE;\n\tutils$2.numberToBytesLE = numberToBytesLE;\n\tutils$2.numberToVarBytesBE = numberToVarBytesBE;\n\tutils$2.ensureBytes = ensureBytes;\n\tutils$2.concatBytes = concatBytes;\n\tutils$2.equalBytes = equalBytes;\n\tutils$2.utf8ToBytes = utf8ToBytes;\n\tutils$2.inRange = inRange;\n\tutils$2.aInRange = aInRange;\n\tutils$2.bitLen = bitLen;\n\tutils$2.bitGet = bitGet;\n\tutils$2.bitSet = bitSet;\n\tutils$2.createHmacDrbg = createHmacDrbg;\n\tutils$2.validateObject = validateObject;\n\tutils$2.memoized = memoized;\n\t// 100 lines of code in the file are duplicated from noble-hashes (utils).\n\t// This is OK: `abstract` directory does not use noble-hashes.\n\t// User may opt-in into using different hashing library. This way, noble-hashes\n\t// won't be included into their bundle.\n\tconst _0n = /* @__PURE__ */ BigInt(0);\n\tconst _1n = /* @__PURE__ */ BigInt(1);\n\tconst _2n = /* @__PURE__ */ BigInt(2);\n\tfunction isBytes(a) {\n\t    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n\t}\n\tfunction abytes(item) {\n\t    if (!isBytes(item))\n\t        throw new Error('Uint8Array expected');\n\t}\n\tfunction abool(title, value) {\n\t    if (typeof value !== 'boolean')\n\t        throw new Error(title + ' boolean expected, got ' + value);\n\t}\n\t// Array where index 0xf0 (240) is mapped to string 'f0'\n\tconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n\t/**\n\t * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n\t */\n\tfunction bytesToHex(bytes) {\n\t    abytes(bytes);\n\t    // pre-caching improves the speed 6x\n\t    let hex = '';\n\t    for (let i = 0; i < bytes.length; i++) {\n\t        hex += hexes[bytes[i]];\n\t    }\n\t    return hex;\n\t}\n\tfunction numberToHexUnpadded(num) {\n\t    const hex = num.toString(16);\n\t    return hex.length & 1 ? '0' + hex : hex;\n\t}\n\tfunction hexToNumber(hex) {\n\t    if (typeof hex !== 'string')\n\t        throw new Error('hex string expected, got ' + typeof hex);\n\t    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n\t}\n\t// We use optimized technique to convert hex string to byte array\n\tconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\n\tfunction asciiToBase16(ch) {\n\t    if (ch >= asciis._0 && ch <= asciis._9)\n\t        return ch - asciis._0; // '2' => 50-48\n\t    if (ch >= asciis.A && ch <= asciis.F)\n\t        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n\t    if (ch >= asciis.a && ch <= asciis.f)\n\t        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n\t    return;\n\t}\n\t/**\n\t * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n\t */\n\tfunction hexToBytes(hex) {\n\t    if (typeof hex !== 'string')\n\t        throw new Error('hex string expected, got ' + typeof hex);\n\t    const hl = hex.length;\n\t    const al = hl / 2;\n\t    if (hl % 2)\n\t        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n\t    const array = new Uint8Array(al);\n\t    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n\t        const n1 = asciiToBase16(hex.charCodeAt(hi));\n\t        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n\t        if (n1 === undefined || n2 === undefined) {\n\t            const char = hex[hi] + hex[hi + 1];\n\t            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n\t        }\n\t        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n\t    }\n\t    return array;\n\t}\n\t// BE: Big Endian, LE: Little Endian\n\tfunction bytesToNumberBE(bytes) {\n\t    return hexToNumber(bytesToHex(bytes));\n\t}\n\tfunction bytesToNumberLE(bytes) {\n\t    abytes(bytes);\n\t    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n\t}\n\tfunction numberToBytesBE(n, len) {\n\t    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n\t}\n\tfunction numberToBytesLE(n, len) {\n\t    return numberToBytesBE(n, len).reverse();\n\t}\n\t// Unpadded, rarely used\n\tfunction numberToVarBytesBE(n) {\n\t    return hexToBytes(numberToHexUnpadded(n));\n\t}\n\t/**\n\t * Takes hex string or Uint8Array, converts to Uint8Array.\n\t * Validates output length.\n\t * Will throw error for other types.\n\t * @param title descriptive title for an error e.g. 'private key'\n\t * @param hex hex string or Uint8Array\n\t * @param expectedLength optional, will compare to result array's length\n\t * @returns\n\t */\n\tfunction ensureBytes(title, hex, expectedLength) {\n\t    let res;\n\t    if (typeof hex === 'string') {\n\t        try {\n\t            res = hexToBytes(hex);\n\t        }\n\t        catch (e) {\n\t            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n\t        }\n\t    }\n\t    else if (isBytes(hex)) {\n\t        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n\t        // is instance of Uint8Array, and its slice() creates **mutable** copy\n\t        res = Uint8Array.from(hex);\n\t    }\n\t    else {\n\t        throw new Error(title + ' must be hex string or Uint8Array');\n\t    }\n\t    const len = res.length;\n\t    if (typeof expectedLength === 'number' && len !== expectedLength)\n\t        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n\t    return res;\n\t}\n\t/**\n\t * Copies several Uint8Arrays into one.\n\t */\n\tfunction concatBytes(...arrays) {\n\t    let sum = 0;\n\t    for (let i = 0; i < arrays.length; i++) {\n\t        const a = arrays[i];\n\t        abytes(a);\n\t        sum += a.length;\n\t    }\n\t    const res = new Uint8Array(sum);\n\t    for (let i = 0, pad = 0; i < arrays.length; i++) {\n\t        const a = arrays[i];\n\t        res.set(a, pad);\n\t        pad += a.length;\n\t    }\n\t    return res;\n\t}\n\t// Compares 2 u8a-s in kinda constant time\n\tfunction equalBytes(a, b) {\n\t    if (a.length !== b.length)\n\t        return false;\n\t    let diff = 0;\n\t    for (let i = 0; i < a.length; i++)\n\t        diff |= a[i] ^ b[i];\n\t    return diff === 0;\n\t}\n\t/**\n\t * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n\t */\n\tfunction utf8ToBytes(str) {\n\t    if (typeof str !== 'string')\n\t        throw new Error('string expected');\n\t    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n\t}\n\t// Is positive bigint\n\tconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\n\tfunction inRange(n, min, max) {\n\t    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n\t}\n\t/**\n\t * Asserts min <= n < max. NOTE: It's < max and not <= max.\n\t * @example\n\t * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n\t */\n\tfunction aInRange(title, n, min, max) {\n\t    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n\t    // consider P=256n, min=0n, max=P\n\t    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n\t    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n\t    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n\t    if (!inRange(n, min, max))\n\t        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n\t}\n\t// Bit operations\n\t/**\n\t * Calculates amount of bits in a bigint.\n\t * Same as `n.toString(2).length`\n\t */\n\tfunction bitLen(n) {\n\t    let len;\n\t    for (len = 0; n > _0n; n >>= _1n, len += 1)\n\t        ;\n\t    return len;\n\t}\n\t/**\n\t * Gets single bit at position.\n\t * NOTE: first bit position is 0 (same as arrays)\n\t * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n\t */\n\tfunction bitGet(n, pos) {\n\t    return (n >> BigInt(pos)) & _1n;\n\t}\n\t/**\n\t * Sets single bit at position.\n\t */\n\tfunction bitSet(n, pos, value) {\n\t    return n | ((value ? _1n : _0n) << BigInt(pos));\n\t}\n\t/**\n\t * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n\t * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n\t */\n\tconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n\tutils$2.bitMask = bitMask;\n\t// DRBG\n\tconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\n\tconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n\t/**\n\t * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n\t * @returns function that will call DRBG until 2nd arg returns something meaningful\n\t * @example\n\t *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n\t *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n\t */\n\tfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n\t    if (typeof hashLen !== 'number' || hashLen < 2)\n\t        throw new Error('hashLen must be a number');\n\t    if (typeof qByteLen !== 'number' || qByteLen < 2)\n\t        throw new Error('qByteLen must be a number');\n\t    if (typeof hmacFn !== 'function')\n\t        throw new Error('hmacFn must be a function');\n\t    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n\t    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n\t    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n\t    let i = 0; // Iterations counter, will throw when over 1000\n\t    const reset = () => {\n\t        v.fill(1);\n\t        k.fill(0);\n\t        i = 0;\n\t    };\n\t    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n\t    const reseed = (seed = u8n()) => {\n\t        // HMAC-DRBG reseed() function. Steps D-G\n\t        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n\t        v = h(); // v = hmac(k || v)\n\t        if (seed.length === 0)\n\t            return;\n\t        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n\t        v = h(); // v = hmac(k || v)\n\t    };\n\t    const gen = () => {\n\t        // HMAC-DRBG generate() function\n\t        if (i++ >= 1000)\n\t            throw new Error('drbg: tried 1000 values');\n\t        let len = 0;\n\t        const out = [];\n\t        while (len < qByteLen) {\n\t            v = h();\n\t            const sl = v.slice();\n\t            out.push(sl);\n\t            len += v.length;\n\t        }\n\t        return concatBytes(...out);\n\t    };\n\t    const genUntil = (seed, pred) => {\n\t        reset();\n\t        reseed(seed); // Steps D-G\n\t        let res = undefined; // Step H: grind until k is in [1..n-1]\n\t        while (!(res = pred(gen())))\n\t            reseed();\n\t        reset();\n\t        return res;\n\t    };\n\t    return genUntil;\n\t}\n\t// Validating curves and fields\n\tconst validatorFns = {\n\t    bigint: (val) => typeof val === 'bigint',\n\t    function: (val) => typeof val === 'function',\n\t    boolean: (val) => typeof val === 'boolean',\n\t    string: (val) => typeof val === 'string',\n\t    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n\t    isSafeInteger: (val) => Number.isSafeInteger(val),\n\t    array: (val) => Array.isArray(val),\n\t    field: (val, object) => object.Fp.isValid(val),\n\t    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n\t};\n\t// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\tfunction validateObject(object, validators, optValidators = {}) {\n\t    const checkField = (fieldName, type, isOptional) => {\n\t        const checkVal = validatorFns[type];\n\t        if (typeof checkVal !== 'function')\n\t            throw new Error('invalid validator function');\n\t        const val = object[fieldName];\n\t        if (isOptional && val === undefined)\n\t            return;\n\t        if (!checkVal(val, object)) {\n\t            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n\t        }\n\t    };\n\t    for (const [fieldName, type] of Object.entries(validators))\n\t        checkField(fieldName, type, false);\n\t    for (const [fieldName, type] of Object.entries(optValidators))\n\t        checkField(fieldName, type, true);\n\t    return object;\n\t}\n\t// validate type tests\n\t// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n\t// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n\t// // Should fail type-check\n\t// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n\t// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n\t// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n\t// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\t/**\n\t * throws not implemented error\n\t */\n\tconst notImplemented = () => {\n\t    throw new Error('not implemented');\n\t};\n\tutils$2.notImplemented = notImplemented;\n\t/**\n\t * Memoizes (caches) computation result.\n\t * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n\t */\n\tfunction memoized(fn) {\n\t    const map = new WeakMap();\n\t    return (arg, ...args) => {\n\t        const val = map.get(arg);\n\t        if (val !== undefined)\n\t            return val;\n\t        const computed = fn(arg, ...args);\n\t        map.set(arg, computed);\n\t        return computed;\n\t    };\n\t}\n\t\n\treturn utils$2;\n}\n\nvar hasRequiredModular;\n\nfunction requireModular () {\n\tif (hasRequiredModular) return modular;\n\thasRequiredModular = 1;\n\tObject.defineProperty(modular, \"__esModule\", { value: true });\n\tmodular.isNegativeLE = void 0;\n\tmodular.mod = mod;\n\tmodular.pow = pow;\n\tmodular.pow2 = pow2;\n\tmodular.invert = invert;\n\tmodular.tonelliShanks = tonelliShanks;\n\tmodular.FpSqrt = FpSqrt;\n\tmodular.validateField = validateField;\n\tmodular.FpPow = FpPow;\n\tmodular.FpInvertBatch = FpInvertBatch;\n\tmodular.FpDiv = FpDiv;\n\tmodular.FpLegendre = FpLegendre;\n\tmodular.FpIsSquare = FpIsSquare;\n\tmodular.nLength = nLength;\n\tmodular.Field = Field;\n\tmodular.FpSqrtOdd = FpSqrtOdd;\n\tmodular.FpSqrtEven = FpSqrtEven;\n\tmodular.hashToPrivateScalar = hashToPrivateScalar;\n\tmodular.getFieldBytesLength = getFieldBytesLength;\n\tmodular.getMinHashLength = getMinHashLength;\n\tmodular.mapHashToField = mapHashToField;\n\t/**\n\t * Utils for modular division and finite fields.\n\t * A finite field over 11 is integer number operations `mod 11`.\n\t * There is no division: it is replaced by modular multiplicative inverse.\n\t * @module\n\t */\n\t/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\tconst utils_js_1 = /*@__PURE__*/ requireUtils$1();\n\t// prettier-ignore\n\tconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n\t// prettier-ignore\n\tconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n\t// Calculates a modulo b\n\tfunction mod(a, b) {\n\t    const result = a % b;\n\t    return result >= _0n ? result : b + result;\n\t}\n\t/**\n\t * Efficiently raise num to power and do modular division.\n\t * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n\t * @todo use field version && remove\n\t * @example\n\t * pow(2n, 6n, 11n) // 64n % 11n == 9n\n\t */\n\tfunction pow(num, power, modulo) {\n\t    if (power < _0n)\n\t        throw new Error('invalid exponent, negatives unsupported');\n\t    if (modulo <= _0n)\n\t        throw new Error('invalid modulus');\n\t    if (modulo === _1n)\n\t        return _0n;\n\t    let res = _1n;\n\t    while (power > _0n) {\n\t        if (power & _1n)\n\t            res = (res * num) % modulo;\n\t        num = (num * num) % modulo;\n\t        power >>= _1n;\n\t    }\n\t    return res;\n\t}\n\t/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\n\tfunction pow2(x, power, modulo) {\n\t    let res = x;\n\t    while (power-- > _0n) {\n\t        res *= res;\n\t        res %= modulo;\n\t    }\n\t    return res;\n\t}\n\t/**\n\t * Inverses number over modulo.\n\t * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n\t */\n\tfunction invert(number, modulo) {\n\t    if (number === _0n)\n\t        throw new Error('invert: expected non-zero number');\n\t    if (modulo <= _0n)\n\t        throw new Error('invert: expected positive modulus, got ' + modulo);\n\t    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n\t    let a = mod(number, modulo);\n\t    let b = modulo;\n\t    // prettier-ignore\n\t    let x = _0n, u = _1n;\n\t    while (a !== _0n) {\n\t        // JIT applies optimization if those two lines follow each other\n\t        const q = b / a;\n\t        const r = b % a;\n\t        const m = x - u * q;\n\t        // prettier-ignore\n\t        b = a, a = r, x = u, u = m;\n\t    }\n\t    const gcd = b;\n\t    if (gcd !== _1n)\n\t        throw new Error('invert: does not exist');\n\t    return mod(x, modulo);\n\t}\n\t/**\n\t * Tonelli-Shanks square root search algorithm.\n\t * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n\t * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n\t * Will start an infinite loop if field order P is not prime.\n\t * @param P field order\n\t * @returns function that takes field Fp (created from P) and number n\n\t */\n\tfunction tonelliShanks(P) {\n\t    // Legendre constant: used to calculate Legendre symbol (a | p),\n\t    // which denotes the value of a^((p-1)/2) (mod p).\n\t    // (a | p)  1    if a is a square (mod p)\n\t    // (a | p)  -1   if a is not a square (mod p)\n\t    // (a | p)  0    if a  0 (mod p)\n\t    const legendreC = (P - _1n) / _2n;\n\t    let Q, S, Z;\n\t    // Step 1: By factoring out powers of 2 from p - 1,\n\t    // find q and s such that p - 1 = q*(2^s) with q odd\n\t    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n\t        ;\n\t    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n\t    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {\n\t        // Crash instead of infinity loop, we cannot reasonable count until P.\n\t        if (Z > 1000)\n\t            throw new Error('Cannot find square root: likely non-prime P');\n\t    }\n\t    // Fast-path\n\t    if (S === 1) {\n\t        const p1div4 = (P + _1n) / _4n;\n\t        return function tonelliFast(Fp, n) {\n\t            const root = Fp.pow(n, p1div4);\n\t            if (!Fp.eql(Fp.sqr(root), n))\n\t                throw new Error('Cannot find square root');\n\t            return root;\n\t        };\n\t    }\n\t    // Slow-path\n\t    const Q1div2 = (Q + _1n) / _2n;\n\t    return function tonelliSlow(Fp, n) {\n\t        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n\t        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n\t            throw new Error('Cannot find square root');\n\t        let r = S;\n\t        // TODO: will fail at Fp2/etc\n\t        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n\t        let x = Fp.pow(n, Q1div2); // first guess at the square root\n\t        let b = Fp.pow(n, Q); // first guess at the fudge factor\n\t        while (!Fp.eql(b, Fp.ONE)) {\n\t            if (Fp.eql(b, Fp.ZERO))\n\t                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n\t            // Find m such b^(2^m)==1\n\t            let m = 1;\n\t            for (let t2 = Fp.sqr(b); m < r; m++) {\n\t                if (Fp.eql(t2, Fp.ONE))\n\t                    break;\n\t                t2 = Fp.sqr(t2); // t2 *= t2\n\t            }\n\t            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n\t            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n\t            g = Fp.sqr(ge); // g = ge * ge\n\t            x = Fp.mul(x, ge); // x *= ge\n\t            b = Fp.mul(b, g); // b *= g\n\t            r = m;\n\t        }\n\t        return x;\n\t    };\n\t}\n\t/**\n\t * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n\t *\n\t * 1. P  3 (mod 4)\n\t * 2. P  5 (mod 8)\n\t * 3. P  9 (mod 16)\n\t * 4. Tonelli-Shanks algorithm\n\t *\n\t * Different algorithms can give different roots, it is up to user to decide which one they want.\n\t * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n\t */\n\tfunction FpSqrt(P) {\n\t    // P  3 (mod 4)\n\t    // n = n^((P+1)/4)\n\t    if (P % _4n === _3n) {\n\t        // Not all roots possible!\n\t        // const ORDER =\n\t        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n\t        // const NUM = 72057594037927816n;\n\t        const p1div4 = (P + _1n) / _4n;\n\t        return function sqrt3mod4(Fp, n) {\n\t            const root = Fp.pow(n, p1div4);\n\t            // Throw if root**2 != n\n\t            if (!Fp.eql(Fp.sqr(root), n))\n\t                throw new Error('Cannot find square root');\n\t            return root;\n\t        };\n\t    }\n\t    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n\t    if (P % _8n === _5n) {\n\t        const c1 = (P - _5n) / _8n;\n\t        return function sqrt5mod8(Fp, n) {\n\t            const n2 = Fp.mul(n, _2n);\n\t            const v = Fp.pow(n2, c1);\n\t            const nv = Fp.mul(n, v);\n\t            const i = Fp.mul(Fp.mul(nv, _2n), v);\n\t            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n\t            if (!Fp.eql(Fp.sqr(root), n))\n\t                throw new Error('Cannot find square root');\n\t            return root;\n\t        };\n\t    }\n\t    // Other cases: Tonelli-Shanks algorithm\n\t    return tonelliShanks(P);\n\t}\n\t// Little-endian check for first LE bit (last BE bit);\n\tconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n\tmodular.isNegativeLE = isNegativeLE;\n\t// prettier-ignore\n\tconst FIELD_FIELDS = [\n\t    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n\t    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n\t    'addN', 'subN', 'mulN', 'sqrN'\n\t];\n\tfunction validateField(field) {\n\t    const initial = {\n\t        ORDER: 'bigint',\n\t        MASK: 'bigint',\n\t        BYTES: 'isSafeInteger',\n\t        BITS: 'isSafeInteger',\n\t    };\n\t    const opts = FIELD_FIELDS.reduce((map, val) => {\n\t        map[val] = 'function';\n\t        return map;\n\t    }, initial);\n\t    return (0, utils_js_1.validateObject)(field, opts);\n\t}\n\t// Generic field functions\n\t/**\n\t * Same as `pow` but for Fp: non-constant-time.\n\t * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n\t */\n\tfunction FpPow(f, num, power) {\n\t    // Should have same speed as pow for bigints\n\t    // TODO: benchmark!\n\t    if (power < _0n)\n\t        throw new Error('invalid exponent, negatives unsupported');\n\t    if (power === _0n)\n\t        return f.ONE;\n\t    if (power === _1n)\n\t        return num;\n\t    let p = f.ONE;\n\t    let d = num;\n\t    while (power > _0n) {\n\t        if (power & _1n)\n\t            p = f.mul(p, d);\n\t        d = f.sqr(d);\n\t        power >>= _1n;\n\t    }\n\t    return p;\n\t}\n\t/**\n\t * Efficiently invert an array of Field elements.\n\t * `inv(0)` will return `undefined` here: make sure to throw an error.\n\t */\n\tfunction FpInvertBatch(f, nums) {\n\t    const tmp = new Array(nums.length);\n\t    // Walk from first to last, multiply them by each other MOD p\n\t    const lastMultiplied = nums.reduce((acc, num, i) => {\n\t        if (f.is0(num))\n\t            return acc;\n\t        tmp[i] = acc;\n\t        return f.mul(acc, num);\n\t    }, f.ONE);\n\t    // Invert last element\n\t    const inverted = f.inv(lastMultiplied);\n\t    // Walk from last to first, multiply them by inverted each other MOD p\n\t    nums.reduceRight((acc, num, i) => {\n\t        if (f.is0(num))\n\t            return acc;\n\t        tmp[i] = f.mul(acc, tmp[i]);\n\t        return f.mul(acc, num);\n\t    }, inverted);\n\t    return tmp;\n\t}\n\tfunction FpDiv(f, lhs, rhs) {\n\t    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n\t}\n\t/**\n\t * Legendre symbol.\n\t * * (a | p)  1    if a is a square (mod p), quadratic residue\n\t * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n\t * * (a | p)  0    if a  0 (mod p)\n\t */\n\tfunction FpLegendre(order) {\n\t    const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n\t    return (f, x) => f.pow(x, legendreConst);\n\t}\n\t// This function returns True whenever the value x is a square in the field F.\n\tfunction FpIsSquare(f) {\n\t    const legendre = FpLegendre(f.ORDER);\n\t    return (x) => {\n\t        const p = legendre(f, x);\n\t        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n\t    };\n\t}\n\t// CURVE.n lengths\n\tfunction nLength(n, nBitLength) {\n\t    // Bit size, byte size of CURVE.n\n\t    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n\t    const nByteLength = Math.ceil(_nBitLength / 8);\n\t    return { nBitLength: _nBitLength, nByteLength };\n\t}\n\t/**\n\t * Initializes a finite field over prime.\n\t * Major performance optimizations:\n\t * * a) denormalized operations like mulN instead of mul\n\t * * b) same object shape: never add or remove keys\n\t * * c) Object.freeze\n\t * Fragile: always run a benchmark on a change.\n\t * Security note: operations don't check 'isValid' for all elements for performance reasons,\n\t * it is caller responsibility to check this.\n\t * This is low-level code, please make sure you know what you're doing.\n\t * @param ORDER prime positive bigint\n\t * @param bitLen how many bits the field consumes\n\t * @param isLE (def: false) if encoding / decoding should be in little-endian\n\t * @param redef optional faster redefinitions of sqrt and other methods\n\t */\n\tfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n\t    if (ORDER <= _0n)\n\t        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n\t    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n\t    if (BYTES > 2048)\n\t        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n\t    let sqrtP; // cached sqrtP\n\t    const f = Object.freeze({\n\t        ORDER,\n\t        isLE,\n\t        BITS,\n\t        BYTES,\n\t        MASK: (0, utils_js_1.bitMask)(BITS),\n\t        ZERO: _0n,\n\t        ONE: _1n,\n\t        create: (num) => mod(num, ORDER),\n\t        isValid: (num) => {\n\t            if (typeof num !== 'bigint')\n\t                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n\t            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n\t        },\n\t        is0: (num) => num === _0n,\n\t        isOdd: (num) => (num & _1n) === _1n,\n\t        neg: (num) => mod(-num, ORDER),\n\t        eql: (lhs, rhs) => lhs === rhs,\n\t        sqr: (num) => mod(num * num, ORDER),\n\t        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n\t        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n\t        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n\t        pow: (num, power) => FpPow(f, num, power),\n\t        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\t        // Same as above, but doesn't normalize\n\t        sqrN: (num) => num * num,\n\t        addN: (lhs, rhs) => lhs + rhs,\n\t        subN: (lhs, rhs) => lhs - rhs,\n\t        mulN: (lhs, rhs) => lhs * rhs,\n\t        inv: (num) => invert(num, ORDER),\n\t        sqrt: redef.sqrt ||\n\t            ((n) => {\n\t                if (!sqrtP)\n\t                    sqrtP = FpSqrt(ORDER);\n\t                return sqrtP(f, n);\n\t            }),\n\t        invertBatch: (lst) => FpInvertBatch(f, lst),\n\t        // TODO: do we really need constant cmov?\n\t        // We don't have const-time bigints anyway, so probably will be not very useful\n\t        cmov: (a, b, c) => (c ? b : a),\n\t        toBytes: (num) => (isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES)),\n\t        fromBytes: (bytes) => {\n\t            if (bytes.length !== BYTES)\n\t                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n\t            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);\n\t        },\n\t    });\n\t    return Object.freeze(f);\n\t}\n\tfunction FpSqrtOdd(Fp, elm) {\n\t    if (!Fp.isOdd)\n\t        throw new Error(\"Field doesn't have isOdd\");\n\t    const root = Fp.sqrt(elm);\n\t    return Fp.isOdd(root) ? root : Fp.neg(root);\n\t}\n\tfunction FpSqrtEven(Fp, elm) {\n\t    if (!Fp.isOdd)\n\t        throw new Error(\"Field doesn't have isOdd\");\n\t    const root = Fp.sqrt(elm);\n\t    return Fp.isOdd(root) ? Fp.neg(root) : root;\n\t}\n\t/**\n\t * \"Constant-time\" private key generation utility.\n\t * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n\t * Which makes it slightly more biased, less secure.\n\t * @deprecated use `mapKeyToField` instead\n\t */\n\tfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n\t    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);\n\t    const hashLen = hash.length;\n\t    const minLen = nLength(groupOrder).nByteLength + 8;\n\t    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n\t        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n\t    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);\n\t    return mod(num, groupOrder - _1n) + _1n;\n\t}\n\t/**\n\t * Returns total number of bytes consumed by the field element.\n\t * For example, 32 bytes for usual 256-bit weierstrass curve.\n\t * @param fieldOrder number of field elements, usually CURVE.n\n\t * @returns byte length of field\n\t */\n\tfunction getFieldBytesLength(fieldOrder) {\n\t    if (typeof fieldOrder !== 'bigint')\n\t        throw new Error('field order must be bigint');\n\t    const bitLength = fieldOrder.toString(2).length;\n\t    return Math.ceil(bitLength / 8);\n\t}\n\t/**\n\t * Returns minimal amount of bytes that can be safely reduced\n\t * by field order.\n\t * Should be 2^-128 for 128-bit curve such as P256.\n\t * @param fieldOrder number of field elements, usually CURVE.n\n\t * @returns byte length of target hash\n\t */\n\tfunction getMinHashLength(fieldOrder) {\n\t    const length = getFieldBytesLength(fieldOrder);\n\t    return length + Math.ceil(length / 2);\n\t}\n\t/**\n\t * \"Constant-time\" private key generation utility.\n\t * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n\t * and convert them into private scalar, with the modulo bias being negligible.\n\t * Needs at least 48 bytes of input for 32-byte private key.\n\t * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n\t * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n\t * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n\t * @param hash hash output from SHA3 or a similar function\n\t * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n\t * @param isLE interpret hash bytes as LE num\n\t * @returns valid private scalar\n\t */\n\tfunction mapHashToField(key, fieldOrder, isLE = false) {\n\t    const len = key.length;\n\t    const fieldLen = getFieldBytesLength(fieldOrder);\n\t    const minLen = getMinHashLength(fieldOrder);\n\t    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n\t    if (len < 16 || len < minLen || len > 1024)\n\t        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n\t    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(key) : (0, utils_js_1.bytesToNumberBE)(key);\n\t    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n\t    const reduced = mod(num, fieldOrder - _1n) + _1n;\n\t    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);\n\t}\n\t\n\treturn modular;\n}\n\nvar hasRequiredCurve;\n\nfunction requireCurve () {\n\tif (hasRequiredCurve) return curve;\n\thasRequiredCurve = 1;\n\tObject.defineProperty(curve, \"__esModule\", { value: true });\n\tcurve.wNAF = wNAF;\n\tcurve.pippenger = pippenger;\n\tcurve.precomputeMSMUnsafe = precomputeMSMUnsafe;\n\tcurve.validateBasic = validateBasic;\n\t/**\n\t * Methods for elliptic curve multiplication by scalars.\n\t * Contains wNAF, pippenger\n\t * @module\n\t */\n\t/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\tconst modular_js_1 = /*@__PURE__*/ requireModular();\n\tconst utils_js_1 = /*@__PURE__*/ requireUtils$1();\n\tconst _0n = BigInt(0);\n\tconst _1n = BigInt(1);\n\tfunction constTimeNegate(condition, item) {\n\t    const neg = item.negate();\n\t    return condition ? neg : item;\n\t}\n\tfunction validateW(W, bits) {\n\t    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n\t        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n\t}\n\tfunction calcWOpts(W, bits) {\n\t    validateW(W, bits);\n\t    const windows = Math.ceil(bits / W) + 1; // +1, because\n\t    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n\t    return { windows, windowSize };\n\t}\n\tfunction validateMSMPoints(points, c) {\n\t    if (!Array.isArray(points))\n\t        throw new Error('array expected');\n\t    points.forEach((p, i) => {\n\t        if (!(p instanceof c))\n\t            throw new Error('invalid point at index ' + i);\n\t    });\n\t}\n\tfunction validateMSMScalars(scalars, field) {\n\t    if (!Array.isArray(scalars))\n\t        throw new Error('array of scalars expected');\n\t    scalars.forEach((s, i) => {\n\t        if (!field.isValid(s))\n\t            throw new Error('invalid scalar at index ' + i);\n\t    });\n\t}\n\t// Since points in different groups cannot be equal (different object constructor),\n\t// we can have single place to store precomputes\n\tconst pointPrecomputes = new WeakMap();\n\tconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\n\tfunction getW(P) {\n\t    return pointWindowSizes.get(P) || 1;\n\t}\n\t/**\n\t * Elliptic curve multiplication of Point by scalar. Fragile.\n\t * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n\t * Creates precomputation tables for fast multiplication:\n\t * - private scalar is split by fixed size windows of W bits\n\t * - every window point is collected from window's table & added to accumulator\n\t * - since windows are different, same point inside tables won't be accessed more than once per calc\n\t * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n\t * - +1 window is neccessary for wNAF\n\t * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n\t *\n\t * @todo Research returning 2d JS array of windows, instead of a single window.\n\t * This would allow windows to be in different memory locations\n\t */\n\tfunction wNAF(c, bits) {\n\t    return {\n\t        constTimeNegate,\n\t        hasPrecomputes(elm) {\n\t            return getW(elm) !== 1;\n\t        },\n\t        // non-const time multiplication ladder\n\t        unsafeLadder(elm, n, p = c.ZERO) {\n\t            let d = elm;\n\t            while (n > _0n) {\n\t                if (n & _1n)\n\t                    p = p.add(d);\n\t                d = d.double();\n\t                n >>= _1n;\n\t            }\n\t            return p;\n\t        },\n\t        /**\n\t         * Creates a wNAF precomputation window. Used for caching.\n\t         * Default window size is set by `utils.precompute()` and is equal to 8.\n\t         * Number of precomputed points depends on the curve size:\n\t         * 2^(1) * (Math.ceil( / ) + 1), where:\n\t         * -  is the window size\n\t         * -  is the bitlength of the curve order.\n\t         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n\t         * @param elm Point instance\n\t         * @param W window size\n\t         * @returns precomputed point tables flattened to a single array\n\t         */\n\t        precomputeWindow(elm, W) {\n\t            const { windows, windowSize } = calcWOpts(W, bits);\n\t            const points = [];\n\t            let p = elm;\n\t            let base = p;\n\t            for (let window = 0; window < windows; window++) {\n\t                base = p;\n\t                points.push(base);\n\t                // =1, because we skip zero\n\t                for (let i = 1; i < windowSize; i++) {\n\t                    base = base.add(p);\n\t                    points.push(base);\n\t                }\n\t                p = base.double();\n\t            }\n\t            return points;\n\t        },\n\t        /**\n\t         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n\t         * @param W window size\n\t         * @param precomputes precomputed tables\n\t         * @param n scalar (we don't check here, but should be less than curve order)\n\t         * @returns real and fake (for const-time) points\n\t         */\n\t        wNAF(W, precomputes, n) {\n\t            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n\t            // But need to carefully remove other checks before wNAF. ORDER == bits here\n\t            const { windows, windowSize } = calcWOpts(W, bits);\n\t            let p = c.ZERO;\n\t            let f = c.BASE;\n\t            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n\t            const maxNumber = 2 ** W;\n\t            const shiftBy = BigInt(W);\n\t            for (let window = 0; window < windows; window++) {\n\t                const offset = window * windowSize;\n\t                // Extract W bits.\n\t                let wbits = Number(n & mask);\n\t                // Shift number by W bits.\n\t                n >>= shiftBy;\n\t                // If the bits are bigger than max size, we'll split those.\n\t                // +224 => 256 - 32\n\t                if (wbits > windowSize) {\n\t                    wbits -= maxNumber;\n\t                    n += _1n;\n\t                }\n\t                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n\t                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n\t                // there is negate now: it is possible that negated element from low value\n\t                // would be the same as high element, which will create carry into next window.\n\t                // It's not obvious how this can fail, but still worth investigating later.\n\t                // Check if we're onto Zero point.\n\t                // Add random point inside current window to f.\n\t                const offset1 = offset;\n\t                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n\t                const cond1 = window % 2 !== 0;\n\t                const cond2 = wbits < 0;\n\t                if (wbits === 0) {\n\t                    // The most important part for const-time getPublicKey\n\t                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n\t                }\n\t                else {\n\t                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n\t                }\n\t            }\n\t            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n\t            // Even if the variable is still unused, there are some checks which will\n\t            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n\t            // At this point there is a way to F be infinity-point even if p is not,\n\t            // which makes it less const-time: around 1 bigint multiply.\n\t            return { p, f };\n\t        },\n\t        /**\n\t         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n\t         * @param W window size\n\t         * @param precomputes precomputed tables\n\t         * @param n scalar (we don't check here, but should be less than curve order)\n\t         * @param acc accumulator point to add result of multiplication\n\t         * @returns point\n\t         */\n\t        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n\t            const { windows, windowSize } = calcWOpts(W, bits);\n\t            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n\t            const maxNumber = 2 ** W;\n\t            const shiftBy = BigInt(W);\n\t            for (let window = 0; window < windows; window++) {\n\t                const offset = window * windowSize;\n\t                if (n === _0n)\n\t                    break; // No need to go over empty scalar\n\t                // Extract W bits.\n\t                let wbits = Number(n & mask);\n\t                // Shift number by W bits.\n\t                n >>= shiftBy;\n\t                // If the bits are bigger than max size, we'll split those.\n\t                // +224 => 256 - 32\n\t                if (wbits > windowSize) {\n\t                    wbits -= maxNumber;\n\t                    n += _1n;\n\t                }\n\t                if (wbits === 0)\n\t                    continue;\n\t                let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n\t                if (wbits < 0)\n\t                    curr = curr.negate();\n\t                // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n\t                acc = acc.add(curr);\n\t            }\n\t            return acc;\n\t        },\n\t        getPrecomputes(W, P, transform) {\n\t            // Calculate precomputes on a first run, reuse them after\n\t            let comp = pointPrecomputes.get(P);\n\t            if (!comp) {\n\t                comp = this.precomputeWindow(P, W);\n\t                if (W !== 1)\n\t                    pointPrecomputes.set(P, transform(comp));\n\t            }\n\t            return comp;\n\t        },\n\t        wNAFCached(P, n, transform) {\n\t            const W = getW(P);\n\t            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n\t        },\n\t        wNAFCachedUnsafe(P, n, transform, prev) {\n\t            const W = getW(P);\n\t            if (W === 1)\n\t                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n\t            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n\t        },\n\t        // We calculate precomputes for elliptic curve point multiplication\n\t        // using windowed method. This specifies window size and\n\t        // stores precomputed values. Usually only base point would be precomputed.\n\t        setWindowSize(P, W) {\n\t            validateW(W, bits);\n\t            pointWindowSizes.set(P, W);\n\t            pointPrecomputes.delete(P);\n\t        },\n\t    };\n\t}\n\t/**\n\t * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n\t * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n\t * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n\t * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n\t * @param c Curve Point constructor\n\t * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n\t * @param points array of L curve points\n\t * @param scalars array of L scalars (aka private keys / bigints)\n\t */\n\tfunction pippenger(c, fieldN, points, scalars) {\n\t    // If we split scalars by some window (let's say 8 bits), every chunk will only\n\t    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n\t    // TODO:\n\t    // - https://eprint.iacr.org/2024/750.pdf\n\t    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n\t    // 0 is accepted in scalars\n\t    validateMSMPoints(points, c);\n\t    validateMSMScalars(scalars, fieldN);\n\t    if (points.length !== scalars.length)\n\t        throw new Error('arrays of points and scalars must have equal length');\n\t    const zero = c.ZERO;\n\t    const wbits = (0, utils_js_1.bitLen)(BigInt(points.length));\n\t    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n\t    const MASK = (1 << windowSize) - 1;\n\t    const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n\t    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n\t    let sum = zero;\n\t    for (let i = lastBits; i >= 0; i -= windowSize) {\n\t        buckets.fill(zero);\n\t        for (let j = 0; j < scalars.length; j++) {\n\t            const scalar = scalars[j];\n\t            const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));\n\t            buckets[wbits] = buckets[wbits].add(points[j]);\n\t        }\n\t        let resI = zero; // not using this will do small speed-up, but will lose ct\n\t        // Skip first bucket, because it is zero\n\t        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n\t            sumI = sumI.add(buckets[j]);\n\t            resI = resI.add(sumI);\n\t        }\n\t        sum = sum.add(resI);\n\t        if (i !== 0)\n\t            for (let j = 0; j < windowSize; j++)\n\t                sum = sum.double();\n\t    }\n\t    return sum;\n\t}\n\t/**\n\t * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n\t * @param c Curve Point constructor\n\t * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n\t * @param points array of L curve points\n\t * @returns function which multiplies points with scaars\n\t */\n\tfunction precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n\t    /**\n\t     * Performance Analysis of Window-based Precomputation\n\t     *\n\t     * Base Case (256-bit scalar, 8-bit window):\n\t     * - Standard precomputation requires:\n\t     *   - 31 additions per scalar  256 scalars = 7,936 ops\n\t     *   - Plus 255 summary additions = 8,191 total ops\n\t     *   Note: Summary additions can be optimized via accumulator\n\t     *\n\t     * Chunked Precomputation Analysis:\n\t     * - Using 32 chunks requires:\n\t     *   - 255 additions per chunk\n\t     *   - 256 doublings\n\t     *   - Total: (255  32) + 256 = 8,416 ops\n\t     *\n\t     * Memory Usage Comparison:\n\t     * Window Size | Standard Points | Chunked Points\n\t     * ------------|-----------------|---------------\n\t     *     4-bit   |     520         |      15\n\t     *     8-bit   |    4,224        |     255\n\t     *    10-bit   |   13,824        |   1,023\n\t     *    16-bit   |  557,056        |  65,535\n\t     *\n\t     * Key Advantages:\n\t     * 1. Enables larger window sizes due to reduced memory overhead\n\t     * 2. More efficient for smaller scalar counts:\n\t     *    - 16 chunks: (16  255) + 256 = 4,336 ops\n\t     *    - ~2x faster than standard 8,191 ops\n\t     *\n\t     * Limitations:\n\t     * - Not suitable for plain precomputes (requires 256 constant doublings)\n\t     * - Performance degrades with larger scalar counts:\n\t     *   - Optimal for ~256 scalars\n\t     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n\t     */\n\t    validateW(windowSize, fieldN.BITS);\n\t    validateMSMPoints(points, c);\n\t    const zero = c.ZERO;\n\t    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n\t    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n\t    const MASK = BigInt((1 << windowSize) - 1);\n\t    const tables = points.map((p) => {\n\t        const res = [];\n\t        for (let i = 0, acc = p; i < tableSize; i++) {\n\t            res.push(acc);\n\t            acc = acc.add(p);\n\t        }\n\t        return res;\n\t    });\n\t    return (scalars) => {\n\t        validateMSMScalars(scalars, fieldN);\n\t        if (scalars.length > points.length)\n\t            throw new Error('array of scalars must be smaller than array of points');\n\t        let res = zero;\n\t        for (let i = 0; i < chunks; i++) {\n\t            // No need to double if accumulator is still zero.\n\t            if (res !== zero)\n\t                for (let j = 0; j < windowSize; j++)\n\t                    res = res.double();\n\t            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n\t            for (let j = 0; j < scalars.length; j++) {\n\t                const n = scalars[j];\n\t                const curr = Number((n >> shiftBy) & MASK);\n\t                if (!curr)\n\t                    continue; // skip zero scalars chunks\n\t                res = res.add(tables[j][curr - 1]);\n\t            }\n\t        }\n\t        return res;\n\t    };\n\t}\n\tfunction validateBasic(curve) {\n\t    (0, modular_js_1.validateField)(curve.Fp);\n\t    (0, utils_js_1.validateObject)(curve, {\n\t        n: 'bigint',\n\t        h: 'bigint',\n\t        Gx: 'field',\n\t        Gy: 'field',\n\t    }, {\n\t        nBitLength: 'isSafeInteger',\n\t        nByteLength: 'isSafeInteger',\n\t    });\n\t    // Set defaults\n\t    return Object.freeze({\n\t        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),\n\t        ...curve,\n\t        ...{ p: curve.Fp.ORDER },\n\t    });\n\t}\n\t\n\treturn curve;\n}\n\nvar edwards = {};\n\nvar hasRequiredEdwards;\n\nfunction requireEdwards () {\n\tif (hasRequiredEdwards) return edwards;\n\thasRequiredEdwards = 1;\n\tObject.defineProperty(edwards, \"__esModule\", { value: true });\n\tedwards.twistedEdwards = twistedEdwards;\n\t/**\n\t * Twisted Edwards curve. The formula is: ax + y = 1 + dxy.\n\t * For design rationale of types / exports, see weierstrass module documentation.\n\t * @module\n\t */\n\t/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\tconst curve_js_1 = /*@__PURE__*/ requireCurve();\n\tconst modular_js_1 = /*@__PURE__*/ requireModular();\n\tconst ut = /*@__PURE__*/ requireUtils$1();\n\tconst utils_js_1 = /*@__PURE__*/ requireUtils$1();\n\t// Be friendly to bad ECMAScript parsers by not using bigint literals\n\t// prettier-ignore\n\tconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\t// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n\tconst VERIFY_DEFAULT = { zip215: true };\n\tfunction validateOpts(curve) {\n\t    const opts = (0, curve_js_1.validateBasic)(curve);\n\t    ut.validateObject(curve, {\n\t        hash: 'function',\n\t        a: 'bigint',\n\t        d: 'bigint',\n\t        randomBytes: 'function',\n\t    }, {\n\t        adjustScalarBytes: 'function',\n\t        domain: 'function',\n\t        uvRatio: 'function',\n\t        mapToCurve: 'function',\n\t    });\n\t    // Set defaults\n\t    return Object.freeze({ ...opts });\n\t}\n\t/**\n\t * Creates Twisted Edwards curve with EdDSA signatures.\n\t * @example\n\t * import { Field } from '@noble/curves/abstract/modular';\n\t * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n\t * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n\t */\n\tfunction twistedEdwards(curveDef) {\n\t    const CURVE = validateOpts(curveDef);\n\t    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;\n\t    // Important:\n\t    // There are some places where Fp.BYTES is used instead of nByteLength.\n\t    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n\t    // TODO: test and find curves which behave otherwise.\n\t    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n\t    const modP = Fp.create; // Function overrides\n\t    const Fn = (0, modular_js_1.Field)(CURVE.n, CURVE.nBitLength);\n\t    // sqrt(u/v)\n\t    const uvRatio = CURVE.uvRatio ||\n\t        ((u, v) => {\n\t            try {\n\t                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n\t            }\n\t            catch (e) {\n\t                return { isValid: false, value: _0n };\n\t            }\n\t        });\n\t    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP\n\t    const domain = CURVE.domain ||\n\t        ((data, ctx, phflag) => {\n\t            (0, utils_js_1.abool)('phflag', phflag);\n\t            if (ctx.length || phflag)\n\t                throw new Error('Contexts/pre-hash are not supported');\n\t            return data;\n\t        }); // NOOP\n\t    // 0 <= n < MASK\n\t    // Coordinates larger than Fp.ORDER are allowed for zip215\n\t    function aCoordinate(title, n) {\n\t        ut.aInRange('coordinate ' + title, n, _0n, MASK);\n\t    }\n\t    function assertPoint(other) {\n\t        if (!(other instanceof Point))\n\t            throw new Error('ExtendedPoint expected');\n\t    }\n\t    // Converts Extended point to default (x, y) coordinates.\n\t    // Can accept precomputed Z^-1 - for example, from invertBatch.\n\t    const toAffineMemo = (0, utils_js_1.memoized)((p, iz) => {\n\t        const { ex: x, ey: y, ez: z } = p;\n\t        const is0 = p.is0();\n\t        if (iz == null)\n\t            iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n\t        const ax = modP(x * iz);\n\t        const ay = modP(y * iz);\n\t        const zz = modP(z * iz);\n\t        if (is0)\n\t            return { x: _0n, y: _1n };\n\t        if (zz !== _1n)\n\t            throw new Error('invZ was invalid');\n\t        return { x: ax, y: ay };\n\t    });\n\t    const assertValidMemo = (0, utils_js_1.memoized)((p) => {\n\t        const { a, d } = CURVE;\n\t        if (p.is0())\n\t            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n\t        // Equation in affine coordinates: ax + y = 1 + dxy\n\t        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n\t        const { ex: X, ey: Y, ez: Z, et: T } = p;\n\t        const X2 = modP(X * X); // X\n\t        const Y2 = modP(Y * Y); // Y\n\t        const Z2 = modP(Z * Z); // Z\n\t        const Z4 = modP(Z2 * Z2); // Z\n\t        const aX2 = modP(X2 * a); // aX\n\t        const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n\t        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n\t        if (left !== right)\n\t            throw new Error('bad point: equation left != right (1)');\n\t        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n\t        const XY = modP(X * Y);\n\t        const ZT = modP(Z * T);\n\t        if (XY !== ZT)\n\t            throw new Error('bad point: equation left != right (2)');\n\t        return true;\n\t    });\n\t    // Extended Point works in extended coordinates: (x, y, z, t)  (x=x/z, y=y/z, t=xy).\n\t    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n\t    class Point {\n\t        constructor(ex, ey, ez, et) {\n\t            this.ex = ex;\n\t            this.ey = ey;\n\t            this.ez = ez;\n\t            this.et = et;\n\t            aCoordinate('x', ex);\n\t            aCoordinate('y', ey);\n\t            aCoordinate('z', ez);\n\t            aCoordinate('t', et);\n\t            Object.freeze(this);\n\t        }\n\t        get x() {\n\t            return this.toAffine().x;\n\t        }\n\t        get y() {\n\t            return this.toAffine().y;\n\t        }\n\t        static fromAffine(p) {\n\t            if (p instanceof Point)\n\t                throw new Error('extended point not allowed');\n\t            const { x, y } = p || {};\n\t            aCoordinate('x', x);\n\t            aCoordinate('y', y);\n\t            return new Point(x, y, _1n, modP(x * y));\n\t        }\n\t        static normalizeZ(points) {\n\t            const toInv = Fp.invertBatch(points.map((p) => p.ez));\n\t            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n\t        }\n\t        // Multiscalar Multiplication\n\t        static msm(points, scalars) {\n\t            return (0, curve_js_1.pippenger)(Point, Fn, points, scalars);\n\t        }\n\t        // \"Private method\", don't use it directly\n\t        _setWindowSize(windowSize) {\n\t            wnaf.setWindowSize(this, windowSize);\n\t        }\n\t        // Not required for fromHex(), which always creates valid points.\n\t        // Could be useful for fromAffine().\n\t        assertValidity() {\n\t            assertValidMemo(this);\n\t        }\n\t        // Compare one point to another.\n\t        equals(other) {\n\t            assertPoint(other);\n\t            const { ex: X1, ey: Y1, ez: Z1 } = this;\n\t            const { ex: X2, ey: Y2, ez: Z2 } = other;\n\t            const X1Z2 = modP(X1 * Z2);\n\t            const X2Z1 = modP(X2 * Z1);\n\t            const Y1Z2 = modP(Y1 * Z2);\n\t            const Y2Z1 = modP(Y2 * Z1);\n\t            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n\t        }\n\t        is0() {\n\t            return this.equals(Point.ZERO);\n\t        }\n\t        negate() {\n\t            // Flips point sign to a negative one (-x, y in affine coords)\n\t            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n\t        }\n\t        // Fast algo for doubling Extended Point.\n\t        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n\t        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n\t        double() {\n\t            const { a } = CURVE;\n\t            const { ex: X1, ey: Y1, ez: Z1 } = this;\n\t            const A = modP(X1 * X1); // A = X12\n\t            const B = modP(Y1 * Y1); // B = Y12\n\t            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n\t            const D = modP(a * A); // D = a*A\n\t            const x1y1 = X1 + Y1;\n\t            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n\t            const G = D + B; // G = D+B\n\t            const F = G - C; // F = G-C\n\t            const H = D - B; // H = D-B\n\t            const X3 = modP(E * F); // X3 = E*F\n\t            const Y3 = modP(G * H); // Y3 = G*H\n\t            const T3 = modP(E * H); // T3 = E*H\n\t            const Z3 = modP(F * G); // Z3 = F*G\n\t            return new Point(X3, Y3, Z3, T3);\n\t        }\n\t        // Fast algo for adding 2 Extended Points.\n\t        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n\t        // Cost: 9M + 1*a + 1*d + 7add.\n\t        add(other) {\n\t            assertPoint(other);\n\t            const { a, d } = CURVE;\n\t            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n\t            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n\t            // Faster algo for adding 2 Extended Points when curve's a=-1.\n\t            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n\t            // Cost: 8M + 8add + 2*2.\n\t            // Note: It does not check whether the `other` point is valid.\n\t            if (a === BigInt(-1)) {\n\t                const A = modP((Y1 - X1) * (Y2 + X2));\n\t                const B = modP((Y1 + X1) * (Y2 - X2));\n\t                const F = modP(B - A);\n\t                if (F === _0n)\n\t                    return this.double(); // Same point. Tests say it doesn't affect timing\n\t                const C = modP(Z1 * _2n * T2);\n\t                const D = modP(T1 * _2n * Z2);\n\t                const E = D + C;\n\t                const G = B + A;\n\t                const H = D - C;\n\t                const X3 = modP(E * F);\n\t                const Y3 = modP(G * H);\n\t                const T3 = modP(E * H);\n\t                const Z3 = modP(F * G);\n\t                return new Point(X3, Y3, Z3, T3);\n\t            }\n\t            const A = modP(X1 * X2); // A = X1*X2\n\t            const B = modP(Y1 * Y2); // B = Y1*Y2\n\t            const C = modP(T1 * d * T2); // C = T1*d*T2\n\t            const D = modP(Z1 * Z2); // D = Z1*Z2\n\t            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n\t            const F = D - C; // F = D-C\n\t            const G = D + C; // G = D+C\n\t            const H = modP(B - a * A); // H = B-a*A\n\t            const X3 = modP(E * F); // X3 = E*F\n\t            const Y3 = modP(G * H); // Y3 = G*H\n\t            const T3 = modP(E * H); // T3 = E*H\n\t            const Z3 = modP(F * G); // Z3 = F*G\n\t            return new Point(X3, Y3, Z3, T3);\n\t        }\n\t        subtract(other) {\n\t            return this.add(other.negate());\n\t        }\n\t        wNAF(n) {\n\t            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n\t        }\n\t        // Constant-time multiplication.\n\t        multiply(scalar) {\n\t            const n = scalar;\n\t            ut.aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n\t            const { p, f } = this.wNAF(n);\n\t            return Point.normalizeZ([p, f])[0];\n\t        }\n\t        // Non-constant-time multiplication. Uses double-and-add algorithm.\n\t        // It's faster, but should only be used when you don't care about\n\t        // an exposed private key e.g. sig verification.\n\t        // Does NOT allow scalars higher than CURVE.n.\n\t        // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n\t        multiplyUnsafe(scalar, acc = Point.ZERO) {\n\t            const n = scalar;\n\t            ut.aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n\t            if (n === _0n)\n\t                return I;\n\t            if (this.is0() || n === _1n)\n\t                return this;\n\t            return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n\t        }\n\t        // Checks if point is of small order.\n\t        // If you add something to small order point, you will have \"dirty\"\n\t        // point with torsion component.\n\t        // Multiplies point by cofactor and checks if the result is 0.\n\t        isSmallOrder() {\n\t            return this.multiplyUnsafe(cofactor).is0();\n\t        }\n\t        // Multiplies point by curve order and checks if the result is 0.\n\t        // Returns `false` is the point is dirty.\n\t        isTorsionFree() {\n\t            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n\t        }\n\t        // Converts Extended point to default (x, y) coordinates.\n\t        // Can accept precomputed Z^-1 - for example, from invertBatch.\n\t        toAffine(iz) {\n\t            return toAffineMemo(this, iz);\n\t        }\n\t        clearCofactor() {\n\t            const { h: cofactor } = CURVE;\n\t            if (cofactor === _1n)\n\t                return this;\n\t            return this.multiplyUnsafe(cofactor);\n\t        }\n\t        // Converts hash string or Uint8Array to Point.\n\t        // Uses algo from RFC8032 5.1.3.\n\t        static fromHex(hex, zip215 = false) {\n\t            const { d, a } = CURVE;\n\t            const len = Fp.BYTES;\n\t            hex = (0, utils_js_1.ensureBytes)('pointHex', hex, len); // copy hex to a new array\n\t            (0, utils_js_1.abool)('zip215', zip215);\n\t            const normed = hex.slice(); // copy again, we'll manipulate it\n\t            const lastByte = hex[len - 1]; // select last byte\n\t            normed[len - 1] = lastByte & ~0x80; // clear last bit\n\t            const y = ut.bytesToNumberLE(normed);\n\t            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n\t            // RFC8032 prohibits >= p, but ZIP215 doesn't\n\t            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n\t            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n\t            const max = zip215 ? MASK : Fp.ORDER;\n\t            ut.aInRange('pointHex.y', y, _0n, max);\n\t            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n\t            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n\t            const y2 = modP(y * y); // denominator is always non-0 mod p.\n\t            const u = modP(y2 - _1n); // u = y - 1\n\t            const v = modP(d * y2 - a); // v = d y + 1.\n\t            let { isValid, value: x } = uvRatio(u, v); // (u/v)\n\t            if (!isValid)\n\t                throw new Error('Point.fromHex: invalid y coordinate');\n\t            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n\t            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n\t            if (!zip215 && x === _0n && isLastByteOdd)\n\t                // if x=0 and x_0 = 1, fail\n\t                throw new Error('Point.fromHex: x=0 and x_0=1');\n\t            if (isLastByteOdd !== isXOdd)\n\t                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n\t            return Point.fromAffine({ x, y });\n\t        }\n\t        static fromPrivateKey(privKey) {\n\t            return getExtendedPublicKey(privKey).point;\n\t        }\n\t        toRawBytes() {\n\t            const { x, y } = this.toAffine();\n\t            const bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n\t            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n\t            return bytes; // and use the last byte to encode sign of x\n\t        }\n\t        toHex() {\n\t            return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n\t        }\n\t    }\n\t    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n\t    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n\t    const { BASE: G, ZERO: I } = Point;\n\t    const wnaf = (0, curve_js_1.wNAF)(Point, nByteLength * 8);\n\t    function modN(a) {\n\t        return (0, modular_js_1.mod)(a, CURVE_ORDER);\n\t    }\n\t    // Little-endian SHA512 with modulo n\n\t    function modN_LE(hash) {\n\t        return modN(ut.bytesToNumberLE(hash));\n\t    }\n\t    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n\t    function getExtendedPublicKey(key) {\n\t        const len = Fp.BYTES;\n\t        key = (0, utils_js_1.ensureBytes)('private key', key, len);\n\t        // Hash private key with curve's hash function to produce uniformingly random input\n\t        // Check byte lengths: ensure(64, h(ensure(32, key)))\n\t        const hashed = (0, utils_js_1.ensureBytes)('hashed private key', cHash(key), 2 * len);\n\t        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n\t        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n\t        const scalar = modN_LE(head); // The actual private scalar\n\t        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n\t        const pointBytes = point.toRawBytes(); // Uint8Array representation\n\t        return { head, prefix, scalar, point, pointBytes };\n\t    }\n\t    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n\t    function getPublicKey(privKey) {\n\t        return getExtendedPublicKey(privKey).pointBytes;\n\t    }\n\t    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n\t    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n\t        const msg = ut.concatBytes(...msgs);\n\t        return modN_LE(cHash(domain(msg, (0, utils_js_1.ensureBytes)('context', context), !!prehash)));\n\t    }\n\t    /** Signs message with privateKey. RFC8032 5.1.6 */\n\t    function sign(msg, privKey, options = {}) {\n\t        msg = (0, utils_js_1.ensureBytes)('message', msg);\n\t        if (prehash)\n\t            msg = prehash(msg); // for ed25519ph etc.\n\t        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n\t        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n\t        const R = G.multiply(r).toRawBytes(); // R = rG\n\t        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n\t        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n\t        ut.aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n\t        const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));\n\t        return (0, utils_js_1.ensureBytes)('result', res, Fp.BYTES * 2); // 64-byte signature\n\t    }\n\t    const verifyOpts = VERIFY_DEFAULT;\n\t    /**\n\t     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n\t     * An extended group equation is checked.\n\t     */\n\t    function verify(sig, msg, publicKey, options = verifyOpts) {\n\t        const { context, zip215 } = options;\n\t        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n\t        sig = (0, utils_js_1.ensureBytes)('signature', sig, 2 * len); // An extended group equation is checked.\n\t        msg = (0, utils_js_1.ensureBytes)('message', msg);\n\t        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey, len);\n\t        if (zip215 !== undefined)\n\t            (0, utils_js_1.abool)('zip215', zip215);\n\t        if (prehash)\n\t            msg = prehash(msg); // for ed25519ph, etc\n\t        const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));\n\t        let A, R, SB;\n\t        try {\n\t            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n\t            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n\t            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n\t            A = Point.fromHex(publicKey, zip215);\n\t            R = Point.fromHex(sig.slice(0, len), zip215);\n\t            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n\t        }\n\t        catch (error) {\n\t            return false;\n\t        }\n\t        if (!zip215 && A.isSmallOrder())\n\t            return false;\n\t        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n\t        const RkA = R.add(A.multiplyUnsafe(k));\n\t        // Extended group equation\n\t        // [8][S]B = [8]R + [8][k]A'\n\t        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n\t    }\n\t    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\t    const utils = {\n\t        getExtendedPublicKey,\n\t        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n\t        randomPrivateKey: () => randomBytes(Fp.BYTES),\n\t        /**\n\t         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n\t         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n\t         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n\t         * @param windowSize 2, 4, 8, 16\n\t         */\n\t        precompute(windowSize = 8, point = Point.BASE) {\n\t            point._setWindowSize(windowSize);\n\t            point.multiply(BigInt(3));\n\t            return point;\n\t        },\n\t    };\n\t    return {\n\t        CURVE,\n\t        getPublicKey,\n\t        sign,\n\t        verify,\n\t        ExtendedPoint: Point,\n\t        utils,\n\t    };\n\t}\n\t\n\treturn edwards;\n}\n\nvar hashToCurve = {};\n\nvar hasRequiredHashToCurve;\n\nfunction requireHashToCurve () {\n\tif (hasRequiredHashToCurve) return hashToCurve;\n\thasRequiredHashToCurve = 1;\n\tObject.defineProperty(hashToCurve, \"__esModule\", { value: true });\n\thashToCurve.expand_message_xmd = expand_message_xmd;\n\thashToCurve.expand_message_xof = expand_message_xof;\n\thashToCurve.hash_to_field = hash_to_field;\n\thashToCurve.isogenyMap = isogenyMap;\n\thashToCurve.createHasher = createHasher;\n\tconst modular_js_1 = /*@__PURE__*/ requireModular();\n\tconst utils_js_1 = /*@__PURE__*/ requireUtils$1();\n\t// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\n\tconst os2ip = utils_js_1.bytesToNumberBE;\n\t// Integer to Octet Stream (numberToBytesBE)\n\tfunction i2osp(value, length) {\n\t    anum(value);\n\t    anum(length);\n\t    if (value < 0 || value >= 1 << (8 * length))\n\t        throw new Error('invalid I2OSP input: ' + value);\n\t    const res = Array.from({ length }).fill(0);\n\t    for (let i = length - 1; i >= 0; i--) {\n\t        res[i] = value & 0xff;\n\t        value >>>= 8;\n\t    }\n\t    return new Uint8Array(res);\n\t}\n\tfunction strxor(a, b) {\n\t    const arr = new Uint8Array(a.length);\n\t    for (let i = 0; i < a.length; i++) {\n\t        arr[i] = a[i] ^ b[i];\n\t    }\n\t    return arr;\n\t}\n\tfunction anum(item) {\n\t    if (!Number.isSafeInteger(item))\n\t        throw new Error('number expected');\n\t}\n\t/**\n\t * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n\t * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n\t */\n\tfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n\t    (0, utils_js_1.abytes)(msg);\n\t    (0, utils_js_1.abytes)(DST);\n\t    anum(lenInBytes);\n\t    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n\t    if (DST.length > 255)\n\t        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n\t    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n\t    const ell = Math.ceil(lenInBytes / b_in_bytes);\n\t    if (lenInBytes > 65535 || ell > 255)\n\t        throw new Error('expand_message_xmd: invalid lenInBytes');\n\t    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));\n\t    const Z_pad = i2osp(0, r_in_bytes);\n\t    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n\t    const b = new Array(ell);\n\t    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n\t    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n\t    for (let i = 1; i <= ell; i++) {\n\t        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n\t        b[i] = H((0, utils_js_1.concatBytes)(...args));\n\t    }\n\t    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);\n\t    return pseudo_random_bytes.slice(0, lenInBytes);\n\t}\n\t/**\n\t * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n\t * 1. The collision resistance of H MUST be at least k bits.\n\t * 2. H MUST be an XOF that has been proved indifferentiable from\n\t *    a random oracle under a reasonable cryptographic assumption.\n\t * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n\t */\n\tfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n\t    (0, utils_js_1.abytes)(msg);\n\t    (0, utils_js_1.abytes)(DST);\n\t    anum(lenInBytes);\n\t    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n\t    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n\t    if (DST.length > 255) {\n\t        const dkLen = Math.ceil((2 * k) / 8);\n\t        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n\t    }\n\t    if (lenInBytes > 65535 || DST.length > 255)\n\t        throw new Error('expand_message_xof: invalid lenInBytes');\n\t    return (H.create({ dkLen: lenInBytes })\n\t        .update(msg)\n\t        .update(i2osp(lenInBytes, 2))\n\t        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n\t        .update(DST)\n\t        .update(i2osp(DST.length, 1))\n\t        .digest());\n\t}\n\t/**\n\t * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n\t * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n\t * @param msg a byte string containing the message to hash\n\t * @param count the number of elements of F to output\n\t * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n\t * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n\t */\n\tfunction hash_to_field(msg, count, options) {\n\t    (0, utils_js_1.validateObject)(options, {\n\t        DST: 'stringOrUint8Array',\n\t        p: 'bigint',\n\t        m: 'isSafeInteger',\n\t        k: 'isSafeInteger',\n\t        hash: 'hash',\n\t    });\n\t    const { p, k, m, hash, expand, DST: _DST } = options;\n\t    (0, utils_js_1.abytes)(msg);\n\t    anum(count);\n\t    const DST = typeof _DST === 'string' ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;\n\t    const log2p = p.toString(2).length;\n\t    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n\t    const len_in_bytes = count * m * L;\n\t    let prb; // pseudo_random_bytes\n\t    if (expand === 'xmd') {\n\t        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n\t    }\n\t    else if (expand === 'xof') {\n\t        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n\t    }\n\t    else if (expand === '_internal_pass') {\n\t        // for internal tests only\n\t        prb = msg;\n\t    }\n\t    else {\n\t        throw new Error('expand must be \"xmd\" or \"xof\"');\n\t    }\n\t    const u = new Array(count);\n\t    for (let i = 0; i < count; i++) {\n\t        const e = new Array(m);\n\t        for (let j = 0; j < m; j++) {\n\t            const elm_offset = L * (j + i * m);\n\t            const tv = prb.subarray(elm_offset, elm_offset + L);\n\t            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);\n\t        }\n\t        u[i] = e;\n\t    }\n\t    return u;\n\t}\n\tfunction isogenyMap(field, map) {\n\t    // Make same order as in spec\n\t    const COEFF = map.map((i) => Array.from(i).reverse());\n\t    return (x, y) => {\n\t        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n\t        x = field.div(xNum, xDen); // xNum / xDen\n\t        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n\t        return { x: x, y: y };\n\t    };\n\t}\n\t/** Creates hash-to-curve methods from EC Point and mapToCurve function. */\n\tfunction createHasher(Point, mapToCurve, def) {\n\t    if (typeof mapToCurve !== 'function')\n\t        throw new Error('mapToCurve() must be defined');\n\t    return {\n\t        // Encodes byte string to elliptic curve.\n\t        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n\t        hashToCurve(msg, options) {\n\t            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n\t            const u0 = Point.fromAffine(mapToCurve(u[0]));\n\t            const u1 = Point.fromAffine(mapToCurve(u[1]));\n\t            const P = u0.add(u1).clearCofactor();\n\t            P.assertValidity();\n\t            return P;\n\t        },\n\t        // Encodes byte string to elliptic curve.\n\t        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n\t        encodeToCurve(msg, options) {\n\t            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n\t            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n\t            P.assertValidity();\n\t            return P;\n\t        },\n\t        // Same as encodeToCurve, but without hash\n\t        mapToCurve(scalars) {\n\t            if (!Array.isArray(scalars))\n\t                throw new Error('mapToCurve: expected array of bigints');\n\t            for (const i of scalars)\n\t                if (typeof i !== 'bigint')\n\t                    throw new Error('mapToCurve: expected array of bigints');\n\t            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n\t            P.assertValidity();\n\t            return P;\n\t        },\n\t    };\n\t}\n\t\n\treturn hashToCurve;\n}\n\nvar montgomery = {};\n\nvar hasRequiredMontgomery;\n\nfunction requireMontgomery () {\n\tif (hasRequiredMontgomery) return montgomery;\n\thasRequiredMontgomery = 1;\n\tObject.defineProperty(montgomery, \"__esModule\", { value: true });\n\tmontgomery.montgomery = montgomery$1;\n\t/**\n\t * Montgomery curve methods. It's not really whole montgomery curve,\n\t * just bunch of very specific methods for X25519 / X448 from\n\t * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n\t * @module\n\t */\n\t/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\tconst modular_js_1 = /*@__PURE__*/ requireModular();\n\tconst utils_js_1 = /*@__PURE__*/ requireUtils$1();\n\tconst _0n = BigInt(0);\n\tconst _1n = BigInt(1);\n\tfunction validateOpts(curve) {\n\t    (0, utils_js_1.validateObject)(curve, {\n\t        a: 'bigint',\n\t    }, {\n\t        montgomeryBits: 'isSafeInteger',\n\t        nByteLength: 'isSafeInteger',\n\t        adjustScalarBytes: 'function',\n\t        domain: 'function',\n\t        powPminus2: 'function',\n\t        Gu: 'bigint',\n\t    });\n\t    // Set defaults\n\t    return Object.freeze({ ...curve });\n\t}\n\t// Uses only one coordinate instead of two\n\tfunction montgomery$1(curveDef) {\n\t    const CURVE = validateOpts(curveDef);\n\t    const { P } = CURVE;\n\t    const modP = (n) => (0, modular_js_1.mod)(n, P);\n\t    const montgomeryBits = CURVE.montgomeryBits;\n\t    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n\t    const fieldLen = CURVE.nByteLength;\n\t    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);\n\t    const powPminus2 = CURVE.powPminus2 || ((x) => (0, modular_js_1.pow)(x, P - BigInt(2), P));\n\t    // cswap from RFC7748. But it is not from RFC7748!\n\t    /*\n\t      cswap(swap, x_2, x_3):\n\t           dummy = mask(swap) AND (x_2 XOR x_3)\n\t           x_2 = x_2 XOR dummy\n\t           x_3 = x_3 XOR dummy\n\t           Return (x_2, x_3)\n\t    Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n\t     and x_3, computed, e.g., as mask(swap) = 0 - swap.\n\t    */\n\t    function cswap(swap, x_2, x_3) {\n\t        const dummy = modP(swap * (x_2 - x_3));\n\t        x_2 = modP(x_2 - dummy);\n\t        x_3 = modP(x_3 + dummy);\n\t        return [x_2, x_3];\n\t    }\n\t    // x25519 from 4\n\t    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n\t    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n\t    /**\n\t     *\n\t     * @param pointU u coordinate (x) on Montgomery Curve 25519\n\t     * @param scalar by which the point would be multiplied\n\t     * @returns new Point on Montgomery curve\n\t     */\n\t    function montgomeryLadder(u, scalar) {\n\t        (0, utils_js_1.aInRange)('u', u, _0n, P);\n\t        (0, utils_js_1.aInRange)('scalar', scalar, _0n, P);\n\t        // Section 5: Implementations MUST accept non-canonical values and process them as\n\t        // if they had been reduced modulo the field prime.\n\t        const k = scalar;\n\t        const x_1 = u;\n\t        let x_2 = _1n;\n\t        let z_2 = _0n;\n\t        let x_3 = u;\n\t        let z_3 = _1n;\n\t        let swap = _0n;\n\t        let sw;\n\t        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n\t            const k_t = (k >> t) & _1n;\n\t            swap ^= k_t;\n\t            sw = cswap(swap, x_2, x_3);\n\t            x_2 = sw[0];\n\t            x_3 = sw[1];\n\t            sw = cswap(swap, z_2, z_3);\n\t            z_2 = sw[0];\n\t            z_3 = sw[1];\n\t            swap = k_t;\n\t            const A = x_2 + z_2;\n\t            const AA = modP(A * A);\n\t            const B = x_2 - z_2;\n\t            const BB = modP(B * B);\n\t            const E = AA - BB;\n\t            const C = x_3 + z_3;\n\t            const D = x_3 - z_3;\n\t            const DA = modP(D * A);\n\t            const CB = modP(C * B);\n\t            const dacb = DA + CB;\n\t            const da_cb = DA - CB;\n\t            x_3 = modP(dacb * dacb);\n\t            z_3 = modP(x_1 * modP(da_cb * da_cb));\n\t            x_2 = modP(AA * BB);\n\t            z_2 = modP(E * (AA + modP(a24 * E)));\n\t        }\n\t        // (x_2, x_3) = cswap(swap, x_2, x_3)\n\t        sw = cswap(swap, x_2, x_3);\n\t        x_2 = sw[0];\n\t        x_3 = sw[1];\n\t        // (z_2, z_3) = cswap(swap, z_2, z_3)\n\t        sw = cswap(swap, z_2, z_3);\n\t        z_2 = sw[0];\n\t        z_3 = sw[1];\n\t        // z_2^(p - 2)\n\t        const z2 = powPminus2(z_2);\n\t        // Return x_2 * (z_2^(p - 2))\n\t        return modP(x_2 * z2);\n\t    }\n\t    function encodeUCoordinate(u) {\n\t        return (0, utils_js_1.numberToBytesLE)(modP(u), montgomeryBytes);\n\t    }\n\t    function decodeUCoordinate(uEnc) {\n\t        // Section 5: When receiving such an array, implementations of X25519\n\t        // MUST mask the most significant bit in the final byte.\n\t        const u = (0, utils_js_1.ensureBytes)('u coordinate', uEnc, montgomeryBytes);\n\t        if (fieldLen === 32)\n\t            u[31] &= 127; // 0b0111_1111\n\t        return (0, utils_js_1.bytesToNumberLE)(u);\n\t    }\n\t    function decodeScalar(n) {\n\t        const bytes = (0, utils_js_1.ensureBytes)('scalar', n);\n\t        const len = bytes.length;\n\t        if (len !== montgomeryBytes && len !== fieldLen) {\n\t            let valid = '' + montgomeryBytes + ' or ' + fieldLen;\n\t            throw new Error('invalid scalar, expected ' + valid + ' bytes, got ' + len);\n\t        }\n\t        return (0, utils_js_1.bytesToNumberLE)(adjustScalarBytes(bytes));\n\t    }\n\t    function scalarMult(scalar, u) {\n\t        const pointU = decodeUCoordinate(u);\n\t        const _scalar = decodeScalar(scalar);\n\t        const pu = montgomeryLadder(pointU, _scalar);\n\t        // The result was not contributory\n\t        // https://cr.yp.to/ecdh.html#validate\n\t        if (pu === _0n)\n\t            throw new Error('invalid private or public key received');\n\t        return encodeUCoordinate(pu);\n\t    }\n\t    // Computes public key from private. By doing scalar multiplication of base point.\n\t    const GuBytes = encodeUCoordinate(CURVE.Gu);\n\t    function scalarMultBase(scalar) {\n\t        return scalarMult(scalar, GuBytes);\n\t    }\n\t    return {\n\t        scalarMult,\n\t        scalarMultBase,\n\t        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n\t        getPublicKey: (privateKey) => scalarMultBase(privateKey),\n\t        utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },\n\t        GuBytes: GuBytes,\n\t    };\n\t}\n\t\n\treturn montgomery;\n}\n\nvar hasRequiredEd25519;\n\nfunction requireEd25519 () {\n\tif (hasRequiredEd25519) return ed25519;\n\thasRequiredEd25519 = 1;\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.RistrettoPoint = exports.encodeToCurve = exports.hashToCurve = exports.edwardsToMontgomery = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = exports.ED25519_TORSION_SUBGROUP = void 0;\n\t\texports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;\n\t\texports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;\n\t\t/**\n\t\t * ed25519 Twisted Edwards curve with following addons:\n\t\t * - X25519 ECDH\n\t\t * - Ristretto cofactor elimination\n\t\t * - Elligator hash-to-group / point indistinguishability\n\t\t * @module\n\t\t */\n\t\t/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\t\tconst sha512_1 = /*@__PURE__*/ requireSha512();\n\t\tconst utils_1 = /*@__PURE__*/ requireUtils$2();\n\t\tconst curve_js_1 = /*@__PURE__*/ requireCurve();\n\t\tconst edwards_js_1 = /*@__PURE__*/ requireEdwards();\n\t\tconst hash_to_curve_js_1 = /*@__PURE__*/ requireHashToCurve();\n\t\tconst modular_js_1 = /*@__PURE__*/ requireModular();\n\t\tconst montgomery_js_1 = /*@__PURE__*/ requireMontgomery();\n\t\tconst utils_js_1 = /*@__PURE__*/ requireUtils$1();\n\t\tconst ED25519_P = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');\n\t\t// (-1) aka (a) aka 2^((p-1)/4)\n\t\tconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n\t\t// prettier-ignore\n\t\tconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n\t\t// prettier-ignore\n\t\tconst _5n = BigInt(5), _8n = BigInt(8);\n\t\tfunction ed25519_pow_2_252_3(x) {\n\t\t    // prettier-ignore\n\t\t    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n\t\t    const P = ED25519_P;\n\t\t    const x2 = (x * x) % P;\n\t\t    const b2 = (x2 * x) % P; // x^3, 11\n\t\t    const b4 = ((0, modular_js_1.pow2)(b2, _2n, P) * b2) % P; // x^15, 1111\n\t\t    const b5 = ((0, modular_js_1.pow2)(b4, _1n, P) * x) % P; // x^31\n\t\t    const b10 = ((0, modular_js_1.pow2)(b5, _5n, P) * b5) % P;\n\t\t    const b20 = ((0, modular_js_1.pow2)(b10, _10n, P) * b10) % P;\n\t\t    const b40 = ((0, modular_js_1.pow2)(b20, _20n, P) * b20) % P;\n\t\t    const b80 = ((0, modular_js_1.pow2)(b40, _40n, P) * b40) % P;\n\t\t    const b160 = ((0, modular_js_1.pow2)(b80, _80n, P) * b80) % P;\n\t\t    const b240 = ((0, modular_js_1.pow2)(b160, _80n, P) * b80) % P;\n\t\t    const b250 = ((0, modular_js_1.pow2)(b240, _10n, P) * b10) % P;\n\t\t    const pow_p_5_8 = ((0, modular_js_1.pow2)(b250, _2n, P) * x) % P;\n\t\t    // ^ To pow to (p+3)/8, multiply it by x.\n\t\t    return { pow_p_5_8, b2 };\n\t\t}\n\t\tfunction adjustScalarBytes(bytes) {\n\t\t    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n\t\t    // set the three least significant bits of the first byte\n\t\t    bytes[0] &= 248; // 0b1111_1000\n\t\t    // and the most significant bit of the last to zero,\n\t\t    bytes[31] &= 127; // 0b0111_1111\n\t\t    // set the second most significant bit of the last byte to 1\n\t\t    bytes[31] |= 64; // 0b0100_0000\n\t\t    return bytes;\n\t\t}\n\t\t// sqrt(u/v)\n\t\tfunction uvRatio(u, v) {\n\t\t    const P = ED25519_P;\n\t\t    const v3 = (0, modular_js_1.mod)(v * v * v, P); // v\n\t\t    const v7 = (0, modular_js_1.mod)(v3 * v3 * v, P); // v\n\t\t    // (p+3)/8 and (p-5)/8\n\t\t    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n\t\t    let x = (0, modular_js_1.mod)(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n\t\t    const vx2 = (0, modular_js_1.mod)(v * x * x, P); // vx\n\t\t    const root1 = x; // First root candidate\n\t\t    const root2 = (0, modular_js_1.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n\t\t    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n\t\t    const useRoot2 = vx2 === (0, modular_js_1.mod)(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n\t\t    const noRoot = vx2 === (0, modular_js_1.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n\t\t    if (useRoot1)\n\t\t        x = root1;\n\t\t    if (useRoot2 || noRoot)\n\t\t        x = root2; // We return root2 anyway, for const-time\n\t\t    if ((0, modular_js_1.isNegativeLE)(x, P))\n\t\t        x = (0, modular_js_1.mod)(-x, P);\n\t\t    return { isValid: useRoot1 || useRoot2, value: x };\n\t\t}\n\t\t// Just in case\n\t\texports.ED25519_TORSION_SUBGROUP = [\n\t\t    '0100000000000000000000000000000000000000000000000000000000000000',\n\t\t    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n\t\t    '0000000000000000000000000000000000000000000000000000000000000080',\n\t\t    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n\t\t    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n\t\t    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n\t\t    '0000000000000000000000000000000000000000000000000000000000000000',\n\t\t    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n\t\t];\n\t\tconst Fp = /* @__PURE__ */ (() => (0, modular_js_1.Field)(ED25519_P, undefined, true))();\n\t\tconst ed25519Defaults = /* @__PURE__ */ (() => ({\n\t\t    // Param: a\n\t\t    a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n\t\t    // d is equal to -121665/121666 over finite field.\n\t\t    // Negative number is P - number, and division is invert(number, P)\n\t\t    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n\t\t    // Finite field p over which we'll do calculations; 2n**255n - 19n\n\t\t    Fp,\n\t\t    // Subgroup order: how many points curve has\n\t\t    // 2n**252n + 27742317777372353535851937790883648493n;\n\t\t    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n\t\t    // Cofactor\n\t\t    h: _8n,\n\t\t    // Base point (x, y) aka generator point\n\t\t    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n\t\t    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n\t\t    hash: sha512_1.sha512,\n\t\t    randomBytes: utils_1.randomBytes,\n\t\t    adjustScalarBytes,\n\t\t    // dom2\n\t\t    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n\t\t    // Constant-time, u/v\n\t\t    uvRatio,\n\t\t}))();\n\t\t/**\n\t\t * ed25519 curve with EdDSA signatures.\n\t\t * @example\n\t\t * import { ed25519 } from '@noble/curves/ed25519';\n\t\t * const priv = ed25519.utils.randomPrivateKey();\n\t\t * const pub = ed25519.getPublicKey(priv);\n\t\t * const msg = new TextEncoder().encode('hello');\n\t\t * const sig = ed25519.sign(msg, priv);\n\t\t * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n\t\t * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n\t\t */\n\t\texports.ed25519 = (() => (0, edwards_js_1.twistedEdwards)(ed25519Defaults))();\n\t\tfunction ed25519_domain(data, ctx, phflag) {\n\t\t    if (ctx.length > 255)\n\t\t        throw new Error('Context is too big');\n\t\t    return (0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n\t\t}\n\t\texports.ed25519ctx = (() => (0, edwards_js_1.twistedEdwards)({\n\t\t    ...ed25519Defaults,\n\t\t    domain: ed25519_domain,\n\t\t}))();\n\t\texports.ed25519ph = (() => (0, edwards_js_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {\n\t\t    domain: ed25519_domain,\n\t\t    prehash: sha512_1.sha512,\n\t\t})))();\n\t\t/**\n\t\t * ECDH using curve25519 aka x25519.\n\t\t * @example\n\t\t * import { x25519 } from '@noble/curves/ed25519';\n\t\t * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n\t\t * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n\t\t * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n\t\t * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n\t\t * x25519.getPublicKey(x25519.utils.randomPrivateKey());\n\t\t */\n\t\texports.x25519 = (() => (0, montgomery_js_1.montgomery)({\n\t\t    P: ED25519_P,\n\t\t    a: BigInt(486662),\n\t\t    montgomeryBits: 255, // n is 253 bits\n\t\t    nByteLength: 32,\n\t\t    Gu: BigInt(9),\n\t\t    powPminus2: (x) => {\n\t\t        const P = ED25519_P;\n\t\t        // x^(p-2) aka x^(2^255-21)\n\t\t        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n\t\t        return (0, modular_js_1.mod)((0, modular_js_1.pow2)(pow_p_5_8, _3n, P) * b2, P);\n\t\t    },\n\t\t    adjustScalarBytes,\n\t\t    randomBytes: utils_1.randomBytes,\n\t\t}))();\n\t\t/**\n\t\t * Converts ed25519 public key to x25519 public key. Uses formula:\n\t\t * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n\t\t * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n\t\t * @example\n\t\t *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n\t\t *   const aPriv = x25519.utils.randomPrivateKey();\n\t\t *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n\t\t */\n\t\tfunction edwardsToMontgomeryPub(edwardsPub) {\n\t\t    const { y } = exports.ed25519.ExtendedPoint.fromHex(edwardsPub);\n\t\t    const _1n = BigInt(1);\n\t\t    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n\t\t}\n\t\texports.edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n\t\t/**\n\t\t * Converts ed25519 secret key to x25519 secret key.\n\t\t * @example\n\t\t *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n\t\t *   const aPriv = ed25519.utils.randomPrivateKey();\n\t\t *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n\t\t */\n\t\tfunction edwardsToMontgomeryPriv(edwardsPriv) {\n\t\t    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n\t\t    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n\t\t}\n\t\t// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n\t\t// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n\t\t// SageMath returns different root first and everything falls apart\n\t\tconst ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\n\t\tconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\n\t\tconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n\t\t// prettier-ignore\n\t\tfunction map_to_curve_elligator2_curve25519(u) {\n\t\t    const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n\t\t    const ELL2_J = BigInt(486662);\n\t\t    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n\t\t    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n\t\t    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n\t\t    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n\t\t    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n\t\t    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n\t\t    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n\t\t    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n\t\t    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n\t\t    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n\t\t    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n\t\t    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n\t\t    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n\t\t    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n\t\t    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n\t\t    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n\t\t    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n\t\t    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n\t\t    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n\t\t    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n\t\t    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n\t\t    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n\t\t    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n\t\t    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n\t\t    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n\t\t    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n\t\t    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n\t\t    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n\t\t    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n\t\t    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n\t\t    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n\t\t    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n\t\t    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n\t\t    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n\t\t    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n\t\t    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n\t\t    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n\t\t    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n\t\t    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n\t\t}\n\t\tconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_js_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\n\t\tfunction map_to_curve_elligator2_edwards25519(u) {\n\t\t    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n\t\t    // map_to_curve_elligator2_curve25519(u)\n\t\t    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n\t\t    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n\t\t    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n\t\t    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n\t\t    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n\t\t    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n\t\t    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n\t\t    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n\t\t    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n\t\t    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n\t\t    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n\t\t    const inv = Fp.invertBatch([xd, yd]); // batch division\n\t\t    return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n\t\t}\n\t\tconst htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n\t\t    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n\t\t    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n\t\t    p: Fp.ORDER,\n\t\t    m: 1,\n\t\t    k: 128,\n\t\t    expand: 'xmd',\n\t\t    hash: sha512_1.sha512,\n\t\t}))();\n\t\texports.hashToCurve = (() => htf.hashToCurve)();\n\t\texports.encodeToCurve = (() => htf.encodeToCurve)();\n\t\tfunction assertRstPoint(other) {\n\t\t    if (!(other instanceof RistPoint))\n\t\t        throw new Error('RistrettoPoint expected');\n\t\t}\n\t\t// (-1) aka (a) aka 2^((p-1)/4)\n\t\tconst SQRT_M1 = ED25519_SQRT_M1;\n\t\t// (ad - 1)\n\t\tconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n\t\t// 1 / (a-d)\n\t\tconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n\t\t// 1-d\n\t\tconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n\t\t// (d-1)\n\t\tconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n\t\t// Calculates 1/(number)\n\t\tconst invertSqrt = (number) => uvRatio(_1n, number);\n\t\tconst MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n\t\tconst bytes255ToNumberLE = (bytes) => exports.ed25519.CURVE.Fp.create((0, utils_js_1.bytesToNumberLE)(bytes) & MAX_255B);\n\t\t// Computes Elligator map for Ristretto\n\t\t// https://ristretto.group/formulas/elligator.html\n\t\tfunction calcElligatorRistrettoMap(r0) {\n\t\t    const { d } = exports.ed25519.CURVE;\n\t\t    const P = exports.ed25519.CURVE.Fp.ORDER;\n\t\t    const mod = exports.ed25519.CURVE.Fp.create;\n\t\t    const r = mod(SQRT_M1 * r0 * r0); // 1\n\t\t    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n\t\t    let c = BigInt(-1); // 3\n\t\t    const D = mod((c - d * r) * mod(r + d)); // 4\n\t\t    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n\t\t    let s_ = mod(s * r0); // 6\n\t\t    if (!(0, modular_js_1.isNegativeLE)(s_, P))\n\t\t        s_ = mod(-s_);\n\t\t    if (!Ns_D_is_sq)\n\t\t        s = s_; // 7\n\t\t    if (!Ns_D_is_sq)\n\t\t        c = r; // 8\n\t\t    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n\t\t    const s2 = s * s;\n\t\t    const W0 = mod((s + s) * D); // 10\n\t\t    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n\t\t    const W2 = mod(_1n - s2); // 12\n\t\t    const W3 = mod(_1n + s2); // 13\n\t\t    return new exports.ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n\t\t}\n\t\t/**\n\t\t * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n\t\t * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n\t\t * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n\t\t * but it should work in its own namespace: do not combine those two.\n\t\t * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n\t\t */\n\t\tclass RistPoint {\n\t\t    // Private property to discourage combining ExtendedPoint + RistrettoPoint\n\t\t    // Always use Ristretto encoding/decoding instead.\n\t\t    constructor(ep) {\n\t\t        this.ep = ep;\n\t\t    }\n\t\t    static fromAffine(ap) {\n\t\t        return new RistPoint(exports.ed25519.ExtendedPoint.fromAffine(ap));\n\t\t    }\n\t\t    /**\n\t\t     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n\t\t     * The hash-to-group operation applies Elligator twice and adds the results.\n\t\t     * **Note:** this is one-way map, there is no conversion from point to hash.\n\t\t     * https://ristretto.group/formulas/elligator.html\n\t\t     * @param hex 64-byte output of a hash function\n\t\t     */\n\t\t    static hashToCurve(hex) {\n\t\t        hex = (0, utils_js_1.ensureBytes)('ristrettoHash', hex, 64);\n\t\t        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n\t\t        const R1 = calcElligatorRistrettoMap(r1);\n\t\t        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n\t\t        const R2 = calcElligatorRistrettoMap(r2);\n\t\t        return new RistPoint(R1.add(R2));\n\t\t    }\n\t\t    /**\n\t\t     * Converts ristretto-encoded string to ristretto point.\n\t\t     * https://ristretto.group/formulas/decoding.html\n\t\t     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n\t\t     */\n\t\t    static fromHex(hex) {\n\t\t        hex = (0, utils_js_1.ensureBytes)('ristrettoHex', hex, 32);\n\t\t        const { a, d } = exports.ed25519.CURVE;\n\t\t        const P = exports.ed25519.CURVE.Fp.ORDER;\n\t\t        const mod = exports.ed25519.CURVE.Fp.create;\n\t\t        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n\t\t        const s = bytes255ToNumberLE(hex);\n\t\t        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n\t\t        // 3. Check that s is non-negative, or else abort\n\t\t        if (!(0, utils_js_1.equalBytes)((0, utils_js_1.numberToBytesLE)(s, 32), hex) || (0, modular_js_1.isNegativeLE)(s, P))\n\t\t            throw new Error(emsg);\n\t\t        const s2 = mod(s * s);\n\t\t        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n\t\t        const u2 = mod(_1n - a * s2); // 5\n\t\t        const u1_2 = mod(u1 * u1);\n\t\t        const u2_2 = mod(u2 * u2);\n\t\t        const v = mod(a * d * u1_2 - u2_2); // 6\n\t\t        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n\t\t        const Dx = mod(I * u2); // 8\n\t\t        const Dy = mod(I * Dx * v); // 9\n\t\t        let x = mod((s + s) * Dx); // 10\n\t\t        if ((0, modular_js_1.isNegativeLE)(x, P))\n\t\t            x = mod(-x); // 10\n\t\t        const y = mod(u1 * Dy); // 11\n\t\t        const t = mod(x * y); // 12\n\t\t        if (!isValid || (0, modular_js_1.isNegativeLE)(t, P) || y === _0n)\n\t\t            throw new Error(emsg);\n\t\t        return new RistPoint(new exports.ed25519.ExtendedPoint(x, y, _1n, t));\n\t\t    }\n\t\t    static msm(points, scalars) {\n\t\t        const Fn = (0, modular_js_1.Field)(exports.ed25519.CURVE.n, exports.ed25519.CURVE.nBitLength);\n\t\t        return (0, curve_js_1.pippenger)(RistPoint, Fn, points, scalars);\n\t\t    }\n\t\t    /**\n\t\t     * Encodes ristretto point to Uint8Array.\n\t\t     * https://ristretto.group/formulas/encoding.html\n\t\t     */\n\t\t    toRawBytes() {\n\t\t        let { ex: x, ey: y, ez: z, et: t } = this.ep;\n\t\t        const P = exports.ed25519.CURVE.Fp.ORDER;\n\t\t        const mod = exports.ed25519.CURVE.Fp.create;\n\t\t        const u1 = mod(mod(z + y) * mod(z - y)); // 1\n\t\t        const u2 = mod(x * y); // 2\n\t\t        // Square root always exists\n\t\t        const u2sq = mod(u2 * u2);\n\t\t        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n\t\t        const D1 = mod(invsqrt * u1); // 4\n\t\t        const D2 = mod(invsqrt * u2); // 5\n\t\t        const zInv = mod(D1 * D2 * t); // 6\n\t\t        let D; // 7\n\t\t        if ((0, modular_js_1.isNegativeLE)(t * zInv, P)) {\n\t\t            let _x = mod(y * SQRT_M1);\n\t\t            let _y = mod(x * SQRT_M1);\n\t\t            x = _x;\n\t\t            y = _y;\n\t\t            D = mod(D1 * INVSQRT_A_MINUS_D);\n\t\t        }\n\t\t        else {\n\t\t            D = D2; // 8\n\t\t        }\n\t\t        if ((0, modular_js_1.isNegativeLE)(x * zInv, P))\n\t\t            y = mod(-y); // 9\n\t\t        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n\t\t        if ((0, modular_js_1.isNegativeLE)(s, P))\n\t\t            s = mod(-s);\n\t\t        return (0, utils_js_1.numberToBytesLE)(s, 32); // 11\n\t\t    }\n\t\t    toHex() {\n\t\t        return (0, utils_js_1.bytesToHex)(this.toRawBytes());\n\t\t    }\n\t\t    toString() {\n\t\t        return this.toHex();\n\t\t    }\n\t\t    // Compare one point to another.\n\t\t    equals(other) {\n\t\t        assertRstPoint(other);\n\t\t        const { ex: X1, ey: Y1 } = this.ep;\n\t\t        const { ex: X2, ey: Y2 } = other.ep;\n\t\t        const mod = exports.ed25519.CURVE.Fp.create;\n\t\t        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n\t\t        const one = mod(X1 * Y2) === mod(Y1 * X2);\n\t\t        const two = mod(Y1 * Y2) === mod(X1 * X2);\n\t\t        return one || two;\n\t\t    }\n\t\t    add(other) {\n\t\t        assertRstPoint(other);\n\t\t        return new RistPoint(this.ep.add(other.ep));\n\t\t    }\n\t\t    subtract(other) {\n\t\t        assertRstPoint(other);\n\t\t        return new RistPoint(this.ep.subtract(other.ep));\n\t\t    }\n\t\t    multiply(scalar) {\n\t\t        return new RistPoint(this.ep.multiply(scalar));\n\t\t    }\n\t\t    multiplyUnsafe(scalar) {\n\t\t        return new RistPoint(this.ep.multiplyUnsafe(scalar));\n\t\t    }\n\t\t    double() {\n\t\t        return new RistPoint(this.ep.double());\n\t\t    }\n\t\t    negate() {\n\t\t        return new RistPoint(this.ep.negate());\n\t\t    }\n\t\t}\n\t\texports.RistrettoPoint = (() => {\n\t\t    if (!RistPoint.BASE)\n\t\t        RistPoint.BASE = new RistPoint(exports.ed25519.ExtendedPoint.BASE);\n\t\t    if (!RistPoint.ZERO)\n\t\t        RistPoint.ZERO = new RistPoint(exports.ed25519.ExtendedPoint.ZERO);\n\t\t    return RistPoint;\n\t\t})();\n\t\t// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\n\t\tconst hashToRistretto255 = (msg, options) => {\n\t\t    const d = options.DST;\n\t\t    const DST = typeof d === 'string' ? (0, utils_1.utf8ToBytes)(d) : d;\n\t\t    const uniform_bytes = (0, hash_to_curve_js_1.expand_message_xmd)(msg, DST, 64, sha512_1.sha512);\n\t\t    const P = RistPoint.hashToCurve(uniform_bytes);\n\t\t    return P;\n\t\t};\n\t\texports.hashToRistretto255 = hashToRistretto255;\n\t\texports.hash_to_ristretto255 = exports.hashToRistretto255; // legacy\n\t\t\n\t} (ed25519));\n\treturn ed25519;\n}\n\nvar secp256k1 = {};\n\nvar sha256 = {};\n\nvar hasRequiredSha256;\n\nfunction requireSha256 () {\n\tif (hasRequiredSha256) return sha256;\n\thasRequiredSha256 = 1;\n\tObject.defineProperty(sha256, \"__esModule\", { value: true });\n\tsha256.sha224 = sha256.sha256 = sha256.SHA256 = void 0;\n\t/**\n\t * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n\t *\n\t * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n\t * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n\t *\n\t * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n\t * @module\n\t */\n\tconst _md_js_1 = /*@__PURE__*/ require_md();\n\tconst utils_js_1 = /*@__PURE__*/ requireUtils$2();\n\t/** Round constants: first 32 bits of fractional parts of the cube roots of the first 64 primes 2..311). */\n\t// prettier-ignore\n\tconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n\t    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n\t    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n\t    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n\t    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n\t    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n\t    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n\t    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n\t    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n\t]);\n\t/** Initial state: first 32 bits of fractional parts of the square roots of the first 8 primes 2..19. */\n\t// prettier-ignore\n\tconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n\t    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n\t]);\n\t/**\n\t * Temporary buffer, not used to store anything between runs.\n\t * Named this way because it matches specification.\n\t */\n\tconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n\tclass SHA256 extends _md_js_1.HashMD {\n\t    constructor() {\n\t        super(64, 32, 8, false);\n\t        // We cannot use array here since array allows indexing by variable\n\t        // which means optimizer/compiler cannot use registers.\n\t        this.A = SHA256_IV[0] | 0;\n\t        this.B = SHA256_IV[1] | 0;\n\t        this.C = SHA256_IV[2] | 0;\n\t        this.D = SHA256_IV[3] | 0;\n\t        this.E = SHA256_IV[4] | 0;\n\t        this.F = SHA256_IV[5] | 0;\n\t        this.G = SHA256_IV[6] | 0;\n\t        this.H = SHA256_IV[7] | 0;\n\t    }\n\t    get() {\n\t        const { A, B, C, D, E, F, G, H } = this;\n\t        return [A, B, C, D, E, F, G, H];\n\t    }\n\t    // prettier-ignore\n\t    set(A, B, C, D, E, F, G, H) {\n\t        this.A = A | 0;\n\t        this.B = B | 0;\n\t        this.C = C | 0;\n\t        this.D = D | 0;\n\t        this.E = E | 0;\n\t        this.F = F | 0;\n\t        this.G = G | 0;\n\t        this.H = H | 0;\n\t    }\n\t    process(view, offset) {\n\t        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n\t        for (let i = 0; i < 16; i++, offset += 4)\n\t            SHA256_W[i] = view.getUint32(offset, false);\n\t        for (let i = 16; i < 64; i++) {\n\t            const W15 = SHA256_W[i - 15];\n\t            const W2 = SHA256_W[i - 2];\n\t            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);\n\t            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);\n\t            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n\t        }\n\t        // Compression function main loop, 64 rounds\n\t        let { A, B, C, D, E, F, G, H } = this;\n\t        for (let i = 0; i < 64; i++) {\n\t            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n\t            const T1 = (H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n\t            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n\t            const T2 = (sigma0 + (0, _md_js_1.Maj)(A, B, C)) | 0;\n\t            H = G;\n\t            G = F;\n\t            F = E;\n\t            E = (D + T1) | 0;\n\t            D = C;\n\t            C = B;\n\t            B = A;\n\t            A = (T1 + T2) | 0;\n\t        }\n\t        // Add the compressed chunk to the current hash value\n\t        A = (A + this.A) | 0;\n\t        B = (B + this.B) | 0;\n\t        C = (C + this.C) | 0;\n\t        D = (D + this.D) | 0;\n\t        E = (E + this.E) | 0;\n\t        F = (F + this.F) | 0;\n\t        G = (G + this.G) | 0;\n\t        H = (H + this.H) | 0;\n\t        this.set(A, B, C, D, E, F, G, H);\n\t    }\n\t    roundClean() {\n\t        SHA256_W.fill(0);\n\t    }\n\t    destroy() {\n\t        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n\t        this.buffer.fill(0);\n\t    }\n\t}\n\tsha256.SHA256 = SHA256;\n\t/**\n\t * Constants taken from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf.\n\t */\n\tclass SHA224 extends SHA256 {\n\t    constructor() {\n\t        super();\n\t        this.A = 0xc1059ed8 | 0;\n\t        this.B = 0x367cd507 | 0;\n\t        this.C = 0x3070dd17 | 0;\n\t        this.D = 0xf70e5939 | 0;\n\t        this.E = 0xffc00b31 | 0;\n\t        this.F = 0x68581511 | 0;\n\t        this.G = 0x64f98fa7 | 0;\n\t        this.H = 0xbefa4fa4 | 0;\n\t        this.outputLen = 28;\n\t    }\n\t}\n\t/** SHA2-256 hash function */\n\tsha256.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\n\t/** SHA2-224 hash function */\n\tsha256.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());\n\t\n\treturn sha256;\n}\n\nvar _shortw_utils = {};\n\nvar hmac = {};\n\nvar hasRequiredHmac;\n\nfunction requireHmac () {\n\tif (hasRequiredHmac) return hmac;\n\thasRequiredHmac = 1;\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.hmac = exports.HMAC = void 0;\n\t\t/**\n\t\t * HMAC: RFC2104 message authentication code.\n\t\t * @module\n\t\t */\n\t\tconst _assert_js_1 = /*@__PURE__*/ require_assert();\n\t\tconst utils_js_1 = /*@__PURE__*/ requireUtils$2();\n\t\tclass HMAC extends utils_js_1.Hash {\n\t\t    constructor(hash, _key) {\n\t\t        super();\n\t\t        this.finished = false;\n\t\t        this.destroyed = false;\n\t\t        (0, _assert_js_1.ahash)(hash);\n\t\t        const key = (0, utils_js_1.toBytes)(_key);\n\t\t        this.iHash = hash.create();\n\t\t        if (typeof this.iHash.update !== 'function')\n\t\t            throw new Error('Expected instance of class which extends utils.Hash');\n\t\t        this.blockLen = this.iHash.blockLen;\n\t\t        this.outputLen = this.iHash.outputLen;\n\t\t        const blockLen = this.blockLen;\n\t\t        const pad = new Uint8Array(blockLen);\n\t\t        // blockLen can be bigger than outputLen\n\t\t        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n\t\t        for (let i = 0; i < pad.length; i++)\n\t\t            pad[i] ^= 0x36;\n\t\t        this.iHash.update(pad);\n\t\t        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n\t\t        this.oHash = hash.create();\n\t\t        // Undo internal XOR && apply outer XOR\n\t\t        for (let i = 0; i < pad.length; i++)\n\t\t            pad[i] ^= 0x36 ^ 0x5c;\n\t\t        this.oHash.update(pad);\n\t\t        pad.fill(0);\n\t\t    }\n\t\t    update(buf) {\n\t\t        (0, _assert_js_1.aexists)(this);\n\t\t        this.iHash.update(buf);\n\t\t        return this;\n\t\t    }\n\t\t    digestInto(out) {\n\t\t        (0, _assert_js_1.aexists)(this);\n\t\t        (0, _assert_js_1.abytes)(out, this.outputLen);\n\t\t        this.finished = true;\n\t\t        this.iHash.digestInto(out);\n\t\t        this.oHash.update(out);\n\t\t        this.oHash.digestInto(out);\n\t\t        this.destroy();\n\t\t    }\n\t\t    digest() {\n\t\t        const out = new Uint8Array(this.oHash.outputLen);\n\t\t        this.digestInto(out);\n\t\t        return out;\n\t\t    }\n\t\t    _cloneInto(to) {\n\t\t        // Create new instance without calling constructor since key already in state and we don't know it.\n\t\t        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n\t\t        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n\t\t        to = to;\n\t\t        to.finished = finished;\n\t\t        to.destroyed = destroyed;\n\t\t        to.blockLen = blockLen;\n\t\t        to.outputLen = outputLen;\n\t\t        to.oHash = oHash._cloneInto(to.oHash);\n\t\t        to.iHash = iHash._cloneInto(to.iHash);\n\t\t        return to;\n\t\t    }\n\t\t    destroy() {\n\t\t        this.destroyed = true;\n\t\t        this.oHash.destroy();\n\t\t        this.iHash.destroy();\n\t\t    }\n\t\t}\n\t\texports.HMAC = HMAC;\n\t\t/**\n\t\t * HMAC: RFC2104 message authentication code.\n\t\t * @param hash - function that would be used e.g. sha256\n\t\t * @param key - message key\n\t\t * @param message - message data\n\t\t * @example\n\t\t * import { hmac } from '@noble/hashes/hmac';\n\t\t * import { sha256 } from '@noble/hashes/sha2';\n\t\t * const mac1 = hmac(sha256, 'key', 'message');\n\t\t */\n\t\tconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\n\t\texports.hmac = hmac;\n\t\texports.hmac.create = (hash, key) => new HMAC(hash, key);\n\t\t\n\t} (hmac));\n\treturn hmac;\n}\n\nvar weierstrass = {};\n\nvar hasRequiredWeierstrass;\n\nfunction requireWeierstrass () {\n\tif (hasRequiredWeierstrass) return weierstrass;\n\thasRequiredWeierstrass = 1;\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.DER = exports.DERErr = void 0;\n\t\texports.weierstrassPoints = weierstrassPoints;\n\t\texports.weierstrass = weierstrass;\n\t\texports.SWUFpSqrtRatio = SWUFpSqrtRatio;\n\t\texports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;\n\t\t/**\n\t\t * Short Weierstrass curve methods. The formula is: y = x + ax + b.\n\t\t *\n\t\t * ### Design rationale for types\n\t\t *\n\t\t * * Interaction between classes from different curves should fail:\n\t\t *   `k256.Point.BASE.add(p256.Point.BASE)`\n\t\t * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n\t\t * * Different calls of `curve()` would return different classes -\n\t\t *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n\t\t *   it won't affect others\n\t\t *\n\t\t * TypeScript can't infer types for classes created inside a function. Classes is one instance\n\t\t * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n\t\t * unique type for every function call.\n\t\t *\n\t\t * We can use generic types via some param, like curve opts, but that would:\n\t\t *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n\t\t *     which is hard to debug.\n\t\t *     2. Params can be generic and we can't enforce them to be constant value:\n\t\t *     if somebody creates curve from non-constant params,\n\t\t *     it would be allowed to interact with other curves with non-constant params\n\t\t *\n\t\t * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n\t\t * @module\n\t\t */\n\t\t/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\t\tconst curve_js_1 = /*@__PURE__*/ requireCurve();\n\t\tconst modular_js_1 = /*@__PURE__*/ requireModular();\n\t\tconst ut = /*@__PURE__*/ requireUtils$1();\n\t\tconst utils_js_1 = /*@__PURE__*/ requireUtils$1();\n\t\tfunction validateSigVerOpts(opts) {\n\t\t    if (opts.lowS !== undefined)\n\t\t        (0, utils_js_1.abool)('lowS', opts.lowS);\n\t\t    if (opts.prehash !== undefined)\n\t\t        (0, utils_js_1.abool)('prehash', opts.prehash);\n\t\t}\n\t\tfunction validatePointOpts(curve) {\n\t\t    const opts = (0, curve_js_1.validateBasic)(curve);\n\t\t    ut.validateObject(opts, {\n\t\t        a: 'field',\n\t\t        b: 'field',\n\t\t    }, {\n\t\t        allowedPrivateKeyLengths: 'array',\n\t\t        wrapPrivateKey: 'boolean',\n\t\t        isTorsionFree: 'function',\n\t\t        clearCofactor: 'function',\n\t\t        allowInfinityPoint: 'boolean',\n\t\t        fromBytes: 'function',\n\t\t        toBytes: 'function',\n\t\t    });\n\t\t    const { endo, Fp, a } = opts;\n\t\t    if (endo) {\n\t\t        if (!Fp.eql(a, Fp.ZERO)) {\n\t\t            throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0');\n\t\t        }\n\t\t        if (typeof endo !== 'object' ||\n\t\t            typeof endo.beta !== 'bigint' ||\n\t\t            typeof endo.splitScalar !== 'function') {\n\t\t            throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function');\n\t\t        }\n\t\t    }\n\t\t    return Object.freeze({ ...opts });\n\t\t}\n\t\tconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\n\t\tclass DERErr extends Error {\n\t\t    constructor(m = '') {\n\t\t        super(m);\n\t\t    }\n\t\t}\n\t\texports.DERErr = DERErr;\n\t\t/**\n\t\t * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n\t\t *\n\t\t *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n\t\t *\n\t\t * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n\t\t */\n\t\texports.DER = {\n\t\t    // asn.1 DER encoding utils\n\t\t    Err: DERErr,\n\t\t    // Basic building block is TLV (Tag-Length-Value)\n\t\t    _tlv: {\n\t\t        encode: (tag, data) => {\n\t\t            const { Err: E } = exports.DER;\n\t\t            if (tag < 0 || tag > 256)\n\t\t                throw new E('tlv.encode: wrong tag');\n\t\t            if (data.length & 1)\n\t\t                throw new E('tlv.encode: unpadded data');\n\t\t            const dataLen = data.length / 2;\n\t\t            const len = ut.numberToHexUnpadded(dataLen);\n\t\t            if ((len.length / 2) & 128)\n\t\t                throw new E('tlv.encode: long form length too big');\n\t\t            // length of length with long form flag\n\t\t            const lenLen = dataLen > 127 ? ut.numberToHexUnpadded((len.length / 2) | 128) : '';\n\t\t            const t = ut.numberToHexUnpadded(tag);\n\t\t            return t + lenLen + len + data;\n\t\t        },\n\t\t        // v - value, l - left bytes (unparsed)\n\t\t        decode(tag, data) {\n\t\t            const { Err: E } = exports.DER;\n\t\t            let pos = 0;\n\t\t            if (tag < 0 || tag > 256)\n\t\t                throw new E('tlv.encode: wrong tag');\n\t\t            if (data.length < 2 || data[pos++] !== tag)\n\t\t                throw new E('tlv.decode: wrong tlv');\n\t\t            const first = data[pos++];\n\t\t            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n\t\t            let length = 0;\n\t\t            if (!isLong)\n\t\t                length = first;\n\t\t            else {\n\t\t                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n\t\t                const lenLen = first & 127;\n\t\t                if (!lenLen)\n\t\t                    throw new E('tlv.decode(long): indefinite length not supported');\n\t\t                if (lenLen > 4)\n\t\t                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n\t\t                const lengthBytes = data.subarray(pos, pos + lenLen);\n\t\t                if (lengthBytes.length !== lenLen)\n\t\t                    throw new E('tlv.decode: length bytes not complete');\n\t\t                if (lengthBytes[0] === 0)\n\t\t                    throw new E('tlv.decode(long): zero leftmost byte');\n\t\t                for (const b of lengthBytes)\n\t\t                    length = (length << 8) | b;\n\t\t                pos += lenLen;\n\t\t                if (length < 128)\n\t\t                    throw new E('tlv.decode(long): not minimal encoding');\n\t\t            }\n\t\t            const v = data.subarray(pos, pos + length);\n\t\t            if (v.length !== length)\n\t\t                throw new E('tlv.decode: wrong value length');\n\t\t            return { v, l: data.subarray(pos + length) };\n\t\t        },\n\t\t    },\n\t\t    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n\t\t    // since we always use positive integers here. It must always be empty:\n\t\t    // - add zero byte if exists\n\t\t    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n\t\t    _int: {\n\t\t        encode(num) {\n\t\t            const { Err: E } = exports.DER;\n\t\t            if (num < _0n)\n\t\t                throw new E('integer: negative integers are not allowed');\n\t\t            let hex = ut.numberToHexUnpadded(num);\n\t\t            // Pad with zero byte if negative flag is present\n\t\t            if (Number.parseInt(hex[0], 16) & 0b1000)\n\t\t                hex = '00' + hex;\n\t\t            if (hex.length & 1)\n\t\t                throw new E('unexpected DER parsing assertion: unpadded hex');\n\t\t            return hex;\n\t\t        },\n\t\t        decode(data) {\n\t\t            const { Err: E } = exports.DER;\n\t\t            if (data[0] & 128)\n\t\t                throw new E('invalid signature integer: negative');\n\t\t            if (data[0] === 0x00 && !(data[1] & 128))\n\t\t                throw new E('invalid signature integer: unnecessary leading zero');\n\t\t            return b2n(data);\n\t\t        },\n\t\t    },\n\t\t    toSig(hex) {\n\t\t        // parse DER signature\n\t\t        const { Err: E, _int: int, _tlv: tlv } = exports.DER;\n\t\t        const data = typeof hex === 'string' ? h2b(hex) : hex;\n\t\t        ut.abytes(data);\n\t\t        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n\t\t        if (seqLeftBytes.length)\n\t\t            throw new E('invalid signature: left bytes after parsing');\n\t\t        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n\t\t        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n\t\t        if (sLeftBytes.length)\n\t\t            throw new E('invalid signature: left bytes after parsing');\n\t\t        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n\t\t    },\n\t\t    hexFromSig(sig) {\n\t\t        const { _tlv: tlv, _int: int } = exports.DER;\n\t\t        const rs = tlv.encode(0x02, int.encode(sig.r));\n\t\t        const ss = tlv.encode(0x02, int.encode(sig.s));\n\t\t        const seq = rs + ss;\n\t\t        return tlv.encode(0x30, seq);\n\t\t    },\n\t\t};\n\t\t// Be friendly to bad ECMAScript parsers by not using bigint literals\n\t\t// prettier-ignore\n\t\tconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\t\tfunction weierstrassPoints(opts) {\n\t\t    const CURVE = validatePointOpts(opts);\n\t\t    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n\t\t    const Fn = (0, modular_js_1.Field)(CURVE.n, CURVE.nBitLength);\n\t\t    const toBytes = CURVE.toBytes ||\n\t\t        ((_c, point, _isCompressed) => {\n\t\t            const a = point.toAffine();\n\t\t            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n\t\t        });\n\t\t    const fromBytes = CURVE.fromBytes ||\n\t\t        ((bytes) => {\n\t\t            // const head = bytes[0];\n\t\t            const tail = bytes.subarray(1);\n\t\t            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n\t\t            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n\t\t            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n\t\t            return { x, y };\n\t\t        });\n\t\t    /**\n\t\t     * y = x + ax + b: Short weierstrass curve formula\n\t\t     * @returns y\n\t\t     */\n\t\t    function weierstrassEquation(x) {\n\t\t        const { a, b } = CURVE;\n\t\t        const x2 = Fp.sqr(x); // x * x\n\t\t        const x3 = Fp.mul(x2, x); // x2 * x\n\t\t        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n\t\t    }\n\t\t    // Validate whether the passed curve params are valid.\n\t\t    // We check if curve equation works for generator point.\n\t\t    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n\t\t    // ProjectivePoint class has not been initialized yet.\n\t\t    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n\t\t        throw new Error('bad generator point: equation left != right');\n\t\t    // Valid group elements reside in range 1..n-1\n\t\t    function isWithinCurveOrder(num) {\n\t\t        return ut.inRange(num, _1n, CURVE.n);\n\t\t    }\n\t\t    // Validates if priv key is valid and converts it to bigint.\n\t\t    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n\t\t    function normPrivateKeyToScalar(key) {\n\t\t        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n\t\t        if (lengths && typeof key !== 'bigint') {\n\t\t            if (ut.isBytes(key))\n\t\t                key = ut.bytesToHex(key);\n\t\t            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n\t\t            if (typeof key !== 'string' || !lengths.includes(key.length))\n\t\t                throw new Error('invalid private key');\n\t\t            key = key.padStart(nByteLength * 2, '0');\n\t\t        }\n\t\t        let num;\n\t\t        try {\n\t\t            num =\n\t\t                typeof key === 'bigint'\n\t\t                    ? key\n\t\t                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));\n\t\t        }\n\t\t        catch (error) {\n\t\t            throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);\n\t\t        }\n\t\t        if (wrapPrivateKey)\n\t\t            num = (0, modular_js_1.mod)(num, N); // disabled by default, enabled for BLS\n\t\t        ut.aInRange('private key', num, _1n, N); // num in range [1..N-1]\n\t\t        return num;\n\t\t    }\n\t\t    function assertPrjPoint(other) {\n\t\t        if (!(other instanceof Point))\n\t\t            throw new Error('ProjectivePoint expected');\n\t\t    }\n\t\t    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n\t\t    // Converts Projective point to affine (x, y) coordinates.\n\t\t    // Can accept precomputed Z^-1 - for example, from invertBatch.\n\t\t    // (x, y, z)  (x=x/z, y=y/z)\n\t\t    const toAffineMemo = (0, utils_js_1.memoized)((p, iz) => {\n\t\t        const { px: x, py: y, pz: z } = p;\n\t\t        // Fast-path for normalized points\n\t\t        if (Fp.eql(z, Fp.ONE))\n\t\t            return { x, y };\n\t\t        const is0 = p.is0();\n\t\t        // If invZ was 0, we return zero point. However we still want to execute\n\t\t        // all operations, so we replace invZ with a random number, 1.\n\t\t        if (iz == null)\n\t\t            iz = is0 ? Fp.ONE : Fp.inv(z);\n\t\t        const ax = Fp.mul(x, iz);\n\t\t        const ay = Fp.mul(y, iz);\n\t\t        const zz = Fp.mul(z, iz);\n\t\t        if (is0)\n\t\t            return { x: Fp.ZERO, y: Fp.ZERO };\n\t\t        if (!Fp.eql(zz, Fp.ONE))\n\t\t            throw new Error('invZ was invalid');\n\t\t        return { x: ax, y: ay };\n\t\t    });\n\t\t    // NOTE: on exception this will crash 'cached' and no value will be set.\n\t\t    // Otherwise true will be return\n\t\t    const assertValidMemo = (0, utils_js_1.memoized)((p) => {\n\t\t        if (p.is0()) {\n\t\t            // (0, 1, 0) aka ZERO is invalid in most contexts.\n\t\t            // In BLS, ZERO can be serialized, so we allow it.\n\t\t            // (0, 0, 0) is invalid representation of ZERO.\n\t\t            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\n\t\t                return;\n\t\t            throw new Error('bad point: ZERO');\n\t\t        }\n\t\t        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n\t\t        const { x, y } = p.toAffine();\n\t\t        // Check if x, y are valid field elements\n\t\t        if (!Fp.isValid(x) || !Fp.isValid(y))\n\t\t            throw new Error('bad point: x or y not FE');\n\t\t        const left = Fp.sqr(y); // y\n\t\t        const right = weierstrassEquation(x); // x + ax + b\n\t\t        if (!Fp.eql(left, right))\n\t\t            throw new Error('bad point: equation left != right');\n\t\t        if (!p.isTorsionFree())\n\t\t            throw new Error('bad point: not in prime-order subgroup');\n\t\t        return true;\n\t\t    });\n\t\t    /**\n\t\t     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n\t\t     * Default Point works in 2d / affine coordinates: (x, y)\n\t\t     * We're doing calculations in projective, because its operations don't require costly inversion.\n\t\t     */\n\t\t    class Point {\n\t\t        constructor(px, py, pz) {\n\t\t            this.px = px;\n\t\t            this.py = py;\n\t\t            this.pz = pz;\n\t\t            if (px == null || !Fp.isValid(px))\n\t\t                throw new Error('x required');\n\t\t            if (py == null || !Fp.isValid(py))\n\t\t                throw new Error('y required');\n\t\t            if (pz == null || !Fp.isValid(pz))\n\t\t                throw new Error('z required');\n\t\t            Object.freeze(this);\n\t\t        }\n\t\t        // Does not validate if the point is on-curve.\n\t\t        // Use fromHex instead, or call assertValidity() later.\n\t\t        static fromAffine(p) {\n\t\t            const { x, y } = p || {};\n\t\t            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n\t\t                throw new Error('invalid affine point');\n\t\t            if (p instanceof Point)\n\t\t                throw new Error('projective point not allowed');\n\t\t            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n\t\t            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n\t\t            if (is0(x) && is0(y))\n\t\t                return Point.ZERO;\n\t\t            return new Point(x, y, Fp.ONE);\n\t\t        }\n\t\t        get x() {\n\t\t            return this.toAffine().x;\n\t\t        }\n\t\t        get y() {\n\t\t            return this.toAffine().y;\n\t\t        }\n\t\t        /**\n\t\t         * Takes a bunch of Projective Points but executes only one\n\t\t         * inversion on all of them. Inversion is very slow operation,\n\t\t         * so this improves performance massively.\n\t\t         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n\t\t         */\n\t\t        static normalizeZ(points) {\n\t\t            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n\t\t            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n\t\t        }\n\t\t        /**\n\t\t         * Converts hash string or Uint8Array to Point.\n\t\t         * @param hex short/long ECDSA hex\n\t\t         */\n\t\t        static fromHex(hex) {\n\t\t            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));\n\t\t            P.assertValidity();\n\t\t            return P;\n\t\t        }\n\t\t        // Multiplies generator point by privateKey.\n\t\t        static fromPrivateKey(privateKey) {\n\t\t            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n\t\t        }\n\t\t        // Multiscalar Multiplication\n\t\t        static msm(points, scalars) {\n\t\t            return (0, curve_js_1.pippenger)(Point, Fn, points, scalars);\n\t\t        }\n\t\t        // \"Private method\", don't use it directly\n\t\t        _setWindowSize(windowSize) {\n\t\t            wnaf.setWindowSize(this, windowSize);\n\t\t        }\n\t\t        // A point on curve is valid if it conforms to equation.\n\t\t        assertValidity() {\n\t\t            assertValidMemo(this);\n\t\t        }\n\t\t        hasEvenY() {\n\t\t            const { y } = this.toAffine();\n\t\t            if (Fp.isOdd)\n\t\t                return !Fp.isOdd(y);\n\t\t            throw new Error(\"Field doesn't support isOdd\");\n\t\t        }\n\t\t        /**\n\t\t         * Compare one point to another.\n\t\t         */\n\t\t        equals(other) {\n\t\t            assertPrjPoint(other);\n\t\t            const { px: X1, py: Y1, pz: Z1 } = this;\n\t\t            const { px: X2, py: Y2, pz: Z2 } = other;\n\t\t            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n\t\t            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n\t\t            return U1 && U2;\n\t\t        }\n\t\t        /**\n\t\t         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n\t\t         */\n\t\t        negate() {\n\t\t            return new Point(this.px, Fp.neg(this.py), this.pz);\n\t\t        }\n\t\t        // Renes-Costello-Batina exception-free doubling formula.\n\t\t        // There is 30% faster Jacobian formula, but it is not complete.\n\t\t        // https://eprint.iacr.org/2015/1060, algorithm 3\n\t\t        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n\t\t        double() {\n\t\t            const { a, b } = CURVE;\n\t\t            const b3 = Fp.mul(b, _3n);\n\t\t            const { px: X1, py: Y1, pz: Z1 } = this;\n\t\t            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n\t\t            let t0 = Fp.mul(X1, X1); // step 1\n\t\t            let t1 = Fp.mul(Y1, Y1);\n\t\t            let t2 = Fp.mul(Z1, Z1);\n\t\t            let t3 = Fp.mul(X1, Y1);\n\t\t            t3 = Fp.add(t3, t3); // step 5\n\t\t            Z3 = Fp.mul(X1, Z1);\n\t\t            Z3 = Fp.add(Z3, Z3);\n\t\t            X3 = Fp.mul(a, Z3);\n\t\t            Y3 = Fp.mul(b3, t2);\n\t\t            Y3 = Fp.add(X3, Y3); // step 10\n\t\t            X3 = Fp.sub(t1, Y3);\n\t\t            Y3 = Fp.add(t1, Y3);\n\t\t            Y3 = Fp.mul(X3, Y3);\n\t\t            X3 = Fp.mul(t3, X3);\n\t\t            Z3 = Fp.mul(b3, Z3); // step 15\n\t\t            t2 = Fp.mul(a, t2);\n\t\t            t3 = Fp.sub(t0, t2);\n\t\t            t3 = Fp.mul(a, t3);\n\t\t            t3 = Fp.add(t3, Z3);\n\t\t            Z3 = Fp.add(t0, t0); // step 20\n\t\t            t0 = Fp.add(Z3, t0);\n\t\t            t0 = Fp.add(t0, t2);\n\t\t            t0 = Fp.mul(t0, t3);\n\t\t            Y3 = Fp.add(Y3, t0);\n\t\t            t2 = Fp.mul(Y1, Z1); // step 25\n\t\t            t2 = Fp.add(t2, t2);\n\t\t            t0 = Fp.mul(t2, t3);\n\t\t            X3 = Fp.sub(X3, t0);\n\t\t            Z3 = Fp.mul(t2, t1);\n\t\t            Z3 = Fp.add(Z3, Z3); // step 30\n\t\t            Z3 = Fp.add(Z3, Z3);\n\t\t            return new Point(X3, Y3, Z3);\n\t\t        }\n\t\t        // Renes-Costello-Batina exception-free addition formula.\n\t\t        // There is 30% faster Jacobian formula, but it is not complete.\n\t\t        // https://eprint.iacr.org/2015/1060, algorithm 1\n\t\t        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n\t\t        add(other) {\n\t\t            assertPrjPoint(other);\n\t\t            const { px: X1, py: Y1, pz: Z1 } = this;\n\t\t            const { px: X2, py: Y2, pz: Z2 } = other;\n\t\t            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n\t\t            const a = CURVE.a;\n\t\t            const b3 = Fp.mul(CURVE.b, _3n);\n\t\t            let t0 = Fp.mul(X1, X2); // step 1\n\t\t            let t1 = Fp.mul(Y1, Y2);\n\t\t            let t2 = Fp.mul(Z1, Z2);\n\t\t            let t3 = Fp.add(X1, Y1);\n\t\t            let t4 = Fp.add(X2, Y2); // step 5\n\t\t            t3 = Fp.mul(t3, t4);\n\t\t            t4 = Fp.add(t0, t1);\n\t\t            t3 = Fp.sub(t3, t4);\n\t\t            t4 = Fp.add(X1, Z1);\n\t\t            let t5 = Fp.add(X2, Z2); // step 10\n\t\t            t4 = Fp.mul(t4, t5);\n\t\t            t5 = Fp.add(t0, t2);\n\t\t            t4 = Fp.sub(t4, t5);\n\t\t            t5 = Fp.add(Y1, Z1);\n\t\t            X3 = Fp.add(Y2, Z2); // step 15\n\t\t            t5 = Fp.mul(t5, X3);\n\t\t            X3 = Fp.add(t1, t2);\n\t\t            t5 = Fp.sub(t5, X3);\n\t\t            Z3 = Fp.mul(a, t4);\n\t\t            X3 = Fp.mul(b3, t2); // step 20\n\t\t            Z3 = Fp.add(X3, Z3);\n\t\t            X3 = Fp.sub(t1, Z3);\n\t\t            Z3 = Fp.add(t1, Z3);\n\t\t            Y3 = Fp.mul(X3, Z3);\n\t\t            t1 = Fp.add(t0, t0); // step 25\n\t\t            t1 = Fp.add(t1, t0);\n\t\t            t2 = Fp.mul(a, t2);\n\t\t            t4 = Fp.mul(b3, t4);\n\t\t            t1 = Fp.add(t1, t2);\n\t\t            t2 = Fp.sub(t0, t2); // step 30\n\t\t            t2 = Fp.mul(a, t2);\n\t\t            t4 = Fp.add(t4, t2);\n\t\t            t0 = Fp.mul(t1, t4);\n\t\t            Y3 = Fp.add(Y3, t0);\n\t\t            t0 = Fp.mul(t5, t4); // step 35\n\t\t            X3 = Fp.mul(t3, X3);\n\t\t            X3 = Fp.sub(X3, t0);\n\t\t            t0 = Fp.mul(t3, t1);\n\t\t            Z3 = Fp.mul(t5, Z3);\n\t\t            Z3 = Fp.add(Z3, t0); // step 40\n\t\t            return new Point(X3, Y3, Z3);\n\t\t        }\n\t\t        subtract(other) {\n\t\t            return this.add(other.negate());\n\t\t        }\n\t\t        is0() {\n\t\t            return this.equals(Point.ZERO);\n\t\t        }\n\t\t        wNAF(n) {\n\t\t            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n\t\t        }\n\t\t        /**\n\t\t         * Non-constant-time multiplication. Uses double-and-add algorithm.\n\t\t         * It's faster, but should only be used when you don't care about\n\t\t         * an exposed private key e.g. sig verification, which works over *public* keys.\n\t\t         */\n\t\t        multiplyUnsafe(sc) {\n\t\t            const { endo, n: N } = CURVE;\n\t\t            ut.aInRange('scalar', sc, _0n, N);\n\t\t            const I = Point.ZERO;\n\t\t            if (sc === _0n)\n\t\t                return I;\n\t\t            if (this.is0() || sc === _1n)\n\t\t                return this;\n\t\t            // Case a: no endomorphism. Case b: has precomputes.\n\t\t            if (!endo || wnaf.hasPrecomputes(this))\n\t\t                return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n\t\t            // Case c: endomorphism\n\t\t            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n\t\t            let k1p = I;\n\t\t            let k2p = I;\n\t\t            let d = this;\n\t\t            while (k1 > _0n || k2 > _0n) {\n\t\t                if (k1 & _1n)\n\t\t                    k1p = k1p.add(d);\n\t\t                if (k2 & _1n)\n\t\t                    k2p = k2p.add(d);\n\t\t                d = d.double();\n\t\t                k1 >>= _1n;\n\t\t                k2 >>= _1n;\n\t\t            }\n\t\t            if (k1neg)\n\t\t                k1p = k1p.negate();\n\t\t            if (k2neg)\n\t\t                k2p = k2p.negate();\n\t\t            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n\t\t            return k1p.add(k2p);\n\t\t        }\n\t\t        /**\n\t\t         * Constant time multiplication.\n\t\t         * Uses wNAF method. Windowed method may be 10% faster,\n\t\t         * but takes 2x longer to generate and consumes 2x memory.\n\t\t         * Uses precomputes when available.\n\t\t         * Uses endomorphism for Koblitz curves.\n\t\t         * @param scalar by which the point would be multiplied\n\t\t         * @returns New point\n\t\t         */\n\t\t        multiply(scalar) {\n\t\t            const { endo, n: N } = CURVE;\n\t\t            ut.aInRange('scalar', scalar, _1n, N);\n\t\t            let point, fake; // Fake point is used to const-time mult\n\t\t            if (endo) {\n\t\t                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n\t\t                let { p: k1p, f: f1p } = this.wNAF(k1);\n\t\t                let { p: k2p, f: f2p } = this.wNAF(k2);\n\t\t                k1p = wnaf.constTimeNegate(k1neg, k1p);\n\t\t                k2p = wnaf.constTimeNegate(k2neg, k2p);\n\t\t                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n\t\t                point = k1p.add(k2p);\n\t\t                fake = f1p.add(f2p);\n\t\t            }\n\t\t            else {\n\t\t                const { p, f } = this.wNAF(scalar);\n\t\t                point = p;\n\t\t                fake = f;\n\t\t            }\n\t\t            // Normalize `z` for both points, but return only real one\n\t\t            return Point.normalizeZ([point, fake])[0];\n\t\t        }\n\t\t        /**\n\t\t         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n\t\t         * Not using Strauss-Shamir trick: precomputation tables are faster.\n\t\t         * The trick could be useful if both P and Q are not G (not in our case).\n\t\t         * @returns non-zero affine point\n\t\t         */\n\t\t        multiplyAndAddUnsafe(Q, a, b) {\n\t\t            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n\t\t            const mul = (P, a // Select faster multiply() method\n\t\t            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n\t\t            const sum = mul(this, a).add(mul(Q, b));\n\t\t            return sum.is0() ? undefined : sum;\n\t\t        }\n\t\t        // Converts Projective point to affine (x, y) coordinates.\n\t\t        // Can accept precomputed Z^-1 - for example, from invertBatch.\n\t\t        // (x, y, z)  (x=x/z, y=y/z)\n\t\t        toAffine(iz) {\n\t\t            return toAffineMemo(this, iz);\n\t\t        }\n\t\t        isTorsionFree() {\n\t\t            const { h: cofactor, isTorsionFree } = CURVE;\n\t\t            if (cofactor === _1n)\n\t\t                return true; // No subgroups, always torsion-free\n\t\t            if (isTorsionFree)\n\t\t                return isTorsionFree(Point, this);\n\t\t            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n\t\t        }\n\t\t        clearCofactor() {\n\t\t            const { h: cofactor, clearCofactor } = CURVE;\n\t\t            if (cofactor === _1n)\n\t\t                return this; // Fast-path\n\t\t            if (clearCofactor)\n\t\t                return clearCofactor(Point, this);\n\t\t            return this.multiplyUnsafe(CURVE.h);\n\t\t        }\n\t\t        toRawBytes(isCompressed = true) {\n\t\t            (0, utils_js_1.abool)('isCompressed', isCompressed);\n\t\t            this.assertValidity();\n\t\t            return toBytes(Point, this, isCompressed);\n\t\t        }\n\t\t        toHex(isCompressed = true) {\n\t\t            (0, utils_js_1.abool)('isCompressed', isCompressed);\n\t\t            return ut.bytesToHex(this.toRawBytes(isCompressed));\n\t\t        }\n\t\t    }\n\t\t    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n\t\t    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n\t\t    const _bits = CURVE.nBitLength;\n\t\t    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n\t\t    // Validate if generator point is on curve\n\t\t    return {\n\t\t        CURVE,\n\t\t        ProjectivePoint: Point,\n\t\t        normPrivateKeyToScalar,\n\t\t        weierstrassEquation,\n\t\t        isWithinCurveOrder,\n\t\t    };\n\t\t}\n\t\tfunction validateOpts(curve) {\n\t\t    const opts = (0, curve_js_1.validateBasic)(curve);\n\t\t    ut.validateObject(opts, {\n\t\t        hash: 'hash',\n\t\t        hmac: 'function',\n\t\t        randomBytes: 'function',\n\t\t    }, {\n\t\t        bits2int: 'function',\n\t\t        bits2int_modN: 'function',\n\t\t        lowS: 'boolean',\n\t\t    });\n\t\t    return Object.freeze({ lowS: true, ...opts });\n\t\t}\n\t\t/**\n\t\t * Creates short weierstrass curve and ECDSA signature methods for it.\n\t\t * @example\n\t\t * import { Field } from '@noble/curves/abstract/modular';\n\t\t * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n\t\t * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n\t\t */\n\t\tfunction weierstrass(curveDef) {\n\t\t    const CURVE = validateOpts(curveDef);\n\t\t    const { Fp, n: CURVE_ORDER } = CURVE;\n\t\t    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n\t\t    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n\t\t    function modN(a) {\n\t\t        return (0, modular_js_1.mod)(a, CURVE_ORDER);\n\t\t    }\n\t\t    function invN(a) {\n\t\t        return (0, modular_js_1.invert)(a, CURVE_ORDER);\n\t\t    }\n\t\t    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n\t\t        ...CURVE,\n\t\t        toBytes(_c, point, isCompressed) {\n\t\t            const a = point.toAffine();\n\t\t            const x = Fp.toBytes(a.x);\n\t\t            const cat = ut.concatBytes;\n\t\t            (0, utils_js_1.abool)('isCompressed', isCompressed);\n\t\t            if (isCompressed) {\n\t\t                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n\t\t            }\n\t\t            else {\n\t\t                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n\t\t            }\n\t\t        },\n\t\t        fromBytes(bytes) {\n\t\t            const len = bytes.length;\n\t\t            const head = bytes[0];\n\t\t            const tail = bytes.subarray(1);\n\t\t            // this.assertValidity() is done inside of fromHex\n\t\t            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n\t\t                const x = ut.bytesToNumberBE(tail);\n\t\t                if (!ut.inRange(x, _1n, Fp.ORDER))\n\t\t                    throw new Error('Point is not on curve');\n\t\t                const y2 = weierstrassEquation(x); // y = x + ax + b\n\t\t                let y;\n\t\t                try {\n\t\t                    y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n\t\t                }\n\t\t                catch (sqrtError) {\n\t\t                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n\t\t                    throw new Error('Point is not on curve' + suffix);\n\t\t                }\n\t\t                const isYOdd = (y & _1n) === _1n;\n\t\t                // ECDSA\n\t\t                const isHeadOdd = (head & 1) === 1;\n\t\t                if (isHeadOdd !== isYOdd)\n\t\t                    y = Fp.neg(y);\n\t\t                return { x, y };\n\t\t            }\n\t\t            else if (len === uncompressedLen && head === 0x04) {\n\t\t                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n\t\t                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n\t\t                return { x, y };\n\t\t            }\n\t\t            else {\n\t\t                const cl = compressedLen;\n\t\t                const ul = uncompressedLen;\n\t\t                throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);\n\t\t            }\n\t\t        },\n\t\t    });\n\t\t    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n\t\t    function isBiggerThanHalfOrder(number) {\n\t\t        const HALF = CURVE_ORDER >> _1n;\n\t\t        return number > HALF;\n\t\t    }\n\t\t    function normalizeS(s) {\n\t\t        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n\t\t    }\n\t\t    // slice bytes num\n\t\t    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n\t\t    /**\n\t\t     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n\t\t     */\n\t\t    class Signature {\n\t\t        constructor(r, s, recovery) {\n\t\t            this.r = r;\n\t\t            this.s = s;\n\t\t            this.recovery = recovery;\n\t\t            this.assertValidity();\n\t\t        }\n\t\t        // pair (bytes of r, bytes of s)\n\t\t        static fromCompact(hex) {\n\t\t            const l = CURVE.nByteLength;\n\t\t            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);\n\t\t            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n\t\t        }\n\t\t        // DER encoded ECDSA signature\n\t\t        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n\t\t        static fromDER(hex) {\n\t\t            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));\n\t\t            return new Signature(r, s);\n\t\t        }\n\t\t        assertValidity() {\n\t\t            ut.aInRange('r', this.r, _1n, CURVE_ORDER); // r in [1..N]\n\t\t            ut.aInRange('s', this.s, _1n, CURVE_ORDER); // s in [1..N]\n\t\t        }\n\t\t        addRecoveryBit(recovery) {\n\t\t            return new Signature(this.r, this.s, recovery);\n\t\t        }\n\t\t        recoverPublicKey(msgHash) {\n\t\t            const { r, s, recovery: rec } = this;\n\t\t            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash\n\t\t            if (rec == null || ![0, 1, 2, 3].includes(rec))\n\t\t                throw new Error('recovery id invalid');\n\t\t            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n\t\t            if (radj >= Fp.ORDER)\n\t\t                throw new Error('recovery id 2 or 3 invalid');\n\t\t            const prefix = (rec & 1) === 0 ? '02' : '03';\n\t\t            const R = Point.fromHex(prefix + numToNByteStr(radj));\n\t\t            const ir = invN(radj); // r^-1\n\t\t            const u1 = modN(-h * ir); // -hr^-1\n\t\t            const u2 = modN(s * ir); // sr^-1\n\t\t            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n\t\t            if (!Q)\n\t\t                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n\t\t            Q.assertValidity();\n\t\t            return Q;\n\t\t        }\n\t\t        // Signatures should be low-s, to prevent malleability.\n\t\t        hasHighS() {\n\t\t            return isBiggerThanHalfOrder(this.s);\n\t\t        }\n\t\t        normalizeS() {\n\t\t            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n\t\t        }\n\t\t        // DER-encoded\n\t\t        toDERRawBytes() {\n\t\t            return ut.hexToBytes(this.toDERHex());\n\t\t        }\n\t\t        toDERHex() {\n\t\t            return exports.DER.hexFromSig({ r: this.r, s: this.s });\n\t\t        }\n\t\t        // padded bytes of r, then padded bytes of s\n\t\t        toCompactRawBytes() {\n\t\t            return ut.hexToBytes(this.toCompactHex());\n\t\t        }\n\t\t        toCompactHex() {\n\t\t            return numToNByteStr(this.r) + numToNByteStr(this.s);\n\t\t        }\n\t\t    }\n\t\t    const utils = {\n\t\t        isValidPrivateKey(privateKey) {\n\t\t            try {\n\t\t                normPrivateKeyToScalar(privateKey);\n\t\t                return true;\n\t\t            }\n\t\t            catch (error) {\n\t\t                return false;\n\t\t            }\n\t\t        },\n\t\t        normPrivateKeyToScalar: normPrivateKeyToScalar,\n\t\t        /**\n\t\t         * Produces cryptographically secure private key from random of size\n\t\t         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n\t\t         */\n\t\t        randomPrivateKey: () => {\n\t\t            const length = (0, modular_js_1.getMinHashLength)(CURVE.n);\n\t\t            return (0, modular_js_1.mapHashToField)(CURVE.randomBytes(length), CURVE.n);\n\t\t        },\n\t\t        /**\n\t\t         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n\t\t         * Allows to massively speed-up `point.multiply(scalar)`.\n\t\t         * @returns cached point\n\t\t         * @example\n\t\t         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n\t\t         * fast.multiply(privKey); // much faster ECDH now\n\t\t         */\n\t\t        precompute(windowSize = 8, point = Point.BASE) {\n\t\t            point._setWindowSize(windowSize);\n\t\t            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n\t\t            return point;\n\t\t        },\n\t\t    };\n\t\t    /**\n\t\t     * Computes public key for a private key. Checks for validity of the private key.\n\t\t     * @param privateKey private key\n\t\t     * @param isCompressed whether to return compact (default), or full key\n\t\t     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n\t\t     */\n\t\t    function getPublicKey(privateKey, isCompressed = true) {\n\t\t        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n\t\t    }\n\t\t    /**\n\t\t     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n\t\t     */\n\t\t    function isProbPub(item) {\n\t\t        const arr = ut.isBytes(item);\n\t\t        const str = typeof item === 'string';\n\t\t        const len = (arr || str) && item.length;\n\t\t        if (arr)\n\t\t            return len === compressedLen || len === uncompressedLen;\n\t\t        if (str)\n\t\t            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n\t\t        if (item instanceof Point)\n\t\t            return true;\n\t\t        return false;\n\t\t    }\n\t\t    /**\n\t\t     * ECDH (Elliptic Curve Diffie Hellman).\n\t\t     * Computes shared public key from private key and public key.\n\t\t     * Checks: 1) private key validity 2) shared key is on-curve.\n\t\t     * Does NOT hash the result.\n\t\t     * @param privateA private key\n\t\t     * @param publicB different public key\n\t\t     * @param isCompressed whether to return compact (default), or full key\n\t\t     * @returns shared public key\n\t\t     */\n\t\t    function getSharedSecret(privateA, publicB, isCompressed = true) {\n\t\t        if (isProbPub(privateA))\n\t\t            throw new Error('first arg must be private key');\n\t\t        if (!isProbPub(publicB))\n\t\t            throw new Error('second arg must be public key');\n\t\t        const b = Point.fromHex(publicB); // check for being on-curve\n\t\t        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n\t\t    }\n\t\t    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n\t\t    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n\t\t    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n\t\t    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n\t\t    const bits2int = CURVE.bits2int ||\n\t\t        function (bytes) {\n\t\t            // Our custom check \"just in case\"\n\t\t            if (bytes.length > 8192)\n\t\t                throw new Error('input is too large');\n\t\t            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n\t\t            // for some cases, since bytes.length * 8 is not actual bitLength.\n\t\t            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n\t\t            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n\t\t            return delta > 0 ? num >> BigInt(delta) : num;\n\t\t        };\n\t\t    const bits2int_modN = CURVE.bits2int_modN ||\n\t\t        function (bytes) {\n\t\t            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n\t\t        };\n\t\t    // NOTE: pads output with zero as per spec\n\t\t    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n\t\t    /**\n\t\t     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n\t\t     */\n\t\t    function int2octets(num) {\n\t\t        ut.aInRange('num < 2^' + CURVE.nBitLength, num, _0n, ORDER_MASK);\n\t\t        // works with order, can have different size than numToField!\n\t\t        return ut.numberToBytesBE(num, CURVE.nByteLength);\n\t\t    }\n\t\t    // Steps A, D of RFC6979 3.2\n\t\t    // Creates RFC6979 seed; converts msg/privKey to numbers.\n\t\t    // Used only in sign, not in verify.\n\t\t    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n\t\t    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n\t\t    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n\t\t        if (['recovered', 'canonical'].some((k) => k in opts))\n\t\t            throw new Error('sign() legacy options not supported');\n\t\t        const { hash, randomBytes } = CURVE;\n\t\t        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n\t\t        if (lowS == null)\n\t\t            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n\t\t        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);\n\t\t        validateSigVerOpts(opts);\n\t\t        if (prehash)\n\t\t            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));\n\t\t        // We can't later call bits2octets, since nested bits2int is broken for curves\n\t\t        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n\t\t        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n\t\t        const h1int = bits2int_modN(msgHash);\n\t\t        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n\t\t        const seedArgs = [int2octets(d), int2octets(h1int)];\n\t\t        // extraEntropy. RFC6979 3.6: additional k' (optional).\n\t\t        if (ent != null && ent !== false) {\n\t\t            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n\t\t            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n\t\t            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes\n\t\t        }\n\t\t        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n\t\t        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n\t\t        // Converts signature params into point w r/s, checks result for validity.\n\t\t        function k2sig(kBytes) {\n\t\t            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n\t\t            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n\t\t            if (!isWithinCurveOrder(k))\n\t\t                return; // Important: all mod() calls here must be done over N\n\t\t            const ik = invN(k); // k^-1 mod n\n\t\t            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n\t\t            const r = modN(q.x); // r = q.x mod n\n\t\t            if (r === _0n)\n\t\t                return;\n\t\t            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n\t\t            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n\t\t            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n\t\t            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n\t\t            if (s === _0n)\n\t\t                return;\n\t\t            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n\t\t            let normS = s;\n\t\t            if (lowS && isBiggerThanHalfOrder(s)) {\n\t\t                normS = normalizeS(s); // if lowS was passed, ensure s is always\n\t\t                recovery ^= 1; // // in the bottom half of N\n\t\t            }\n\t\t            return new Signature(r, normS, recovery); // use normS, not s\n\t\t        }\n\t\t        return { seed, k2sig };\n\t\t    }\n\t\t    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n\t\t    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n\t\t    /**\n\t\t     * Signs message hash with a private key.\n\t\t     * ```\n\t\t     * sign(m, d, k) where\n\t\t     *   (x, y) = G  k\n\t\t     *   r = x mod n\n\t\t     *   s = (m + dr)/k mod n\n\t\t     * ```\n\t\t     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n\t\t     * @param privKey private key\n\t\t     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n\t\t     * @returns signature with recovery param\n\t\t     */\n\t\t    function sign(msgHash, privKey, opts = defaultSigOpts) {\n\t\t        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n\t\t        const C = CURVE;\n\t\t        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n\t\t        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n\t\t    }\n\t\t    // Enable precomputes. Slows down first publicKey computation by 20ms.\n\t\t    Point.BASE._setWindowSize(8);\n\t\t    // utils.precompute(8, ProjectivePoint.BASE)\n\t\t    /**\n\t\t     * Verifies a signature against message hash and public key.\n\t\t     * Rejects lowS signatures by default: to override,\n\t\t     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n\t\t     *\n\t\t     * ```\n\t\t     * verify(r, s, h, P) where\n\t\t     *   U1 = hs^-1 mod n\n\t\t     *   U2 = rs^-1 mod n\n\t\t     *   R = U1G - U2P\n\t\t     *   mod(R.x, n) == r\n\t\t     * ```\n\t\t     */\n\t\t    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n\t\t        const sg = signature;\n\t\t        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);\n\t\t        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);\n\t\t        const { lowS, prehash, format } = opts;\n\t\t        // Verify opts, deduce signature format\n\t\t        validateSigVerOpts(opts);\n\t\t        if ('strict' in opts)\n\t\t            throw new Error('options.strict was renamed to lowS');\n\t\t        if (format !== undefined && format !== 'compact' && format !== 'der')\n\t\t            throw new Error('format must be compact or der');\n\t\t        const isHex = typeof sg === 'string' || ut.isBytes(sg);\n\t\t        const isObj = !isHex &&\n\t\t            !format &&\n\t\t            typeof sg === 'object' &&\n\t\t            sg !== null &&\n\t\t            typeof sg.r === 'bigint' &&\n\t\t            typeof sg.s === 'bigint';\n\t\t        if (!isHex && !isObj)\n\t\t            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n\t\t        let _sig = undefined;\n\t\t        let P;\n\t\t        try {\n\t\t            if (isObj)\n\t\t                _sig = new Signature(sg.r, sg.s);\n\t\t            if (isHex) {\n\t\t                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n\t\t                // Since DER can also be 2*nByteLength bytes, we check for it first.\n\t\t                try {\n\t\t                    if (format !== 'compact')\n\t\t                        _sig = Signature.fromDER(sg);\n\t\t                }\n\t\t                catch (derError) {\n\t\t                    if (!(derError instanceof exports.DER.Err))\n\t\t                        throw derError;\n\t\t                }\n\t\t                if (!_sig && format !== 'der')\n\t\t                    _sig = Signature.fromCompact(sg);\n\t\t            }\n\t\t            P = Point.fromHex(publicKey);\n\t\t        }\n\t\t        catch (error) {\n\t\t            return false;\n\t\t        }\n\t\t        if (!_sig)\n\t\t            return false;\n\t\t        if (lowS && _sig.hasHighS())\n\t\t            return false;\n\t\t        if (prehash)\n\t\t            msgHash = CURVE.hash(msgHash);\n\t\t        const { r, s } = _sig;\n\t\t        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n\t\t        const is = invN(s); // s^-1\n\t\t        const u1 = modN(h * is); // u1 = hs^-1 mod n\n\t\t        const u2 = modN(r * is); // u2 = rs^-1 mod n\n\t\t        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n\t\t        if (!R)\n\t\t            return false;\n\t\t        const v = modN(R.x);\n\t\t        return v === r;\n\t\t    }\n\t\t    return {\n\t\t        CURVE,\n\t\t        getPublicKey,\n\t\t        getSharedSecret,\n\t\t        sign,\n\t\t        verify,\n\t\t        ProjectivePoint: Point,\n\t\t        Signature,\n\t\t        utils,\n\t\t    };\n\t\t}\n\t\t/**\n\t\t * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n\t\t * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n\t\t * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n\t\t * b = False and y = sqrt(Z * (u / v)) otherwise.\n\t\t * @param Fp\n\t\t * @param Z\n\t\t * @returns\n\t\t */\n\t\tfunction SWUFpSqrtRatio(Fp, Z) {\n\t\t    // Generic implementation\n\t\t    const q = Fp.ORDER;\n\t\t    let l = _0n;\n\t\t    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n\t\t        l += _1n;\n\t\t    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n\t\t    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n\t\t    // 2n ** c1 == 2n << (c1-1)\n\t\t    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n\t\t    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n\t\t    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n\t\t    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n\t\t    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n\t\t    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n\t\t    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n\t\t    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n\t\t    let sqrtRatio = (u, v) => {\n\t\t        let tv1 = c6; // 1. tv1 = c6\n\t\t        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n\t\t        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n\t\t        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n\t\t        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n\t\t        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n\t\t        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n\t\t        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n\t\t        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n\t\t        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n\t\t        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n\t\t        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n\t\t        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n\t\t        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n\t\t        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n\t\t        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n\t\t        // 17. for i in (c1, c1 - 1, ..., 2):\n\t\t        for (let i = c1; i > _1n; i--) {\n\t\t            let tv5 = i - _2n; // 18.    tv5 = i - 2\n\t\t            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n\t\t            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n\t\t            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n\t\t            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n\t\t            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n\t\t            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n\t\t            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n\t\t            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n\t\t        }\n\t\t        return { isValid: isQR, value: tv3 };\n\t\t    };\n\t\t    if (Fp.ORDER % _4n === _3n) {\n\t\t        // sqrt_ratio_3mod4(u, v)\n\t\t        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n\t\t        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n\t\t        sqrtRatio = (u, v) => {\n\t\t            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n\t\t            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n\t\t            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n\t\t            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n\t\t            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n\t\t            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n\t\t            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n\t\t            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n\t\t            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n\t\t            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n\t\t        };\n\t\t    }\n\t\t    // No curves uses that\n\t\t    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n\t\t    return sqrtRatio;\n\t\t}\n\t\t/**\n\t\t * Simplified Shallue-van de Woestijne-Ulas Method\n\t\t * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n\t\t */\n\t\tfunction mapToCurveSimpleSWU(Fp, opts) {\n\t\t    (0, modular_js_1.validateField)(Fp);\n\t\t    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n\t\t        throw new Error('mapToCurveSimpleSWU: invalid opts');\n\t\t    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n\t\t    if (!Fp.isOdd)\n\t\t        throw new Error('Fp.isOdd is not implemented!');\n\t\t    // Input: u, an element of F.\n\t\t    // Output: (x, y), a point on E.\n\t\t    return (u) => {\n\t\t        // prettier-ignore\n\t\t        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n\t\t        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n\t\t        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n\t\t        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n\t\t        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n\t\t        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n\t\t        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n\t\t        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n\t\t        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n\t\t        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n\t\t        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n\t\t        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n\t\t        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n\t\t        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n\t\t        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n\t\t        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n\t\t        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n\t\t        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n\t\t        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n\t\t        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n\t\t        y = Fp.mul(y, value); // 20.   y = y * y1\n\t\t        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n\t\t        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n\t\t        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n\t\t        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n\t\t        x = Fp.div(x, tv4); // 25.   x = x / tv4\n\t\t        return { x, y };\n\t\t    };\n\t\t}\n\t\t\n\t} (weierstrass));\n\treturn weierstrass;\n}\n\nvar hasRequired_shortw_utils;\n\nfunction require_shortw_utils () {\n\tif (hasRequired_shortw_utils) return _shortw_utils;\n\thasRequired_shortw_utils = 1;\n\tObject.defineProperty(_shortw_utils, \"__esModule\", { value: true });\n\t_shortw_utils.getHash = getHash;\n\t_shortw_utils.createCurve = createCurve;\n\t/**\n\t * Utilities for short weierstrass curves, combined with noble-hashes.\n\t * @module\n\t */\n\t/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\tconst hmac_1 = /*@__PURE__*/ requireHmac();\n\tconst utils_1 = /*@__PURE__*/ requireUtils$2();\n\tconst weierstrass_js_1 = /*@__PURE__*/ requireWeierstrass();\n\t/** connects noble-curves to noble-hashes */\n\tfunction getHash(hash) {\n\t    return {\n\t        hash,\n\t        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),\n\t        randomBytes: utils_1.randomBytes,\n\t    };\n\t}\n\tfunction createCurve(curveDef, defHash) {\n\t    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });\n\t    return { ...create(defHash), create };\n\t}\n\t\n\treturn _shortw_utils;\n}\n\nvar hasRequiredSecp256k1;\n\nfunction requireSecp256k1 () {\n\tif (hasRequiredSecp256k1) return secp256k1;\n\thasRequiredSecp256k1 = 1;\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;\n\t\t/**\n\t\t * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n\t\t *\n\t\t * Seems to be rigid (not backdoored)\n\t\t * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n\t\t *\n\t\t * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n\t\t * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n\t\t * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n\t\t * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n\t\t * @module\n\t\t */\n\t\t/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\t\tconst sha256_1 = /*@__PURE__*/ requireSha256();\n\t\tconst utils_1 = /*@__PURE__*/ requireUtils$2();\n\t\tconst _shortw_utils_js_1 = /*@__PURE__*/ require_shortw_utils();\n\t\tconst hash_to_curve_js_1 = /*@__PURE__*/ requireHashToCurve();\n\t\tconst modular_js_1 = /*@__PURE__*/ requireModular();\n\t\tconst utils_js_1 = /*@__PURE__*/ requireUtils$1();\n\t\tconst weierstrass_js_1 = /*@__PURE__*/ requireWeierstrass();\n\t\tconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\n\t\tconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\n\t\tconst _1n = BigInt(1);\n\t\tconst _2n = BigInt(2);\n\t\tconst divNearest = (a, b) => (a + b / _2n) / b;\n\t\t/**\n\t\t * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n\t\t * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n\t\t */\n\t\tfunction sqrtMod(y) {\n\t\t    const P = secp256k1P;\n\t\t    // prettier-ignore\n\t\t    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n\t\t    // prettier-ignore\n\t\t    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n\t\t    const b2 = (y * y * y) % P; // x^3, 11\n\t\t    const b3 = (b2 * b2 * y) % P; // x^7\n\t\t    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;\n\t\t    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;\n\t\t    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;\n\t\t    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;\n\t\t    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;\n\t\t    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;\n\t\t    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;\n\t\t    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;\n\t\t    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;\n\t\t    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;\n\t\t    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;\n\t\t    const root = (0, modular_js_1.pow2)(t2, _2n, P);\n\t\t    if (!Fpk1.eql(Fpk1.sqr(root), y))\n\t\t        throw new Error('Cannot find square root');\n\t\t    return root;\n\t\t}\n\t\tconst Fpk1 = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n\t\t/**\n\t\t * secp256k1 short weierstrass curve and ECDSA signatures over it.\n\t\t *\n\t\t * @example\n\t\t * import { secp256k1 } from '@noble/curves/secp256k1';\n\t\t *\n\t\t * const priv = secp256k1.utils.randomPrivateKey();\n\t\t * const pub = secp256k1.getPublicKey(priv);\n\t\t * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n\t\t * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n\t\t * const isValid = secp256k1.verify(sig, msg, pub) === true;\n\t\t */\n\t\texports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({\n\t\t    a: BigInt(0), // equation params: a, b\n\t\t    b: BigInt(7),\n\t\t    Fp: Fpk1, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n\t\t    n: secp256k1N, // Curve order, total count of valid points in the field\n\t\t    // Base point (x, y) aka generator point\n\t\t    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n\t\t    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n\t\t    h: BigInt(1), // Cofactor\n\t\t    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n\t\t    endo: {\n\t\t        // Endomorphism, see above\n\t\t        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n\t\t        splitScalar: (k) => {\n\t\t            const n = secp256k1N;\n\t\t            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n\t\t            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n\t\t            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n\t\t            const b2 = a1;\n\t\t            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n\t\t            const c1 = divNearest(b2 * k, n);\n\t\t            const c2 = divNearest(-b1 * k, n);\n\t\t            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);\n\t\t            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);\n\t\t            const k1neg = k1 > POW_2_128;\n\t\t            const k2neg = k2 > POW_2_128;\n\t\t            if (k1neg)\n\t\t                k1 = n - k1;\n\t\t            if (k2neg)\n\t\t                k2 = n - k2;\n\t\t            if (k1 > POW_2_128 || k2 > POW_2_128) {\n\t\t                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n\t\t            }\n\t\t            return { k1neg, k1, k2neg, k2 };\n\t\t        },\n\t\t    },\n\t\t}, sha256_1.sha256);\n\t\t// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n\t\t// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n\t\tconst _0n = BigInt(0);\n\t\t/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\n\t\tconst TAGGED_HASH_PREFIXES = {};\n\t\tfunction taggedHash(tag, ...messages) {\n\t\t    let tagP = TAGGED_HASH_PREFIXES[tag];\n\t\t    if (tagP === undefined) {\n\t\t        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n\t\t        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);\n\t\t        TAGGED_HASH_PREFIXES[tag] = tagP;\n\t\t    }\n\t\t    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));\n\t\t}\n\t\t// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\n\t\tconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\n\t\tconst numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);\n\t\tconst modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);\n\t\tconst modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);\n\t\tconst Point = exports.secp256k1.ProjectivePoint;\n\t\tconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n\t\t// Calculate point, scalar and bytes\n\t\tfunction schnorrGetExtPubKey(priv) {\n\t\t    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n\t\t    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n\t\t    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n\t\t    return { scalar: scalar, bytes: pointToBytes(p) };\n\t\t}\n\t\t/**\n\t\t * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n\t\t * @returns valid point checked for being on-curve\n\t\t */\n\t\tfunction lift_x(x) {\n\t\t    (0, utils_js_1.aInRange)('x', x, _1n, secp256k1P); // Fail if x  p.\n\t\t    const xx = modP(x * x);\n\t\t    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n\t\t    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n\t\t    if (y % _2n !== _0n)\n\t\t        y = modP(-y); // Return the unique point P such that x(P) = x and\n\t\t    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n\t\t    p.assertValidity();\n\t\t    return p;\n\t\t}\n\t\tconst num = utils_js_1.bytesToNumberBE;\n\t\t/**\n\t\t * Create tagged hash, convert it to bigint, reduce modulo-n.\n\t\t */\n\t\tfunction challenge(...args) {\n\t\t    return modN(num(taggedHash('BIP0340/challenge', ...args)));\n\t\t}\n\t\t/**\n\t\t * Schnorr public key is just `x` coordinate of Point as per BIP340.\n\t\t */\n\t\tfunction schnorrGetPublicKey(privateKey) {\n\t\t    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n\t\t}\n\t\t/**\n\t\t * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n\t\t * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n\t\t */\n\t\tfunction schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\n\t\t    const m = (0, utils_js_1.ensureBytes)('message', message);\n\t\t    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n\t\t    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n\t\t    const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n\t\t    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n\t\t    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n\t\t    if (k_ === _0n)\n\t\t        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n\t\t    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n\t\t    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n\t\t    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n\t\t    sig.set(rx, 0);\n\t\t    sig.set(numTo32b(modN(k + e * d)), 32);\n\t\t    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n\t\t    if (!schnorrVerify(sig, m, px))\n\t\t        throw new Error('sign: Invalid signature produced');\n\t\t    return sig;\n\t\t}\n\t\t/**\n\t\t * Verifies Schnorr signature.\n\t\t * Will swallow errors & return false except for initial type validation of arguments.\n\t\t */\n\t\tfunction schnorrVerify(signature, message, publicKey) {\n\t\t    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);\n\t\t    const m = (0, utils_js_1.ensureBytes)('message', message);\n\t\t    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);\n\t\t    try {\n\t\t        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n\t\t        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n\t\t        if (!(0, utils_js_1.inRange)(r, _1n, secp256k1P))\n\t\t            return false;\n\t\t        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n\t\t        if (!(0, utils_js_1.inRange)(s, _1n, secp256k1N))\n\t\t            return false;\n\t\t        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n\t\t        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n\t\t        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n\t\t            return false; // -eP == (n-e)P\n\t\t        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n\t\t    }\n\t\t    catch (error) {\n\t\t        return false;\n\t\t    }\n\t\t}\n\t\t/**\n\t\t * Schnorr signatures over secp256k1.\n\t\t * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n\t\t * @example\n\t\t * import { schnorr } from '@noble/curves/secp256k1';\n\t\t * const priv = schnorr.utils.randomPrivateKey();\n\t\t * const pub = schnorr.getPublicKey(priv);\n\t\t * const msg = new TextEncoder().encode('hello');\n\t\t * const sig = schnorr.sign(msg, priv);\n\t\t * const isValid = schnorr.verify(sig, msg, pub);\n\t\t */\n\t\texports.schnorr = (() => ({\n\t\t    getPublicKey: schnorrGetPublicKey,\n\t\t    sign: schnorrSign,\n\t\t    verify: schnorrVerify,\n\t\t    utils: {\n\t\t        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\n\t\t        lift_x,\n\t\t        pointToBytes,\n\t\t        numberToBytesBE: utils_js_1.numberToBytesBE,\n\t\t        bytesToNumberBE: utils_js_1.bytesToNumberBE,\n\t\t        taggedHash,\n\t\t        mod: modular_js_1.mod,\n\t\t    },\n\t\t}))();\n\t\tconst isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fpk1, [\n\t\t    // xNum\n\t\t    [\n\t\t        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n\t\t        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n\t\t        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n\t\t        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n\t\t    ],\n\t\t    // xDen\n\t\t    [\n\t\t        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n\t\t        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n\t\t        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n\t\t    ],\n\t\t    // yNum\n\t\t    [\n\t\t        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n\t\t        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n\t\t        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n\t\t        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n\t\t    ],\n\t\t    // yDen\n\t\t    [\n\t\t        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n\t\t        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n\t\t        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n\t\t        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n\t\t    ],\n\t\t].map((i) => i.map((j) => BigInt(j)))))();\n\t\tconst mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fpk1, {\n\t\t    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n\t\t    B: BigInt('1771'),\n\t\t    Z: Fpk1.create(BigInt('-11')),\n\t\t}))();\n\t\tconst htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {\n\t\t    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n\t\t    return isoMap(x, y);\n\t\t}, {\n\t\t    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n\t\t    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n\t\t    p: Fpk1.ORDER,\n\t\t    m: 1,\n\t\t    k: 128,\n\t\t    expand: 'xmd',\n\t\t    hash: sha256_1.sha256,\n\t\t}))();\n\t\t/** secp256k1 hash-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\n\t\texports.hashToCurve = (() => htf.hashToCurve)();\n\t\t/** secp256k1 encode-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\n\t\texports.encodeToCurve = (() => htf.encodeToCurve)();\n\t\t\n\t} (secp256k1));\n\treturn secp256k1;\n}\n\nvar hex = {};\n\nvar hasRequiredHex;\n\nfunction requireHex () {\n\tif (hasRequiredHex) return hex;\n\thasRequiredHex = 1;\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.decodeHex = exports.remove0x = void 0;\n\t\tvar utils_1 = /*@__PURE__*/ requireUtils$3();\n\t\tvar remove0x = function (hex) {\n\t\t    return hex.startsWith(\"0x\") || hex.startsWith(\"0X\") ? hex.slice(2) : hex;\n\t\t};\n\t\texports.remove0x = remove0x;\n\t\tvar decodeHex = function (hex) { return (0, utils_1.hexToBytes)((0, exports.remove0x)(hex)); };\n\t\texports.decodeHex = decodeHex; \n\t} (hex));\n\treturn hex;\n}\n\nvar hasRequiredElliptic;\n\nfunction requireElliptic () {\n\tif (hasRequiredElliptic) return elliptic;\n\thasRequiredElliptic = 1;\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.hexToPublicKey = exports.convertPublicKeyFormat = exports.getSharedPoint = exports.getPublicKey = exports.isValidPrivateKey = exports.getValidSecret = void 0;\n\t\tvar webcrypto_1 = /*@__PURE__*/ requireWebcrypto();\n\t\tvar ed25519_1 = /*@__PURE__*/ requireEd25519();\n\t\tvar secp256k1_1 = /*@__PURE__*/ requireSecp256k1();\n\t\tvar config_1 = requireConfig();\n\t\tvar consts_1 = requireConsts();\n\t\tvar hex_1 = requireHex();\n\t\tvar getValidSecret = function () {\n\t\t    var key;\n\t\t    do {\n\t\t        key = (0, webcrypto_1.randomBytes)(consts_1.SECRET_KEY_LENGTH);\n\t\t    } while (!(0, exports.isValidPrivateKey)(key));\n\t\t    return key;\n\t\t};\n\t\texports.getValidSecret = getValidSecret;\n\t\tvar isValidPrivateKey = function (secret) {\n\t\t    // on secp256k1: only key  (0, group order) is valid\n\t\t    // on curve25519: any 32-byte key is valid\n\t\t    return _exec((0, config_1.ellipticCurve)(), function (curve) { return curve.utils.isValidPrivateKey(secret); }, function () { return true; }, function () { return true; });\n\t\t};\n\t\texports.isValidPrivateKey = isValidPrivateKey;\n\t\tvar getPublicKey = function (secret) {\n\t\t    return _exec((0, config_1.ellipticCurve)(), function (curve) { return curve.getPublicKey(secret); }, function (curve) { return curve.getPublicKey(secret); }, function (curve) { return curve.getPublicKey(secret); });\n\t\t};\n\t\texports.getPublicKey = getPublicKey;\n\t\tvar getSharedPoint = function (sk, pk, compressed) {\n\t\t    return _exec((0, config_1.ellipticCurve)(), function (curve) { return curve.getSharedSecret(sk, pk, compressed); }, function (curve) { return curve.getSharedSecret(sk, pk); }, function (curve) { return getSharedPointOnEd25519(curve, sk, pk); });\n\t\t};\n\t\texports.getSharedPoint = getSharedPoint;\n\t\tvar convertPublicKeyFormat = function (pk, compressed) {\n\t\t    // only for secp256k1\n\t\t    return _exec((0, config_1.ellipticCurve)(), function (curve) { return curve.getSharedSecret(BigInt(1), pk, compressed); }, function () { return pk; }, function () { return pk; });\n\t\t};\n\t\texports.convertPublicKeyFormat = convertPublicKeyFormat;\n\t\tvar hexToPublicKey = function (hex) {\n\t\t    var decoded = (0, hex_1.decodeHex)(hex);\n\t\t    return _exec((0, config_1.ellipticCurve)(), function () { return compatEthPublicKey(decoded); }, function () { return decoded; }, function () { return decoded; });\n\t\t};\n\t\texports.hexToPublicKey = hexToPublicKey;\n\t\tfunction _exec(curve, secp256k1Callback, x25519Callback, ed25519Callback) {\n\t\t    if (curve === \"secp256k1\") {\n\t\t        return secp256k1Callback(secp256k1_1.secp256k1);\n\t\t    }\n\t\t    else if (curve === \"x25519\") {\n\t\t        return x25519Callback(ed25519_1.x25519);\n\t\t    }\n\t\t    else if (curve === \"ed25519\") {\n\t\t        return ed25519Callback(ed25519_1.ed25519);\n\t\t    } /* v8 ignore next 2 */\n\t\t    else {\n\t\t        throw new Error(\"Not implemented\");\n\t\t    }\n\t\t}\n\t\tvar compatEthPublicKey = function (pk) {\n\t\t    if (pk.length === consts_1.ETH_PUBLIC_KEY_SIZE) {\n\t\t        var fixed = new Uint8Array(1 + pk.length);\n\t\t        fixed.set([0x04]);\n\t\t        fixed.set(pk, 1);\n\t\t        return fixed;\n\t\t    }\n\t\t    return pk;\n\t\t};\n\t\tvar getSharedPointOnEd25519 = function (curve, sk, pk) {\n\t\t    // Note: scalar is hashed from sk\n\t\t    var scalar = curve.utils.getExtendedPublicKey(sk).scalar;\n\t\t    var point = curve.ExtendedPoint.fromHex(pk).multiply(scalar);\n\t\t    return point.toRawBytes();\n\t\t}; \n\t} (elliptic));\n\treturn elliptic;\n}\n\nvar hash = {};\n\nvar hkdf = {};\n\nvar hasRequiredHkdf;\n\nfunction requireHkdf () {\n\tif (hasRequiredHkdf) return hkdf;\n\thasRequiredHkdf = 1;\n\tObject.defineProperty(hkdf, \"__esModule\", { value: true });\n\thkdf.hkdf = void 0;\n\thkdf.extract = extract;\n\thkdf.expand = expand;\n\t/**\n\t * HKDF (RFC 5869): extract + expand in one step.\n\t * See https://soatok.blog/2021/11/17/understanding-hkdf/.\n\t * @module\n\t */\n\tconst _assert_js_1 = /*@__PURE__*/ require_assert();\n\tconst hmac_js_1 = /*@__PURE__*/ requireHmac();\n\tconst utils_js_1 = /*@__PURE__*/ requireUtils$2();\n\t/**\n\t * HKDF-extract from spec. Less important part. `HKDF-Extract(IKM, salt) -> PRK`\n\t * Arguments position differs from spec (IKM is first one, since it is not optional)\n\t * @param hash - hash function that would be used (e.g. sha256)\n\t * @param ikm - input keying material, the initial key\n\t * @param salt - optional salt value (a non-secret random value)\n\t */\n\tfunction extract(hash, ikm, salt) {\n\t    (0, _assert_js_1.ahash)(hash);\n\t    // NOTE: some libraries treat zero-length array as 'not provided';\n\t    // we don't, since we have undefined as 'not provided'\n\t    // https://github.com/RustCrypto/KDFs/issues/15\n\t    if (salt === undefined)\n\t        salt = new Uint8Array(hash.outputLen);\n\t    return (0, hmac_js_1.hmac)(hash, (0, utils_js_1.toBytes)(salt), (0, utils_js_1.toBytes)(ikm));\n\t}\n\tconst HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);\n\tconst EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();\n\t/**\n\t * HKDF-expand from the spec. The most important part. `HKDF-Expand(PRK, info, L) -> OKM`\n\t * @param hash - hash function that would be used (e.g. sha256)\n\t * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n\t * @param info - optional context and application specific information (can be a zero-length string)\n\t * @param length - length of output keying material in bytes\n\t */\n\tfunction expand(hash, prk, info, length = 32) {\n\t    (0, _assert_js_1.ahash)(hash);\n\t    (0, _assert_js_1.anumber)(length);\n\t    if (length > 255 * hash.outputLen)\n\t        throw new Error('Length should be <= 255*HashLen');\n\t    const blocks = Math.ceil(length / hash.outputLen);\n\t    if (info === undefined)\n\t        info = EMPTY_BUFFER;\n\t    // first L(ength) octets of T\n\t    const okm = new Uint8Array(blocks * hash.outputLen);\n\t    // Re-use HMAC instance between blocks\n\t    const HMAC = hmac_js_1.hmac.create(hash, prk);\n\t    const HMACTmp = HMAC._cloneInto();\n\t    const T = new Uint8Array(HMAC.outputLen);\n\t    for (let counter = 0; counter < blocks; counter++) {\n\t        HKDF_COUNTER[0] = counter + 1;\n\t        // T(0) = empty string (zero length)\n\t        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n\t        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n\t            .update(info)\n\t            .update(HKDF_COUNTER)\n\t            .digestInto(T);\n\t        okm.set(T, hash.outputLen * counter);\n\t        HMAC._cloneInto(HMACTmp);\n\t    }\n\t    HMAC.destroy();\n\t    HMACTmp.destroy();\n\t    T.fill(0);\n\t    HKDF_COUNTER.fill(0);\n\t    return okm.slice(0, length);\n\t}\n\t/**\n\t * HKDF (RFC 5869): derive keys from an initial input.\n\t * Combines hkdf_extract + hkdf_expand in one step\n\t * @param hash - hash function that would be used (e.g. sha256)\n\t * @param ikm - input keying material, the initial key\n\t * @param salt - optional salt value (a non-secret random value)\n\t * @param info - optional context and application specific information (can be a zero-length string)\n\t * @param length - length of output keying material in bytes\n\t * @example\n\t * import { hkdf } from '@noble/hashes/hkdf';\n\t * import { sha256 } from '@noble/hashes/sha2';\n\t * import { randomBytes } from '@noble/hashes/utils';\n\t * const inputKey = randomBytes(32);\n\t * const salt = randomBytes(32);\n\t * const info = 'application-key';\n\t * const hk1 = hkdf(sha256, inputKey, salt, info, 32);\n\t */\n\tconst hkdf$1 = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);\n\thkdf.hkdf = hkdf$1;\n\t\n\treturn hkdf;\n}\n\nvar hasRequiredHash;\n\nfunction requireHash () {\n\tif (hasRequiredHash) return hash;\n\thasRequiredHash = 1;\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.getSharedKey = exports.deriveKey = void 0;\n\t\tvar utils_1 = /*@__PURE__*/ requireUtils$3();\n\t\tvar hkdf_1 = /*@__PURE__*/ requireHkdf();\n\t\tvar sha256_1 = /*@__PURE__*/ requireSha256();\n\t\tvar deriveKey = function (master, salt, info) {\n\t\t    // 32 bytes shared secret for aes256 and xchacha20 derived from HKDF-SHA256\n\t\t    return (0, hkdf_1.hkdf)(sha256_1.sha256, master, salt, info, 32);\n\t\t};\n\t\texports.deriveKey = deriveKey;\n\t\tvar getSharedKey = function () {\n\t\t    var parts = [];\n\t\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t\t        parts[_i] = arguments[_i];\n\t\t    }\n\t\t    return (0, exports.deriveKey)(utils_1.concatBytes.apply(void 0, parts));\n\t\t};\n\t\texports.getSharedKey = getSharedKey; \n\t} (hash));\n\treturn hash;\n}\n\nvar symmetric = {};\n\nvar noble$1 = {};\n\nvar aes = {};\n\nvar _polyval = {};\n\nvar hasRequired_polyval;\n\nfunction require_polyval () {\n\tif (hasRequired_polyval) return _polyval;\n\thasRequired_polyval = 1;\n\tObject.defineProperty(_polyval, \"__esModule\", { value: true });\n\t_polyval.polyval = _polyval.ghash = void 0;\n\t_polyval._toGHASHKey = _toGHASHKey;\n\t/**\n\t * GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n\t *\n\t * Implemented in terms of GHash with conversion function for keys\n\t * GCM GHASH from\n\t * [NIST SP800-38d](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf),\n\t * SIV from\n\t * [RFC 8452](https://datatracker.ietf.org/doc/html/rfc8452).\n\t *\n\t * GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n\t * POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\n\t *\n\t * @module\n\t */\n\tconst _assert_js_1 = /*@__PURE__*/ require_assert$1();\n\tconst utils_js_1 = /*@__PURE__*/ requireUtils$3();\n\tconst BLOCK_SIZE = 16;\n\t// TODO: rewrite\n\t// temporary padding buffer\n\tconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n\tconst ZEROS32 = (0, utils_js_1.u32)(ZEROS16);\n\tconst POLY = 0xe1; // v = 2*v % POLY\n\t// v = 2*v % POLY\n\t// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n\t// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\n\tconst mul2 = (s0, s1, s2, s3) => {\n\t    const hiBit = s3 & 1;\n\t    return {\n\t        s3: (s2 << 31) | (s3 >>> 1),\n\t        s2: (s1 << 31) | (s2 >>> 1),\n\t        s1: (s0 << 31) | (s1 >>> 1),\n\t        s0: (s0 >>> 1) ^ ((POLY << 24) & -(hiBit & 1)), // reduce % poly\n\t    };\n\t};\n\tconst swapLE = (n) => (((n >>> 0) & 0xff) << 24) |\n\t    (((n >>> 8) & 0xff) << 16) |\n\t    (((n >>> 16) & 0xff) << 8) |\n\t    ((n >>> 24) & 0xff) |\n\t    0;\n\t/**\n\t * `mulX_POLYVAL(ByteReverse(H))` from spec\n\t * @param k mutated in place\n\t */\n\tfunction _toGHASHKey(k) {\n\t    k.reverse();\n\t    const hiBit = k[15] & 1;\n\t    // k >>= 1\n\t    let carry = 0;\n\t    for (let i = 0; i < k.length; i++) {\n\t        const t = k[i];\n\t        k[i] = (t >>> 1) | carry;\n\t        carry = (t & 1) << 7;\n\t    }\n\t    k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n\t    return k;\n\t}\n\tconst estimateWindow = (bytes) => {\n\t    if (bytes > 64 * 1024)\n\t        return 8;\n\t    if (bytes > 1024)\n\t        return 4;\n\t    return 2;\n\t};\n\tclass GHASH {\n\t    // We select bits per window adaptively based on expectedLength\n\t    constructor(key, expectedLength) {\n\t        this.blockLen = BLOCK_SIZE;\n\t        this.outputLen = BLOCK_SIZE;\n\t        this.s0 = 0;\n\t        this.s1 = 0;\n\t        this.s2 = 0;\n\t        this.s3 = 0;\n\t        this.finished = false;\n\t        key = (0, utils_js_1.toBytes)(key);\n\t        (0, _assert_js_1.abytes)(key, 16);\n\t        const kView = (0, utils_js_1.createView)(key);\n\t        let k0 = kView.getUint32(0, false);\n\t        let k1 = kView.getUint32(4, false);\n\t        let k2 = kView.getUint32(8, false);\n\t        let k3 = kView.getUint32(12, false);\n\t        // generate table of doubled keys (half of montgomery ladder)\n\t        const doubles = [];\n\t        for (let i = 0; i < 128; i++) {\n\t            doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });\n\t            ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));\n\t        }\n\t        const W = estimateWindow(expectedLength || 1024);\n\t        if (![1, 2, 4, 8].includes(W))\n\t            throw new Error('ghash: invalid window size, expected 2, 4 or 8');\n\t        this.W = W;\n\t        const bits = 128; // always 128 bits;\n\t        const windows = bits / W;\n\t        const windowSize = (this.windowSize = 2 ** W);\n\t        const items = [];\n\t        // Create precompute table for window of W bits\n\t        for (let w = 0; w < windows; w++) {\n\t            // truth table: 00, 01, 10, 11\n\t            for (let byte = 0; byte < windowSize; byte++) {\n\t                // prettier-ignore\n\t                let s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n\t                for (let j = 0; j < W; j++) {\n\t                    const bit = (byte >>> (W - j - 1)) & 1;\n\t                    if (!bit)\n\t                        continue;\n\t                    const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];\n\t                    (s0 ^= d0), (s1 ^= d1), (s2 ^= d2), (s3 ^= d3);\n\t                }\n\t                items.push({ s0, s1, s2, s3 });\n\t            }\n\t        }\n\t        this.t = items;\n\t    }\n\t    _updateBlock(s0, s1, s2, s3) {\n\t        (s0 ^= this.s0), (s1 ^= this.s1), (s2 ^= this.s2), (s3 ^= this.s3);\n\t        const { W, t, windowSize } = this;\n\t        // prettier-ignore\n\t        let o0 = 0, o1 = 0, o2 = 0, o3 = 0;\n\t        const mask = (1 << W) - 1; // 2**W will kill performance.\n\t        let w = 0;\n\t        for (const num of [s0, s1, s2, s3]) {\n\t            for (let bytePos = 0; bytePos < 4; bytePos++) {\n\t                const byte = (num >>> (8 * bytePos)) & 0xff;\n\t                for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {\n\t                    const bit = (byte >>> (W * bitPos)) & mask;\n\t                    const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];\n\t                    (o0 ^= e0), (o1 ^= e1), (o2 ^= e2), (o3 ^= e3);\n\t                    w += 1;\n\t                }\n\t            }\n\t        }\n\t        this.s0 = o0;\n\t        this.s1 = o1;\n\t        this.s2 = o2;\n\t        this.s3 = o3;\n\t    }\n\t    update(data) {\n\t        data = (0, utils_js_1.toBytes)(data);\n\t        (0, _assert_js_1.aexists)(this);\n\t        const b32 = (0, utils_js_1.u32)(data);\n\t        const blocks = Math.floor(data.length / BLOCK_SIZE);\n\t        const left = data.length % BLOCK_SIZE;\n\t        for (let i = 0; i < blocks; i++) {\n\t            this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n\t        }\n\t        if (left) {\n\t            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n\t            this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);\n\t            (0, utils_js_1.clean)(ZEROS32); // clean tmp buffer\n\t        }\n\t        return this;\n\t    }\n\t    destroy() {\n\t        const { t } = this;\n\t        // clean precompute table\n\t        for (const elm of t) {\n\t            (elm.s0 = 0), (elm.s1 = 0), (elm.s2 = 0), (elm.s3 = 0);\n\t        }\n\t    }\n\t    digestInto(out) {\n\t        (0, _assert_js_1.aexists)(this);\n\t        (0, _assert_js_1.aoutput)(out, this);\n\t        this.finished = true;\n\t        const { s0, s1, s2, s3 } = this;\n\t        const o32 = (0, utils_js_1.u32)(out);\n\t        o32[0] = s0;\n\t        o32[1] = s1;\n\t        o32[2] = s2;\n\t        o32[3] = s3;\n\t        return out;\n\t    }\n\t    digest() {\n\t        const res = new Uint8Array(BLOCK_SIZE);\n\t        this.digestInto(res);\n\t        this.destroy();\n\t        return res;\n\t    }\n\t}\n\tclass Polyval extends GHASH {\n\t    constructor(key, expectedLength) {\n\t        key = (0, utils_js_1.toBytes)(key);\n\t        const ghKey = _toGHASHKey((0, utils_js_1.copyBytes)(key));\n\t        super(ghKey, expectedLength);\n\t        (0, utils_js_1.clean)(ghKey);\n\t    }\n\t    update(data) {\n\t        data = (0, utils_js_1.toBytes)(data);\n\t        (0, _assert_js_1.aexists)(this);\n\t        const b32 = (0, utils_js_1.u32)(data);\n\t        const left = data.length % BLOCK_SIZE;\n\t        const blocks = Math.floor(data.length / BLOCK_SIZE);\n\t        for (let i = 0; i < blocks; i++) {\n\t            this._updateBlock(swapLE(b32[i * 4 + 3]), swapLE(b32[i * 4 + 2]), swapLE(b32[i * 4 + 1]), swapLE(b32[i * 4 + 0]));\n\t        }\n\t        if (left) {\n\t            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n\t            this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));\n\t            (0, utils_js_1.clean)(ZEROS32);\n\t        }\n\t        return this;\n\t    }\n\t    digestInto(out) {\n\t        (0, _assert_js_1.aexists)(this);\n\t        (0, _assert_js_1.aoutput)(out, this);\n\t        this.finished = true;\n\t        // tmp ugly hack\n\t        const { s0, s1, s2, s3 } = this;\n\t        const o32 = (0, utils_js_1.u32)(out);\n\t        o32[0] = s0;\n\t        o32[1] = s1;\n\t        o32[2] = s2;\n\t        o32[3] = s3;\n\t        return out.reverse();\n\t    }\n\t}\n\tfunction wrapConstructorWithKey(hashCons) {\n\t    const hashC = (msg, key) => hashCons(key, msg.length).update((0, utils_js_1.toBytes)(msg)).digest();\n\t    const tmp = hashCons(new Uint8Array(16), 0);\n\t    hashC.outputLen = tmp.outputLen;\n\t    hashC.blockLen = tmp.blockLen;\n\t    hashC.create = (key, expectedLength) => hashCons(key, expectedLength);\n\t    return hashC;\n\t}\n\t/** GHash MAC for AES-GCM. */\n\t_polyval.ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));\n\t/** Polyval MAC for AES-SIV. */\n\t_polyval.polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));\n\t\n\treturn _polyval;\n}\n\nvar hasRequiredAes;\n\nfunction requireAes () {\n\tif (hasRequiredAes) return aes;\n\thasRequiredAes = 1;\n\tObject.defineProperty(aes, \"__esModule\", { value: true });\n\taes.unsafe = aes.aeskwp = aes.aeskw = aes.siv = aes.gcm = aes.cfb = aes.cbc = aes.ecb = aes.ctr = void 0;\n\t/**\n\t * [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n\t * a.k.a. Advanced Encryption Standard\n\t * is a variant of Rijndael block cipher, standardized by NIST in 2001.\n\t * We provide the fastest available pure JS implementation.\n\t *\n\t * Data is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256 bits). In every round:\n\t * 1. **S-box**, table substitution\n\t * 2. **Shift rows**, cyclic shift left of all rows of data array\n\t * 3. **Mix columns**, multiplying every column by fixed polynomial\n\t * 4. **Add round key**, round_key xor i-th column of array\n\t *\n\t * Check out [FIPS-197](https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf)\n\t * and [original proposal](https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf)\n\t * @module\n\t */\n\tconst _assert_js_1 = /*@__PURE__*/ require_assert$1();\n\tconst _polyval_js_1 = /*@__PURE__*/ require_polyval();\n\tconst utils_js_1 = /*@__PURE__*/ requireUtils$3();\n\tconst BLOCK_SIZE = 16;\n\tconst BLOCK_SIZE32 = 4;\n\tconst EMPTY_BLOCK = /* @__PURE__ */ new Uint8Array(BLOCK_SIZE);\n\tconst POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n\t// TODO: remove multiplication, binary ops only\n\tfunction mul2(n) {\n\t    return (n << 1) ^ (POLY & -(n >> 7));\n\t}\n\tfunction mul(a, b) {\n\t    let res = 0;\n\t    for (; b > 0; b >>= 1) {\n\t        // Montgomery ladder\n\t        res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n\t        a = mul2(a); // a = 2*a\n\t    }\n\t    return res;\n\t}\n\t// AES S-box is generated using finite field inversion,\n\t// an affine transform, and xor of a constant 0x63.\n\tconst sbox = /* @__PURE__ */ (() => {\n\t    const t = new Uint8Array(256);\n\t    for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x))\n\t        t[i] = x;\n\t    const box = new Uint8Array(256);\n\t    box[0] = 0x63; // first elm\n\t    for (let i = 0; i < 255; i++) {\n\t        let x = t[255 - i];\n\t        x |= x << 8;\n\t        box[t[i]] = (x ^ (x >> 4) ^ (x >> 5) ^ (x >> 6) ^ (x >> 7) ^ 0x63) & 0xff;\n\t    }\n\t    (0, utils_js_1.clean)(t);\n\t    return box;\n\t})();\n\t// Inverted S-box\n\tconst invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));\n\t// Rotate u32 by 8\n\tconst rotr32_8 = (n) => (n << 24) | (n >>> 8);\n\tconst rotl32_8 = (n) => (n << 8) | (n >>> 24);\n\t// The byte swap operation for uint32 (LE<->BE)\n\tconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n\t    ((word << 8) & 0xff0000) |\n\t    ((word >>> 8) & 0xff00) |\n\t    ((word >>> 24) & 0xff);\n\t// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n\t// - LE instead of BE\n\t// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n\t//   so index is u16, instead of u8. This speeds up things, unexpectedly\n\tfunction genTtable(sbox, fn) {\n\t    if (sbox.length !== 256)\n\t        throw new Error('Wrong sbox length');\n\t    const T0 = new Uint32Array(256).map((_, j) => fn(sbox[j]));\n\t    const T1 = T0.map(rotl32_8);\n\t    const T2 = T1.map(rotl32_8);\n\t    const T3 = T2.map(rotl32_8);\n\t    const T01 = new Uint32Array(256 * 256);\n\t    const T23 = new Uint32Array(256 * 256);\n\t    const sbox2 = new Uint16Array(256 * 256);\n\t    for (let i = 0; i < 256; i++) {\n\t        for (let j = 0; j < 256; j++) {\n\t            const idx = i * 256 + j;\n\t            T01[idx] = T0[i] ^ T1[j];\n\t            T23[idx] = T2[i] ^ T3[j];\n\t            sbox2[idx] = (sbox[i] << 8) | sbox[j];\n\t        }\n\t    }\n\t    return { sbox, sbox2, T0, T1, T2, T3, T01, T23 };\n\t}\n\tconst tableEncoding = /* @__PURE__ */ genTtable(sbox, (s) => (mul(s, 3) << 24) | (s << 16) | (s << 8) | mul(s, 2));\n\tconst tableDecoding = /* @__PURE__ */ genTtable(invSbox, (s) => (mul(s, 11) << 24) | (mul(s, 13) << 16) | (mul(s, 9) << 8) | mul(s, 14));\n\tconst xPowers = /* @__PURE__ */ (() => {\n\t    const p = new Uint8Array(16);\n\t    for (let i = 0, x = 1; i < 16; i++, x = mul2(x))\n\t        p[i] = x;\n\t    return p;\n\t})();\n\t/** Key expansion used in CTR. */\n\tfunction expandKeyLE(key) {\n\t    (0, _assert_js_1.abytes)(key);\n\t    const len = key.length;\n\t    if (![16, 24, 32].includes(len))\n\t        throw new Error('aes: invalid key size, should be 16, 24 or 32, got ' + len);\n\t    const { sbox2 } = tableEncoding;\n\t    const toClean = [];\n\t    if (!(0, utils_js_1.isAligned32)(key))\n\t        toClean.push((key = (0, utils_js_1.copyBytes)(key)));\n\t    const k32 = (0, utils_js_1.u32)(key);\n\t    const Nk = k32.length;\n\t    const subByte = (n) => applySbox(sbox2, n, n, n, n);\n\t    const xk = new Uint32Array(len + 28); // expanded key\n\t    xk.set(k32);\n\t    // 4.3.1 Key expansion\n\t    for (let i = Nk; i < xk.length; i++) {\n\t        let t = xk[i - 1];\n\t        if (i % Nk === 0)\n\t            t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];\n\t        else if (Nk > 6 && i % Nk === 4)\n\t            t = subByte(t);\n\t        xk[i] = xk[i - Nk] ^ t;\n\t    }\n\t    (0, utils_js_1.clean)(...toClean);\n\t    return xk;\n\t}\n\tfunction expandKeyDecLE(key) {\n\t    const encKey = expandKeyLE(key);\n\t    const xk = encKey.slice();\n\t    const Nk = encKey.length;\n\t    const { sbox2 } = tableEncoding;\n\t    const { T0, T1, T2, T3 } = tableDecoding;\n\t    // Inverse key by chunks of 4 (rounds)\n\t    for (let i = 0; i < Nk; i += 4) {\n\t        for (let j = 0; j < 4; j++)\n\t            xk[i + j] = encKey[Nk - i - 4 + j];\n\t    }\n\t    (0, utils_js_1.clean)(encKey);\n\t    // apply InvMixColumn except first & last round\n\t    for (let i = 4; i < Nk - 4; i++) {\n\t        const x = xk[i];\n\t        const w = applySbox(sbox2, x, x, x, x);\n\t        xk[i] = T0[w & 0xff] ^ T1[(w >>> 8) & 0xff] ^ T2[(w >>> 16) & 0xff] ^ T3[w >>> 24];\n\t    }\n\t    return xk;\n\t}\n\t// Apply tables\n\tfunction apply0123(T01, T23, s0, s1, s2, s3) {\n\t    return (T01[((s0 << 8) & 0xff00) | ((s1 >>> 8) & 0xff)] ^\n\t        T23[((s2 >>> 8) & 0xff00) | ((s3 >>> 24) & 0xff)]);\n\t}\n\tfunction applySbox(sbox2, s0, s1, s2, s3) {\n\t    return (sbox2[(s0 & 0xff) | (s1 & 0xff00)] |\n\t        (sbox2[((s2 >>> 16) & 0xff) | ((s3 >>> 16) & 0xff00)] << 16));\n\t}\n\tfunction encrypt(xk, s0, s1, s2, s3) {\n\t    const { sbox2, T01, T23 } = tableEncoding;\n\t    let k = 0;\n\t    (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n\t    const rounds = xk.length / 4 - 2;\n\t    for (let i = 0; i < rounds; i++) {\n\t        const t0 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);\n\t        const t1 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);\n\t        const t2 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);\n\t        const t3 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);\n\t        (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n\t    }\n\t    // last round (without mixcolumns, so using SBOX2 table)\n\t    const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);\n\t    const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);\n\t    const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);\n\t    const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);\n\t    return { s0: t0, s1: t1, s2: t2, s3: t3 };\n\t}\n\t// Can't be merged with encrypt: arg positions for apply0123 / applySbox are different\n\tfunction decrypt(xk, s0, s1, s2, s3) {\n\t    const { sbox2, T01, T23 } = tableDecoding;\n\t    let k = 0;\n\t    (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n\t    const rounds = xk.length / 4 - 2;\n\t    for (let i = 0; i < rounds; i++) {\n\t        const t0 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);\n\t        const t1 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);\n\t        const t2 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);\n\t        const t3 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);\n\t        (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n\t    }\n\t    // Last round\n\t    const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);\n\t    const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);\n\t    const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);\n\t    const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);\n\t    return { s0: t0, s1: t1, s2: t2, s3: t3 };\n\t}\n\t// TODO: investigate merging with ctr32\n\tfunction ctrCounter(xk, nonce, src, dst) {\n\t    (0, _assert_js_1.abytes)(nonce, BLOCK_SIZE);\n\t    (0, _assert_js_1.abytes)(src);\n\t    const srcLen = src.length;\n\t    dst = (0, utils_js_1.getOutput)(srcLen, dst);\n\t    (0, utils_js_1.complexOverlapBytes)(src, dst);\n\t    const ctr = nonce;\n\t    const c32 = (0, utils_js_1.u32)(ctr);\n\t    // Fill block (empty, ctr=0)\n\t    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n\t    const src32 = (0, utils_js_1.u32)(src);\n\t    const dst32 = (0, utils_js_1.u32)(dst);\n\t    // process blocks\n\t    for (let i = 0; i + 4 <= src32.length; i += 4) {\n\t        dst32[i + 0] = src32[i + 0] ^ s0;\n\t        dst32[i + 1] = src32[i + 1] ^ s1;\n\t        dst32[i + 2] = src32[i + 2] ^ s2;\n\t        dst32[i + 3] = src32[i + 3] ^ s3;\n\t        // Full 128 bit counter with wrap around\n\t        let carry = 1;\n\t        for (let i = ctr.length - 1; i >= 0; i--) {\n\t            carry = (carry + (ctr[i] & 0xff)) | 0;\n\t            ctr[i] = carry & 0xff;\n\t            carry >>>= 8;\n\t        }\n\t        ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n\t    }\n\t    // leftovers (less than block)\n\t    // It's possible to handle > u32 fast, but is it worth it?\n\t    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n\t    if (start < srcLen) {\n\t        const b32 = new Uint32Array([s0, s1, s2, s3]);\n\t        const buf = (0, utils_js_1.u8)(b32);\n\t        for (let i = start, pos = 0; i < srcLen; i++, pos++)\n\t            dst[i] = src[i] ^ buf[pos];\n\t        (0, utils_js_1.clean)(b32);\n\t    }\n\t    return dst;\n\t}\n\t// AES CTR with overflowing 32 bit counter\n\t// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n\t// But, we need both, and perf bottleneck is in ghash anyway.\n\tfunction ctr32(xk, isLE, nonce, src, dst) {\n\t    (0, _assert_js_1.abytes)(nonce, BLOCK_SIZE);\n\t    (0, _assert_js_1.abytes)(src);\n\t    dst = (0, utils_js_1.getOutput)(src.length, dst);\n\t    const ctr = nonce; // write new value to nonce, so it can be re-used\n\t    const c32 = (0, utils_js_1.u32)(ctr);\n\t    const view = (0, utils_js_1.createView)(ctr);\n\t    const src32 = (0, utils_js_1.u32)(src);\n\t    const dst32 = (0, utils_js_1.u32)(dst);\n\t    const ctrPos = isLE ? 0 : 12;\n\t    const srcLen = src.length;\n\t    // Fill block (empty, ctr=0)\n\t    let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n\t    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n\t    // process blocks\n\t    for (let i = 0; i + 4 <= src32.length; i += 4) {\n\t        dst32[i + 0] = src32[i + 0] ^ s0;\n\t        dst32[i + 1] = src32[i + 1] ^ s1;\n\t        dst32[i + 2] = src32[i + 2] ^ s2;\n\t        dst32[i + 3] = src32[i + 3] ^ s3;\n\t        ctrNum = (ctrNum + 1) >>> 0; // u32 wrap\n\t        view.setUint32(ctrPos, ctrNum, isLE);\n\t        ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n\t    }\n\t    // leftovers (less than a block)\n\t    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n\t    if (start < srcLen) {\n\t        const b32 = new Uint32Array([s0, s1, s2, s3]);\n\t        const buf = (0, utils_js_1.u8)(b32);\n\t        for (let i = start, pos = 0; i < srcLen; i++, pos++)\n\t            dst[i] = src[i] ^ buf[pos];\n\t        (0, utils_js_1.clean)(b32);\n\t    }\n\t    return dst;\n\t}\n\t/**\n\t * CTR: counter mode. Creates stream cipher.\n\t * Requires good IV. Parallelizable. OK, but no MAC.\n\t */\n\taes.ctr = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function aesctr(key, nonce) {\n\t    function processCtr(buf, dst) {\n\t        (0, _assert_js_1.abytes)(buf);\n\t        if (dst !== undefined) {\n\t            (0, _assert_js_1.abytes)(dst);\n\t            if (!(0, utils_js_1.isAligned32)(dst))\n\t                throw new Error('unaligned destination');\n\t        }\n\t        const xk = expandKeyLE(key);\n\t        const n = (0, utils_js_1.copyBytes)(nonce); // align + avoid changing\n\t        const toClean = [xk, n];\n\t        if (!(0, utils_js_1.isAligned32)(buf))\n\t            toClean.push((buf = (0, utils_js_1.copyBytes)(buf)));\n\t        const out = ctrCounter(xk, n, buf, dst);\n\t        (0, utils_js_1.clean)(...toClean);\n\t        return out;\n\t    }\n\t    return {\n\t        encrypt: (plaintext, dst) => processCtr(plaintext, dst),\n\t        decrypt: (ciphertext, dst) => processCtr(ciphertext, dst),\n\t    };\n\t});\n\tfunction validateBlockDecrypt(data) {\n\t    (0, _assert_js_1.abytes)(data);\n\t    if (data.length % BLOCK_SIZE !== 0) {\n\t        throw new Error('aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size ' + BLOCK_SIZE);\n\t    }\n\t}\n\tfunction validateBlockEncrypt(plaintext, pcks5, dst) {\n\t    (0, _assert_js_1.abytes)(plaintext);\n\t    let outLen = plaintext.length;\n\t    const remaining = outLen % BLOCK_SIZE;\n\t    if (!pcks5 && remaining !== 0)\n\t        throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n\t    if (!(0, utils_js_1.isAligned32)(plaintext))\n\t        plaintext = (0, utils_js_1.copyBytes)(plaintext);\n\t    const b = (0, utils_js_1.u32)(plaintext);\n\t    if (pcks5) {\n\t        let left = BLOCK_SIZE - remaining;\n\t        if (!left)\n\t            left = BLOCK_SIZE; // if no bytes left, create empty padding block\n\t        outLen = outLen + left;\n\t    }\n\t    dst = (0, utils_js_1.getOutput)(outLen, dst);\n\t    (0, utils_js_1.complexOverlapBytes)(plaintext, dst);\n\t    const o = (0, utils_js_1.u32)(dst);\n\t    return { b, o, out: dst };\n\t}\n\tfunction validatePCKS(data, pcks5) {\n\t    if (!pcks5)\n\t        return data;\n\t    const len = data.length;\n\t    if (!len)\n\t        throw new Error('aes/pcks5: empty ciphertext not allowed');\n\t    const lastByte = data[len - 1];\n\t    if (lastByte <= 0 || lastByte > 16)\n\t        throw new Error('aes/pcks5: wrong padding');\n\t    const out = data.subarray(0, -lastByte);\n\t    for (let i = 0; i < lastByte; i++)\n\t        if (data[len - i - 1] !== lastByte)\n\t            throw new Error('aes/pcks5: wrong padding');\n\t    return out;\n\t}\n\tfunction padPCKS(left) {\n\t    const tmp = new Uint8Array(16);\n\t    const tmp32 = (0, utils_js_1.u32)(tmp);\n\t    tmp.set(left);\n\t    const paddingByte = BLOCK_SIZE - left.length;\n\t    for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++)\n\t        tmp[i] = paddingByte;\n\t    return tmp32;\n\t}\n\t/**\n\t * ECB: Electronic CodeBook. Simple deterministic replacement.\n\t * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n\t */\n\taes.ecb = (0, utils_js_1.wrapCipher)({ blockSize: 16 }, function aesecb(key, opts = {}) {\n\t    const pcks5 = !opts.disablePadding;\n\t    return {\n\t        encrypt(plaintext, dst) {\n\t            const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n\t            const xk = expandKeyLE(key);\n\t            let i = 0;\n\t            for (; i + 4 <= b.length;) {\n\t                const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n\t                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n\t            }\n\t            if (pcks5) {\n\t                const tmp32 = padPCKS(plaintext.subarray(i * 4));\n\t                const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n\t                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n\t            }\n\t            (0, utils_js_1.clean)(xk);\n\t            return _out;\n\t        },\n\t        decrypt(ciphertext, dst) {\n\t            validateBlockDecrypt(ciphertext);\n\t            const xk = expandKeyDecLE(key);\n\t            dst = (0, utils_js_1.getOutput)(ciphertext.length, dst);\n\t            const toClean = [xk];\n\t            if (!(0, utils_js_1.isAligned32)(ciphertext))\n\t                toClean.push((ciphertext = (0, utils_js_1.copyBytes)(ciphertext)));\n\t            (0, utils_js_1.complexOverlapBytes)(ciphertext, dst);\n\t            const b = (0, utils_js_1.u32)(ciphertext);\n\t            const o = (0, utils_js_1.u32)(dst);\n\t            for (let i = 0; i + 4 <= b.length;) {\n\t                const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n\t                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n\t            }\n\t            (0, utils_js_1.clean)(...toClean);\n\t            return validatePCKS(dst, pcks5);\n\t        },\n\t    };\n\t});\n\t/**\n\t * CBC: Cipher-Block-Chaining. Key is previous rounds block.\n\t * Fragile: needs proper padding. Unauthenticated: needs MAC.\n\t */\n\taes.cbc = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function aescbc(key, iv, opts = {}) {\n\t    const pcks5 = !opts.disablePadding;\n\t    return {\n\t        encrypt(plaintext, dst) {\n\t            const xk = expandKeyLE(key);\n\t            const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n\t            let _iv = iv;\n\t            const toClean = [xk];\n\t            if (!(0, utils_js_1.isAligned32)(_iv))\n\t                toClean.push((_iv = (0, utils_js_1.copyBytes)(_iv)));\n\t            const n32 = (0, utils_js_1.u32)(_iv);\n\t            // prettier-ignore\n\t            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n\t            let i = 0;\n\t            for (; i + 4 <= b.length;) {\n\t                (s0 ^= b[i + 0]), (s1 ^= b[i + 1]), (s2 ^= b[i + 2]), (s3 ^= b[i + 3]);\n\t                ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n\t                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n\t            }\n\t            if (pcks5) {\n\t                const tmp32 = padPCKS(plaintext.subarray(i * 4));\n\t                (s0 ^= tmp32[0]), (s1 ^= tmp32[1]), (s2 ^= tmp32[2]), (s3 ^= tmp32[3]);\n\t                ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n\t                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n\t            }\n\t            (0, utils_js_1.clean)(...toClean);\n\t            return _out;\n\t        },\n\t        decrypt(ciphertext, dst) {\n\t            validateBlockDecrypt(ciphertext);\n\t            const xk = expandKeyDecLE(key);\n\t            let _iv = iv;\n\t            const toClean = [xk];\n\t            if (!(0, utils_js_1.isAligned32)(_iv))\n\t                toClean.push((_iv = (0, utils_js_1.copyBytes)(_iv)));\n\t            const n32 = (0, utils_js_1.u32)(_iv);\n\t            dst = (0, utils_js_1.getOutput)(ciphertext.length, dst);\n\t            if (!(0, utils_js_1.isAligned32)(ciphertext))\n\t                toClean.push((ciphertext = (0, utils_js_1.copyBytes)(ciphertext)));\n\t            (0, utils_js_1.complexOverlapBytes)(ciphertext, dst);\n\t            const b = (0, utils_js_1.u32)(ciphertext);\n\t            const o = (0, utils_js_1.u32)(dst);\n\t            // prettier-ignore\n\t            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n\t            for (let i = 0; i + 4 <= b.length;) {\n\t                // prettier-ignore\n\t                const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;\n\t                (s0 = b[i + 0]), (s1 = b[i + 1]), (s2 = b[i + 2]), (s3 = b[i + 3]);\n\t                const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);\n\t                (o[i++] = o0 ^ ps0), (o[i++] = o1 ^ ps1), (o[i++] = o2 ^ ps2), (o[i++] = o3 ^ ps3);\n\t            }\n\t            (0, utils_js_1.clean)(...toClean);\n\t            return validatePCKS(dst, pcks5);\n\t        },\n\t    };\n\t});\n\t/**\n\t * CFB: Cipher Feedback Mode. The input for the block cipher is the previous cipher output.\n\t * Unauthenticated: needs MAC.\n\t */\n\taes.cfb = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function aescfb(key, iv) {\n\t    function processCfb(src, isEncrypt, dst) {\n\t        (0, _assert_js_1.abytes)(src);\n\t        const srcLen = src.length;\n\t        dst = (0, utils_js_1.getOutput)(srcLen, dst);\n\t        if ((0, utils_js_1.overlapBytes)(src, dst))\n\t            throw new Error('overlapping src and dst not supported.');\n\t        const xk = expandKeyLE(key);\n\t        let _iv = iv;\n\t        const toClean = [xk];\n\t        if (!(0, utils_js_1.isAligned32)(_iv))\n\t            toClean.push((_iv = (0, utils_js_1.copyBytes)(_iv)));\n\t        if (!(0, utils_js_1.isAligned32)(src))\n\t            toClean.push((src = (0, utils_js_1.copyBytes)(src)));\n\t        const src32 = (0, utils_js_1.u32)(src);\n\t        const dst32 = (0, utils_js_1.u32)(dst);\n\t        const next32 = isEncrypt ? dst32 : src32;\n\t        const n32 = (0, utils_js_1.u32)(_iv);\n\t        // prettier-ignore\n\t        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n\t        for (let i = 0; i + 4 <= src32.length;) {\n\t            const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt(xk, s0, s1, s2, s3);\n\t            dst32[i + 0] = src32[i + 0] ^ e0;\n\t            dst32[i + 1] = src32[i + 1] ^ e1;\n\t            dst32[i + 2] = src32[i + 2] ^ e2;\n\t            dst32[i + 3] = src32[i + 3] ^ e3;\n\t            (s0 = next32[i++]), (s1 = next32[i++]), (s2 = next32[i++]), (s3 = next32[i++]);\n\t        }\n\t        // leftovers (less than block)\n\t        const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n\t        if (start < srcLen) {\n\t            ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n\t            const buf = (0, utils_js_1.u8)(new Uint32Array([s0, s1, s2, s3]));\n\t            for (let i = start, pos = 0; i < srcLen; i++, pos++)\n\t                dst[i] = src[i] ^ buf[pos];\n\t            (0, utils_js_1.clean)(buf);\n\t        }\n\t        (0, utils_js_1.clean)(...toClean);\n\t        return dst;\n\t    }\n\t    return {\n\t        encrypt: (plaintext, dst) => processCfb(plaintext, true, dst),\n\t        decrypt: (ciphertext, dst) => processCfb(ciphertext, false, dst),\n\t    };\n\t});\n\t// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\n\tfunction computeTag(fn, isLE, key, data, AAD) {\n\t    const aadLength = AAD == null ? 0 : AAD.length;\n\t    const h = fn.create(key, data.length + aadLength);\n\t    if (AAD)\n\t        h.update(AAD);\n\t    h.update(data);\n\t    const num = new Uint8Array(16);\n\t    const view = (0, utils_js_1.createView)(num);\n\t    if (AAD)\n\t        (0, utils_js_1.setBigUint64)(view, 0, BigInt(aadLength * 8), isLE);\n\t    (0, utils_js_1.setBigUint64)(view, 8, BigInt(data.length * 8), isLE);\n\t    h.update(num);\n\t    const res = h.digest();\n\t    (0, utils_js_1.clean)(num);\n\t    return res;\n\t}\n\t/**\n\t * GCM: Galois/Counter Mode.\n\t * Modern, parallel version of CTR, with MAC.\n\t * Be careful: MACs can be forged.\n\t * Unsafe to use random nonces under the same key, due to collision chance.\n\t * As for nonce size, prefer 12-byte, instead of 8-byte.\n\t */\n\taes.gcm = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true }, function aesgcm(key, nonce, AAD) {\n\t    // NIST 800-38d doesn't enforce minimum nonce length.\n\t    // We enforce 8 bytes for compat with openssl.\n\t    // 12 bytes are recommended. More than 12 bytes would be converted into 12.\n\t    if (nonce.length < 8)\n\t        throw new Error('aes/gcm: invalid nonce length');\n\t    const tagLength = 16;\n\t    function _computeTag(authKey, tagMask, data) {\n\t        const tag = computeTag(_polyval_js_1.ghash, false, authKey, data, AAD);\n\t        for (let i = 0; i < tagMask.length; i++)\n\t            tag[i] ^= tagMask[i];\n\t        return tag;\n\t    }\n\t    function deriveKeys() {\n\t        const xk = expandKeyLE(key);\n\t        const authKey = EMPTY_BLOCK.slice();\n\t        const counter = EMPTY_BLOCK.slice();\n\t        ctr32(xk, false, counter, counter, authKey);\n\t        // NIST 800-38d, page 15: different behavior for 96-bit and non-96-bit nonces\n\t        if (nonce.length === 12) {\n\t            counter.set(nonce);\n\t        }\n\t        else {\n\t            const nonceLen = EMPTY_BLOCK.slice();\n\t            const view = (0, utils_js_1.createView)(nonceLen);\n\t            (0, utils_js_1.setBigUint64)(view, 8, BigInt(nonce.length * 8), false);\n\t            // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n\t            const g = _polyval_js_1.ghash.create(authKey).update(nonce).update(nonceLen);\n\t            g.digestInto(counter); // digestInto doesn't trigger '.destroy'\n\t            g.destroy();\n\t        }\n\t        const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);\n\t        return { xk, authKey, counter, tagMask };\n\t    }\n\t    return {\n\t        encrypt(plaintext) {\n\t            const { xk, authKey, counter, tagMask } = deriveKeys();\n\t            const out = new Uint8Array(plaintext.length + tagLength);\n\t            const toClean = [xk, authKey, counter, tagMask];\n\t            if (!(0, utils_js_1.isAligned32)(plaintext))\n\t                toClean.push((plaintext = (0, utils_js_1.copyBytes)(plaintext)));\n\t            ctr32(xk, false, counter, plaintext, out.subarray(0, plaintext.length));\n\t            const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n\t            toClean.push(tag);\n\t            out.set(tag, plaintext.length);\n\t            (0, utils_js_1.clean)(...toClean);\n\t            return out;\n\t        },\n\t        decrypt(ciphertext) {\n\t            const { xk, authKey, counter, tagMask } = deriveKeys();\n\t            const toClean = [xk, authKey, tagMask, counter];\n\t            if (!(0, utils_js_1.isAligned32)(ciphertext))\n\t                toClean.push((ciphertext = (0, utils_js_1.copyBytes)(ciphertext)));\n\t            const data = ciphertext.subarray(0, -tagLength);\n\t            const passedTag = ciphertext.subarray(-tagLength);\n\t            const tag = _computeTag(authKey, tagMask, data);\n\t            toClean.push(tag);\n\t            if (!(0, utils_js_1.equalBytes)(tag, passedTag))\n\t                throw new Error('aes/gcm: invalid ghash tag');\n\t            const out = ctr32(xk, false, counter, data);\n\t            (0, utils_js_1.clean)(...toClean);\n\t            return out;\n\t        },\n\t    };\n\t});\n\tconst limit = (name, min, max) => (value) => {\n\t    if (!Number.isSafeInteger(value) || min > value || value > max) {\n\t        const minmax = '[' + min + '..' + max + ']';\n\t        throw new Error('' + name + ': expected value in range ' + minmax + ', got ' + value);\n\t    }\n\t};\n\t/**\n\t * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n\t * Guarantees that, when a nonce is repeated, the only security loss is that identical\n\t * plaintexts will produce identical ciphertexts.\n\t * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n\t */\n\taes.siv = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true }, function aessiv(key, nonce, AAD) {\n\t    const tagLength = 16;\n\t    // From RFC 8452: Section 6\n\t    const AAD_LIMIT = limit('AAD', 0, 2 ** 36);\n\t    const PLAIN_LIMIT = limit('plaintext', 0, 2 ** 36);\n\t    const NONCE_LIMIT = limit('nonce', 12, 12);\n\t    const CIPHER_LIMIT = limit('ciphertext', 16, 2 ** 36 + 16);\n\t    (0, _assert_js_1.abytes)(key, 16, 24, 32);\n\t    NONCE_LIMIT(nonce.length);\n\t    if (AAD !== undefined)\n\t        AAD_LIMIT(AAD.length);\n\t    function deriveKeys() {\n\t        const xk = expandKeyLE(key);\n\t        const encKey = new Uint8Array(key.length);\n\t        const authKey = new Uint8Array(16);\n\t        const toClean = [xk, encKey];\n\t        let _nonce = nonce;\n\t        if (!(0, utils_js_1.isAligned32)(_nonce))\n\t            toClean.push((_nonce = (0, utils_js_1.copyBytes)(_nonce)));\n\t        const n32 = (0, utils_js_1.u32)(_nonce);\n\t        // prettier-ignore\n\t        let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];\n\t        let counter = 0;\n\t        for (const derivedKey of [authKey, encKey].map(utils_js_1.u32)) {\n\t            const d32 = (0, utils_js_1.u32)(derivedKey);\n\t            for (let i = 0; i < d32.length; i += 2) {\n\t                // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n\t                const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);\n\t                d32[i + 0] = o0;\n\t                d32[i + 1] = o1;\n\t                s0 = ++counter; // increment counter inside state\n\t            }\n\t        }\n\t        const res = { authKey, encKey: expandKeyLE(encKey) };\n\t        // Cleanup\n\t        (0, utils_js_1.clean)(...toClean);\n\t        return res;\n\t    }\n\t    function _computeTag(encKey, authKey, data) {\n\t        const tag = computeTag(_polyval_js_1.polyval, true, authKey, data, AAD);\n\t        // Compute the expected tag by XORing S_s and the nonce, clearing the\n\t        // most significant bit of the last byte and encrypting with the\n\t        // message-encryption key.\n\t        for (let i = 0; i < 12; i++)\n\t            tag[i] ^= nonce[i];\n\t        tag[15] &= 0x7f; // Clear the highest bit\n\t        // encrypt tag as block\n\t        const t32 = (0, utils_js_1.u32)(tag);\n\t        // prettier-ignore\n\t        let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];\n\t        ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));\n\t        (t32[0] = s0), (t32[1] = s1), (t32[2] = s2), (t32[3] = s3);\n\t        return tag;\n\t    }\n\t    // actual decrypt/encrypt of message.\n\t    function processSiv(encKey, tag, input) {\n\t        let block = (0, utils_js_1.copyBytes)(tag);\n\t        block[15] |= 0x80; // Force highest bit\n\t        const res = ctr32(encKey, true, block, input);\n\t        // Cleanup\n\t        (0, utils_js_1.clean)(block);\n\t        return res;\n\t    }\n\t    return {\n\t        encrypt(plaintext) {\n\t            PLAIN_LIMIT(plaintext.length);\n\t            const { encKey, authKey } = deriveKeys();\n\t            const tag = _computeTag(encKey, authKey, plaintext);\n\t            const toClean = [encKey, authKey, tag];\n\t            if (!(0, utils_js_1.isAligned32)(plaintext))\n\t                toClean.push((plaintext = (0, utils_js_1.copyBytes)(plaintext)));\n\t            const out = new Uint8Array(plaintext.length + tagLength);\n\t            out.set(tag, plaintext.length);\n\t            out.set(processSiv(encKey, tag, plaintext));\n\t            // Cleanup\n\t            (0, utils_js_1.clean)(...toClean);\n\t            return out;\n\t        },\n\t        decrypt(ciphertext) {\n\t            CIPHER_LIMIT(ciphertext.length);\n\t            const tag = ciphertext.subarray(-tagLength);\n\t            const { encKey, authKey } = deriveKeys();\n\t            const toClean = [encKey, authKey];\n\t            if (!(0, utils_js_1.isAligned32)(ciphertext))\n\t                toClean.push((ciphertext = (0, utils_js_1.copyBytes)(ciphertext)));\n\t            const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n\t            const expectedTag = _computeTag(encKey, authKey, plaintext);\n\t            toClean.push(expectedTag);\n\t            if (!(0, utils_js_1.equalBytes)(tag, expectedTag)) {\n\t                (0, utils_js_1.clean)(...toClean);\n\t                throw new Error('invalid polyval tag');\n\t            }\n\t            // Cleanup\n\t            (0, utils_js_1.clean)(...toClean);\n\t            return plaintext;\n\t        },\n\t    };\n\t});\n\tfunction isBytes32(a) {\n\t    return (a instanceof Uint32Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint32Array'));\n\t}\n\tfunction encryptBlock(xk, block) {\n\t    (0, _assert_js_1.abytes)(block, 16);\n\t    if (!isBytes32(xk))\n\t        throw new Error('_encryptBlock accepts result of expandKeyLE');\n\t    const b32 = (0, utils_js_1.u32)(block);\n\t    let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n\t    (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n\t    return block;\n\t}\n\tfunction decryptBlock(xk, block) {\n\t    (0, _assert_js_1.abytes)(block, 16);\n\t    if (!isBytes32(xk))\n\t        throw new Error('_decryptBlock accepts result of expandKeyLE');\n\t    const b32 = (0, utils_js_1.u32)(block);\n\t    let { s0, s1, s2, s3 } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n\t    (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n\t    return block;\n\t}\n\t/**\n\t * AES-W (base for AESKW/AESKWP).\n\t * Specs: [SP800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf),\n\t * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n\t * [RFC 5649](https://datatracker.ietf.org/doc/rfc5649/).\n\t */\n\tconst AESW = {\n\t    /*\n\t    High-level pseudocode:\n\t    ```\n\t    A: u64 = IV\n\t    out = []\n\t    for (let i=0, ctr = 0; i<6; i++) {\n\t      for (const chunk of chunks(plaintext, 8)) {\n\t        A ^= swapEndianess(ctr++)\n\t        [A, res] = chunks(encrypt(A || chunk), 8);\n\t        out ||= res\n\t      }\n\t    }\n\t    out = A || out\n\t    ```\n\t    Decrypt is the same, but reversed.\n\t    */\n\t    encrypt(kek, out) {\n\t        // Size is limited to 4GB, otherwise ctr will overflow and we'll need to switch to bigints.\n\t        // If you need it larger, open an issue.\n\t        if (out.length >= 2 ** 32)\n\t            throw new Error('plaintext should be less than 4gb');\n\t        const xk = expandKeyLE(kek);\n\t        if (out.length === 16)\n\t            encryptBlock(xk, out);\n\t        else {\n\t            const o32 = (0, utils_js_1.u32)(out);\n\t            // prettier-ignore\n\t            let a0 = o32[0], a1 = o32[1]; // A\n\t            for (let j = 0, ctr = 1; j < 6; j++) {\n\t                for (let pos = 2; pos < o32.length; pos += 2, ctr++) {\n\t                    const { s0, s1, s2, s3 } = encrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n\t                    // A = MSB(64, B) ^ t where t = (n*j)+i\n\t                    (a0 = s0), (a1 = s1 ^ byteSwap(ctr)), (o32[pos] = s2), (o32[pos + 1] = s3);\n\t                }\n\t            }\n\t            (o32[0] = a0), (o32[1] = a1); // out = A || out\n\t        }\n\t        xk.fill(0);\n\t    },\n\t    decrypt(kek, out) {\n\t        if (out.length - 8 >= 2 ** 32)\n\t            throw new Error('ciphertext should be less than 4gb');\n\t        const xk = expandKeyDecLE(kek);\n\t        const chunks = out.length / 8 - 1; // first chunk is IV\n\t        if (chunks === 1)\n\t            decryptBlock(xk, out);\n\t        else {\n\t            const o32 = (0, utils_js_1.u32)(out);\n\t            // prettier-ignore\n\t            let a0 = o32[0], a1 = o32[1]; // A\n\t            for (let j = 0, ctr = chunks * 6; j < 6; j++) {\n\t                for (let pos = chunks * 2; pos >= 1; pos -= 2, ctr--) {\n\t                    a1 ^= byteSwap(ctr);\n\t                    const { s0, s1, s2, s3 } = decrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n\t                    (a0 = s0), (a1 = s1), (o32[pos] = s2), (o32[pos + 1] = s3);\n\t                }\n\t            }\n\t            (o32[0] = a0), (o32[1] = a1);\n\t        }\n\t        xk.fill(0);\n\t    },\n\t};\n\tconst AESKW_IV = /* @__PURE__ */ new Uint8Array(8).fill(0xa6); // A6A6A6A6A6A6A6A6\n\t/**\n\t * AES-KW (key-wrap). Injects static IV into plaintext, adds counter, encrypts 6 times.\n\t * Reduces block size from 16 to 8 bytes.\n\t * For padded version, use aeskwp.\n\t * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n\t * [NIST.SP.800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf).\n\t */\n\taes.aeskw = (0, utils_js_1.wrapCipher)({ blockSize: 8 }, (kek) => ({\n\t    encrypt(plaintext) {\n\t        if (!plaintext.length || plaintext.length % 8 !== 0)\n\t            throw new Error('invalid plaintext length');\n\t        if (plaintext.length === 8)\n\t            throw new Error('8-byte keys not allowed in AESKW, use AESKWP instead');\n\t        const out = (0, utils_js_1.concatBytes)(AESKW_IV, plaintext);\n\t        AESW.encrypt(kek, out);\n\t        return out;\n\t    },\n\t    decrypt(ciphertext) {\n\t        // ciphertext must be at least 24 bytes and a multiple of 8 bytes\n\t        // 24 because should have at least two block (1 iv + 2).\n\t        // Replace with 16 to enable '8-byte keys'\n\t        if (ciphertext.length % 8 !== 0 || ciphertext.length < 3 * 8)\n\t            throw new Error('invalid ciphertext length');\n\t        const out = (0, utils_js_1.copyBytes)(ciphertext);\n\t        AESW.decrypt(kek, out);\n\t        if (!(0, utils_js_1.equalBytes)(out.subarray(0, 8), AESKW_IV))\n\t            throw new Error('integrity check failed');\n\t        out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n\t        return out.subarray(8);\n\t    },\n\t}));\n\t/*\n\tWe don't support 8-byte keys. The rabbit hole:\n\n\t- Wycheproof says: \"NIST SP 800-38F does not define the wrapping of 8 byte keys.\n\t  RFC 3394 Section 2  on the other hand specifies that 8 byte keys are wrapped\n\t  by directly encrypting one block with AES.\"\n\t    - https://github.com/C2SP/wycheproof/blob/master/doc/key_wrap.md\n\t    - \"RFC 3394 specifies in Section 2, that the input for the key wrap\n\t      algorithm must be at least two blocks and otherwise the constant\n\t      field and key are simply encrypted with ECB as a single block\"\n\t- What RFC 3394 actually says (in Section 2):\n\t    - \"Before being wrapped, the key data is parsed into n blocks of 64 bits.\n\t      The only restriction the key wrap algorithm places on n is that n be\n\t      at least two\"\n\t    - \"For key data with length less than or equal to 64 bits, the constant\n\t      field used in this specification and the key data form a single\n\t      128-bit codebook input making this key wrap unnecessary.\"\n\t- Which means \"assert(n >= 2)\" and \"use something else for 8 byte keys\"\n\t- NIST SP800-38F actually prohibits 8-byte in \"5.3.1 Mandatory Limits\".\n\t  It states that plaintext for KW should be \"2 to 2^54 -1 semiblocks\".\n\t- So, where does \"directly encrypt single block with AES\" come from?\n\t    - Not RFC 3394. Pseudocode of key wrap in 2.2 explicitly uses\n\t      loop of 6 for any code path\n\t    - There is a weird W3C spec:\n\t      https://www.w3.org/TR/2002/REC-xmlenc-core-20021210/Overview.html#kw-aes128\n\t    - This spec is outdated, as admitted by Wycheproof authors\n\t    - There is RFC 5649 for padded key wrap, which is padding construction on\n\t      top of AESKW. In '4.1.2' it says: \"If the padded plaintext contains exactly\n\t      eight octets, then prepend the AIV as defined in Section 3 above to P[1] and\n\t      encrypt the resulting 128-bit block using AES in ECB mode [Modes] with key\n\t      K (the KEK).  In this case, the output is two 64-bit blocks C[0] and C[1]:\"\n\t    - Browser subtle crypto is actually crashes on wrapping keys less than 16 bytes:\n\t      `Error: error:1C8000E6:Provider routines::invalid input length] { opensslErrorStack: [ 'error:030000BD:digital envelope routines::update error' ]`\n\n\tIn the end, seems like a bug in Wycheproof.\n\tThe 8-byte check can be easily disabled inside of AES_W.\n\t*/\n\tconst AESKWP_IV = 0xa65959a6; // single u32le value\n\t/**\n\t * AES-KW, but with padding and allows random keys.\n\t * Second u32 of IV is used as counter for length.\n\t * [RFC 5649](https://www.rfc-editor.org/rfc/rfc5649)\n\t */\n\taes.aeskwp = (0, utils_js_1.wrapCipher)({ blockSize: 8 }, (kek) => ({\n\t    encrypt(plaintext) {\n\t        if (!plaintext.length)\n\t            throw new Error('invalid plaintext length');\n\t        const padded = Math.ceil(plaintext.length / 8) * 8;\n\t        const out = new Uint8Array(8 + padded);\n\t        out.set(plaintext, 8);\n\t        const out32 = (0, utils_js_1.u32)(out);\n\t        out32[0] = AESKWP_IV;\n\t        out32[1] = byteSwap(plaintext.length);\n\t        AESW.encrypt(kek, out);\n\t        return out;\n\t    },\n\t    decrypt(ciphertext) {\n\t        // 16 because should have at least one block\n\t        if (ciphertext.length < 16)\n\t            throw new Error('invalid ciphertext length');\n\t        const out = (0, utils_js_1.copyBytes)(ciphertext);\n\t        const o32 = (0, utils_js_1.u32)(out);\n\t        AESW.decrypt(kek, out);\n\t        const len = byteSwap(o32[1]) >>> 0;\n\t        const padded = Math.ceil(len / 8) * 8;\n\t        if (o32[0] !== AESKWP_IV || out.length - 8 !== padded)\n\t            throw new Error('integrity check failed');\n\t        for (let i = len; i < padded; i++)\n\t            if (out[8 + i] !== 0)\n\t                throw new Error('integrity check failed');\n\t        out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n\t        return out.subarray(8, 8 + len);\n\t    },\n\t}));\n\t/** Unsafe low-level internal methods. May change at any time. */\n\taes.unsafe = {\n\t    expandKeyLE,\n\t    expandKeyDecLE,\n\t    encrypt,\n\t    decrypt,\n\t    encryptBlock,\n\t    decryptBlock,\n\t    ctrCounter,\n\t    ctr32,\n\t};\n\t\n\treturn aes;\n}\n\nvar hasRequiredNoble$1;\n\nfunction requireNoble$1 () {\n\tif (hasRequiredNoble$1) return noble$1;\n\thasRequiredNoble$1 = 1;\n\tObject.defineProperty(noble$1, \"__esModule\", { value: true });\n\tnoble$1.aes256cbc = noble$1.aes256gcm = void 0;\n\tvar aes_1 = /*@__PURE__*/ requireAes();\n\tvar aes256gcm = function (key, nonce, AAD) {\n\t    return (0, aes_1.gcm)(key, nonce, AAD);\n\t};\n\tnoble$1.aes256gcm = aes256gcm;\n\tvar aes256cbc = function (key, nonce, AAD) {\n\t    return (0, aes_1.cbc)(key, nonce);\n\t};\n\tnoble$1.aes256cbc = aes256cbc;\n\treturn noble$1;\n}\n\nvar noble = {};\n\nvar chacha = {};\n\nvar _arx = {};\n\nvar hasRequired_arx;\n\nfunction require_arx () {\n\tif (hasRequired_arx) return _arx;\n\thasRequired_arx = 1;\n\tObject.defineProperty(_arx, \"__esModule\", { value: true });\n\t_arx.rotl = rotl;\n\t_arx.createCipher = createCipher;\n\t/**\n\t * Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\n\n\tRFC8439 requires multi-step cipher stream, where\n\tauthKey starts with counter: 0, actual msg with counter: 1.\n\n\tFor this, we need a way to re-use nonce / counter:\n\n\t    const counter = new Uint8Array(4);\n\t    chacha(..., counter, ...); // counter is now 1\n\t    chacha(..., counter, ...); // counter is now 2\n\n\tThis is complicated:\n\n\t- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n\t- Original papers don't allow mutating counters\n\t- Counter overflow is undefined [^1]\n\t- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n\t- Caveat: Cannot be re-used through all cases:\n\t- * chacha has (counter | nonce)\n\t- * xchacha has (nonce16 | counter | nonce16)\n\t- Idea B: separate nonce / counter and provide separate API for counter re-use\n\t- Caveat: there are different counter sizes depending on an algorithm.\n\t- salsa & chacha also differ in structures of key & sigma:\n\t  salsa20:      s[0] | k(4) | s[1] | nonce(2) | ctr(2) | s[2] | k(4) | s[3]\n\t  chacha:       s(4) | k(8) | ctr(1) | nonce(3)\n\t  chacha20orig: s(4) | k(8) | ctr(2) | nonce(2)\n\t- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n\t- Caveat: we can't re-use counter array\n\n\txchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n\t(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n\t[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n\t[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n\n\t * @module\n\t */\n\tconst _assert_js_1 = /*@__PURE__*/ require_assert$1();\n\tconst utils_js_1 = /*@__PURE__*/ requireUtils$3();\n\t// We can't make top-level var depend on utils.utf8ToBytes\n\t// because it's not present in all envs. Creating a similar fn here\n\tconst _utf8ToBytes = (str) => Uint8Array.from(str.split('').map((c) => c.charCodeAt(0)));\n\tconst sigma16 = _utf8ToBytes('expand 16-byte k');\n\tconst sigma32 = _utf8ToBytes('expand 32-byte k');\n\tconst sigma16_32 = (0, utils_js_1.u32)(sigma16);\n\tconst sigma32_32 = (0, utils_js_1.u32)(sigma32);\n\tfunction rotl(a, b) {\n\t    return (a << b) | (a >>> (32 - b));\n\t}\n\t// Is byte array aligned to 4 byte offset (u32)?\n\tfunction isAligned32(b) {\n\t    return b.byteOffset % 4 === 0;\n\t}\n\t// Salsa and Chacha block length is always 512-bit\n\tconst BLOCK_LEN = 64;\n\tconst BLOCK_LEN32 = 16;\n\t// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n\t// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\n\tconst MAX_COUNTER = 2 ** 32 - 1;\n\tconst U32_EMPTY = new Uint32Array();\n\tfunction runCipher(core, sigma, key, nonce, data, output, counter, rounds) {\n\t    const len = data.length;\n\t    const block = new Uint8Array(BLOCK_LEN);\n\t    const b32 = (0, utils_js_1.u32)(block);\n\t    // Make sure that buffers aligned to 4 bytes\n\t    const isAligned = isAligned32(data) && isAligned32(output);\n\t    const d32 = isAligned ? (0, utils_js_1.u32)(data) : U32_EMPTY;\n\t    const o32 = isAligned ? (0, utils_js_1.u32)(output) : U32_EMPTY;\n\t    for (let pos = 0; pos < len; counter++) {\n\t        core(sigma, key, nonce, b32, counter, rounds);\n\t        if (counter >= MAX_COUNTER)\n\t            throw new Error('arx: counter overflow');\n\t        const take = Math.min(BLOCK_LEN, len - pos);\n\t        // aligned to 4 bytes\n\t        if (isAligned && take === BLOCK_LEN) {\n\t            const pos32 = pos / 4;\n\t            if (pos % 4 !== 0)\n\t                throw new Error('arx: invalid block position');\n\t            for (let j = 0, posj; j < BLOCK_LEN32; j++) {\n\t                posj = pos32 + j;\n\t                o32[posj] = d32[posj] ^ b32[j];\n\t            }\n\t            pos += BLOCK_LEN;\n\t            continue;\n\t        }\n\t        for (let j = 0, posj; j < take; j++) {\n\t            posj = pos + j;\n\t            output[posj] = data[posj] ^ block[j];\n\t        }\n\t        pos += take;\n\t    }\n\t}\n\t/** Creates ARX-like (ChaCha, Salsa) cipher stream from core function. */\n\tfunction createCipher(core, opts) {\n\t    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = (0, utils_js_1.checkOpts)({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);\n\t    if (typeof core !== 'function')\n\t        throw new Error('core must be a function');\n\t    (0, _assert_js_1.anumber)(counterLength);\n\t    (0, _assert_js_1.anumber)(rounds);\n\t    (0, _assert_js_1.abool)(counterRight);\n\t    (0, _assert_js_1.abool)(allowShortKeys);\n\t    return (key, nonce, data, output, counter = 0) => {\n\t        (0, _assert_js_1.abytes)(key);\n\t        (0, _assert_js_1.abytes)(nonce);\n\t        (0, _assert_js_1.abytes)(data);\n\t        const len = data.length;\n\t        if (output === undefined)\n\t            output = new Uint8Array(len);\n\t        (0, _assert_js_1.abytes)(output);\n\t        (0, _assert_js_1.anumber)(counter);\n\t        if (counter < 0 || counter >= MAX_COUNTER)\n\t            throw new Error('arx: counter overflow');\n\t        if (output.length < len)\n\t            throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n\t        const toClean = [];\n\t        // Key & sigma\n\t        // key=16 -> sigma16, k=key|key\n\t        // key=32 -> sigma32, k=key\n\t        let l = key.length;\n\t        let k;\n\t        let sigma;\n\t        if (l === 32) {\n\t            toClean.push((k = (0, utils_js_1.copyBytes)(key)));\n\t            sigma = sigma32_32;\n\t        }\n\t        else if (l === 16 && allowShortKeys) {\n\t            k = new Uint8Array(32);\n\t            k.set(key);\n\t            k.set(key, 16);\n\t            sigma = sigma16_32;\n\t            toClean.push(k);\n\t        }\n\t        else {\n\t            throw new Error(`arx: invalid 32-byte key, got length=${l}`);\n\t        }\n\t        // Nonce\n\t        // salsa20:      8   (8-byte counter)\n\t        // chacha20orig: 8   (8-byte counter)\n\t        // chacha20:     12  (4-byte counter)\n\t        // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n\t        // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n\t        // Align nonce to 4 bytes\n\t        if (!isAligned32(nonce))\n\t            toClean.push((nonce = (0, utils_js_1.copyBytes)(nonce)));\n\t        const k32 = (0, utils_js_1.u32)(k);\n\t        // hsalsa & hchacha: handle extended nonce\n\t        if (extendNonceFn) {\n\t            if (nonce.length !== 24)\n\t                throw new Error(`arx: extended nonce must be 24 bytes`);\n\t            extendNonceFn(sigma, k32, (0, utils_js_1.u32)(nonce.subarray(0, 16)), k32);\n\t            nonce = nonce.subarray(16);\n\t        }\n\t        // Handle nonce counter\n\t        const nonceNcLen = 16 - counterLength;\n\t        if (nonceNcLen !== nonce.length)\n\t            throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n\t        // Pad counter when nonce is 64 bit\n\t        if (nonceNcLen !== 12) {\n\t            const nc = new Uint8Array(12);\n\t            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n\t            nonce = nc;\n\t            toClean.push(nonce);\n\t        }\n\t        const n32 = (0, utils_js_1.u32)(nonce);\n\t        runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n\t        (0, utils_js_1.clean)(...toClean);\n\t        return output;\n\t    };\n\t}\n\t\n\treturn _arx;\n}\n\nvar _poly1305 = {};\n\nvar hasRequired_poly1305;\n\nfunction require_poly1305 () {\n\tif (hasRequired_poly1305) return _poly1305;\n\thasRequired_poly1305 = 1;\n\tObject.defineProperty(_poly1305, \"__esModule\", { value: true });\n\t_poly1305.poly1305 = void 0;\n\t_poly1305.wrapConstructorWithKey = wrapConstructorWithKey;\n\t/**\n\t * Poly1305 ([PDF](https://cr.yp.to/mac/poly1305-20050329.pdf),\n\t * [wiki](https://en.wikipedia.org/wiki/Poly1305))\n\t * is a fast and parallel secret-key message-authentication code suitable for\n\t * a wide variety of applications. It was standardized in\n\t * [RFC 8439](https://datatracker.ietf.org/doc/html/rfc8439) and is now used in TLS 1.3.\n\t *\n\t * Polynomial MACs are not perfect for every situation:\n\t * they lack Random Key Robustness: the MAC can be forged, and can't be used in PAKE schemes.\n\t * See [invisible salamanders attack](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/).\n\t * To combat invisible salamanders, `hash(key)` can be included in ciphertext,\n\t * however, this would violate ciphertext indistinguishability:\n\t * an attacker would know which key was used - so `HKDF(key, i)`\n\t * could be used instead.\n\t *\n\t * Check out [original website](https://cr.yp.to/mac.html).\n\t * @module\n\t */\n\tconst _assert_js_1 = /*@__PURE__*/ require_assert$1();\n\tconst utils_js_1 = /*@__PURE__*/ requireUtils$3();\n\t// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna\n\tconst u8to16 = (a, i) => (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\n\tclass Poly1305 {\n\t    constructor(key) {\n\t        this.blockLen = 16;\n\t        this.outputLen = 16;\n\t        this.buffer = new Uint8Array(16);\n\t        this.r = new Uint16Array(10);\n\t        this.h = new Uint16Array(10);\n\t        this.pad = new Uint16Array(8);\n\t        this.pos = 0;\n\t        this.finished = false;\n\t        key = (0, utils_js_1.toBytes)(key);\n\t        (0, _assert_js_1.abytes)(key, 32);\n\t        const t0 = u8to16(key, 0);\n\t        const t1 = u8to16(key, 2);\n\t        const t2 = u8to16(key, 4);\n\t        const t3 = u8to16(key, 6);\n\t        const t4 = u8to16(key, 8);\n\t        const t5 = u8to16(key, 10);\n\t        const t6 = u8to16(key, 12);\n\t        const t7 = u8to16(key, 14);\n\t        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n\t        this.r[0] = t0 & 0x1fff;\n\t        this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n\t        this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n\t        this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n\t        this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n\t        this.r[5] = (t4 >>> 1) & 0x1ffe;\n\t        this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n\t        this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n\t        this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n\t        this.r[9] = (t7 >>> 5) & 0x007f;\n\t        for (let i = 0; i < 8; i++)\n\t            this.pad[i] = u8to16(key, 16 + 2 * i);\n\t    }\n\t    process(data, offset, isLast = false) {\n\t        const hibit = isLast ? 0 : 1 << 11;\n\t        const { h, r } = this;\n\t        const r0 = r[0];\n\t        const r1 = r[1];\n\t        const r2 = r[2];\n\t        const r3 = r[3];\n\t        const r4 = r[4];\n\t        const r5 = r[5];\n\t        const r6 = r[6];\n\t        const r7 = r[7];\n\t        const r8 = r[8];\n\t        const r9 = r[9];\n\t        const t0 = u8to16(data, offset + 0);\n\t        const t1 = u8to16(data, offset + 2);\n\t        const t2 = u8to16(data, offset + 4);\n\t        const t3 = u8to16(data, offset + 6);\n\t        const t4 = u8to16(data, offset + 8);\n\t        const t5 = u8to16(data, offset + 10);\n\t        const t6 = u8to16(data, offset + 12);\n\t        const t7 = u8to16(data, offset + 14);\n\t        let h0 = h[0] + (t0 & 0x1fff);\n\t        let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n\t        let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n\t        let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n\t        let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n\t        let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n\t        let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n\t        let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n\t        let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n\t        let h9 = h[9] + ((t7 >>> 5) | hibit);\n\t        let c = 0;\n\t        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n\t        c = d0 >>> 13;\n\t        d0 &= 0x1fff;\n\t        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n\t        c += d0 >>> 13;\n\t        d0 &= 0x1fff;\n\t        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n\t        c = d1 >>> 13;\n\t        d1 &= 0x1fff;\n\t        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n\t        c += d1 >>> 13;\n\t        d1 &= 0x1fff;\n\t        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n\t        c = d2 >>> 13;\n\t        d2 &= 0x1fff;\n\t        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n\t        c += d2 >>> 13;\n\t        d2 &= 0x1fff;\n\t        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n\t        c = d3 >>> 13;\n\t        d3 &= 0x1fff;\n\t        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n\t        c += d3 >>> 13;\n\t        d3 &= 0x1fff;\n\t        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n\t        c = d4 >>> 13;\n\t        d4 &= 0x1fff;\n\t        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n\t        c += d4 >>> 13;\n\t        d4 &= 0x1fff;\n\t        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n\t        c = d5 >>> 13;\n\t        d5 &= 0x1fff;\n\t        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n\t        c += d5 >>> 13;\n\t        d5 &= 0x1fff;\n\t        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n\t        c = d6 >>> 13;\n\t        d6 &= 0x1fff;\n\t        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n\t        c += d6 >>> 13;\n\t        d6 &= 0x1fff;\n\t        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n\t        c = d7 >>> 13;\n\t        d7 &= 0x1fff;\n\t        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n\t        c += d7 >>> 13;\n\t        d7 &= 0x1fff;\n\t        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n\t        c = d8 >>> 13;\n\t        d8 &= 0x1fff;\n\t        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n\t        c += d8 >>> 13;\n\t        d8 &= 0x1fff;\n\t        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n\t        c = d9 >>> 13;\n\t        d9 &= 0x1fff;\n\t        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n\t        c += d9 >>> 13;\n\t        d9 &= 0x1fff;\n\t        c = ((c << 2) + c) | 0;\n\t        c = (c + d0) | 0;\n\t        d0 = c & 0x1fff;\n\t        c = c >>> 13;\n\t        d1 += c;\n\t        h[0] = d0;\n\t        h[1] = d1;\n\t        h[2] = d2;\n\t        h[3] = d3;\n\t        h[4] = d4;\n\t        h[5] = d5;\n\t        h[6] = d6;\n\t        h[7] = d7;\n\t        h[8] = d8;\n\t        h[9] = d9;\n\t    }\n\t    finalize() {\n\t        const { h, pad } = this;\n\t        const g = new Uint16Array(10);\n\t        let c = h[1] >>> 13;\n\t        h[1] &= 0x1fff;\n\t        for (let i = 2; i < 10; i++) {\n\t            h[i] += c;\n\t            c = h[i] >>> 13;\n\t            h[i] &= 0x1fff;\n\t        }\n\t        h[0] += c * 5;\n\t        c = h[0] >>> 13;\n\t        h[0] &= 0x1fff;\n\t        h[1] += c;\n\t        c = h[1] >>> 13;\n\t        h[1] &= 0x1fff;\n\t        h[2] += c;\n\t        g[0] = h[0] + 5;\n\t        c = g[0] >>> 13;\n\t        g[0] &= 0x1fff;\n\t        for (let i = 1; i < 10; i++) {\n\t            g[i] = h[i] + c;\n\t            c = g[i] >>> 13;\n\t            g[i] &= 0x1fff;\n\t        }\n\t        g[9] -= 1 << 13;\n\t        let mask = (c ^ 1) - 1;\n\t        for (let i = 0; i < 10; i++)\n\t            g[i] &= mask;\n\t        mask = ~mask;\n\t        for (let i = 0; i < 10; i++)\n\t            h[i] = (h[i] & mask) | g[i];\n\t        h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n\t        h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n\t        h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n\t        h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n\t        h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n\t        h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n\t        h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n\t        h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n\t        let f = h[0] + pad[0];\n\t        h[0] = f & 0xffff;\n\t        for (let i = 1; i < 8; i++) {\n\t            f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n\t            h[i] = f & 0xffff;\n\t        }\n\t        (0, utils_js_1.clean)(g);\n\t    }\n\t    update(data) {\n\t        (0, _assert_js_1.aexists)(this);\n\t        const { buffer, blockLen } = this;\n\t        data = (0, utils_js_1.toBytes)(data);\n\t        const len = data.length;\n\t        for (let pos = 0; pos < len;) {\n\t            const take = Math.min(blockLen - this.pos, len - pos);\n\t            // Fast path: we have at least one block in input\n\t            if (take === blockLen) {\n\t                for (; blockLen <= len - pos; pos += blockLen)\n\t                    this.process(data, pos);\n\t                continue;\n\t            }\n\t            buffer.set(data.subarray(pos, pos + take), this.pos);\n\t            this.pos += take;\n\t            pos += take;\n\t            if (this.pos === blockLen) {\n\t                this.process(buffer, 0, false);\n\t                this.pos = 0;\n\t            }\n\t        }\n\t        return this;\n\t    }\n\t    destroy() {\n\t        (0, utils_js_1.clean)(this.h, this.r, this.buffer, this.pad);\n\t    }\n\t    digestInto(out) {\n\t        (0, _assert_js_1.aexists)(this);\n\t        (0, _assert_js_1.aoutput)(out, this);\n\t        this.finished = true;\n\t        const { buffer, h } = this;\n\t        let { pos } = this;\n\t        if (pos) {\n\t            buffer[pos++] = 1;\n\t            for (; pos < 16; pos++)\n\t                buffer[pos] = 0;\n\t            this.process(buffer, 0, true);\n\t        }\n\t        this.finalize();\n\t        let opos = 0;\n\t        for (let i = 0; i < 8; i++) {\n\t            out[opos++] = h[i] >>> 0;\n\t            out[opos++] = h[i] >>> 8;\n\t        }\n\t        return out;\n\t    }\n\t    digest() {\n\t        const { buffer, outputLen } = this;\n\t        this.digestInto(buffer);\n\t        const res = buffer.slice(0, outputLen);\n\t        this.destroy();\n\t        return res;\n\t    }\n\t}\n\tfunction wrapConstructorWithKey(hashCons) {\n\t    const hashC = (msg, key) => hashCons(key).update((0, utils_js_1.toBytes)(msg)).digest();\n\t    const tmp = hashCons(new Uint8Array(32));\n\t    hashC.outputLen = tmp.outputLen;\n\t    hashC.blockLen = tmp.blockLen;\n\t    hashC.create = (key) => hashCons(key);\n\t    return hashC;\n\t}\n\t/** Poly1305 MAC from RFC 8439. */\n\t_poly1305.poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));\n\t\n\treturn _poly1305;\n}\n\nvar hasRequiredChacha;\n\nfunction requireChacha () {\n\tif (hasRequiredChacha) return chacha;\n\thasRequiredChacha = 1;\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.xchacha20poly1305 = exports.chacha20poly1305 = exports._poly1305_aead = exports.chacha12 = exports.chacha8 = exports.xchacha20 = exports.chacha20 = exports.chacha20orig = void 0;\n\t\texports.hchacha = hchacha;\n\t\t/**\n\t\t * [ChaCha20](https://cr.yp.to/chacha.html) stream cipher, released\n\t\t * in 2008. Developed after Salsa20, ChaCha aims to increase diffusion per round.\n\t\t * It was standardized in [RFC 8439](https://datatracker.ietf.org/doc/html/rfc8439) and\n\t\t * is now used in TLS 1.3.\n\t\t *\n\t\t * [XChaCha20](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha)\n\t\t * extended-nonce variant is also provided. Similar to XSalsa, it's safe to use with\n\t\t * randomly-generated nonces.\n\t\t *\n\t\t * Check out [PDF](http://cr.yp.to/chacha/chacha-20080128.pdf) and\n\t\t * [wiki](https://en.wikipedia.org/wiki/Salsa20).\n\t\t * @module\n\t\t */\n\t\tconst _arx_js_1 = /*@__PURE__*/ require_arx();\n\t\tconst _poly1305_js_1 = /*@__PURE__*/ require_poly1305();\n\t\tconst utils_js_1 = /*@__PURE__*/ requireUtils$3();\n\t\t/**\n\t\t * ChaCha core function.\n\t\t */\n\t\t// prettier-ignore\n\t\tfunction chachaCore(s, k, n, out, cnt, rounds = 20) {\n\t\t    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n\t\t    y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], // Key      Key     Key     Key\n\t\t    y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], // Key      Key     Key     Key\n\t\t    y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n\t\t    // Save state to temporary variables\n\t\t    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n\t\t    for (let r = 0; r < rounds; r += 2) {\n\t\t        x00 = (x00 + x04) | 0;\n\t\t        x12 = (0, _arx_js_1.rotl)(x12 ^ x00, 16);\n\t\t        x08 = (x08 + x12) | 0;\n\t\t        x04 = (0, _arx_js_1.rotl)(x04 ^ x08, 12);\n\t\t        x00 = (x00 + x04) | 0;\n\t\t        x12 = (0, _arx_js_1.rotl)(x12 ^ x00, 8);\n\t\t        x08 = (x08 + x12) | 0;\n\t\t        x04 = (0, _arx_js_1.rotl)(x04 ^ x08, 7);\n\t\t        x01 = (x01 + x05) | 0;\n\t\t        x13 = (0, _arx_js_1.rotl)(x13 ^ x01, 16);\n\t\t        x09 = (x09 + x13) | 0;\n\t\t        x05 = (0, _arx_js_1.rotl)(x05 ^ x09, 12);\n\t\t        x01 = (x01 + x05) | 0;\n\t\t        x13 = (0, _arx_js_1.rotl)(x13 ^ x01, 8);\n\t\t        x09 = (x09 + x13) | 0;\n\t\t        x05 = (0, _arx_js_1.rotl)(x05 ^ x09, 7);\n\t\t        x02 = (x02 + x06) | 0;\n\t\t        x14 = (0, _arx_js_1.rotl)(x14 ^ x02, 16);\n\t\t        x10 = (x10 + x14) | 0;\n\t\t        x06 = (0, _arx_js_1.rotl)(x06 ^ x10, 12);\n\t\t        x02 = (x02 + x06) | 0;\n\t\t        x14 = (0, _arx_js_1.rotl)(x14 ^ x02, 8);\n\t\t        x10 = (x10 + x14) | 0;\n\t\t        x06 = (0, _arx_js_1.rotl)(x06 ^ x10, 7);\n\t\t        x03 = (x03 + x07) | 0;\n\t\t        x15 = (0, _arx_js_1.rotl)(x15 ^ x03, 16);\n\t\t        x11 = (x11 + x15) | 0;\n\t\t        x07 = (0, _arx_js_1.rotl)(x07 ^ x11, 12);\n\t\t        x03 = (x03 + x07) | 0;\n\t\t        x15 = (0, _arx_js_1.rotl)(x15 ^ x03, 8);\n\t\t        x11 = (x11 + x15) | 0;\n\t\t        x07 = (0, _arx_js_1.rotl)(x07 ^ x11, 7);\n\t\t        x00 = (x00 + x05) | 0;\n\t\t        x15 = (0, _arx_js_1.rotl)(x15 ^ x00, 16);\n\t\t        x10 = (x10 + x15) | 0;\n\t\t        x05 = (0, _arx_js_1.rotl)(x05 ^ x10, 12);\n\t\t        x00 = (x00 + x05) | 0;\n\t\t        x15 = (0, _arx_js_1.rotl)(x15 ^ x00, 8);\n\t\t        x10 = (x10 + x15) | 0;\n\t\t        x05 = (0, _arx_js_1.rotl)(x05 ^ x10, 7);\n\t\t        x01 = (x01 + x06) | 0;\n\t\t        x12 = (0, _arx_js_1.rotl)(x12 ^ x01, 16);\n\t\t        x11 = (x11 + x12) | 0;\n\t\t        x06 = (0, _arx_js_1.rotl)(x06 ^ x11, 12);\n\t\t        x01 = (x01 + x06) | 0;\n\t\t        x12 = (0, _arx_js_1.rotl)(x12 ^ x01, 8);\n\t\t        x11 = (x11 + x12) | 0;\n\t\t        x06 = (0, _arx_js_1.rotl)(x06 ^ x11, 7);\n\t\t        x02 = (x02 + x07) | 0;\n\t\t        x13 = (0, _arx_js_1.rotl)(x13 ^ x02, 16);\n\t\t        x08 = (x08 + x13) | 0;\n\t\t        x07 = (0, _arx_js_1.rotl)(x07 ^ x08, 12);\n\t\t        x02 = (x02 + x07) | 0;\n\t\t        x13 = (0, _arx_js_1.rotl)(x13 ^ x02, 8);\n\t\t        x08 = (x08 + x13) | 0;\n\t\t        x07 = (0, _arx_js_1.rotl)(x07 ^ x08, 7);\n\t\t        x03 = (x03 + x04) | 0;\n\t\t        x14 = (0, _arx_js_1.rotl)(x14 ^ x03, 16);\n\t\t        x09 = (x09 + x14) | 0;\n\t\t        x04 = (0, _arx_js_1.rotl)(x04 ^ x09, 12);\n\t\t        x03 = (x03 + x04) | 0;\n\t\t        x14 = (0, _arx_js_1.rotl)(x14 ^ x03, 8);\n\t\t        x09 = (x09 + x14) | 0;\n\t\t        x04 = (0, _arx_js_1.rotl)(x04 ^ x09, 7);\n\t\t    }\n\t\t    // Write output\n\t\t    let oi = 0;\n\t\t    out[oi++] = (y00 + x00) | 0;\n\t\t    out[oi++] = (y01 + x01) | 0;\n\t\t    out[oi++] = (y02 + x02) | 0;\n\t\t    out[oi++] = (y03 + x03) | 0;\n\t\t    out[oi++] = (y04 + x04) | 0;\n\t\t    out[oi++] = (y05 + x05) | 0;\n\t\t    out[oi++] = (y06 + x06) | 0;\n\t\t    out[oi++] = (y07 + x07) | 0;\n\t\t    out[oi++] = (y08 + x08) | 0;\n\t\t    out[oi++] = (y09 + x09) | 0;\n\t\t    out[oi++] = (y10 + x10) | 0;\n\t\t    out[oi++] = (y11 + x11) | 0;\n\t\t    out[oi++] = (y12 + x12) | 0;\n\t\t    out[oi++] = (y13 + x13) | 0;\n\t\t    out[oi++] = (y14 + x14) | 0;\n\t\t    out[oi++] = (y15 + x15) | 0;\n\t\t}\n\t\t/**\n\t\t * hchacha helper method, used primarily in xchacha, to hash\n\t\t * key and nonce into key' and nonce'.\n\t\t * Same as chachaCore, but there doesn't seem to be a way to move the block\n\t\t * out without 25% performance hit.\n\t\t */\n\t\t// prettier-ignore\n\t\tfunction hchacha(s, k, i, o32) {\n\t\t    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n\t\t    for (let r = 0; r < 20; r += 2) {\n\t\t        x00 = (x00 + x04) | 0;\n\t\t        x12 = (0, _arx_js_1.rotl)(x12 ^ x00, 16);\n\t\t        x08 = (x08 + x12) | 0;\n\t\t        x04 = (0, _arx_js_1.rotl)(x04 ^ x08, 12);\n\t\t        x00 = (x00 + x04) | 0;\n\t\t        x12 = (0, _arx_js_1.rotl)(x12 ^ x00, 8);\n\t\t        x08 = (x08 + x12) | 0;\n\t\t        x04 = (0, _arx_js_1.rotl)(x04 ^ x08, 7);\n\t\t        x01 = (x01 + x05) | 0;\n\t\t        x13 = (0, _arx_js_1.rotl)(x13 ^ x01, 16);\n\t\t        x09 = (x09 + x13) | 0;\n\t\t        x05 = (0, _arx_js_1.rotl)(x05 ^ x09, 12);\n\t\t        x01 = (x01 + x05) | 0;\n\t\t        x13 = (0, _arx_js_1.rotl)(x13 ^ x01, 8);\n\t\t        x09 = (x09 + x13) | 0;\n\t\t        x05 = (0, _arx_js_1.rotl)(x05 ^ x09, 7);\n\t\t        x02 = (x02 + x06) | 0;\n\t\t        x14 = (0, _arx_js_1.rotl)(x14 ^ x02, 16);\n\t\t        x10 = (x10 + x14) | 0;\n\t\t        x06 = (0, _arx_js_1.rotl)(x06 ^ x10, 12);\n\t\t        x02 = (x02 + x06) | 0;\n\t\t        x14 = (0, _arx_js_1.rotl)(x14 ^ x02, 8);\n\t\t        x10 = (x10 + x14) | 0;\n\t\t        x06 = (0, _arx_js_1.rotl)(x06 ^ x10, 7);\n\t\t        x03 = (x03 + x07) | 0;\n\t\t        x15 = (0, _arx_js_1.rotl)(x15 ^ x03, 16);\n\t\t        x11 = (x11 + x15) | 0;\n\t\t        x07 = (0, _arx_js_1.rotl)(x07 ^ x11, 12);\n\t\t        x03 = (x03 + x07) | 0;\n\t\t        x15 = (0, _arx_js_1.rotl)(x15 ^ x03, 8);\n\t\t        x11 = (x11 + x15) | 0;\n\t\t        x07 = (0, _arx_js_1.rotl)(x07 ^ x11, 7);\n\t\t        x00 = (x00 + x05) | 0;\n\t\t        x15 = (0, _arx_js_1.rotl)(x15 ^ x00, 16);\n\t\t        x10 = (x10 + x15) | 0;\n\t\t        x05 = (0, _arx_js_1.rotl)(x05 ^ x10, 12);\n\t\t        x00 = (x00 + x05) | 0;\n\t\t        x15 = (0, _arx_js_1.rotl)(x15 ^ x00, 8);\n\t\t        x10 = (x10 + x15) | 0;\n\t\t        x05 = (0, _arx_js_1.rotl)(x05 ^ x10, 7);\n\t\t        x01 = (x01 + x06) | 0;\n\t\t        x12 = (0, _arx_js_1.rotl)(x12 ^ x01, 16);\n\t\t        x11 = (x11 + x12) | 0;\n\t\t        x06 = (0, _arx_js_1.rotl)(x06 ^ x11, 12);\n\t\t        x01 = (x01 + x06) | 0;\n\t\t        x12 = (0, _arx_js_1.rotl)(x12 ^ x01, 8);\n\t\t        x11 = (x11 + x12) | 0;\n\t\t        x06 = (0, _arx_js_1.rotl)(x06 ^ x11, 7);\n\t\t        x02 = (x02 + x07) | 0;\n\t\t        x13 = (0, _arx_js_1.rotl)(x13 ^ x02, 16);\n\t\t        x08 = (x08 + x13) | 0;\n\t\t        x07 = (0, _arx_js_1.rotl)(x07 ^ x08, 12);\n\t\t        x02 = (x02 + x07) | 0;\n\t\t        x13 = (0, _arx_js_1.rotl)(x13 ^ x02, 8);\n\t\t        x08 = (x08 + x13) | 0;\n\t\t        x07 = (0, _arx_js_1.rotl)(x07 ^ x08, 7);\n\t\t        x03 = (x03 + x04) | 0;\n\t\t        x14 = (0, _arx_js_1.rotl)(x14 ^ x03, 16);\n\t\t        x09 = (x09 + x14) | 0;\n\t\t        x04 = (0, _arx_js_1.rotl)(x04 ^ x09, 12);\n\t\t        x03 = (x03 + x04) | 0;\n\t\t        x14 = (0, _arx_js_1.rotl)(x14 ^ x03, 8);\n\t\t        x09 = (x09 + x14) | 0;\n\t\t        x04 = (0, _arx_js_1.rotl)(x04 ^ x09, 7);\n\t\t    }\n\t\t    let oi = 0;\n\t\t    o32[oi++] = x00;\n\t\t    o32[oi++] = x01;\n\t\t    o32[oi++] = x02;\n\t\t    o32[oi++] = x03;\n\t\t    o32[oi++] = x12;\n\t\t    o32[oi++] = x13;\n\t\t    o32[oi++] = x14;\n\t\t    o32[oi++] = x15;\n\t\t}\n\t\t/**\n\t\t * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.\n\t\t */\n\t\texports.chacha20orig = (0, _arx_js_1.createCipher)(chachaCore, {\n\t\t    counterRight: false,\n\t\t    counterLength: 8,\n\t\t    allowShortKeys: true,\n\t\t});\n\t\t/**\n\t\t * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n\t\t * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n\t\t */\n\t\texports.chacha20 = (0, _arx_js_1.createCipher)(chachaCore, {\n\t\t    counterRight: false,\n\t\t    counterLength: 4,\n\t\t    allowShortKeys: false,\n\t\t});\n\t\t/**\n\t\t * XChaCha eXtended-nonce ChaCha. 24-byte nonce.\n\t\t * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n\t\t * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n\t\t */\n\t\texports.xchacha20 = (0, _arx_js_1.createCipher)(chachaCore, {\n\t\t    counterRight: false,\n\t\t    counterLength: 8,\n\t\t    extendNonceFn: hchacha,\n\t\t    allowShortKeys: false,\n\t\t});\n\t\t/**\n\t\t * Reduced 8-round chacha, described in original paper.\n\t\t */\n\t\texports.chacha8 = (0, _arx_js_1.createCipher)(chachaCore, {\n\t\t    counterRight: false,\n\t\t    counterLength: 4,\n\t\t    rounds: 8,\n\t\t});\n\t\t/**\n\t\t * Reduced 12-round chacha, described in original paper.\n\t\t */\n\t\texports.chacha12 = (0, _arx_js_1.createCipher)(chachaCore, {\n\t\t    counterRight: false,\n\t\t    counterLength: 4,\n\t\t    rounds: 12,\n\t\t});\n\t\tconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n\t\t// Pad to digest size with zeros\n\t\tconst updatePadded = (h, msg) => {\n\t\t    h.update(msg);\n\t\t    const left = msg.length % 16;\n\t\t    if (left)\n\t\t        h.update(ZEROS16.subarray(left));\n\t\t};\n\t\tconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\n\t\tfunction computeTag(fn, key, nonce, data, AAD) {\n\t\t    const authKey = fn(key, nonce, ZEROS32);\n\t\t    const h = _poly1305_js_1.poly1305.create(authKey);\n\t\t    if (AAD)\n\t\t        updatePadded(h, AAD);\n\t\t    updatePadded(h, data);\n\t\t    const num = new Uint8Array(16);\n\t\t    const view = (0, utils_js_1.createView)(num);\n\t\t    (0, utils_js_1.setBigUint64)(view, 0, BigInt(AAD ? AAD.length : 0), true);\n\t\t    (0, utils_js_1.setBigUint64)(view, 8, BigInt(data.length), true);\n\t\t    h.update(num);\n\t\t    const res = h.digest();\n\t\t    (0, utils_js_1.clean)(authKey, num);\n\t\t    return res;\n\t\t}\n\t\t/**\n\t\t * AEAD algorithm from RFC 8439.\n\t\t * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n\t\t * We could have composed them similar to:\n\t\t * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250\n\t\t * But it's hard because of authKey:\n\t\t * In salsa20, authKey changes position in salsa stream.\n\t\t * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n\t\t */\n\t\tconst _poly1305_aead = (xorStream) => (key, nonce, AAD) => {\n\t\t    const tagLength = 16;\n\t\t    return {\n\t\t        encrypt(plaintext, output) {\n\t\t            const plength = plaintext.length;\n\t\t            output = (0, utils_js_1.getOutput)(plength + tagLength, output, false);\n\t\t            output.set(plaintext);\n\t\t            const oPlain = output.subarray(0, -tagLength);\n\t\t            xorStream(key, nonce, oPlain, oPlain, 1);\n\t\t            const tag = computeTag(xorStream, key, nonce, oPlain, AAD);\n\t\t            output.set(tag, plength); // append tag\n\t\t            (0, utils_js_1.clean)(tag);\n\t\t            return output;\n\t\t        },\n\t\t        decrypt(ciphertext, output) {\n\t\t            output = (0, utils_js_1.getOutput)(ciphertext.length - tagLength, output, false);\n\t\t            const data = ciphertext.subarray(0, -tagLength);\n\t\t            const passedTag = ciphertext.subarray(-tagLength);\n\t\t            const tag = computeTag(xorStream, key, nonce, data, AAD);\n\t\t            if (!(0, utils_js_1.equalBytes)(passedTag, tag))\n\t\t                throw new Error('invalid tag');\n\t\t            output.set(ciphertext.subarray(0, -tagLength));\n\t\t            xorStream(key, nonce, output, output, 1); // start stream with i=1\n\t\t            (0, utils_js_1.clean)(tag);\n\t\t            return output;\n\t\t        },\n\t\t    };\n\t\t};\n\t\texports._poly1305_aead = _poly1305_aead;\n\t\t/**\n\t\t * ChaCha20-Poly1305 from RFC 8439.\n\t\t *\n\t\t * Unsafe to use random nonces under the same key, due to collision chance.\n\t\t * Prefer XChaCha instead.\n\t\t */\n\t\texports.chacha20poly1305 = (0, utils_js_1.wrapCipher)({ blockSize: 64, nonceLength: 12, tagLength: 16 }, (0, exports._poly1305_aead)(exports.chacha20));\n\t\t/**\n\t\t * XChaCha20-Poly1305 extended-nonce chacha.\n\t\t *\n\t\t * Can be safely used with random nonces (CSPRNG).\n\t\t * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).\n\t\t */\n\t\texports.xchacha20poly1305 = (0, utils_js_1.wrapCipher)({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (0, exports._poly1305_aead)(exports.xchacha20));\n\t\t\n\t} (chacha));\n\treturn chacha;\n}\n\nvar hasRequiredNoble;\n\nfunction requireNoble () {\n\tif (hasRequiredNoble) return noble;\n\thasRequiredNoble = 1;\n\tObject.defineProperty(noble, \"__esModule\", { value: true });\n\tnoble.chacha20 = noble.xchacha20 = void 0;\n\tvar chacha_1 = /*@__PURE__*/ requireChacha();\n\tvar xchacha20 = function (key, nonce, AAD) {\n\t    return (0, chacha_1.xchacha20poly1305)(key, nonce, AAD);\n\t};\n\tnoble.xchacha20 = xchacha20;\n\tvar chacha20 = function (key, nonce, AAD) {\n\t    return (0, chacha_1.chacha20poly1305)(key, nonce, AAD);\n\t};\n\tnoble.chacha20 = chacha20;\n\treturn noble;\n}\n\nvar hasRequiredSymmetric;\n\nfunction requireSymmetric () {\n\tif (hasRequiredSymmetric) return symmetric;\n\thasRequiredSymmetric = 1;\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.aesDecrypt = exports.aesEncrypt = exports.symDecrypt = exports.symEncrypt = void 0;\n\t\tvar utils_1 = /*@__PURE__*/ requireUtils$3();\n\t\tvar webcrypto_1 = /*@__PURE__*/ requireWebcrypto();\n\t\tvar aes_1 = requireNoble$1();\n\t\tvar chacha_1 = requireNoble();\n\t\tvar config_1 = requireConfig();\n\t\tvar consts_1 = requireConsts();\n\t\tvar symEncrypt = function (key, plainText, AAD) { return _exec(_encrypt, key, plainText, AAD); };\n\t\texports.symEncrypt = symEncrypt;\n\t\tvar symDecrypt = function (key, cipherText, AAD) { return _exec(_decrypt, key, cipherText, AAD); };\n\t\texports.symDecrypt = symDecrypt;\n\t\t/** @deprecated - use `symEncrypt` instead. */\n\t\texports.aesEncrypt = exports.symEncrypt; // TODO: delete\n\t\t/** @deprecated - use `symDecrypt` instead. */\n\t\texports.aesDecrypt = exports.symDecrypt; // TODO: delete\n\t\tfunction _exec(callback, key, data, AAD) {\n\t\t    var algorithm = (0, config_1.symmetricAlgorithm)();\n\t\t    if (algorithm === \"aes-256-gcm\") {\n\t\t        return callback(aes_1.aes256gcm, key, data, (0, config_1.symmetricNonceLength)(), consts_1.AEAD_TAG_LENGTH, AAD);\n\t\t    }\n\t\t    else if (algorithm === \"xchacha20\") {\n\t\t        return callback(chacha_1.xchacha20, key, data, consts_1.XCHACHA20_NONCE_LENGTH, consts_1.AEAD_TAG_LENGTH, AAD);\n\t\t    }\n\t\t    else if (algorithm === \"aes-256-cbc\") {\n\t\t        // NOT RECOMMENDED. There is neither AAD nor AEAD tag in cbc mode\n\t\t        // aes-256-cbc always uses 16 bytes iv\n\t\t        return callback(aes_1.aes256cbc, key, data, 16, 0);\n\t\t    }\n\t\t    else {\n\t\t        throw new Error(\"Not implemented\");\n\t\t    }\n\t\t}\n\t\tfunction _encrypt(func, key, data, nonceLength, tagLength, AAD) {\n\t\t    var nonce = (0, webcrypto_1.randomBytes)(nonceLength);\n\t\t    var cipher = func(key, nonce, AAD);\n\t\t    // @noble/ciphers format: cipherText || tag\n\t\t    var encrypted = cipher.encrypt(data);\n\t\t    if (tagLength === 0) {\n\t\t        return (0, utils_1.concatBytes)(nonce, encrypted);\n\t\t    }\n\t\t    var cipherTextLength = encrypted.length - tagLength;\n\t\t    var cipherText = encrypted.subarray(0, cipherTextLength);\n\t\t    var tag = encrypted.subarray(cipherTextLength);\n\t\t    // ecies payload format: pk || nonce || tag || cipherText\n\t\t    return (0, utils_1.concatBytes)(nonce, tag, cipherText);\n\t\t}\n\t\tfunction _decrypt(func, key, data, nonceLength, tagLength, AAD) {\n\t\t    var nonce = data.subarray(0, nonceLength);\n\t\t    var cipher = func(key, Uint8Array.from(nonce), AAD); // to reset byteOffset\n\t\t    var encrypted = data.subarray(nonceLength);\n\t\t    if (tagLength === 0) {\n\t\t        return cipher.decrypt(encrypted);\n\t\t    }\n\t\t    var tag = encrypted.subarray(0, tagLength);\n\t\t    var cipherText = encrypted.subarray(tagLength);\n\t\t    return cipher.decrypt((0, utils_1.concatBytes)(cipherText, tag));\n\t\t} \n\t} (symmetric));\n\treturn symmetric;\n}\n\nvar hasRequiredUtils;\n\nfunction requireUtils () {\n\tif (hasRequiredUtils) return utils$4;\n\thasRequiredUtils = 1;\n\t(function (exports) {\n\t\tvar __createBinding = (utils$4 && utils$4.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n\t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n\t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n\t\t    }\n\t\t    Object.defineProperty(o, k2, desc);\n\t\t}) : (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    o[k2] = m[k];\n\t\t}));\n\t\tvar __exportStar = (utils$4 && utils$4.__exportStar) || function(m, exports) {\n\t\t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n\t\t};\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\t__exportStar(requireElliptic(), exports);\n\t\t__exportStar(requireHash(), exports);\n\t\t__exportStar(requireHex(), exports);\n\t\t__exportStar(requireSymmetric(), exports); \n\t} (utils$4));\n\treturn utils$4;\n}\n\nvar PublicKey = {};\n\nvar hasRequiredPublicKey;\n\nfunction requirePublicKey () {\n\tif (hasRequiredPublicKey) return PublicKey;\n\thasRequiredPublicKey = 1;\n\tObject.defineProperty(PublicKey, \"__esModule\", { value: true });\n\tPublicKey.PublicKey = void 0;\n\tvar utils_1 = /*@__PURE__*/ requireUtils$3();\n\tvar utils_2 = requireUtils();\n\tvar PublicKey$1 = /** @class */ (function () {\n\t    function PublicKey(data) {\n\t        // data can be either compressed or uncompressed if secp256k1\n\t        var compressed = (0, utils_2.convertPublicKeyFormat)(data, true);\n\t        var uncompressed = (0, utils_2.convertPublicKeyFormat)(data, false);\n\t        this.data = compressed;\n\t        this.dataUncompressed =\n\t            compressed.length !== uncompressed.length ? uncompressed : null;\n\t    }\n\t    PublicKey.fromHex = function (hex) {\n\t        return new PublicKey((0, utils_2.hexToPublicKey)(hex));\n\t    };\n\t    Object.defineProperty(PublicKey.prototype, \"_uncompressed\", {\n\t        get: function () {\n\t            return this.dataUncompressed !== null ? this.dataUncompressed : this.data;\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(PublicKey.prototype, \"uncompressed\", {\n\t        /** @deprecated - use `PublicKey.toBytes(false)` instead. You may also need `Buffer.from`. */\n\t        get: function () {\n\t            return Buffer.from(this._uncompressed); // TODO: delete\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(PublicKey.prototype, \"compressed\", {\n\t        /** @deprecated - use `PublicKey.toBytes()` instead. You may also need `Buffer.from`. */\n\t        get: function () {\n\t            return Buffer.from(this.data); // TODO: delete\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    PublicKey.prototype.toBytes = function (compressed) {\n\t        if (compressed === void 0) { compressed = true; }\n\t        return compressed ? this.data : this._uncompressed;\n\t    };\n\t    PublicKey.prototype.toHex = function (compressed) {\n\t        if (compressed === void 0) { compressed = true; }\n\t        return (0, utils_1.bytesToHex)(this.toBytes(compressed));\n\t    };\n\t    /**\n\t     * Derives a shared secret from receiver's private key (sk) and ephemeral public key (this).\n\t     * Opposite of `encapsulate`.\n\t     * @see PrivateKey.encapsulate\n\t     *\n\t     * @param sk - Receiver's private key.\n\t     * @param compressed - (default: `false`) Whether to use compressed or uncompressed public keys in the key derivation (secp256k1 only).\n\t     * @returns Shared secret, derived with HKDF-SHA256.\n\t     */\n\t    PublicKey.prototype.decapsulate = function (sk, compressed) {\n\t        if (compressed === void 0) { compressed = false; }\n\t        var senderPoint = this.toBytes(compressed);\n\t        var sharedPoint = sk.multiply(this, compressed);\n\t        return (0, utils_2.getSharedKey)(senderPoint, sharedPoint);\n\t    };\n\t    PublicKey.prototype.equals = function (other) {\n\t        return (0, utils_1.equalBytes)(this.data, other.data);\n\t    };\n\t    return PublicKey;\n\t}());\n\tPublicKey.PublicKey = PublicKey$1;\n\treturn PublicKey;\n}\n\nvar hasRequiredPrivateKey;\n\nfunction requirePrivateKey () {\n\tif (hasRequiredPrivateKey) return PrivateKey;\n\thasRequiredPrivateKey = 1;\n\tObject.defineProperty(PrivateKey, \"__esModule\", { value: true });\n\tPrivateKey.PrivateKey = void 0;\n\tvar utils_1 = /*@__PURE__*/ requireUtils$3();\n\tvar utils_2 = requireUtils();\n\tvar PublicKey_1 = requirePublicKey();\n\tvar PrivateKey$1 = /** @class */ (function () {\n\t    function PrivateKey(secret) {\n\t        if (secret === undefined) {\n\t            this.data = (0, utils_2.getValidSecret)();\n\t        }\n\t        else if ((0, utils_2.isValidPrivateKey)(secret)) {\n\t            this.data = secret;\n\t        }\n\t        else {\n\t            throw new Error(\"Invalid private key\");\n\t        }\n\t        this.publicKey = new PublicKey_1.PublicKey((0, utils_2.getPublicKey)(this.data));\n\t    }\n\t    PrivateKey.fromHex = function (hex) {\n\t        return new PrivateKey((0, utils_2.decodeHex)(hex));\n\t    };\n\t    Object.defineProperty(PrivateKey.prototype, \"secret\", {\n\t        /** @description From version 0.5.0, `Uint8Array` will be returned instead of `Buffer`. */\n\t        get: function () {\n\t            // TODO: Uint8Array\n\t            return Buffer.from(this.data);\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    PrivateKey.prototype.toHex = function () {\n\t        return (0, utils_1.bytesToHex)(this.data);\n\t    };\n\t    /**\n\t     * Derives a shared secret from ephemeral private key (this) and receiver's public key (pk).\n\t     * @description The shared key is 32 bytes, derived with `HKDF-SHA256(senderPoint || sharedPoint)`. See implementation for details.\n\t     *\n\t     * There are some variations in different ECIES implementations:\n\t     * which key derivation function to use, compressed or uncompressed `senderPoint`/`sharedPoint`, whether to include `senderPoint`, etc.\n\t     *\n\t     * Because the entropy of `senderPoint`, `sharedPoint` is enough high[1], we don't need salt to derive keys.\n\t     *\n\t     * [1]: Two reasons: the public keys are \"random\" bytes (albeit secp256k1 public keys are **not uniformly** random), and ephemeral keys are generated in every encryption.\n\t     *\n\t     * @param pk - Receiver's public key.\n\t     * @param compressed - (default: `false`) Whether to use compressed or uncompressed public keys in the key derivation (secp256k1 only).\n\t     * @returns Shared secret, derived with HKDF-SHA256.\n\t     */\n\t    PrivateKey.prototype.encapsulate = function (pk, compressed) {\n\t        if (compressed === void 0) { compressed = false; }\n\t        var senderPoint = this.publicKey.toBytes(compressed);\n\t        var sharedPoint = this.multiply(pk, compressed);\n\t        return (0, utils_2.getSharedKey)(senderPoint, sharedPoint);\n\t    };\n\t    PrivateKey.prototype.multiply = function (pk, compressed) {\n\t        if (compressed === void 0) { compressed = false; }\n\t        return (0, utils_2.getSharedPoint)(this.data, pk.toBytes(true), compressed);\n\t    };\n\t    PrivateKey.prototype.equals = function (other) {\n\t        return (0, utils_1.equalBytes)(this.data, other.data);\n\t    };\n\t    return PrivateKey;\n\t}());\n\tPrivateKey.PrivateKey = PrivateKey$1;\n\treturn PrivateKey;\n}\n\nvar hasRequiredKeys;\n\nfunction requireKeys () {\n\tif (hasRequiredKeys) return keys;\n\thasRequiredKeys = 1;\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.PublicKey = exports.PrivateKey = void 0;\n\t\t// treat Buffer as Uint8array, i.e. no call of Buffer specific functions\n\t\t// finally Uint8Array only\n\t\tvar PrivateKey_1 = requirePrivateKey();\n\t\tObject.defineProperty(exports, \"PrivateKey\", { enumerable: true, get: function () { return PrivateKey_1.PrivateKey; } });\n\t\tvar PublicKey_1 = requirePublicKey();\n\t\tObject.defineProperty(exports, \"PublicKey\", { enumerable: true, get: function () { return PublicKey_1.PublicKey; } }); \n\t} (keys));\n\treturn keys;\n}\n\nvar hasRequiredDist;\n\nfunction requireDist () {\n\tif (hasRequiredDist) return dist;\n\thasRequiredDist = 1;\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.utils = exports.PublicKey = exports.PrivateKey = exports.ECIES_CONFIG = void 0;\n\t\texports.encrypt = encrypt;\n\t\texports.decrypt = decrypt;\n\t\tvar utils_1 = /*@__PURE__*/ requireUtils$3();\n\t\tvar config_1 = requireConfig();\n\t\tvar keys_1 = requireKeys();\n\t\tvar utils_2 = requireUtils();\n\t\t/**\n\t\t * Encrypts data with a receiver's public key.\n\t\t * @description From version 0.5.0, `Uint8Array` will be returned instead of `Buffer`.\n\t\t * To keep the same behavior, use `Buffer.from(encrypt(...))`.\n\t\t *\n\t\t * @param receiverRawPK - Raw public key of the receiver, either as a hex string or a Uint8Array.\n\t\t * @param data - Data to encrypt.\n\t\t * @returns Encrypted payload, format: `public key || encrypted`.\n\t\t */\n\t\tfunction encrypt(receiverRawPK, data) {\n\t\t    return Buffer.from(_encrypt(receiverRawPK, data));\n\t\t}\n\t\tfunction _encrypt(receiverRawPK, data) {\n\t\t    var ephemeralSK = new keys_1.PrivateKey();\n\t\t    var receiverPK = receiverRawPK instanceof Uint8Array\n\t\t        ? new keys_1.PublicKey(receiverRawPK)\n\t\t        : keys_1.PublicKey.fromHex(receiverRawPK);\n\t\t    var sharedKey = ephemeralSK.encapsulate(receiverPK, (0, config_1.isHkdfKeyCompressed)());\n\t\t    var ephemeralPK = ephemeralSK.publicKey.toBytes((0, config_1.isEphemeralKeyCompressed)());\n\t\t    var encrypted = (0, utils_2.symEncrypt)(sharedKey, data);\n\t\t    return (0, utils_1.concatBytes)(ephemeralPK, encrypted);\n\t\t}\n\t\t/**\n\t\t * Decrypts data with a receiver's private key.\n\t\t * @description From version 0.5.0, `Uint8Array` will be returned instead of `Buffer`.\n\t\t * To keep the same behavior, use `Buffer.from(decrypt(...))`.\n\t\t *\n\t\t * @param receiverRawSK - Raw private key of the receiver, either as a hex string or a Uint8Array.\n\t\t * @param data - Data to decrypt.\n\t\t * @returns Decrypted plain text.\n\t\t */\n\t\tfunction decrypt(receiverRawSK, data) {\n\t\t    return Buffer.from(_decrypt(receiverRawSK, data));\n\t\t}\n\t\tfunction _decrypt(receiverRawSK, data) {\n\t\t    var receiverSK = receiverRawSK instanceof Uint8Array\n\t\t        ? new keys_1.PrivateKey(receiverRawSK)\n\t\t        : keys_1.PrivateKey.fromHex(receiverRawSK);\n\t\t    var keySize = (0, config_1.ephemeralKeySize)();\n\t\t    var ephemeralPK = new keys_1.PublicKey(data.subarray(0, keySize));\n\t\t    var encrypted = data.subarray(keySize);\n\t\t    var sharedKey = ephemeralPK.decapsulate(receiverSK, (0, config_1.isHkdfKeyCompressed)());\n\t\t    return (0, utils_2.symDecrypt)(sharedKey, encrypted);\n\t\t}\n\t\tvar config_2 = requireConfig();\n\t\tObject.defineProperty(exports, \"ECIES_CONFIG\", { enumerable: true, get: function () { return config_2.ECIES_CONFIG; } });\n\t\tvar keys_2 = requireKeys();\n\t\tObject.defineProperty(exports, \"PrivateKey\", { enumerable: true, get: function () { return keys_2.PrivateKey; } });\n\t\tObject.defineProperty(exports, \"PublicKey\", { enumerable: true, get: function () { return keys_2.PublicKey; } });\n\t\t/** @deprecated - use `import utils from \"eciesjs/utils\"` instead. */\n\t\texports.utils = {\n\t\t    // TODO: remove these after 0.5.0\n\t\t    aesEncrypt: utils_2.aesEncrypt,\n\t\t    aesDecrypt: utils_2.aesDecrypt,\n\t\t    symEncrypt: utils_2.symEncrypt,\n\t\t    symDecrypt: utils_2.symDecrypt,\n\t\t    decodeHex: utils_2.decodeHex,\n\t\t    getValidSecret: utils_2.getValidSecret,\n\t\t    remove0x: utils_2.remove0x,\n\t\t}; \n\t} (dist));\n\treturn dist;\n}\n\nvar distExports = requireDist();\n\n/**\n * Environment detection utility\n * Helps distinguish between Node.js and browser environments\n */\nconst isBrowser = () => {\n    return (typeof window !== 'undefined' && typeof window.document !== 'undefined');\n};\nconst isNode = () => {\n    return (typeof process !== 'undefined' &&\n        process.versions &&\n        process.versions.node !== undefined);\n};\nconst isWebWorker = () => {\n    return (typeof globalThis.importScripts === 'function' &&\n        typeof navigator !== 'undefined');\n};\nconst hasWebCrypto = () => {\n    return (isBrowser() &&\n        typeof window.crypto !== 'undefined' &&\n        typeof window.crypto.subtle !== 'undefined');\n};\n\nclass NodeCryptoAdapter {\n    crypto;\n    constructor() {\n        if (isBrowser()) {\n            throw new Error('NodeCryptoAdapter can only be used in Node.js environment');\n        }\n    }\n    async getCrypto() {\n        if (!this.crypto) {\n            this.crypto = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ \"crypto\", 23));\n        }\n        return this.crypto;\n    }\n    async aesGCMEncrypt(key, data, iv) {\n        const crypto = await this.getCrypto();\n        const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\n        const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);\n        const authTag = cipher.getAuthTag();\n        return { encrypted, authTag };\n    }\n    async aesGCMDecrypt(key, encryptedData, iv, authTag) {\n        const crypto = await this.getCrypto();\n        const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);\n        decipher.setAuthTag(authTag);\n        const decrypted = Buffer.concat([\n            decipher.update(encryptedData),\n            decipher.final(),\n        ]);\n        return decrypted;\n    }\n    randomBytes(length) {\n        if (this.crypto) {\n            return this.crypto.randomBytes(length);\n        }\n        // For synchronous random bytes in Node.js, we'll need to handle this differently\n        // This is a limitation - ideally this should be async\n        const array = new Uint8Array(length);\n        // Use Node.js crypto if available (simplified fallback)\n        // In production, this should ideally be async\n        try {\n            // Check if we're in Node.js environment by checking for process\n            if (typeof process !== 'undefined' && process.versions?.node) {\n                // Import crypto-browserify as fallback for browser compatibility\n                const cryptoBrowserify = __webpack_require__(/*! crypto-browserify */ \"(ssr)/./node_modules/crypto-browserify/index.js\");\n                return cryptoBrowserify.randomBytes(length);\n            }\n        }\n        catch {\n            // Crypto not available\n        }\n        // Fallback to Math.random (not cryptographically secure, but functional)\n        console.warn('Using Math.random for random bytes - not cryptographically secure');\n        for (let i = 0; i < length; i++) {\n            array[i] = Math.floor(Math.random() * 256);\n        }\n        return Buffer.from(array);\n    }\n}\nclass BrowserCryptoAdapter {\n    constructor() {\n        if (!hasWebCrypto()) {\n            throw new Error('Web Crypto API is not available in this browser');\n        }\n    }\n    async aesGCMEncrypt(key, data, iv) {\n        const cryptoKey = await crypto.subtle.importKey('raw', key, { name: 'AES-GCM' }, false, ['encrypt']);\n        const result = await crypto.subtle.encrypt({\n            name: 'AES-GCM',\n            iv: iv,\n            tagLength: 128,\n        }, cryptoKey, data);\n        const encrypted = new Uint8Array(result.slice(0, -16));\n        const authTag = new Uint8Array(result.slice(-16));\n        return {\n            encrypted: Buffer.from(encrypted),\n            authTag: Buffer.from(authTag),\n        };\n    }\n    async aesGCMDecrypt(key, encryptedData, iv, authTag) {\n        const cryptoKey = await crypto.subtle.importKey('raw', key, { name: 'AES-GCM' }, false, ['decrypt']);\n        const combined = new Uint8Array(encryptedData.length + authTag.length);\n        combined.set(encryptedData, 0);\n        combined.set(authTag, encryptedData.length);\n        const result = await crypto.subtle.decrypt({\n            name: 'AES-GCM',\n            iv: iv,\n            tagLength: 128,\n        }, cryptoKey, combined);\n        return Buffer.from(result);\n    }\n    randomBytes(length) {\n        const array = new Uint8Array(length);\n        crypto.getRandomValues(array);\n        return Buffer.from(array);\n    }\n}\nlet cryptoAdapter = null;\nfunction getCryptoAdapter() {\n    if (!cryptoAdapter) {\n        if (isBrowser()) {\n            cryptoAdapter = new BrowserCryptoAdapter();\n        }\n        else {\n            cryptoAdapter = new NodeCryptoAdapter();\n        }\n    }\n    return cryptoAdapter;\n}\n\nconst ivLength = 12;\nconst tagLength = 16;\nconst sigLength = 65;\nconst chunkLength = 64 * 1024 * 1024 + tagLength;\n// Inference\nasync function deriveEncryptionKey(signer) {\n    const signature = await signer.signMessage(MESSAGE_FOR_ENCRYPTION_KEY);\n    const hash = ethers__WEBPACK_IMPORTED_MODULE_5__.sha256(ethers__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes(signature));\n    return hash;\n}\nasync function encryptData(signer, data) {\n    const key = await deriveEncryptionKey(signer);\n    const encrypted = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.encrypt(data, key).toString();\n    return encrypted;\n}\nasync function decryptData(signer, encryptedData) {\n    const key = await deriveEncryptionKey(signer);\n    const bytes = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.decrypt(encryptedData, key);\n    const decrypted = bytes.toString((crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc).Utf8);\n    return decrypted;\n}\n// Fine-tuning\nfunction hexToRoots(hexString) {\n    if (hexString.startsWith('0x')) {\n        hexString = hexString.slice(2);\n    }\n    return Buffer.from(hexString, 'hex').toString('utf8');\n}\nasync function signRequest(signer, userAddress, nonce, datasetRootHash, fee) {\n    const hash = ethers__WEBPACK_IMPORTED_MODULE_7__.solidityPackedKeccak256(['address', 'uint256', 'string', 'uint256'], [userAddress, nonce, datasetRootHash, fee]);\n    return await signer.signMessage(ethers__WEBPACK_IMPORTED_MODULE_8__.toBeArray(hash));\n}\nasync function signTaskID(signer, taskID) {\n    const hash = ethers__WEBPACK_IMPORTED_MODULE_7__.solidityPackedKeccak256(['bytes'], ['0x' + taskID.replace(/-/g, '')]);\n    return await signer.signMessage(ethers__WEBPACK_IMPORTED_MODULE_8__.toBeArray(hash));\n}\nasync function eciesDecrypt(signer, encryptedData) {\n    encryptedData = encryptedData.startsWith('0x')\n        ? encryptedData.slice(2)\n        : encryptedData;\n    const privateKey = distExports.PrivateKey.fromHex(signer.privateKey);\n    const data = Buffer.from(encryptedData, 'hex');\n    const decrypted = distExports.decrypt(privateKey.secret, data);\n    return decrypted.toString('hex');\n}\nasync function aesGCMDecryptToFile(key, encryptedModelPath, decryptedModelPath, providerSigner) {\n    if (isBrowser()) {\n        throw new Error('File operations are not supported in browser environment. Use aesGCMDecrypt with ArrayBuffer instead.');\n    }\n    // Only import fs when in Node.js environment\n    const { promises: fs } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n    const fd = await fs.open(encryptedModelPath, 'r');\n    // read signature and nonce\n    const tagSig = Buffer.alloc(sigLength);\n    const iv = Buffer.alloc(ivLength);\n    let offset = 0;\n    let readResult = await fd.read(tagSig, 0, sigLength, offset);\n    offset += readResult.bytesRead;\n    readResult = await fd.read(iv, 0, ivLength, offset);\n    offset += readResult.bytesRead;\n    const privateKey = Buffer.from(key, 'hex');\n    const buffer = Buffer.alloc(chunkLength);\n    let tagsBuffer = Buffer.from([]);\n    const writeFd = await fs.open(decryptedModelPath, 'w');\n    const cryptoAdapter = getCryptoAdapter();\n    // read chunks\n    while (true) {\n        readResult = await fd.read(buffer, 0, chunkLength, offset);\n        const chunkSize = readResult.bytesRead;\n        if (chunkSize === 0) {\n            break;\n        }\n        const tag = buffer.subarray(chunkSize - tagLength, chunkSize);\n        const encryptedChunk = buffer.subarray(0, chunkSize - tagLength);\n        const decrypted = await cryptoAdapter.aesGCMDecrypt(privateKey, Buffer.from(encryptedChunk), Buffer.from(iv), Buffer.from(tag));\n        await writeFd.appendFile(decrypted);\n        tagsBuffer = Buffer.concat([tagsBuffer, tag]);\n        offset += chunkSize;\n        for (let i = iv.length - 1; i >= 0; i--) {\n            iv[i]++;\n            if (iv[i] !== 0)\n                break;\n        }\n    }\n    await writeFd.close();\n    await fd.close();\n    const recoveredAddress = ethers__WEBPACK_IMPORTED_MODULE_9__.recoverAddress(ethers__WEBPACK_IMPORTED_MODULE_10__.keccak256(tagsBuffer), '0x' + tagSig.toString('hex'));\n    if (recoveredAddress.toLowerCase() !== providerSigner.toLowerCase()) {\n        throw new Error('Invalid tag signature');\n    }\n}\n\nfunction strToPrivateKey(str) {\n    const parsed = JSON.parse(str);\n    if (!Array.isArray(parsed) || parsed.length !== 2) {\n        throw new Error('Invalid input string');\n    }\n    const [first, second] = parsed.map((value) => {\n        if (typeof value === 'string' || typeof value === 'number') {\n            return BigInt(value);\n        }\n        throw new Error('Invalid number format');\n    });\n    return [first, second];\n}\nfunction privateKeyToStr(key) {\n    try {\n        return JSON.stringify(key.map((v) => v.toString()));\n    }\n    catch (error) {\n        throw error;\n    }\n}\n\nclass Metadata {\n    nodeStorage = {};\n    initialized = false;\n    isBrowser = typeof window !== 'undefined' &&\n        typeof window.localStorage !== 'undefined';\n    storagePrefix = '0g_metadata_';\n    constructor() { }\n    async initialize() {\n        if (this.initialized) {\n            return;\n        }\n        if (!this.isBrowser) {\n            this.nodeStorage = {};\n        }\n        this.initialized = true;\n    }\n    async setItem(key, value) {\n        await this.initialize();\n        const fullKey = this.storagePrefix + key;\n        if (this.isBrowser) {\n            try {\n                console.log('Setting localStorage item:', fullKey, value);\n                window.localStorage.setItem(fullKey, value);\n            }\n            catch (e) {\n                console.warn('Failed to set localStorage item:', e);\n                this.nodeStorage[key] = value;\n            }\n        }\n        else {\n            this.nodeStorage[key] = value;\n        }\n    }\n    async getItem(key) {\n        await this.initialize();\n        const fullKey = this.storagePrefix + key;\n        if (this.isBrowser) {\n            try {\n                return window.localStorage.getItem(fullKey);\n            }\n            catch (e) {\n                console.warn('Failed to get localStorage item:', e);\n                return this.nodeStorage[key] ?? null;\n            }\n        }\n        else {\n            return this.nodeStorage[key] ?? null;\n        }\n    }\n    async storeSettleSignerPrivateKey(key, value) {\n        const bigIntStringArray = value.map((bi) => bi.toString());\n        const bigIntJsonString = JSON.stringify(bigIntStringArray);\n        await this.setItem(`${key}_settleSignerPrivateKey`, bigIntJsonString);\n    }\n    async storeSigningKey(key, value) {\n        await this.setItem(`${key}_signingKey`, value);\n    }\n    async getSettleSignerPrivateKey(key) {\n        const value = await this.getItem(`${key}_settleSignerPrivateKey`);\n        if (!value) {\n            return null;\n        }\n        const bigIntStringArray = JSON.parse(value);\n        return bigIntStringArray.map((str) => BigInt(str));\n    }\n    async getSigningKey(key) {\n        const value = await this.getItem(`${key}_signingKey`);\n        return value ?? null;\n    }\n}\n\nvar CacheValueTypeEnum;\n(function (CacheValueTypeEnum) {\n    CacheValueTypeEnum[\"Service\"] = \"service\";\n    CacheValueTypeEnum[\"BigInt\"] = \"bigint\";\n    CacheValueTypeEnum[\"Other\"] = \"other\";\n})(CacheValueTypeEnum || (CacheValueTypeEnum = {}));\nclass Cache {\n    nodeStorage = {};\n    initialized = false;\n    isBrowser = typeof window !== 'undefined' &&\n        typeof window.localStorage !== 'undefined';\n    storagePrefix = '0g_cache_';\n    constructor() { }\n    setLock(key, value, ttl, type) {\n        this.initialize();\n        if (this.getStorageItem(key)) {\n            return false;\n        }\n        this.setItem(key, value, ttl, type);\n        return true;\n    }\n    removeLock(key) {\n        this.initialize();\n        this.removeStorageItem(key);\n    }\n    setItem(key, value, ttl, type) {\n        this.initialize();\n        const now = new Date();\n        const item = {\n            type,\n            value: Cache.encodeValue(value),\n            expiry: now.getTime() + ttl,\n        };\n        this.setStorageItem(key, JSON.stringify(item));\n    }\n    getItem(key) {\n        this.initialize();\n        const itemStr = this.getStorageItem(key);\n        if (!itemStr) {\n            return null;\n        }\n        const item = JSON.parse(itemStr);\n        const now = new Date();\n        if (now.getTime() > item.expiry) {\n            this.removeStorageItem(key);\n            return null;\n        }\n        return Cache.decodeValue(item.value, item.type);\n    }\n    initialize() {\n        if (this.initialized) {\n            return;\n        }\n        if (!this.isBrowser) {\n            this.nodeStorage = {};\n        }\n        else {\n            this.cleanupExpiredItems();\n        }\n        this.initialized = true;\n    }\n    setStorageItem(key, value) {\n        const fullKey = this.storagePrefix + key;\n        if (this.isBrowser) {\n            try {\n                window.localStorage.setItem(fullKey, value);\n            }\n            catch (e) {\n                console.warn('Failed to set localStorage item:', e);\n                this.nodeStorage[key] = value;\n            }\n        }\n        else {\n            this.nodeStorage[key] = value;\n        }\n    }\n    getStorageItem(key) {\n        const fullKey = this.storagePrefix + key;\n        if (this.isBrowser) {\n            try {\n                return window.localStorage.getItem(fullKey);\n            }\n            catch (e) {\n                console.warn('Failed to get localStorage item:', e);\n                return this.nodeStorage[key] ?? null;\n            }\n        }\n        else {\n            return this.nodeStorage[key] ?? null;\n        }\n    }\n    removeStorageItem(key) {\n        const fullKey = this.storagePrefix + key;\n        if (this.isBrowser) {\n            try {\n                window.localStorage.removeItem(fullKey);\n            }\n            catch (e) {\n                console.warn('Failed to remove localStorage item:', e);\n                delete this.nodeStorage[key];\n            }\n        }\n        else {\n            delete this.nodeStorage[key];\n        }\n    }\n    cleanupExpiredItems() {\n        if (!this.isBrowser)\n            return;\n        try {\n            const keysToRemove = [];\n            for (let i = 0; i < window.localStorage.length; i++) {\n                const key = window.localStorage.key(i);\n                if (key && key.startsWith(this.storagePrefix)) {\n                    const itemStr = window.localStorage.getItem(key);\n                    if (itemStr) {\n                        try {\n                            const item = JSON.parse(itemStr);\n                            if (new Date().getTime() > item.expiry) {\n                                keysToRemove.push(key);\n                            }\n                        }\n                        catch (e) {\n                            keysToRemove.push(key);\n                        }\n                    }\n                }\n            }\n            keysToRemove.forEach((key) => window.localStorage.removeItem(key));\n        }\n        catch (e) {\n            console.warn('Failed to cleanup expired items:', e);\n        }\n    }\n    static encodeValue(value) {\n        return JSON.stringify(value, (_, val) => typeof val === 'bigint' ? `${val.toString()}n` : val);\n    }\n    static decodeValue(encodedValue, type) {\n        let ret = JSON.parse(encodedValue, (_, val) => {\n            if (typeof val === 'string' && /^\\d+n$/.test(val)) {\n                return BigInt(val.slice(0, -1));\n            }\n            return val;\n        });\n        if (type === CacheValueTypeEnum.Service) {\n            return Cache.createServiceStructOutput(ret);\n        }\n        return ret;\n    }\n    static createServiceStructOutput(fields) {\n        const tuple = fields;\n        const object = {\n            provider: fields[0],\n            serviceType: fields[1],\n            url: fields[2],\n            inputPrice: fields[3],\n            outputPrice: fields[4],\n            updatedAt: fields[5],\n            model: fields[6],\n            verifiability: fields[7],\n            additionalInfo: fields[8],\n        };\n        return Object.assign(tuple, object);\n    }\n}\n\nasync function getNonceWithCache(cache) {\n    const lockKey = 'nonce_lock';\n    const nonceKey = 'nonce';\n    while (!(await acquireLock(cache, lockKey))) {\n        await delay(10);\n    }\n    try {\n        const now = new Date();\n        const lastNonce = cache.getItem(nonceKey) || 0;\n        let nonce = now.getTime() * 10000 + 40;\n        if (lastNonce >= nonce) {\n            nonce = lastNonce + 40;\n        }\n        cache.setItem(nonceKey, nonce, 10000000 * 60 * 1000, CacheValueTypeEnum.Other);\n        return nonce;\n    }\n    finally {\n        await releaseLock(cache, lockKey);\n    }\n}\nfunction getNonce() {\n    const now = new Date();\n    return now.getTime() * 10000 + 40;\n}\nasync function acquireLock(cache, key) {\n    const lock = await cache.setLock(key, 'true', 1000, CacheValueTypeEnum.Other);\n    return lock;\n}\nasync function releaseLock(cache, key) {\n    await cache.removeLock(key);\n}\nfunction delay(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/* Autogenerated file. Do not edit manually. */\n/* tslint:disable */\n/* eslint-disable */\nconst _abi$2 = [\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n        ],\n        name: 'InsufficientBalance',\n        type: 'error',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n        ],\n        name: 'LedgerExists',\n        type: 'error',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n        ],\n        name: 'LedgerNotExists',\n        type: 'error',\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'previousOwner',\n                type: 'address',\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'newOwner',\n                type: 'address',\n            },\n        ],\n        name: 'OwnershipTransferred',\n        type: 'event',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'uint256[2]',\n                name: 'inferenceSigner',\n                type: 'uint256[2]',\n            },\n            {\n                internalType: 'string',\n                name: 'additionalInfo',\n                type: 'string',\n            },\n        ],\n        name: 'addLedger',\n        outputs: [\n            {\n                internalType: 'uint256',\n                name: '',\n                type: 'uint256',\n            },\n            {\n                internalType: 'uint256',\n                name: '',\n                type: 'uint256',\n            },\n        ],\n        stateMutability: 'payable',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'deleteLedger',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'depositFund',\n        outputs: [],\n        stateMutability: 'payable',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'fineTuningAddress',\n        outputs: [\n            {\n                internalType: 'address payable',\n                name: '',\n                type: 'address',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'getAllLedgers',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'user',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'availableBalance',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'totalBalance',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256[2]',\n                        name: 'inferenceSigner',\n                        type: 'uint256[2]',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'address[]',\n                        name: 'inferenceProviders',\n                        type: 'address[]',\n                    },\n                    {\n                        internalType: 'address[]',\n                        name: 'fineTuningProviders',\n                        type: 'address[]',\n                    },\n                ],\n                internalType: 'struct Ledger[]',\n                name: 'ledgers',\n                type: 'tuple[]',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n        ],\n        name: 'getLedger',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'user',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'availableBalance',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'totalBalance',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256[2]',\n                        name: 'inferenceSigner',\n                        type: 'uint256[2]',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'address[]',\n                        name: 'inferenceProviders',\n                        type: 'address[]',\n                    },\n                    {\n                        internalType: 'address[]',\n                        name: 'fineTuningProviders',\n                        type: 'address[]',\n                    },\n                ],\n                internalType: 'struct Ledger',\n                name: '',\n                type: 'tuple',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'inferenceAddress',\n        outputs: [\n            {\n                internalType: 'address payable',\n                name: '',\n                type: 'address',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: '_inferenceAddress',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: '_fineTuningAddress',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'owner',\n                type: 'address',\n            },\n        ],\n        name: 'initialize',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'initialized',\n        outputs: [\n            {\n                internalType: 'bool',\n                name: '',\n                type: 'bool',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'owner',\n        outputs: [\n            {\n                internalType: 'address',\n                name: '',\n                type: 'address',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'uint256',\n                name: 'amount',\n                type: 'uint256',\n            },\n        ],\n        name: 'refund',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'renounceOwnership',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address[]',\n                name: 'providers',\n                type: 'address[]',\n            },\n            {\n                internalType: 'string',\n                name: 'serviceType',\n                type: 'string',\n            },\n        ],\n        name: 'retrieveFund',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'uint256',\n                name: 'amount',\n                type: 'uint256',\n            },\n        ],\n        name: 'spendFund',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                internalType: 'string',\n                name: 'serviceTypeStr',\n                type: 'string',\n            },\n            {\n                internalType: 'uint256',\n                name: 'amount',\n                type: 'uint256',\n            },\n        ],\n        name: 'transferFund',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'newOwner',\n                type: 'address',\n            },\n        ],\n        name: 'transferOwnership',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        stateMutability: 'payable',\n        type: 'receive',\n    },\n];\nconst _bytecode$2 = '0x608060405234801561001057600080fd5b5061001a33610023565b60018055610073565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b61239a806100826000396000f3fe6080604052600436106100f75760003560e01c806372adc0d91161008a578063dd8a411811610059578063dd8a41181461028d578063e5d9fdab146102ad578063f2fde38b146102cd578063f7cd6af9146102ed57600080fd5b806372adc0d91461021f5780638d0d8cb6146102475780638da5cb5b1461024f578063c0c53b8b1461026d57600080fd5b806331404a19116100c657806331404a191461019d578063382e1112146101bd578063410b3815146101f5578063715018a61461020a57600080fd5b8063158ef93e146101035780631665c79b14610139578063278ecde11461015b5780632ba43b821461017d57600080fd5b366100fe57005b600080fd5b34801561010f57600080fd5b5060005461012490600160a01b900460ff1681565b60405190151581526020015b60405180910390f35b34801561014557600080fd5b5061014e61031a565b6040516101309190611c75565b34801561016757600080fd5b5061017b610176366004611cd7565b61057d565b005b34801561018957600080fd5b5061017b610198366004611dc3565b61068c565b3480156101a957600080fd5b5061017b6101b8366004611e1a565b610a62565b3480156101c957600080fd5b506003546101dd906001600160a01b031681565b6040516001600160a01b039091168152602001610130565b34801561020157600080fd5b5061017b610c7e565b34801561021657600080fd5b5061017b610ef4565b61023261022d366004611ee9565b610f06565b60408051928352602083019190915201610130565b61017b610fc4565b34801561025b57600080fd5b506000546001600160a01b03166101dd565b34801561027957600080fd5b5061017b610288366004611f32565b611074565b34801561029957600080fd5b5061017b6102a8366004611f75565b61113e565b3480156102b957600080fd5b506002546101dd906001600160a01b031681565b3480156102d957600080fd5b5061017b6102e8366004611f9f565b61124e565b3480156102f957600080fd5b5061030d610308366004611f9f565b6112c7565b6040516101309190611fba565b60606000610326611496565b90508067ffffffffffffffff81111561034157610341611d0c565b60405190808252806020026020018201604052801561037a57816020015b610367611a26565b81526020019060019003908161035f5790505b50915060005b8181101561057857610391816114a7565b6040805160e08101825282546001600160a01b031681526001830154602082015260028084015482840152825180840193849052919392606085019291600385019182845b8154815260200190600101908083116103d6575050505050815260200160058201805461040290611fcd565b80601f016020809104026020016040519081016040528092919081815260200182805461042e90611fcd565b801561047b5780601f106104505761010080835404028352916020019161047b565b820191906000526020600020905b81548152906001019060200180831161045e57829003601f168201915b50505050508152602001600682018054806020026020016040519081016040528092919081815260200182805480156104dd57602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116104bf575b505050505081526020016007820180548060200260200160405190810160405280929190818152602001828054801561053f57602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610521575b50505050508152505083828151811061055a5761055a612007565b6020026020010181905250808061057090612033565b915050610380565b505090565b336000610589826114ca565b60008181526007602052604090205490915060ff16156105c45760405162461bcd60e51b81526004016105bb9061204c565b60405180910390fd5b6000818152600760205260408120805460ff191660011790556105e6336114fe565b9050838160010154101561060f5760405163112fed8b60e31b81523360048201526024016105bb565b838160010160008282546106239190612083565b925050819055508381600201600082825461063e9190612083565b9091555050604051339085156108fc029086906000818181858888f19350505050158015610670573d6000803e3d6000fd5b50506000908152600760205260409020805460ff191690555050565b610694611551565b3360006106a0826114ca565b60008181526007602052604090205490915060ff16156106d25760405162461bcd60e51b81526004016105bb9061204c565b6000818152600760205260408120805460ff191660011790556106f4336114fe565b90506000806000610704886115aa565b60405163147500e360e01b81523360048201526001600160a01b038d81166024830152939650919450925088916060919085169063147500e390604401602060405180830381865afa15801561075e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107829190612096565b1561086e57604051631320b9eb60e11b81523360048201526001600160a01b038c811660248301526000919086169063264173d690604401602060405180830381865afa1580156107d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107fb91906120bf565b905060006108098b836116ab565b90506108158185612083565b6040513360248201526001600160a01b038f1660448201526064810183905290945060840160408051601f198184030181529190526020810180516001600160e01b031663745e87f760e01b1790529250610922915050565b826000036108d157338b87600301886005016040516024016108939493929190612155565b60408051601f198184030181529190526020810180516001600160e01b03166312f0ebfd60e21b17905290506108cc600687018c6116c5565b610922565b338b876005016040516024016108e9939291906121b7565b60408051601f198184030181529190526020810180516001600160e01b031663e50688f960e01b1790529050610922600787018c6116c5565b818660010154101561096d5760405162461bcd60e51b8152602060048201526014602482015273496e73756666696369656e742062616c616e636560601b60448201526064016105bb565b818660010160008282546109819190612083565b925050819055506000856001600160a01b031683836040516109a391906121e3565b60006040518083038185875af1925050503d80600081146109e0576040519150601f19603f3d011682016040523d82523d6000602084013e6109e5565b606091505b5050905080610a365760405162461bcd60e51b815260206004820152601d60248201527f43616c6c20746f206368696c6420636f6e7472616374206661696c656400000060448201526064016105bb565b505050600094855250506007602052505060409020805460ff1916905550610a5d60018055565b505050565b610a6a611551565b336000610a76826114ca565b60008181526007602052604090205490915060ff1615610aa85760405162461bcd60e51b81526004016105bb9061204c565b6000818152600760205260408120805460ff19166001179055610aca846115aa565b509150506000610ad9336114fe565b90506000805b8751811015610c3d576000846001600160a01b0316634e3c4f22338b8581518110610b0c57610b0c612007565b60200260200101516040518363ffffffff1660e01b8152600401610b469291906001600160a01b0392831681529116602082015260400190565b6060604051808303816000875af1158015610b65573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b8991906121ff565b505090508083610b99919061222d565b9250846001600160a01b0316636c79158d338b8581518110610bbd57610bbd612007565b60200260200101516040518363ffffffff1660e01b8152600401610bf79291906001600160a01b0392831681529116602082015260400190565b600060405180830381600087803b158015610c1157600080fd5b505af1158015610c25573d6000803e3d6000fd5b50505050508080610c3590612033565b915050610adf565b5080826001016000828254610c52919061222d565b90915550505060009283525050600760205260409020805460ff1916905550610c7a60018055565b5050565b610c86611551565b336000610c92826114ca565b60008181526007602052604090205490915060ff1615610cc45760405162461bcd60e51b81526004016105bb9061204c565b6000818152600760205260408120805460ff19166001179055610ce6336114ca565b90506000610cf3336114fe565b905060005b6006820154811015610da9576009546006830180546001600160a01b0390921691639721672591339185908110610d3157610d31612007565b60009182526020909120015460405160e084901b6001600160e01b03191681526001600160a01b03928316600482015291166024820152604401600060405180830381600087803b158015610d8557600080fd5b505af1925050508015610d96575060015b5080610da181612033565b915050610cf8565b5060005b6007820154811015610e5e576008546007830180546001600160a01b0390921691639721672591339185908110610de657610de6612007565b60009182526020909120015460405160e084901b6001600160e01b03191681526001600160a01b03928316600482015291166024820152604401600060405180830381600087803b158015610e3a57600080fd5b505af1925050508015610e4b575060015b5080610e5681612033565b915050610dad565b50610e6a600483611753565b50600082815260066020526040812080546001600160a01b03191681556001810182905560028101829055600381018290556004810182905590610eb2600583016000611a72565b610ec0600683016000611aac565b610ece600783016000611aac565b505050600091825250600760205260409020805460ff1916905550610ef260018055565b565b610efc61175f565b610ef260006117b9565b600080336000610f15826114ca565b60008181526007602052604090205490915060ff1615610f475760405162461bcd60e51b81526004016105bb9061204c565b6000818152600760205260408120805460ff19166001179055610f69336114ca565b9050610f7481611809565b15610f945760405163cde58aa160e01b81523360048201526024016105bb565b610fa1813389348a611816565b506000908152600760205260408120805460ff1916905534969095509350505050565b336000610fd0826114ca565b60008181526007602052604090205490915060ff16156110025760405162461bcd60e51b81526004016105bb9061204c565b6000818152600760205260408120805460ff19166001179055611024336114fe565b90503481600101600082825461103a919061222d565b9250508190555034816002016000828254611055919061222d565b9091555050506000908152600760205260409020805460ff1916905550565b600054600160a01b900460ff16156110d95760405162461bcd60e51b815260206004820152602260248201527f496e697469616c697a61626c653a20616c726561647920696e697469616c697a604482015261195960f21b60648201526084016105bb565b6000805460ff60a01b1916600160a01b1790556110f5816117b9565b50600280546001600160a01b039384166001600160a01b031991821681179092556003805493909416928116831790935560088054841690921790915560098054909216179055565b6003546001600160a01b031633148061116157506002546001600160a01b031633145b6111c95760405162461bcd60e51b815260206004820152603360248201527f43616c6c6572206973206e6f74207468652066696e652074756e696e67206f72604482015272081a5b99995c995b98d94818dbdb9d1c9858dd606a1b60648201526084016105bb565b60006111d4836114fe565b905081816001015482600201546111eb9190612083565b10156112305760405162461bcd60e51b8152602060048201526014602482015273496e73756666696369656e742062616c616e636560601b60448201526064016105bb565b818160020160008282546112449190612083565b9091555050505050565b61125661175f565b6001600160a01b0381166112bb5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016105bb565b6112c4816117b9565b50565b6112cf611a26565b6112d8826114fe565b6040805160e08101825282546001600160a01b031681526001830154602082015260028084015482840152825180840193849052919392606085019291600385019182845b81548152602001906001019080831161131d575050505050815260200160058201805461134990611fcd565b80601f016020809104026020016040519081016040528092919081815260200182805461137590611fcd565b80156113c25780601f10611397576101008083540402835291602001916113c2565b820191906000526020600020905b8154815290600101906020018083116113a557829003601f168201915b505050505081526020016006820180548060200260200160405190810160405280929190818152602001828054801561142457602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311611406575b505050505081526020016007820180548060200260200160405190810160405280929190818152602001828054801561148657602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311611468575b5050505050815250509050919050565b60006114a26004611880565b905090565b6000806114b560048461188a565b60009081526006602052604090209392505050565b604080516001600160a01b038316602082015260009101604051602081830303815290604052805190602001209050919050565b60008061150a836114ca565b905061151581611809565b61153d57604051637d2d536b60e01b81526001600160a01b03841660048201526024016105bb565b600090815260066020526040902092915050565b6002600154036115a35760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016105bb565b6002600155565b600080600080846040516020016115c191906121e3565b6040516020818303038152906040528051906020012090507f2a52b6261f3850b89541ab4444869004fe552e50532808641800076f8e9ec465810361161f5750506002546009546001600160a01b03918216935016905060006116a4565b7f37f0d1f2303720bab95e3c739b15188d8c19fade32eb63f80ef3d06b64daa9d281036116655750506003546008546001600160a01b03918216935016905060016116a4565b60405162461bcd60e51b8152602060048201526014602482015273496e76616c69642073657276696365207479706560601b60448201526064016105bb565b9193909250565b60008183106116ba57816116bc565b825b90505b92915050565b60005b825481101561171e57816001600160a01b03168382815481106116ed576116ed612007565b6000918252602090912001546001600160a01b03160361170c57505050565b8061171681612033565b9150506116c8565b5081546001810183556000928352602090922090910180546001600160a01b0319166001600160a01b03909216919091179055565b60006116bc8383611896565b6000546001600160a01b03163314610ef25760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016105bb565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60006116bf600483611989565b600085815260066020526040902060018101839055600280820184905581546001600160a01b0319166001600160a01b03871617825561185c9060038301908690611aca565b506005810161186b838261228e565b506118776004876119a1565b50505050505050565b60006116bf825490565b60006116bc83836119ad565b6000818152600183016020526040812054801561197f5760006118ba600183612083565b85549091506000906118ce90600190612083565b90508181146119335760008660000182815481106118ee576118ee612007565b906000526020600020015490508087600001848154811061191157611911612007565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806119445761194461234e565b6001900381819060005260206000200160009055905585600101600086815260200190815260200160002060009055600193505050506116bf565b60009150506116bf565b600081815260018301602052604081205415156116bc565b60006116bc83836119d7565b60008260000182815481106119c4576119c4612007565b9060005260206000200154905092915050565b6000818152600183016020526040812054611a1e575081546001818101845560008481526020808220909301849055845484825282860190935260409020919091556116bf565b5060006116bf565b6040518060e0016040528060006001600160a01b031681526020016000815260200160008152602001611a57611b08565b81526020016060815260200160608152602001606081525090565b508054611a7e90611fcd565b6000825580601f10611a8e575050565b601f0160209004906000526020600020908101906112c49190611b26565b50805460008255906000526020600020908101906112c49190611b26565b8260028101928215611af8579160200282015b82811115611af8578235825591602001919060010190611add565b50611b04929150611b26565b5090565b60405180604001604052806002906020820280368337509192915050565b5b80821115611b045760008155600101611b27565b60005b83811015611b56578181015183820152602001611b3e565b50506000910152565b60008151808452611b77816020860160208601611b3b565b601f01601f19169290920160200192915050565b600081518084526020808501945080840160005b83811015611bc45781516001600160a01b031687529582019590820190600101611b9f565b509495945050505050565b600061010060018060a01b038351168452602080840151818601526040840151604086015260608401516060860160005b6002811015611c1d57825182529183019190830190600101611c00565b5050505060808301518160a0860152611c3882860182611b5f565b91505060a083015184820360c0860152611c528282611b8b565b91505060c083015184820360e0860152611c6c8282611b8b565b95945050505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b82811015611cca57603f19888603018452611cb8858351611bcf565b94509285019290850190600101611c9c565b5092979650505050505050565b600060208284031215611ce957600080fd5b5035919050565b80356001600160a01b0381168114611d0757600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611d4b57611d4b611d0c565b604052919050565b600082601f830112611d6457600080fd5b813567ffffffffffffffff811115611d7e57611d7e611d0c565b611d91601f8201601f1916602001611d22565b818152846020838601011115611da657600080fd5b816020850160208301376000918101602001919091529392505050565b600080600060608486031215611dd857600080fd5b611de184611cf0565b9250602084013567ffffffffffffffff811115611dfd57600080fd5b611e0986828701611d53565b925050604084013590509250925092565b60008060408385031215611e2d57600080fd5b823567ffffffffffffffff80821115611e4557600080fd5b818501915085601f830112611e5957600080fd5b8135602082821115611e6d57611e6d611d0c565b8160051b611e7c828201611d22565b928352848101820192828101908a851115611e9657600080fd5b958301955b84871015611ebb57611eac87611cf0565b82529583019590830190611e9b565b9750505086013592505080821115611ed257600080fd5b50611edf85828601611d53565b9150509250929050565b60008060608385031215611efc57600080fd5b6040830184811115611f0d57600080fd5b8392503567ffffffffffffffff811115611f2657600080fd5b611edf85828601611d53565b600080600060608486031215611f4757600080fd5b611f5084611cf0565b9250611f5e60208501611cf0565b9150611f6c60408501611cf0565b90509250925092565b60008060408385031215611f8857600080fd5b611f9183611cf0565b946020939093013593505050565b600060208284031215611fb157600080fd5b6116bc82611cf0565b6020815260006116bc6020830184611bcf565b600181811c90821680611fe157607f821691505b60208210810361200157634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016120455761204561201d565b5060010190565b6020808252601b908201527f4c6564676572206c6f636b656420666f72206f7065726174696f6e0000000000604082015260600190565b818103818111156116bf576116bf61201d565b6000602082840312156120a857600080fd5b815180151581146120b857600080fd5b9392505050565b6000602082840312156120d157600080fd5b5051919050565b600081546120e581611fcd565b808552602060018381168015612102576001811461211c5761214a565b60ff1985168884015283151560051b88018301955061214a565b866000528260002060005b858110156121425781548a8201860152908301908401612127565b890184019650505b505050505092915050565b6001600160a01b0385811682528416602080830191909152600090604083019085835b600281101561219557815484529282019260019182019101612178565b5050505060a060808301526121ad60a08301846120d8565b9695505050505050565b6001600160a01b03848116825283166020820152606060408201819052600090611c6c908301846120d8565b600082516121f5818460208701611b3b565b9190910192915050565b60008060006060848603121561221457600080fd5b8351925060208401519150604084015190509250925092565b808201808211156116bf576116bf61201d565b601f821115610a5d57600081815260208120601f850160051c810160208610156122675750805b601f850160051c820191505b8181101561228657828155600101612273565b505050505050565b815167ffffffffffffffff8111156122a8576122a8611d0c565b6122bc816122b68454611fcd565b84612240565b602080601f8311600181146122f157600084156122d95750858301515b600019600386901b1c1916600185901b178555612286565b600085815260208120601f198616915b8281101561232057888601518255948401946001909101908401612301565b508582101561233e5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b634e487b7160e01b600052603160045260246000fdfea2646970667358221220c47c96a81d1816b037e4fa3e2212b80c51464e9930815755d937d55ceed6bf4864736f6c63430008140033';\nconst isSuperArgs$2 = (xs) => xs.length > 1;\nclass LedgerManager__factory extends ethers__WEBPACK_IMPORTED_MODULE_11__.ContractFactory {\n    constructor(...args) {\n        if (isSuperArgs$2(args)) {\n            super(...args);\n        }\n        else {\n            super(_abi$2, _bytecode$2, args[0]);\n        }\n    }\n    getDeployTransaction(overrides) {\n        return super.getDeployTransaction(overrides || {});\n    }\n    deploy(overrides) {\n        return super.deploy(overrides || {});\n    }\n    connect(runner) {\n        return super.connect(runner);\n    }\n    static bytecode = _bytecode$2;\n    static abi = _abi$2;\n    static createInterface() {\n        return new ethers__WEBPACK_IMPORTED_MODULE_12__.Interface(_abi$2);\n    }\n    static connect(address, runner) {\n        return new ethers__WEBPACK_IMPORTED_MODULE_13__.Contract(address, _abi$2, runner);\n    }\n}\n\n/* Autogenerated file. Do not edit manually. */\n/* tslint:disable */\n/* eslint-disable */\nconst _abi$1 = [\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'AccountExists',\n        type: 'error',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'AccountNotExists',\n        type: 'error',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'string',\n                name: 'reason',\n                type: 'string',\n            },\n        ],\n        name: 'InvalidProofInputs',\n        type: 'error',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'ServiceNotExist',\n        type: 'error',\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                indexed: false,\n                internalType: 'uint256',\n                name: 'amount',\n                type: 'uint256',\n            },\n            {\n                indexed: false,\n                internalType: 'uint256',\n                name: 'pendingRefund',\n                type: 'uint256',\n            },\n        ],\n        name: 'BalanceUpdated',\n        type: 'event',\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'previousOwner',\n                type: 'address',\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'newOwner',\n                type: 'address',\n            },\n        ],\n        name: 'OwnershipTransferred',\n        type: 'event',\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                indexed: true,\n                internalType: 'uint256',\n                name: 'index',\n                type: 'uint256',\n            },\n            {\n                indexed: false,\n                internalType: 'uint256',\n                name: 'timestamp',\n                type: 'uint256',\n            },\n        ],\n        name: 'RefundRequested',\n        type: 'event',\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'service',\n                type: 'address',\n            },\n        ],\n        name: 'ServiceRemoved',\n        type: 'event',\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'service',\n                type: 'address',\n            },\n            {\n                indexed: false,\n                internalType: 'string',\n                name: 'serviceType',\n                type: 'string',\n            },\n            {\n                indexed: false,\n                internalType: 'string',\n                name: 'url',\n                type: 'string',\n            },\n            {\n                indexed: false,\n                internalType: 'uint256',\n                name: 'inputPrice',\n                type: 'uint256',\n            },\n            {\n                indexed: false,\n                internalType: 'uint256',\n                name: 'outputPrice',\n                type: 'uint256',\n            },\n            {\n                indexed: false,\n                internalType: 'uint256',\n                name: 'updatedAt',\n                type: 'uint256',\n            },\n            {\n                indexed: false,\n                internalType: 'string',\n                name: 'model',\n                type: 'string',\n            },\n            {\n                indexed: false,\n                internalType: 'string',\n                name: 'verifiability',\n                type: 'string',\n            },\n        ],\n        name: 'ServiceUpdated',\n        type: 'event',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'accountExists',\n        outputs: [\n            {\n                internalType: 'bool',\n                name: '',\n                type: 'bool',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                internalType: 'uint256[2]',\n                name: 'providerPubKey',\n                type: 'uint256[2]',\n            },\n        ],\n        name: 'acknowledgeProviderSigner',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                internalType: 'uint256[2]',\n                name: 'signer',\n                type: 'uint256[2]',\n            },\n            {\n                internalType: 'string',\n                name: 'additionalInfo',\n                type: 'string',\n            },\n        ],\n        name: 'addAccount',\n        outputs: [],\n        stateMutability: 'payable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                components: [\n                    {\n                        internalType: 'string',\n                        name: 'serviceType',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'url',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'model',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'verifiability',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'inputPrice',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'outputPrice',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                ],\n                internalType: 'struct ServiceParams',\n                name: 'params',\n                type: 'tuple',\n            },\n        ],\n        name: 'addOrUpdateService',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'batchVerifierAddress',\n        outputs: [\n            {\n                internalType: 'address',\n                name: '',\n                type: 'address',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'deleteAccount',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                internalType: 'uint256',\n                name: 'cancelRetrievingAmount',\n                type: 'uint256',\n            },\n        ],\n        name: 'depositFund',\n        outputs: [],\n        stateMutability: 'payable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'getAccount',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'user',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'provider',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nonce',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'balance',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'pendingRefund',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256[2]',\n                        name: 'signer',\n                        type: 'uint256[2]',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'uint256',\n                                name: 'index',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'amount',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'createdAt',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'processed',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Refund[]',\n                        name: 'refunds',\n                        type: 'tuple[]',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'uint256[2]',\n                        name: 'providerPubKey',\n                        type: 'uint256[2]',\n                    },\n                ],\n                internalType: 'struct Account',\n                name: '',\n                type: 'tuple',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                internalType: 'uint256',\n                name: 'offset',\n                type: 'uint256',\n            },\n            {\n                internalType: 'uint256',\n                name: 'limit',\n                type: 'uint256',\n            },\n        ],\n        name: 'getAccountsByProvider',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'user',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'provider',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nonce',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'balance',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'pendingRefund',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256[2]',\n                        name: 'signer',\n                        type: 'uint256[2]',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'uint256',\n                                name: 'index',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'amount',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'createdAt',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'processed',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Refund[]',\n                        name: 'refunds',\n                        type: 'tuple[]',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'uint256[2]',\n                        name: 'providerPubKey',\n                        type: 'uint256[2]',\n                    },\n                ],\n                internalType: 'struct Account[]',\n                name: 'accounts',\n                type: 'tuple[]',\n            },\n            {\n                internalType: 'uint256',\n                name: 'total',\n                type: 'uint256',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'uint256',\n                name: 'offset',\n                type: 'uint256',\n            },\n            {\n                internalType: 'uint256',\n                name: 'limit',\n                type: 'uint256',\n            },\n        ],\n        name: 'getAccountsByUser',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'user',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'provider',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nonce',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'balance',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'pendingRefund',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256[2]',\n                        name: 'signer',\n                        type: 'uint256[2]',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'uint256',\n                                name: 'index',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'amount',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'createdAt',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'processed',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Refund[]',\n                        name: 'refunds',\n                        type: 'tuple[]',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'uint256[2]',\n                        name: 'providerPubKey',\n                        type: 'uint256[2]',\n                    },\n                ],\n                internalType: 'struct Account[]',\n                name: 'accounts',\n                type: 'tuple[]',\n            },\n            {\n                internalType: 'uint256',\n                name: 'total',\n                type: 'uint256',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'getAllAccounts',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'user',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'provider',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nonce',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'balance',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'pendingRefund',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256[2]',\n                        name: 'signer',\n                        type: 'uint256[2]',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'uint256',\n                                name: 'index',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'amount',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'createdAt',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'processed',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Refund[]',\n                        name: 'refunds',\n                        type: 'tuple[]',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'uint256[2]',\n                        name: 'providerPubKey',\n                        type: 'uint256[2]',\n                    },\n                ],\n                internalType: 'struct Account[]',\n                name: '',\n                type: 'tuple[]',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'getAllServices',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'provider',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'serviceType',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'url',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'inputPrice',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'outputPrice',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'updatedAt',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'model',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'verifiability',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                ],\n                internalType: 'struct Service[]',\n                name: 'services',\n                type: 'tuple[]',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address[]',\n                name: 'users',\n                type: 'address[]',\n            },\n        ],\n        name: 'getBatchAccountsByUsers',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'user',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'provider',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nonce',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'balance',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'pendingRefund',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256[2]',\n                        name: 'signer',\n                        type: 'uint256[2]',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'uint256',\n                                name: 'index',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'amount',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'createdAt',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'processed',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Refund[]',\n                        name: 'refunds',\n                        type: 'tuple[]',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'uint256[2]',\n                        name: 'providerPubKey',\n                        type: 'uint256[2]',\n                    },\n                ],\n                internalType: 'struct Account[]',\n                name: 'accounts',\n                type: 'tuple[]',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'getPendingRefund',\n        outputs: [\n            {\n                internalType: 'uint256',\n                name: '',\n                type: 'uint256',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'getService',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'provider',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'serviceType',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'url',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'inputPrice',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'outputPrice',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'updatedAt',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'model',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'verifiability',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                ],\n                internalType: 'struct Service',\n                name: 'service',\n                type: 'tuple',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'uint256',\n                name: '_locktime',\n                type: 'uint256',\n            },\n            {\n                internalType: 'address',\n                name: '_batchVerifierAddress',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: '_ledgerAddress',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'owner',\n                type: 'address',\n            },\n        ],\n        name: 'initialize',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'initialized',\n        outputs: [\n            {\n                internalType: 'bool',\n                name: '',\n                type: 'bool',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'ledgerAddress',\n        outputs: [\n            {\n                internalType: 'address',\n                name: '',\n                type: 'address',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'lockTime',\n        outputs: [\n            {\n                internalType: 'uint256',\n                name: '',\n                type: 'uint256',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'owner',\n        outputs: [\n            {\n                internalType: 'address',\n                name: '',\n                type: 'address',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'processRefund',\n        outputs: [\n            {\n                internalType: 'uint256',\n                name: 'totalAmount',\n                type: 'uint256',\n            },\n            {\n                internalType: 'uint256',\n                name: 'balance',\n                type: 'uint256',\n            },\n            {\n                internalType: 'uint256',\n                name: 'pendingRefund',\n                type: 'uint256',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'removeService',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'renounceOwnership',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'requestRefundAll',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                components: [\n                    {\n                        internalType: 'uint256[]',\n                        name: 'inProof',\n                        type: 'uint256[]',\n                    },\n                    {\n                        internalType: 'uint256[]',\n                        name: 'proofInputs',\n                        type: 'uint256[]',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'numChunks',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256[]',\n                        name: 'segmentSize',\n                        type: 'uint256[]',\n                    },\n                ],\n                internalType: 'struct VerifierInput',\n                name: 'verifierInput',\n                type: 'tuple',\n            },\n        ],\n        name: 'settleFees',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'newOwner',\n                type: 'address',\n            },\n        ],\n        name: 'transferOwnership',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: '_batchVerifierAddress',\n                type: 'address',\n            },\n        ],\n        name: 'updateBatchVerifierAddress',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'uint256',\n                name: '_locktime',\n                type: 'uint256',\n            },\n        ],\n        name: 'updateLockTime',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n];\nconst _bytecode$1 = '0x60806040523480156200001157600080fd5b506200001d3362000023565b62000073565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b61492c80620000836000396000f3fe6080604052600436106101b75760003560e01c8063745e87f7116100ec578063ba16a7501161008a578063d9f4140b11610064578063d9f4140b146104fc578063f2fde38b1461051c578063fbfa4e111461053c578063fd5908471461055c57600080fd5b8063ba16a750146104a7578063bbee42d9146104c7578063d1d20056146104dc57600080fd5b806378c00436116100c657806378c00436146104295780638da5cb5b1461044957806394842d1414610467578063972167251461048757600080fd5b8063745e87f7146103d6578063746e78d7146103e9578063754d1d541461040957600080fd5b8063264173d6116101595780634e3c4f22116101335780634e3c4f22146103465780634fe63f4d146103815780636c79158d146103a1578063715018a6146103c157600080fd5b8063264173d6146102d9578063371c22c5146102f95780634bc3aff41461033157600080fd5b8063158ef93e11610195578063158ef93e1461023b57806315a523021461025c5780631d73b9f51461028957806321fe0f30146102b757600080fd5b806308e93d0a146101bc5780630d668087146101e7578063147500e31461020b575b600080fd5b3480156101c857600080fd5b506101d1610589565b6040516101de9190613f4a565b60405180910390f35b3480156101f357600080fd5b506101fd60015481565b6040519081526020016101de565b34801561021757600080fd5b5061022b610226366004613f79565b61059a565b60405190151581526020016101de565b34801561024757600080fd5b5060005461022b90600160a01b900460ff1681565b34801561026857600080fd5b5061027c610277366004613fac565b6105b1565b6040516101de9190614081565b34801561029557600080fd5b506102a96102a4366004614094565b6108e4565b6040516101de9291906140c7565b3480156102c357600080fd5b506102cc610952565b6040516101de91906140e9565b3480156102e557600080fd5b506101fd6102f4366004613f79565b61095e565b34801561030557600080fd5b50600254610319906001600160a01b031681565b6040516001600160a01b0390911681526020016101de565b61034461033f366004614172565b61096c565b005b34801561035257600080fd5b50610366610361366004613f79565b6109f8565b604080519384526020840192909252908201526060016101de565b34801561038d57600080fd5b506102a961039c366004614094565b610ac3565b3480156103ad57600080fd5b506103446103bc366004613f79565b610b20565b3480156103cd57600080fd5b50610344610da2565b6103446103e4366004614255565b610db6565b3480156103f557600080fd5b50610344610404366004613fac565b610e40565b34801561041557600080fd5b50610344610424366004614291565b610e74565b34801561043557600080fd5b506103446104443660046142de565b610f44565b34801561045557600080fd5b506000546001600160a01b0316610319565b34801561047357600080fd5b5061034461048236600461431f565b61162d565b34801561049357600080fd5b506103446104a2366004613f79565b6116b9565b3480156104b357600080fd5b506101d16104c2366004614359565b6116f3565b3480156104d357600080fd5b50610344611702565b3480156104e857600080fd5b50600354610319906001600160a01b031681565b34801561050857600080fd5b506103446105173660046143cd565b61173a565b34801561052857600080fd5b50610344610537366004613fac565b611747565b34801561054857600080fd5b506103446105573660046143f8565b6117c0565b34801561056857600080fd5b5061057c610577366004613f79565b6117cd565b6040516101de9190614411565b606061059560066119b2565b905090565b60006105a860068484611c2a565b90505b92915050565b6105b9613bc7565b6105c4600b83611c47565b60408051610120810190915281546001600160a01b031681526001820180549192916020840191906105f590614424565b80601f016020809104026020016040519081016040528092919081815260200182805461062190614424565b801561066e5780601f106106435761010080835404028352916020019161066e565b820191906000526020600020905b81548152906001019060200180831161065157829003601f168201915b5050505050815260200160028201805461068790614424565b80601f01602080910402602001604051908101604052809291908181526020018280546106b390614424565b80156107005780601f106106d557610100808354040283529160200191610700565b820191906000526020600020905b8154815290600101906020018083116106e357829003601f168201915b5050505050815260200160038201548152602001600482015481526020016005820154815260200160068201805461073790614424565b80601f016020809104026020016040519081016040528092919081815260200182805461076390614424565b80156107b05780601f10610785576101008083540402835291602001916107b0565b820191906000526020600020905b81548152906001019060200180831161079357829003601f168201915b505050505081526020016007820180546107c990614424565b80601f01602080910402602001604051908101604052809291908181526020018280546107f590614424565b80156108425780601f1061081757610100808354040283529160200191610842565b820191906000526020600020905b81548152906001019060200180831161082557829003601f168201915b5050505050815260200160088201805461085b90614424565b80601f016020809104026020016040519081016040528092919081815260200182805461088790614424565b80156108d45780601f106108a9576101008083540402835291602001916108d4565b820191906000526020600020905b8154815290600101906020018083116108b757829003601f168201915b5050505050815250509050919050565b606060008215806108f6575060328311155b6109395760405162461bcd60e51b815260206004820152600f60248201526e4c696d697420746f6f206c6172676560881b60448201526064015b60405180910390fd5b6109466006868686611c53565b91509150935093915050565b6060610595600b611f84565b60006105a860068484612343565b6003546001600160a01b031633146109965760405162461bcd60e51b81526004016109309061445e565b6000806109a86006878787348861235e565b91509150846001600160a01b0316866001600160a01b03166000805160206148d783398151915284846040516109e8929190918252602082015260400190565b60405180910390a3505050505050565b600354600090819081906001600160a01b03163314610a295760405162461bcd60e51b81526004016109309061445e565b600154610a3c9060069087908790612413565b919450925090508215610abc57604051339084156108fc029085906000818181858888f19350505050158015610a76573d6000803e3d6000fd5b50836001600160a01b0316856001600160a01b03166000805160206148d78339815191528484604051610ab3929190918252602082015260400190565b60405180910390a35b9250925092565b60606000821580610ad5575060328311155b610b135760405162461bcd60e51b815260206004820152600f60248201526e4c696d697420746f6f206c6172676560881b6044820152606401610930565b6109466006868686612602565b6003546001600160a01b03163314610b4a5760405162461bcd60e51b81526004016109309061445e565b610b566006838361291d565b6000610b64600684846129de565b604080516101208101825282546001600160a01b039081168252600184015416602082015260028084015482840152600384015460608301526004840154608083015282518084019384905291939260a085019291600585019182845b815481526020019060010190808311610bc1575050505050815260200160078201805480602002602001604051908101604052809291908181526020016000905b82821015610c5b576000848152602090819020604080516080810182526004860290920180548352600180820154848601526002820154928401929092526003015460ff16151560608301529083529092019101610c02565b505050508152602001600882018054610c7390614424565b80601f0160208091040260200160405190810160405280929190818152602001828054610c9f90614424565b8015610cec5780601f10610cc157610100808354040283529160200191610cec565b820191906000526020600020905b815481529060010190602001808311610ccf57829003601f168201915b5050509183525050604080518082019182905260209092019190600984019060029082845b815481526020019060010190808311610d1157505050505081525050905060008160c00151511115610d9d5760018160c0015151610d4f91906144b5565b826001600160a01b0316846001600160a01b03167f54377dfdebf06f6df53fbda737d2dcd7e141f95bbfb0c1223437e856b9de3ac342604051610d9491815260200190565b60405180910390a45b505050565b610daa6129eb565b610db46000612a45565b565b6003546001600160a01b03163314610de05760405162461bcd60e51b81526004016109309061445e565b600080610df1600686868634612a95565b91509150836001600160a01b0316856001600160a01b03166000805160206148d78339815191528484604051610e31929190918252602082015260400190565b60405180910390a35050505050565b610e486129eb565b600280546001600160a01b039092166001600160a01b0319928316811790915560048054909216179055565b600054600160a01b900460ff1615610ed95760405162461bcd60e51b815260206004820152602260248201527f496e697469616c697a61626c653a20616c726561647920696e697469616c697a604482015261195960f21b6064820152608401610930565b6000805460ff60a01b1916600160a01b179055610ef581612a45565b50600192909255600280546001600160a01b039283166001600160a01b031991821681179092556003805493909416928116831790935560058054841690921790915560048054909216179055565b6004546000906001600160a01b031663ad12259a610f6284806144c8565b610f6f60208701876144c8565b87604001356040518663ffffffff1660e01b8152600401610f9495949392919061454a565b602060405180830381865afa158015610fb1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fd59190614584565b9050806110255760405163885e287960e01b815260206004820152601f60248201527f5a4b20736574746c656d656e742076616c69646174696f6e206661696c6564006044820152606401610930565b600061103460208401846144c8565b808060200260200160405190810160405280939291908181526020018383602002808284376000920182905250939450339250839150505b61107960608701876144c8565b90508110156115b757600061109160608801886144c8565b838181106110a1576110a16145a6565b905060200201359050600081856110b891906145bc565b90506000808787815181106110cf576110cf6145a6565b602002602001015190506000888860026110e991906145bc565b815181106110f9576110f96145a6565b6020026020010151905060008989600361111391906145bc565b81518110611123576111236145a6565b602002602001015190506000611145843360066129de9092919063ffffffff16565b90508a6111538b60056145bc565b81518110611163576111636145a6565b602002602001015181600501600060028110611181576111816145a6565b01541415806111ca57508a6111978b60066145bc565b815181106111a7576111a76145a6565b6020026020010151816005016001600281106111c5576111c56145a6565b015414155b156112185760405163885e287960e01b815260206004820152601760248201527f7369676e6572206b657920697320696e636f72726563740000000000000000006044820152606401610930565b8a6112248b60076145bc565b81518110611234576112346145a6565b602002602001015181600901600060028110611252576112526145a6565b015414158061129b57508a6112688b60086145bc565b81518110611278576112786145a6565b602002602001015181600901600160028110611296576112966145a6565b015414155b156112e95760405163885e287960e01b815260206004820181905260248201527f70726f7669646572207369676e6572206b657920697320696e636f72726563746044820152606401610930565b828160020154111561133e5760405163885e287960e01b815260206004820152601a60248201527f696e697469616c206e6f6e636520697320696e636f72726563740000000000006044820152606401610930565b895b868110156115405760008c828151811061135c5761135c6145a6565b6020026020010151905060008d83600161137691906145bc565b81518110611386576113866145a6565b602002602001015190508d83600361139e91906145bc565b815181106113ae576113ae6145a6565b6020026020010151945060008e8460046113c891906145bc565b815181106113d8576113d86145a6565b6020026020010151905060008a85600b6113f291906145bc565b106113fe576000611423565b8f61140a86600b6145bc565b8151811061141a5761141a6145a6565b60200260200101515b905080158015906114345750808710155b156114755760405163885e287960e01b815260206004820152601060248201526f1b9bdb98d9481bdd995c9b185c1c195960821b6044820152606401610930565b888414158061148457508d8314155b1561151c578884036114cb576040518060400160405280601d81526020017f70726f7669646572206164647265737320697320696e636f7272656374000000815250611502565b6040518060400160405280601981526020017f75736572206164647265737320697320696e636f7272656374000000000000008152505b60405163885e287960e01b815260040161093091906145cf565b611526828b6145bc565b99505050505060098161153991906145bc565b9050611340565b50848160030154101561158d5760405163885e287960e01b8152602060048201526014602482015273696e73756666696369656e742062616c616e636560601b6044820152606401610930565b6115978186612cf8565b60020155509195508392506115af91508290506145e2565b91505061106c565b50825182146116265760405163885e287960e01b815260206004820152603460248201527f6172726179207365676d656e7453697a652073756d206d69736d617463686573604482015273040e0eac4d8d2c640d2dce0eae840d8cadccee8d60631b6064820152608401610930565b5050505050565b611639600b3383612f60565b337f30ecc203691b2d18e17ee75d47caf34a3fb9f86e855f7e0414d3cec26d0c424b61166583806145fb565b61167260208601866145fb565b608087013560a08801354261168a60408b018b6145fb565b61169760608d018d6145fb565b6040516116ae9b9a9998979695949392919061466a565b60405180910390a250565b6003546001600160a01b031633146116e35760405162461bcd60e51b81526004016109309061445e565b6116ef600683836131e4565b5050565b60606105a860068484336132d9565b61170d600b336135e7565b60405133907f29d546abb6e94f4f04d5bdccb6682316f597d43776078f47e273f000e77b2a9190600090a2565b6116ef6006338484613636565b61174f6129eb565b6001600160a01b0381166117b45760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610930565b6117bd81612a45565b50565b6117c86129eb565b600155565b6117d5613c1c565b6117e1600684846129de565b604080516101208101825282546001600160a01b039081168252600184015416602082015260028084015482840152600384015460608301526004840154608083015282518084019384905291939260a085019291600585019182845b81548152602001906001019080831161183e575050505050815260200160078201805480602002602001604051908101604052809291908181526020016000905b828210156118d8576000848152602090819020604080516080810182526004860290920180548352600180820154848601526002820154928401929092526003015460ff1615156060830152908352909201910161187f565b5050505081526020016008820180546118f090614424565b80601f016020809104026020016040519081016040528092919081815260200182805461191c90614424565b80156119695780601f1061193e57610100808354040283529160200191611969565b820191906000526020600020905b81548152906001019060200180831161194c57829003601f168201915b5050509183525050604080518082019182905260209092019190600984019060029082845b81548152602001906001019080831161198e57505050505081525050905092915050565b606060006119bf83613654565b9050806001600160401b038111156119d9576119d961415c565b604051908082528060200260200182016040528015611a1257816020015b6119ff613c1c565b8152602001906001900390816119f75790505b50915060005b81811015611c2357611a2a848261365f565b604080516101208101825282546001600160a01b039081168252600184015416602082015260028084015482840152600384015460608301526004840154608083015282518084019384905291939260a085019291600585019182845b815481526020019060010190808311611a87575050505050815260200160078201805480602002602001604051908101604052809291908181526020016000905b82821015611b21576000848152602090819020604080516080810182526004860290920180548352600180820154848601526002820154928401929092526003015460ff16151560608301529083529092019101611ac8565b505050508152602001600882018054611b3990614424565b80601f0160208091040260200160405190810160405280929190818152602001828054611b6590614424565b8015611bb25780601f10611b8757610100808354040283529160200191611bb2565b820191906000526020600020905b815481529060010190602001808311611b9557829003601f168201915b5050509183525050604080518082019182905260209092019190600984019060029082845b815481526020019060010190808311611bd757505050505081525050838281518110611c0557611c056145a6565b60200260200101819052508080611c1b906145e2565b915050611a18565b5050919050565b6000611c3f84611c3a8585613685565b6136bd565b949350505050565b60006105a883836136c9565b6001600160a01b0383166000908152600385016020526040812060609190611c7a8161371a565b9150818510611cbd576040805160008082526020820190925290611cb4565b611ca1613c1c565b815260200190600190039081611c995790505b50925050611f7b565b60008415611cd457611ccf85876145bc565b611cd6565b825b905082811115611ce35750815b6000611cef87836144b5565b9050806001600160401b03811115611d0957611d0961415c565b604051908082528060200260200182016040528015611d4257816020015b611d2f613c1c565b815260200190600190039081611d275790505b50945060005b81811015611f76576000611d66611d5f838b6145bc565b8690613724565b600081815260028d8101602090815260409283902083516101208101855281546001600160a01b03908116825260018301541692810192909252808301548285015260038101546060830152600481015460808301528351808501948590529495509093909260a0850192600585019182845b815481526020019060010190808311611dd9575050505050815260200160078201805480602002602001604051908101604052809291908181526020016000905b82821015611e73576000848152602090819020604080516080810182526004860290920180548352600180820154848601526002820154928401929092526003015460ff16151560608301529083529092019101611e1a565b505050508152602001600882018054611e8b90614424565b80601f0160208091040260200160405190810160405280929190818152602001828054611eb790614424565b8015611f045780601f10611ed957610100808354040283529160200191611f04565b820191906000526020600020905b815481529060010190602001808311611ee757829003601f168201915b5050509183525050604080518082019182905260209092019190600984019060029082845b815481526020019060010190808311611f2957505050505081525050878381518110611f5757611f576145a6565b6020026020010181905250508080611f6e906145e2565b915050611d48565b505050505b94509492505050565b60606000611f9183613654565b9050806001600160401b03811115611fab57611fab61415c565b604051908082528060200260200182016040528015611fe457816020015b611fd1613bc7565b815260200190600190039081611fc95790505b50915060005b81811015611c2357611ffc848261365f565b60408051610120810190915281546001600160a01b0316815260018201805491929160208401919061202d90614424565b80601f016020809104026020016040519081016040528092919081815260200182805461205990614424565b80156120a65780601f1061207b576101008083540402835291602001916120a6565b820191906000526020600020905b81548152906001019060200180831161208957829003601f168201915b505050505081526020016002820180546120bf90614424565b80601f01602080910402602001604051908101604052809291908181526020018280546120eb90614424565b80156121385780601f1061210d57610100808354040283529160200191612138565b820191906000526020600020905b81548152906001019060200180831161211b57829003601f168201915b5050505050815260200160038201548152602001600482015481526020016005820154815260200160068201805461216f90614424565b80601f016020809104026020016040519081016040528092919081815260200182805461219b90614424565b80156121e85780601f106121bd576101008083540402835291602001916121e8565b820191906000526020600020905b8154815290600101906020018083116121cb57829003601f168201915b5050505050815260200160078201805461220190614424565b80601f016020809104026020016040519081016040528092919081815260200182805461222d90614424565b801561227a5780601f1061224f5761010080835404028352916020019161227a565b820191906000526020600020905b81548152906001019060200180831161225d57829003601f168201915b5050505050815260200160088201805461229390614424565b80601f01602080910402602001604051908101604052809291908181526020018280546122bf90614424565b801561230c5780601f106122e15761010080835404028352916020019161230c565b820191906000526020600020905b8154815290600101906020018083116122ef57829003601f168201915b505050505081525050838281518110612327576123276145a6565b60200260200101819052508061233c906145e2565b9050611fea565b600080612351858585613730565b6004015495945050505050565b600080600061236d8888613685565b905061237989826136bd565b156123aa57604051632cf0675960e21b81526001600160a01b03808a16600483015288166024820152604401610930565b6123b989828a8a8a8a8a613792565b6001600160a01b038716600090815260038a01602052604090206123dd908261380d565b506001600160a01b038816600090815260048a0160205260409020612402908261380d565b509398600098509650505050505050565b600080600080612424888888613730565b60078101549091506000036124435760009350806004015491506125d0565b60078101546000906001600160401b038111156124625761246261415c565b6040519080825280602002602001820160405280156124c057816020015b6124ad60405180608001604052806000815260200160008152602001600081526020016000151581525090565b8152602001906001900390816124805790505b50905060008095506000935060005b60078401548110156125c15760008460070182815481106124f2576124f26145a6565b60009182526020909120600490910201600381015490915060ff161561251857506125af565b88816002015461252891906145bc565b421061254457600181015461253d90896145bc565b97506125ad565b6040518060800160405280848152602001826001015481526020018260020154815260200160001515815250848481518110612582576125826145a6565b602002602001018190525080600101548661259d91906145bc565b9550826125a9816145e2565b9350505b505b806125b9816145e2565b9150506124cf565b506125cd838383613819565b50505b838160030160008282546125e491906144b5565b90915550506004810182905560030154929792965094509092505050565b6001600160a01b03831660009081526004850160205260408120606091906126298161371a565b915081851061266b576040805160008082526020820190925290611cb4565b612650613c1c565b81526020019060019003908161264857905050925050611f7b565b600084156126825761267d85876145bc565b612684565b825b9050828111156126915750815b600061269d87836144b5565b9050806001600160401b038111156126b7576126b761415c565b6040519080825280602002602001820160405280156126f057816020015b6126dd613c1c565b8152602001906001900390816126d55790505b50945060005b81811015611f7657600061270d611d5f838b6145bc565b600081815260028d8101602090815260409283902083516101208101855281546001600160a01b03908116825260018301541692810192909252808301548285015260038101546060830152600481015460808301528351808501948590529495509093909260a0850192600585019182845b815481526020019060010190808311612780575050505050815260200160078201805480602002602001604051908101604052809291908181526020016000905b8282101561281a576000848152602090819020604080516080810182526004860290920180548352600180820154848601526002820154928401929092526003015460ff161515606083015290835290920191016127c1565b50505050815260200160088201805461283290614424565b80601f016020809104026020016040519081016040528092919081815260200182805461285e90614424565b80156128ab5780601f10612880576101008083540402835291602001916128ab565b820191906000526020600020905b81548152906001019060200180831161288e57829003601f168201915b5050509183525050604080518082019182905260209092019190600984019060029082845b8154815260200190600101908083116128d0575050505050815250508783815181106128fe576128fe6145a6565b6020026020010181905250508080612915906145e2565b9150506126f6565b600061292a848484613730565b905060008160040154826003015461294291906144b5565b905080600003612953575050505050565b6040805160808101825260078401805480835260208084018681524295850195865260006060860181815260018086018755958252928120955160049485029096019586559051938501939093559351600284015592516003909201805460ff19169215159290921790915590830180548392906129d29084906145bc565b90915550505050505050565b6000611c3f848484613730565b6000546001600160a01b03163314610db45760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610930565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000806000612aa5888888613730565b90508415612cc657600781015415612cc65760078101546000906001600160401b03811115612ad657612ad661415c565b604051908082528060200260200182016040528015612b3457816020015b612b2160405180608001604052806000815260200160008152602001600081526020016000151581525090565b815260200190600190039081612af45790505b50905060008681805b6007860154811015612cae576000866007018281548110612b6057612b606145a6565b60009182526020909120600490910201600381015490915060ff1615612b865750612c9c565b80600101548410612ba7576001810154612ba090856144b5565b9350612c9a565b8315612c29576000848260010154612bbf91906144b5565b905060405180608001604052808781526020018281526020018360020154815260200160001515815250878781518110612bfb57612bfb6145a6565b6020908102919091010152612c1081856145bc565b935085612c1c816145e2565b9650506000945050612c9a565b6040805160808101825286815260018301546020820152600283015491810191909152600382015460ff16151560608201528651879087908110612c6f57612c6f6145a6565b6020026020010181905250806001015483612c8a91906145bc565b925084612c96816145e2565b9550505b505b80612ca6816145e2565b915050612b3d565b5060048501819055612cc1858585613819565b505050505b83816003016000828254612cda91906145bc565b90915550506003810154600490910154909890975095505050505050565b81600401548260030154612d0c91906144b5565b811115612e7157600082600401548360030154612d2991906144b5565b612d3390836144b5565b90508083600401541015612d985760405163885e287960e01b815260206004820152602560248201527f696e73756666696369656e742062616c616e636520696e2070656e64696e675260448201526419599d5b9960da1b6064820152608401610930565b80836004016000828254612dac91906144b5565b90915550506007830154600090612dc5906001906144b5565b90505b60008112612e6e576000846007018281548110612de757612de76145a6565b60009182526020909120600490910201600381015490915060ff1615612e0d5750612e5c565b82816001015411612e2e576001810154612e2790846144b5565b9250612e4c565b82816001016000828254612e4291906144b5565b9091555060009350505b82600003612e5a5750612e6e565b505b80612e66816146df565b915050612dc8565b50505b80826003016000828254612e8591906144b5565b90915550506005548254604051631bb1482360e31b81526001600160a01b0391821660048201526024810184905291169063dd8a411890604401600060405180830381600087803b158015612ed957600080fd5b505af1158015612eed573d6000803e3d6000fd5b50508354600385015460048601546040805192835260208301919091523394506001600160a01b0390921692506000805160206148d7833981519152910160405180910390a3604051339082156108fc029083906000818181858888f19350505050158015610d9d573d6000803e3d6000fd5b6000612f6b836138b2565b9050612f7784826136bd565b613122576116268482604051806101200160405280876001600160a01b03168152602001868060000190612fab91906145fb565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250505090825250602090810190612ff4908801886145fb565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250505090825250608080880135602083015260a0880135604080840191909152426060840152910190613059908801886145fb565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505050908252506020016130a060608801886145fb565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505050908252506020016130e760c08801886145fb565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050509152506138e6565b600061312e85856136c9565b905061313a83806145fb565b600183019161314a919083614742565b506080830135600382015560a0830135600482015561316c60208401846145fb565b600283019161317c919083614742565b5042600582015561319060408401846145fb565b60068301916131a0919083614742565b506131ae60608401846145fb565b60078301916131be919083614742565b506131cc60c08401846145fb565b60088301916131dc919083614742565b505050505050565b60006131f08383613685565b90506131fc84826136bd565b6132065750505050565b6001600160a01b0382166000908152600385016020526040902061322a90826139ac565b506001600160a01b0383166000908152600485016020526040902061324f90826139ac565b5061325a84826139ac565b50600081815260028086016020526040822080546001600160a01b03199081168255600182018054909116905590810182905560038101829055600481018290556005810182905560068101829055906132b8600783016000613c85565b6132c6600883016000613ca6565b600060098301819055600a8301556131dc565b60606101f483111561332d5760405162461bcd60e51b815260206004820152601e60248201527f42617463682073697a6520746f6f206c6172676520286d6178203530302900006044820152606401610930565b826001600160401b038111156133455761334561415c565b60405190808252806020026020018201604052801561337e57816020015b61336b613c1c565b8152602001906001900390816133635790505b50905060005b838110156135de5760006133be8686848181106133a3576133a36145a6565b90506020020160208101906133b89190613fac565b85613685565b90506133ca87826136bd565b156135cb5760008181526002888101602090815260409283902083516101208101855281546001600160a01b03908116825260018301541692810192909252808301548285015260038101546060830152600481015460808301528351808501948590529193909260a08501929160058501919082845b815481526020019060010190808311613441575050505050815260200160078201805480602002602001604051908101604052809291908181526020016000905b828210156134db576000848152602090819020604080516080810182526004860290920180548352600180820154848601526002820154928401929092526003015460ff16151560608301529083529092019101613482565b5050505081526020016008820180546134f390614424565b80601f016020809104026020016040519081016040528092919081815260200182805461351f90614424565b801561356c5780601f106135415761010080835404028352916020019161356c565b820191906000526020600020905b81548152906001019060200180831161354f57829003601f168201915b5050509183525050604080518082019182905260209092019190600984019060029082845b815481526020019060010190808311613591575050505050815250508383815181106135bf576135bf6145a6565b60200260200101819052505b50806135d6816145e2565b915050613384565b50949350505050565b60006135f2826138b2565b90506135fe83826136bd565b613626576040516304c76d3f60e11b81526001600160a01b0383166004820152602401610930565b61363083826139b8565b50505050565b6000613643858585613730565b90506131dc60098201836002613ce0565b60006105ab8261371a565b60008061366c8484613724565b6000908152600285016020526040902091505092915050565b604080516001600160a01b03938416602080830191909152929093168382015280518084038201815260609093019052815191012090565b60006105a88383613a43565b6000806136d5836138b2565b600081815260028601602052604090209091506136f285836136bd565b611c3f576040516304c76d3f60e11b81526001600160a01b0385166004820152602401610930565b60006105ab825490565b60006105a88383613a5b565b60008061373d8484613685565b905061374985826136bd565b6137795760405163023280eb60e21b81526001600160a01b03808616600483015284166024820152604401610930565b6000908152600285016020526040902090509392505050565b6000868152600280890160205260409091206003810184905580546001600160a01b038089166001600160a01b031992831617835560018301805491891691909216179055906137e89060058301908690613ce0565b50600881016137f78382614801565b50613802888861380d565b505050505050505050565b60006105a88383613a85565b613827600784016000613c85565b60005b818110156136305783600701838281518110613848576138486145a6565b60209081029190910181015182546001808201855560009485529383902082516004909202019081559181015192820192909255604082015160028201556060909101516003909101805460ff1916911515919091179055806138aa816145e2565b91505061382a565b604080516001600160a01b038316602082015260009101604051602081830303815290604052805190602001209050919050565b600082815260028401602090815260408220835181546001600160a01b0319166001600160a01b0390911617815590830151839190600182019061392a9082614801565b506040820151600282019061393f9082614801565b50606082015160038201556080820151600482015560a0820151600582015560c082015160068201906139729082614801565b5060e082015160078201906139879082614801565b50610100820151600882019061399d9082614801565b50611c3f91508590508461380d565b60006105a88383613ad4565b6000818152600283016020526040812080546001600160a01b0319168155816139e46001830182613ca6565b6139f2600283016000613ca6565b600382016000905560048201600090556005820160009055600682016000613a1a9190613ca6565b613a28600783016000613ca6565b613a36600883016000613ca6565b506105a8905083836139ac565b600081815260018301602052604081205415156105a8565b6000826000018281548110613a7257613a726145a6565b9060005260206000200154905092915050565b6000818152600183016020526040812054613acc575081546001818101845560008481526020808220909301849055845484825282860190935260409020919091556105ab565b5060006105ab565b60008181526001830160205260408120548015613bbd576000613af86001836144b5565b8554909150600090613b0c906001906144b5565b9050818114613b71576000866000018281548110613b2c57613b2c6145a6565b9060005260206000200154905080876000018481548110613b4f57613b4f6145a6565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080613b8257613b826148c0565b6001900381819060005260206000200160009055905585600101600086815260200190815260200160002060009055600193505050506105ab565b60009150506105ab565b60405180610120016040528060006001600160a01b0316815260200160608152602001606081526020016000815260200160008152602001600081526020016060815260200160608152602001606081525090565b60405180610120016040528060006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001613c65613d1e565b81526020016060815260200160608152602001613c80613d1e565b905290565b50805460008255600402906000526020600020908101906117bd9190613d3c565b508054613cb290614424565b6000825580601f10613cc2575050565b601f0160209004906000526020600020908101906117bd9190613d6a565b8260028101928215613d0e579160200282015b82811115613d0e578235825591602001919060010190613cf3565b50613d1a929150613d6a565b5090565b60405180604001604052806002906020820280368337509192915050565b5b80821115613d1a57600080825560018201819055600282015560038101805460ff19169055600401613d3d565b5b80821115613d1a5760008155600101613d6b565b8060005b6002811015613630578151845260209384019390910190600101613d83565b600081518084526020808501945080840160005b83811015613df45781518051885283810151848901526040808201519089015260609081015115159088015260809096019590820190600101613db6565b509495945050505050565b6000815180845260005b81811015613e2557602081850181015186830182015201613e09565b506000602082860101526020601f19601f83011685010191505092915050565b80516001600160a01b0316825260006101606020830151613e7160208601826001600160a01b03169052565b5060408301516040850152606083015160608501526080830151608085015260a0830151613ea260a0860182613d7f565b5060c08301518160e0860152613eba82860182613da2565b91505060e083015161010085830381870152613ed68383613dff565b925080850151915050613eed610120860182613d7f565b509392505050565b600081518084526020808501808196508360051b8101915082860160005b85811015613f3d578284038952613f2b848351613e45565b98850198935090840190600101613f13565b5091979650505050505050565b6020815260006105a86020830184613ef5565b80356001600160a01b0381168114613f7457600080fd5b919050565b60008060408385031215613f8c57600080fd5b613f9583613f5d565b9150613fa360208401613f5d565b90509250929050565b600060208284031215613fbe57600080fd5b6105a882613f5d565b80516001600160a01b0316825260006101206020830151816020860152613ff082860182613dff565b9150506040830151848203604086015261400a8282613dff565b915050606083015160608501526080830151608085015260a083015160a085015260c083015184820360c08601526140428282613dff565b91505060e083015184820360e086015261405c8282613dff565b91505061010080840151858303828701526140778382613dff565b9695505050505050565b6020815260006105a86020830184613fc7565b6000806000606084860312156140a957600080fd5b6140b284613f5d565b95602085013595506040909401359392505050565b6040815260006140da6040830185613ef5565b90508260208301529392505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b8281101561413e57603f1988860301845261412c858351613fc7565b94509285019290850190600101614110565b5092979650505050505050565b80604081018310156105ab57600080fd5b634e487b7160e01b600052604160045260246000fd5b60008060008060a0858703121561418857600080fd5b61419185613f5d565b935061419f60208601613f5d565b92506141ae866040870161414b565b915060808501356001600160401b03808211156141ca57600080fd5b818701915087601f8301126141de57600080fd5b8135818111156141f0576141f061415c565b604051601f8201601f19908116603f011681019083821181831017156142185761421861415c565b816040528281528a602084870101111561423157600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b60008060006060848603121561426a57600080fd5b61427384613f5d565b925061428160208501613f5d565b9150604084013590509250925092565b600080600080608085870312156142a757600080fd5b843593506142b760208601613f5d565b92506142c560408601613f5d565b91506142d360608601613f5d565b905092959194509250565b6000602082840312156142f057600080fd5b81356001600160401b0381111561430657600080fd5b82016080818503121561431857600080fd5b9392505050565b60006020828403121561433157600080fd5b81356001600160401b0381111561434757600080fd5b820160e0818503121561431857600080fd5b6000806020838503121561436c57600080fd5b82356001600160401b038082111561438357600080fd5b818501915085601f83011261439757600080fd5b8135818111156143a657600080fd5b8660208260051b85010111156143bb57600080fd5b60209290920196919550909350505050565b600080606083850312156143e057600080fd5b6143e983613f5d565b9150613fa3846020850161414b565b60006020828403121561440a57600080fd5b5035919050565b6020815260006105a86020830184613e45565b600181811c9082168061443857607f821691505b60208210810361445857634e487b7160e01b600052602260045260246000fd5b50919050565b60208082526021908201527f43616c6c6572206973206e6f7420746865206c656467657220636f6e747261636040820152601d60fa1b606082015260800190565b634e487b7160e01b600052601160045260246000fd5b818103818111156105ab576105ab61449f565b6000808335601e198436030181126144df57600080fd5b8301803591506001600160401b038211156144f957600080fd5b6020019150600581901b360382131561451157600080fd5b9250929050565b81835260006001600160fb1b0383111561453157600080fd5b8260051b80836020870137939093016020019392505050565b60608152600061455e606083018789614518565b8281036020840152614571818688614518565b9150508260408301529695505050505050565b60006020828403121561459657600080fd5b8151801515811461431857600080fd5b634e487b7160e01b600052603260045260246000fd5b808201808211156105ab576105ab61449f565b6020815260006105a86020830184613dff565b6000600182016145f4576145f461449f565b5060010190565b6000808335601e1984360301811261461257600080fd5b8301803591506001600160401b0382111561462c57600080fd5b60200191503681900382131561451157600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b60e08152600061467e60e083018d8f614641565b8281036020840152614691818c8e614641565b905089604084015288606084015287608084015282810360a08401526146b8818789614641565b905082810360c08401526146cd818587614641565b9e9d5050505050505050505050505050565b6000600160ff1b82016146f4576146f461449f565b506000190190565b601f821115610d9d57600081815260208120601f850160051c810160208610156147235750805b601f850160051c820191505b818110156131dc5782815560010161472f565b6001600160401b038311156147595761475961415c565b61476d836147678354614424565b836146fc565b6000601f8411600181146147a157600085156147895750838201355b600019600387901b1c1916600186901b178355611626565b600083815260209020601f19861690835b828110156147d257868501358255602094850194600190920191016147b2565b50868210156147ef5760001960f88860031b161c19848701351681555b505060018560011b0183555050505050565b81516001600160401b0381111561481a5761481a61415c565b61482e816148288454614424565b846146fc565b602080601f831160018114614863576000841561484b5750858301515b600019600386901b1c1916600185901b1785556131dc565b600085815260208120601f198616915b8281101561489257888601518255948401946001909101908401614873565b50858210156148b05787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b634e487b7160e01b600052603160045260246000fdfe526824944047da5b81071fb6349412005c5da81380b336103fbe5dd34556c776a26469706673582212209548af52cd86b8bd3af1a165f3d0afb9289d221829013e5347144790a7641eb764736f6c63430008140033';\nconst isSuperArgs$1 = (xs) => xs.length > 1;\nclass InferenceServing__factory extends ethers__WEBPACK_IMPORTED_MODULE_11__.ContractFactory {\n    constructor(...args) {\n        if (isSuperArgs$1(args)) {\n            super(...args);\n        }\n        else {\n            super(_abi$1, _bytecode$1, args[0]);\n        }\n    }\n    getDeployTransaction(overrides) {\n        return super.getDeployTransaction(overrides || {});\n    }\n    deploy(overrides) {\n        return super.deploy(overrides || {});\n    }\n    connect(runner) {\n        return super.connect(runner);\n    }\n    static bytecode = _bytecode$1;\n    static abi = _abi$1;\n    static createInterface() {\n        return new ethers__WEBPACK_IMPORTED_MODULE_12__.Interface(_abi$1);\n    }\n    static connect(address, runner) {\n        return new ethers__WEBPACK_IMPORTED_MODULE_13__.Contract(address, _abi$1, runner);\n    }\n}\n\n/* Autogenerated file. Do not edit manually. */\n/* tslint:disable */\n/* eslint-disable */\nconst _abi = [\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'AccountExists',\n        type: 'error',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'AccountNotExists',\n        type: 'error',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'string',\n                name: 'reason',\n                type: 'string',\n            },\n        ],\n        name: 'InvalidVerifierInput',\n        type: 'error',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'ServiceNotExist',\n        type: 'error',\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                indexed: false,\n                internalType: 'uint256',\n                name: 'amount',\n                type: 'uint256',\n            },\n            {\n                indexed: false,\n                internalType: 'uint256',\n                name: 'pendingRefund',\n                type: 'uint256',\n            },\n        ],\n        name: 'BalanceUpdated',\n        type: 'event',\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'previousOwner',\n                type: 'address',\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'newOwner',\n                type: 'address',\n            },\n        ],\n        name: 'OwnershipTransferred',\n        type: 'event',\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                indexed: true,\n                internalType: 'uint256',\n                name: 'index',\n                type: 'uint256',\n            },\n            {\n                indexed: false,\n                internalType: 'uint256',\n                name: 'timestamp',\n                type: 'uint256',\n            },\n        ],\n        name: 'RefundRequested',\n        type: 'event',\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n        ],\n        name: 'ServiceRemoved',\n        type: 'event',\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                indexed: false,\n                internalType: 'string',\n                name: 'url',\n                type: 'string',\n            },\n            {\n                components: [\n                    {\n                        internalType: 'uint256',\n                        name: 'cpuCount',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nodeMemory',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'gpuCount',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nodeStorage',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'gpuType',\n                        type: 'string',\n                    },\n                ],\n                indexed: false,\n                internalType: 'struct Quota',\n                name: 'quota',\n                type: 'tuple',\n            },\n            {\n                indexed: false,\n                internalType: 'uint256',\n                name: 'pricePerToken',\n                type: 'uint256',\n            },\n            {\n                indexed: false,\n                internalType: 'address',\n                name: 'providerSigner',\n                type: 'address',\n            },\n            {\n                indexed: false,\n                internalType: 'bool',\n                name: 'occupied',\n                type: 'bool',\n            },\n        ],\n        name: 'ServiceUpdated',\n        type: 'event',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'accountExists',\n        outputs: [\n            {\n                internalType: 'bool',\n                name: '',\n                type: 'bool',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                internalType: 'uint256',\n                name: 'index',\n                type: 'uint256',\n            },\n        ],\n        name: 'acknowledgeDeliverable',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'providerSigner',\n                type: 'address',\n            },\n        ],\n        name: 'acknowledgeProviderSigner',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                internalType: 'string',\n                name: 'additionalInfo',\n                type: 'string',\n            },\n        ],\n        name: 'addAccount',\n        outputs: [],\n        stateMutability: 'payable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'bytes',\n                name: 'modelRootHash',\n                type: 'bytes',\n            },\n        ],\n        name: 'addDeliverable',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'string',\n                name: 'url',\n                type: 'string',\n            },\n            {\n                components: [\n                    {\n                        internalType: 'uint256',\n                        name: 'cpuCount',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nodeMemory',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'gpuCount',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nodeStorage',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'gpuType',\n                        type: 'string',\n                    },\n                ],\n                internalType: 'struct Quota',\n                name: 'quota',\n                type: 'tuple',\n            },\n            {\n                internalType: 'uint256',\n                name: 'pricePerToken',\n                type: 'uint256',\n            },\n            {\n                internalType: 'address',\n                name: 'providerSigner',\n                type: 'address',\n            },\n            {\n                internalType: 'bool',\n                name: 'occupied',\n                type: 'bool',\n            },\n            {\n                internalType: 'string[]',\n                name: 'models',\n                type: 'string[]',\n            },\n        ],\n        name: 'addOrUpdateService',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'deleteAccount',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                internalType: 'uint256',\n                name: 'cancelRetrievingAmount',\n                type: 'uint256',\n            },\n        ],\n        name: 'depositFund',\n        outputs: [],\n        stateMutability: 'payable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'getAccount',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'user',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'provider',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nonce',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'balance',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'pendingRefund',\n                        type: 'uint256',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'uint256',\n                                name: 'index',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'amount',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'createdAt',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'processed',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Refund[]',\n                        name: 'refunds',\n                        type: 'tuple[]',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'providerSigner',\n                        type: 'address',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'bytes',\n                                name: 'modelRootHash',\n                                type: 'bytes',\n                            },\n                            {\n                                internalType: 'bytes',\n                                name: 'encryptedSecret',\n                                type: 'bytes',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'acknowledged',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Deliverable[]',\n                        name: 'deliverables',\n                        type: 'tuple[]',\n                    },\n                ],\n                internalType: 'struct Account',\n                name: '',\n                type: 'tuple',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                internalType: 'uint256',\n                name: 'offset',\n                type: 'uint256',\n            },\n            {\n                internalType: 'uint256',\n                name: 'limit',\n                type: 'uint256',\n            },\n        ],\n        name: 'getAccountsByProvider',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'user',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'provider',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nonce',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'balance',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'pendingRefund',\n                        type: 'uint256',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'uint256',\n                                name: 'index',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'amount',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'createdAt',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'processed',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Refund[]',\n                        name: 'refunds',\n                        type: 'tuple[]',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'providerSigner',\n                        type: 'address',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'bytes',\n                                name: 'modelRootHash',\n                                type: 'bytes',\n                            },\n                            {\n                                internalType: 'bytes',\n                                name: 'encryptedSecret',\n                                type: 'bytes',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'acknowledged',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Deliverable[]',\n                        name: 'deliverables',\n                        type: 'tuple[]',\n                    },\n                ],\n                internalType: 'struct Account[]',\n                name: 'accounts',\n                type: 'tuple[]',\n            },\n            {\n                internalType: 'uint256',\n                name: 'total',\n                type: 'uint256',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'uint256',\n                name: 'offset',\n                type: 'uint256',\n            },\n            {\n                internalType: 'uint256',\n                name: 'limit',\n                type: 'uint256',\n            },\n        ],\n        name: 'getAccountsByUser',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'user',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'provider',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nonce',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'balance',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'pendingRefund',\n                        type: 'uint256',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'uint256',\n                                name: 'index',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'amount',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'createdAt',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'processed',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Refund[]',\n                        name: 'refunds',\n                        type: 'tuple[]',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'providerSigner',\n                        type: 'address',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'bytes',\n                                name: 'modelRootHash',\n                                type: 'bytes',\n                            },\n                            {\n                                internalType: 'bytes',\n                                name: 'encryptedSecret',\n                                type: 'bytes',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'acknowledged',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Deliverable[]',\n                        name: 'deliverables',\n                        type: 'tuple[]',\n                    },\n                ],\n                internalType: 'struct Account[]',\n                name: 'accounts',\n                type: 'tuple[]',\n            },\n            {\n                internalType: 'uint256',\n                name: 'total',\n                type: 'uint256',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'getAllAccounts',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'user',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'provider',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nonce',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'balance',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'pendingRefund',\n                        type: 'uint256',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'uint256',\n                                name: 'index',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'amount',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'createdAt',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'processed',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Refund[]',\n                        name: 'refunds',\n                        type: 'tuple[]',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'providerSigner',\n                        type: 'address',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'bytes',\n                                name: 'modelRootHash',\n                                type: 'bytes',\n                            },\n                            {\n                                internalType: 'bytes',\n                                name: 'encryptedSecret',\n                                type: 'bytes',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'acknowledged',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Deliverable[]',\n                        name: 'deliverables',\n                        type: 'tuple[]',\n                    },\n                ],\n                internalType: 'struct Account[]',\n                name: '',\n                type: 'tuple[]',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'getAllServices',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'provider',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'url',\n                        type: 'string',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'uint256',\n                                name: 'cpuCount',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'nodeMemory',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'gpuCount',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'nodeStorage',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'string',\n                                name: 'gpuType',\n                                type: 'string',\n                            },\n                        ],\n                        internalType: 'struct Quota',\n                        name: 'quota',\n                        type: 'tuple',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'pricePerToken',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'providerSigner',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'bool',\n                        name: 'occupied',\n                        type: 'bool',\n                    },\n                    {\n                        internalType: 'string[]',\n                        name: 'models',\n                        type: 'string[]',\n                    },\n                ],\n                internalType: 'struct Service[]',\n                name: 'services',\n                type: 'tuple[]',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address[]',\n                name: 'users',\n                type: 'address[]',\n            },\n        ],\n        name: 'getBatchAccountsByUsers',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'user',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'provider',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nonce',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'balance',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'pendingRefund',\n                        type: 'uint256',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'uint256',\n                                name: 'index',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'amount',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'createdAt',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'processed',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Refund[]',\n                        name: 'refunds',\n                        type: 'tuple[]',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'additionalInfo',\n                        type: 'string',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'providerSigner',\n                        type: 'address',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'bytes',\n                                name: 'modelRootHash',\n                                type: 'bytes',\n                            },\n                            {\n                                internalType: 'bytes',\n                                name: 'encryptedSecret',\n                                type: 'bytes',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'acknowledged',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct Deliverable[]',\n                        name: 'deliverables',\n                        type: 'tuple[]',\n                    },\n                ],\n                internalType: 'struct Account[]',\n                name: 'accounts',\n                type: 'tuple[]',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n            {\n                internalType: 'uint256',\n                name: 'index',\n                type: 'uint256',\n            },\n        ],\n        name: 'getDeliverable',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'bytes',\n                        name: 'modelRootHash',\n                        type: 'bytes',\n                    },\n                    {\n                        internalType: 'bytes',\n                        name: 'encryptedSecret',\n                        type: 'bytes',\n                    },\n                    {\n                        internalType: 'bool',\n                        name: 'acknowledged',\n                        type: 'bool',\n                    },\n                ],\n                internalType: 'struct Deliverable',\n                name: '',\n                type: 'tuple',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'getPendingRefund',\n        outputs: [\n            {\n                internalType: 'uint256',\n                name: '',\n                type: 'uint256',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'getService',\n        outputs: [\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'provider',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'string',\n                        name: 'url',\n                        type: 'string',\n                    },\n                    {\n                        components: [\n                            {\n                                internalType: 'uint256',\n                                name: 'cpuCount',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'nodeMemory',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'gpuCount',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'uint256',\n                                name: 'nodeStorage',\n                                type: 'uint256',\n                            },\n                            {\n                                internalType: 'string',\n                                name: 'gpuType',\n                                type: 'string',\n                            },\n                        ],\n                        internalType: 'struct Quota',\n                        name: 'quota',\n                        type: 'tuple',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'pricePerToken',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'providerSigner',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'bool',\n                        name: 'occupied',\n                        type: 'bool',\n                    },\n                    {\n                        internalType: 'string[]',\n                        name: 'models',\n                        type: 'string[]',\n                    },\n                ],\n                internalType: 'struct Service',\n                name: 'service',\n                type: 'tuple',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'uint256',\n                name: '_locktime',\n                type: 'uint256',\n            },\n            {\n                internalType: 'address',\n                name: '_ledgerAddress',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'owner',\n                type: 'address',\n            },\n            {\n                internalType: 'uint256',\n                name: '_penaltyPercentage',\n                type: 'uint256',\n            },\n        ],\n        name: 'initialize',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'initialized',\n        outputs: [\n            {\n                internalType: 'bool',\n                name: '',\n                type: 'bool',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'ledgerAddress',\n        outputs: [\n            {\n                internalType: 'address',\n                name: '',\n                type: 'address',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'lockTime',\n        outputs: [\n            {\n                internalType: 'uint256',\n                name: '',\n                type: 'uint256',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'owner',\n        outputs: [\n            {\n                internalType: 'address',\n                name: '',\n                type: 'address',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'penaltyPercentage',\n        outputs: [\n            {\n                internalType: 'uint256',\n                name: '',\n                type: 'uint256',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'processRefund',\n        outputs: [\n            {\n                internalType: 'uint256',\n                name: 'totalAmount',\n                type: 'uint256',\n            },\n            {\n                internalType: 'uint256',\n                name: 'balance',\n                type: 'uint256',\n            },\n            {\n                internalType: 'uint256',\n                name: 'pendingRefund',\n                type: 'uint256',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'removeService',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'renounceOwnership',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'user',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'provider',\n                type: 'address',\n            },\n        ],\n        name: 'requestRefundAll',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                components: [\n                    {\n                        internalType: 'uint256',\n                        name: 'index',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'bytes',\n                        name: 'encryptedSecret',\n                        type: 'bytes',\n                    },\n                    {\n                        internalType: 'bytes',\n                        name: 'modelRootHash',\n                        type: 'bytes',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nonce',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'providerSigner',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'bytes',\n                        name: 'signature',\n                        type: 'bytes',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'taskFee',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'user',\n                        type: 'address',\n                    },\n                ],\n                internalType: 'struct VerifierInput',\n                name: 'verifierInput',\n                type: 'tuple',\n            },\n        ],\n        name: 'settleFees',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'newOwner',\n                type: 'address',\n            },\n        ],\n        name: 'transferOwnership',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'uint256',\n                name: '_locktime',\n                type: 'uint256',\n            },\n        ],\n        name: 'updateLockTime',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'uint256',\n                name: '_penaltyPercentage',\n                type: 'uint256',\n            },\n        ],\n        name: 'updatePenaltyPercentage',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n];\nconst _bytecode = '0x60806040523480156200001157600080fd5b506200001d3362000023565b62000073565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6151c880620000836000396000f3fe6080604052600436106101d85760003560e01c8063715018a611610102578063d1d2005611610095578063f2c6741a11610064578063f2c6741a1461057c578063f2fde38b1461059c578063fbfa4e11146105bc578063fd590847146105dc57600080fd5b8063d1d2005614610509578063e37259e914610529578063e50688f914610549578063eb9616931461055c57600080fd5b806397e19403116100d157806397e194031461049457806398248997146104b4578063ba16a750146104d4578063bbee42d9146104f457600080fd5b8063715018a61461041a578063745e87f71461042f5780638da5cb5b14610442578063972167251461047457600080fd5b806321fe0f301161017a5780634e3c4f22116101495780634e3c4f221461037f5780634fe63f4d146103ba5780635f7069db146103da5780636c79158d146103fa57600080fd5b806321fe0f30146102ee578063264173d614610310578063290a68df14610330578063389f68ee1461035d57600080fd5b8063158ef93e116101b6578063158ef93e1461025c57806315908d511461027d57806315a52302146102935780631d73b9f5146102c057600080fd5b806308e93d0a146101dd5780630d66808714610208578063147500e31461022c575b600080fd5b3480156101e957600080fd5b506101f2610609565b6040516101ff919061447c565b60405180910390f35b34801561021457600080fd5b5061021e60015481565b6040519081526020016101ff565b34801561023857600080fd5b5061024c6102473660046144ab565b61061a565b60405190151581526020016101ff565b34801561026857600080fd5b5060005461024c90600160a01b900460ff1681565b34801561028957600080fd5b5061021e600c5481565b34801561029f57600080fd5b506102b36102ae3660046144de565b610631565b6040516101ff9190614601565b3480156102cc57600080fd5b506102e06102db366004614614565b6108db565b6040516101ff929190614647565b3480156102fa57600080fd5b50610303610949565b6040516101ff9190614669565b34801561031c57600080fd5b5061021e61032b3660046144ab565b610955565b34801561033c57600080fd5b5061035061034b3660046146cb565b610963565b6040516101ff9190614707565b34801561036957600080fd5b5061037d610378366004614932565b610af5565b005b34801561038b57600080fd5b5061039f61039a3660046144ab565b610b94565b604080519384526020840192909252908201526060016101ff565b3480156103c657600080fd5b506102e06103d5366004614614565b610c7d565b3480156103e657600080fd5b5061037d6103f5366004614a15565b610cda565b34801561040657600080fd5b5061037d6104153660046144ab565b610ceb565b34801561042657600080fd5b5061037d610d21565b61037d61043d3660046146cb565b610d35565b34801561044e57600080fd5b506000546001600160a01b03165b6040516001600160a01b0390911681526020016101ff565b34801561048057600080fd5b5061037d61048f3660046144ab565b610dd1565b3480156104a057600080fd5b5061037d6104af366004614a3f565b610e07565b3480156104c057600080fd5b5061037d6104cf366004614a81565b6111d6565b3480156104e057600080fd5b506101f26104ef366004614ace565b6111e3565b34801561050057600080fd5b5061037d6111f2565b34801561051557600080fd5b5060025461045c906001600160a01b031681565b34801561053557600080fd5b5061037d610544366004614b42565b61122a565b61037d610557366004614b86565b6112e1565b34801561056857600080fd5b5061037d610577366004614be3565b61131c565b34801561058857600080fd5b5061037d6105973660046144ab565b611329565b3480156105a857600080fd5b5061037d6105b73660046144de565b611336565b3480156105c857600080fd5b5061037d6105d7366004614be3565b6113af565b3480156105e857600080fd5b506105fc6105f73660046144ab565b6113bc565b6040516101ff9190614bfc565b606061061560046116db565b905090565b600061062860048484611a8e565b90505b92915050565b610639613fb4565b610644600983611aab565b6040805160e0810190915281546001600160a01b0316815260018201805491929160208401919061067490614c0f565b80601f01602080910402602001604051908101604052809291908181526020018280546106a090614c0f565b80156106ed5780601f106106c2576101008083540402835291602001916106ed565b820191906000526020600020905b8154815290600101906020018083116106d057829003601f168201915b50505050508152602001600282016040518060a00160405290816000820154815260200160018201548152602001600282015481526020016003820154815260200160048201805461073e90614c0f565b80601f016020809104026020016040519081016040528092919081815260200182805461076a90614c0f565b80156107b75780601f1061078c576101008083540402835291602001916107b7565b820191906000526020600020905b81548152906001019060200180831161079a57829003601f168201915b505050919092525050508152600782015460208083019190915260088301546001600160a01b038116604080850191909152600160a01b90910460ff1615156060840152600984018054825181850281018501909352808352608090940193919290919060009084015b828210156108cd57838290600052602060002001805461084090614c0f565b80601f016020809104026020016040519081016040528092919081815260200182805461086c90614c0f565b80156108b95780601f1061088e576101008083540402835291602001916108b9565b820191906000526020600020905b81548152906001019060200180831161089c57829003601f168201915b505050505081526020019060010190610821565b505050915250909392505050565b606060008215806108ed575060328311155b6109305760405162461bcd60e51b815260206004820152600f60248201526e4c696d697420746f6f206c6172676560881b60448201526064015b60405180910390fd5b61093d6004868686611ab7565b91509150935093915050565b60606106156009611f1a565b600061062860048484612251565b6040805160608082018352808252602082015260009181019190915261098b6004858561226c565b600801828154811061099f5761099f614c49565b90600052602060002090600302016040518060600160405290816000820180546109c890614c0f565b80601f01602080910402602001604051908101604052809291908181526020018280546109f490614c0f565b8015610a415780601f10610a1657610100808354040283529160200191610a41565b820191906000526020600020905b815481529060010190602001808311610a2457829003601f168201915b50505050508152602001600182018054610a5a90614c0f565b80601f0160208091040260200160405190810160405280929190818152602001828054610a8690614c0f565b8015610ad35780601f10610aa857610100808354040283529160200191610ad3565b820191906000526020600020905b815481529060010190602001808311610ab657829003601f168201915b50505091835250506002919091015460ff161515602090910152949350505050565b610b403388888080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506009949392508a9150899050888888612279565b336001600160a01b03167f9657518f02d23efc8a15c042c006a06464dd791f65394ff87310a287c6949462888888888888604051610b8396959493929190614c5f565b60405180910390a250505050505050565b600254600090819081906001600160a01b03163314610bc55760405162461bcd60e51b815260040161092790614cc7565b600154610bd8906004908790879061239e565b919450925090506000839003610bf15760009250610c76565b604051339084156108fc029085906000818181858888f19350505050158015610c1e573d6000803e3d6000fd5b50836001600160a01b0316856001600160a01b03167f526824944047da5b81071fb6349412005c5da81380b336103fbe5dd34556c7768484604051610c6d929190918252602082015260400190565b60405180910390a35b9250925092565b60606000821580610c8f575060328311155b610ccd5760405162461bcd60e51b815260206004820152600f60248201526e4c696d697420746f6f206c6172676560881b6044820152606401610927565b61093d600486868661258d565b610ce760043384846129da565b5050565b6002546001600160a01b03163314610d155760405162461bcd60e51b815260040161092790614cc7565b610ce760048383612ae9565b610d29612baa565b610d336000612c04565b565b6002546001600160a01b03163314610d5f5760405162461bcd60e51b815260040161092790614cc7565b600080610d70600486868634612c54565b91509150836001600160a01b0316856001600160a01b03167f526824944047da5b81071fb6349412005c5da81380b336103fbe5dd34556c7768484604051610dc2929190918252602082015260400190565b60405180910390a35050505050565b6002546001600160a01b03163314610dfb5760405162461bcd60e51b815260040161092790614cc7565b610ce760048383612ebf565b6000610e26610e1d610100840160e085016144de565b6004903361226c565b9050610e3860a08301608084016144de565b60078201546001600160a01b03908116911614610ead5760405163de83c54360e01b815260206004820152602c60248201527f70726f7669646572207369676e696e672061646472657373206973206e6f742060448201526b1858dadb9bdddb195919d95960a21b6064820152608401610927565b8160600135816002015410610f185760405163de83c54360e01b815260206004820152602a60248201527f6e6f6e63652073686f756c64206c6172676572207468616e207468652063757260448201526972656e74206e6f6e636560b01b6064820152608401610927565b8160c0013581600301541015610f685760405163de83c54360e01b8152602060048201526014602482015273696e73756666696369656e742062616c616e636560601b6044820152606401610927565b600081600801836000013581548110610f8357610f83614c49565b90600052602060002090600302019050828060400190610fa39190614d08565b604051610fb1929190614d55565b60405190819003812090610fc6908390614d65565b60405180910390201461101c5760405163de83c54360e01b815260206004820152601860248201527f6d6f64656c20726f6f742068617368206d69736d6174636800000000000000006044820152606401610927565b6007820154600090611040906001600160a01b031661103a86614ddb565b90612fba565b9050806110905760405163de83c54360e01b815260206004820181905260248201527f54454520736574746c656d656e742076616c69646174696f6e206661696c65646044820152606401610927565b600282015460c08501359060ff1615611149576110b06020860186614d08565b90506000036111015760405162461bcd60e51b815260206004820152601a60248201527f7365637265742073686f756c64206e6f7420626520656d7074790000000000006044820152606401610927565b61110e6020860186614d08565b600886018054883590811061112557611125614c49565b90600052602060002090600302016001019182611143929190614ef3565b506111bb565b6111566020860186614d08565b15905061119e5760405162461bcd60e51b81526020600482015260166024820152757365637265742073686f756c6420626520656d70747960501b6044820152606401610927565b6064600c54826111ae9190614fc8565b6111b89190614fdf565b90505b606085013560028501556111cf8482613000565b5050505050565b610ce7600483338461327f565b60606106286004848433613359565b6111fd600933613799565b60405133907f29d546abb6e94f4f04d5bdccb6682316f597d43776078f47e273f000e77b2a9190600090a2565b600054600160a01b900460ff161561128f5760405162461bcd60e51b815260206004820152602260248201527f496e697469616c697a61626c653a20616c726561647920696e697469616c697a604482015261195960f21b6064820152608401610927565b6000805460ff60a01b1916600160a01b1790556112ab82612c04565b60019390935550600280546001600160a01b039092166001600160a01b0319928316811790915560038054909216179055600c55565b6002546001600160a01b0316331461130b5760405162461bcd60e51b815260040161092790614cc7565b600080610d706004868634876137e8565b611324612baa565b600c55565b610ce7600433848461389b565b61133e612baa565b6001600160a01b0381166113a35760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610927565b6113ac81612c04565b50565b6113b7612baa565b600155565b6113c4614035565b6113d06004848461226c565b604080516101208101825282546001600160a01b039081168252600184015416602080830191909152600284015482840152600384015460608301526004840154608083015260058401805484518184028101840190955280855292949360a0860193909260009084015b82821015611494576000848152602090819020604080516080810182526004860290920180548352600180820154848601526002820154928401929092526003015460ff1615156060830152908352909201910161143b565b5050505081526020016006820180546114ac90614c0f565b80601f01602080910402602001604051908101604052809291908181526020018280546114d890614c0f565b80156115255780601f106114fa57610100808354040283529160200191611525565b820191906000526020600020905b81548152906001019060200180831161150857829003601f168201915b505050918352505060078201546001600160a01b0316602080830191909152600883018054604080518285028101850182528281529401939260009084015b828210156116cc578382906000526020600020906003020160405180606001604052908160008201805461159790614c0f565b80601f01602080910402602001604051908101604052809291908181526020018280546115c390614c0f565b80156116105780601f106115e557610100808354040283529160200191611610565b820191906000526020600020905b8154815290600101906020018083116115f357829003601f168201915b5050505050815260200160018201805461162990614c0f565b80601f016020809104026020016040519081016040528092919081815260200182805461165590614c0f565b80156116a25780601f10611677576101008083540402835291602001916116a2565b820191906000526020600020905b81548152906001019060200180831161168557829003601f168201915b50505091835250506002919091015460ff1615156020918201529082526001929092019101611564565b50505091525090949350505050565b606060006116e88361390e565b9050806001600160401b038111156117025761170261471a565b60405190808252806020026020018201604052801561173b57816020015b611728614035565b8152602001906001900390816117205790505b50915060005b81811015611a87576117538482613919565b604080516101208101825282546001600160a01b039081168252600184015416602080830191909152600284015482840152600384015460608301526004840154608083015260058401805484518184028101840190955280855292949360a0860193909260009084015b82821015611817576000848152602090819020604080516080810182526004860290920180548352600180820154848601526002820154928401929092526003015460ff161515606083015290835290920191016117be565b50505050815260200160068201805461182f90614c0f565b80601f016020809104026020016040519081016040528092919081815260200182805461185b90614c0f565b80156118a85780601f1061187d576101008083540402835291602001916118a8565b820191906000526020600020905b81548152906001019060200180831161188b57829003601f168201915b505050918352505060078201546001600160a01b0316602080830191909152600883018054604080518285028101850182528281529401939260009084015b82821015611a4f578382906000526020600020906003020160405180606001604052908160008201805461191a90614c0f565b80601f016020809104026020016040519081016040528092919081815260200182805461194690614c0f565b80156119935780601f1061196857610100808354040283529160200191611993565b820191906000526020600020905b81548152906001019060200180831161197657829003601f168201915b505050505081526020016001820180546119ac90614c0f565b80601f01602080910402602001604051908101604052809291908181526020018280546119d890614c0f565b8015611a255780601f106119fa57610100808354040283529160200191611a25565b820191906000526020600020905b815481529060010190602001808311611a0857829003601f168201915b50505091835250506002919091015460ff16151560209182015290825260019290920191016118e7565b5050505081525050838281518110611a6957611a69614c49565b60200260200101819052508080611a7f90615001565b915050611741565b5050919050565b6000611aa384611a9e858561393f565b613977565b949350505050565b60006106288383613983565b6001600160a01b0383166000908152600385016020526040812060609190611ade816139d4565b9150818510611b21576040805160008082526020820190925290611b18565b611b05614035565b815260200190600190039081611afd5790505b50925050611f11565b60008415611b3857611b33858761501a565b611b3a565b825b905082811115611b475750815b6000611b53878361502d565b9050806001600160401b03811115611b6d57611b6d61471a565b604051908082528060200260200182016040528015611ba657816020015b611b93614035565b815260200190600190039081611b8b5790505b50945060005b81811015611f0c576000611bca611bc3838b61501a565b86906139de565b60008181526002808e016020908152604080842081516101208101835281546001600160a01b03908116825260018301541681850152938101548483015260038101546060850152600481015460808501526005810180548351818602810186019094528084529697509395909460a0870194929384015b82821015611c9b576000848152602090819020604080516080810182526004860290920180548352600180820154848601526002820154928401929092526003015460ff16151560608301529083529092019101611c42565b505050508152602001600682018054611cb390614c0f565b80601f0160208091040260200160405190810160405280929190818152602001828054611cdf90614c0f565b8015611d2c5780601f10611d0157610100808354040283529160200191611d2c565b820191906000526020600020905b815481529060010190602001808311611d0f57829003601f168201915b505050918352505060078201546001600160a01b0316602080830191909152600883018054604080518285028101850182528281529401939260009084015b82821015611ed35783829060005260206000209060030201604051806060016040529081600082018054611d9e90614c0f565b80601f0160208091040260200160405190810160405280929190818152602001828054611dca90614c0f565b8015611e175780601f10611dec57610100808354040283529160200191611e17565b820191906000526020600020905b815481529060010190602001808311611dfa57829003601f168201915b50505050508152602001600182018054611e3090614c0f565b80601f0160208091040260200160405190810160405280929190818152602001828054611e5c90614c0f565b8015611ea95780601f10611e7e57610100808354040283529160200191611ea9565b820191906000526020600020905b815481529060010190602001808311611e8c57829003601f168201915b50505091835250506002919091015460ff1615156020918201529082526001929092019101611d6b565b5050505081525050878381518110611eed57611eed614c49565b6020026020010181905250508080611f0490615001565b915050611bac565b505050505b94509492505050565b60606000611f278361390e565b9050806001600160401b03811115611f4157611f4161471a565b604051908082528060200260200182016040528015611f7a57816020015b611f67613fb4565b815260200190600190039081611f5f5790505b50915060005b81811015611a8757611f928482613919565b6040805160e0810190915281546001600160a01b03168152600182018054919291602084019190611fc290614c0f565b80601f0160208091040260200160405190810160405280929190818152602001828054611fee90614c0f565b801561203b5780601f106120105761010080835404028352916020019161203b565b820191906000526020600020905b81548152906001019060200180831161201e57829003601f168201915b50505050508152602001600282016040518060a00160405290816000820154815260200160018201548152602001600282015481526020016003820154815260200160048201805461208c90614c0f565b80601f01602080910402602001604051908101604052809291908181526020018280546120b890614c0f565b80156121055780601f106120da57610100808354040283529160200191612105565b820191906000526020600020905b8154815290600101906020018083116120e857829003601f168201915b505050919092525050508152600782015460208083019190915260088301546001600160a01b038116604080850191909152600160a01b90910460ff1615156060840152600984018054825181850281018501909352808352608090940193919290919060009084015b8282101561221b57838290600052602060002001805461218e90614c0f565b80601f01602080910402602001604051908101604052809291908181526020018280546121ba90614c0f565b80156122075780601f106121dc57610100808354040283529160200191612207565b820191906000526020600020905b8154815290600101906020018083116121ea57829003601f168201915b50505050508152602001906001019061216f565b505050508152505083828151811061223557612235614c49565b60200260200101819052508061224a90615001565b9050611f80565b60008061225f8585856139ea565b6004015495945050505050565b6000611aa38484846139ea565b600061228488613a4d565b90506122908982613977565b6122ed576122e689826040518060e001604052808c6001600160a01b031681526020018b81526020018a8152602001898152602001886001600160a01b0316815260200160001515815260200186815250613a82565b5050612394565b60006122f98a8a613983565b9050600181016123098982615040565b50865160028201908155602088015160038301556040880151600483015560608801516005830155608088015188919060068401906123489082615040565b50505060078101869055600881018054851515600160a01b026001600160a81b03199091166001600160a01b038816171790558251612390906009830190602086019061409c565b5050505b5050505050505050565b6000806000806123af8888886139ea565b60058101549091506000036123ce57600093508060040154915061255b565b60058101546000906001600160401b038111156123ed576123ed61471a565b60405190808252806020026020018201604052801561244b57816020015b61243860405180608001604052806000815260200160008152602001600081526020016000151581525090565b81526020019060019003908161240b5790505b50905060008095506000935060005b600584015481101561254c57600084600501828154811061247d5761247d614c49565b60009182526020909120600490910201600381015490915060ff16156124a3575061253a565b8881600201546124b3919061501a565b42106124cf5760018101546124c8908961501a565b9750612538565b604051806080016040528084815260200182600101548152602001826002015481526020016000151581525084848151811061250d5761250d614c49565b6020026020010181905250806001015486612528919061501a565b95508261253481615001565b9350505b505b8061254481615001565b91505061245a565b50612558838383613b7d565b50505b8381600301600082825461256f919061502d565b90915550506004810182905560030154929792965094509092505050565b6001600160a01b03831660009081526004850160205260408120606091906125b4816139d4565b91508185106125f6576040805160008082526020820190925290611b18565b6125db614035565b8152602001906001900390816125d357905050925050611f11565b6000841561260d57612608858761501a565b61260f565b825b90508281111561261c5750815b6000612628878361502d565b9050806001600160401b038111156126425761264261471a565b60405190808252806020026020018201604052801561267b57816020015b612668614035565b8152602001906001900390816126605790505b50945060005b81811015611f0c576000612698611bc3838b61501a565b60008181526002808e016020908152604080842081516101208101835281546001600160a01b03908116825260018301541681850152938101548483015260038101546060850152600481015460808501526005810180548351818602810186019094528084529697509395909460a0870194929384015b82821015612769576000848152602090819020604080516080810182526004860290920180548352600180820154848601526002820154928401929092526003015460ff16151560608301529083529092019101612710565b50505050815260200160068201805461278190614c0f565b80601f01602080910402602001604051908101604052809291908181526020018280546127ad90614c0f565b80156127fa5780601f106127cf576101008083540402835291602001916127fa565b820191906000526020600020905b8154815290600101906020018083116127dd57829003601f168201915b505050918352505060078201546001600160a01b0316602080830191909152600883018054604080518285028101850182528281529401939260009084015b828210156129a1578382906000526020600020906003020160405180606001604052908160008201805461286c90614c0f565b80601f016020809104026020016040519081016040528092919081815260200182805461289890614c0f565b80156128e55780601f106128ba576101008083540402835291602001916128e5565b820191906000526020600020905b8154815290600101906020018083116128c857829003601f168201915b505050505081526020016001820180546128fe90614c0f565b80601f016020809104026020016040519081016040528092919081815260200182805461292a90614c0f565b80156129775780601f1061294c57610100808354040283529160200191612977565b820191906000526020600020905b81548152906001019060200180831161295a57829003601f168201915b50505091835250506002919091015460ff1615156020918201529082526001929092019101612839565b50505050815250508783815181106129bb576129bb614c49565b60200260200101819052505080806129d290615001565b915050612681565b6129e884611a9e858561393f565b612a185760405163023280eb60e21b81526001600160a01b03808516600483015283166024820152604401610927565b6000612a258585856139ea565b9050806008018281548110612a3c57612a3c614c49565b90600052602060002090600302016000018054612a5890614c0f565b9050600003612aa95760405162461bcd60e51b815260206004820152601b60248201527f64656c6976657261626c6520646f6573206e6f742065786973742e00000000006044820152606401610927565b6001816008018381548110612ac057612ac0614c49565b60009182526020909120600390910201600201805460ff19169115159190911790555050505050565b6000612af68484846139ea565b9050600081600401548260030154612b0e919061502d565b905080600003612b1f575050505050565b6040805160808101825260058401805480835260208084018681524295850195865260006060860181815260018086018755958252928120955160049485029096019586559051938501939093559351600284015592516003909201805460ff1916921515929092179091559083018054839290612b9e90849061501a565b90915550505050505050565b6000546001600160a01b03163314610d335760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610927565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000806000612c648888886139ea565b9050600085118015612c795750600581015415155b15612e8d5760058101546000906001600160401b03811115612c9d57612c9d61471a565b604051908082528060200260200182016040528015612cfb57816020015b612ce860405180608001604052806000815260200160008152602001600081526020016000151581525090565b815260200190600190039081612cbb5790505b50905060008681805b6005860154811015612e75576000866005018281548110612d2757612d27614c49565b60009182526020909120600490910201600381015490915060ff1615612d4d5750612e63565b80600101548410612d6e576001810154612d67908561502d565b9350612e61565b8315612df0576000848260010154612d86919061502d565b905060405180608001604052808781526020018281526020018360020154815260200160001515815250878781518110612dc257612dc2614c49565b6020908102919091010152612dd7818561501a565b935085612de381615001565b9650506000945050612e61565b6040805160808101825286815260018301546020820152600283015491810191909152600382015460ff16151560608201528651879087908110612e3657612e36614c49565b6020026020010181905250806001015483612e51919061501a565b925084612e5d81615001565b9550505b505b80612e6d81615001565b915050612d04565b5060048501819055612e88858585613b7d565b505050505b83816003016000828254612ea1919061501a565b90915550506003810154600490910154909890975095505050505050565b6000612ecb838361393f565b9050612ed78482613977565b612ee15750505050565b6001600160a01b03821660009081526003850160205260409020612f059082613c16565b506001600160a01b03831660009081526004850160205260409020612f2a9082613c16565b50612f358482613c16565b50600081815260028086016020526040822080546001600160a01b031990811682556001820180549091169055908101829055600381018290556004810182905590612f8460058301826140f2565b612f92600683016000614113565b6007820180546001600160a01b0319169055612fb260088301600061414d565b505050505050565b600080612fc684613c22565b90506000612fd382613c53565b9050836001600160a01b0316612fed828760a00151613c8e565b6001600160a01b03161495945050505050565b81600401548260030154613014919061502d565b81111561317957600082600401548360030154613031919061502d565b61303b908361502d565b905080836004015410156130a05760405163de83c54360e01b815260206004820152602560248201527f696e73756666696369656e742062616c616e636520696e2070656e64696e675260448201526419599d5b9960da1b6064820152608401610927565b808360040160008282546130b4919061502d565b909155505060058301546000906130cd9060019061502d565b90505b600081126131765760008460050182815481106130ef576130ef614c49565b60009182526020909120600490910201600381015490915060ff16156131155750613164565b8281600101541161313657600181015461312f908461502d565b9250613154565b8281600101600082825461314a919061502d565b9091555060009350505b826000036131625750613176565b505b8061316e816150ff565b9150506130d0565b50505b8082600301600082825461318d919061502d565b90915550506003548254604051631bb1482360e31b81526001600160a01b0391821660048201526024810184905291169063dd8a411890604401600060405180830381600087803b1580156131e157600080fd5b505af11580156131f5573d6000803e3d6000fd5b50508354600385015460048601546040805192835260208301919091523394506001600160a01b0390921692507f526824944047da5b81071fb6349412005c5da81380b336103fbe5dd34556c776910160405180910390a3604051339082156108fc029083906000818181858888f1935050505015801561327a573d6000803e3d6000fd5b505050565b61328d84611a9e858561393f565b6132bd5760405163023280eb60e21b81526001600160a01b03808516600483015283166024820152604401610927565b60006132ca8585856139ea565b604080516060810182528481528151602081810184526000808352818401929092529282018190526008840180546001810182559082529290208151939450909283926003029091019081906133209082615040565b50602082015160018201906133359082615040565b50604091909101516002909101805460ff1916911515919091179055505050505050565b60606101f48311156133ad5760405162461bcd60e51b815260206004820152601e60248201527f42617463682073697a6520746f6f206c6172676520286d6178203530302900006044820152606401610927565b826001600160401b038111156133c5576133c561471a565b6040519080825280602002602001820160405280156133fe57816020015b6133eb614035565b8152602001906001900390816133e35790505b50905060005b8381101561379057600061343e86868481811061342357613423614c49565b905060200201602081019061343891906144de565b8561393f565b905061344a8782613977565b1561377d57600081815260028089016020908152604080842081516101208101835281546001600160a01b03908116825260018301541681850152938101548483015260038101546060850152600481015460808501526005810180548351818602810186019094528084529495919460a08701949192909184015b8282101561351f576000848152602090819020604080516080810182526004860290920180548352600180820154848601526002820154928401929092526003015460ff161515606083015290835290920191016134c6565b50505050815260200160068201805461353790614c0f565b80601f016020809104026020016040519081016040528092919081815260200182805461356390614c0f565b80156135b05780601f10613585576101008083540402835291602001916135b0565b820191906000526020600020905b81548152906001019060200180831161359357829003601f168201915b505050918352505060078201546001600160a01b0316602080830191909152600883018054604080518285028101850182528281529401939260009084015b82821015613757578382906000526020600020906003020160405180606001604052908160008201805461362290614c0f565b80601f016020809104026020016040519081016040528092919081815260200182805461364e90614c0f565b801561369b5780601f106136705761010080835404028352916020019161369b565b820191906000526020600020905b81548152906001019060200180831161367e57829003601f168201915b505050505081526020016001820180546136b490614c0f565b80601f01602080910402602001604051908101604052809291908181526020018280546136e090614c0f565b801561372d5780601f106137025761010080835404028352916020019161372d565b820191906000526020600020905b81548152906001019060200180831161371057829003601f168201915b50505091835250506002919091015460ff16151560209182015290825260019290920191016135ef565b505050508152505083838151811061377157613771614c49565b60200260200101819052505b508061378881615001565b915050613404565b50949350505050565b60006137a482613a4d565b90506137b08382613977565b6137d8576040516304c76d3f60e11b81526001600160a01b0383166004820152602401610927565b6137e28382613d0d565b50505050565b60008060006137f7878761393f565b90506138038882613977565b1561383457604051632cf0675960e21b81526001600160a01b03808916600483015287166024820152604401610927565b613842888289898989613d9d565b6001600160a01b038616600090815260038901602052604090206138669082613df5565b506001600160a01b0387166000908152600489016020526040902061388b9082613df5565b5093976000975095505050505050565b6138a984611a9e858561393f565b6138d95760405163023280eb60e21b81526001600160a01b03808516600483015283166024820152604401610927565b60006138e68585856139ea565b60070180546001600160a01b0319166001600160a01b03939093169290921790915550505050565b600061062b826139d4565b60008061392684846139de565b6000908152600285016020526040902091505092915050565b604080516001600160a01b03938416602080830191909152929093168382015280518084038201815260609093019052815191012090565b60006106288383613e01565b60008061398f83613a4d565b600081815260028601602052604090209091506139ac8583613977565b611aa3576040516304c76d3f60e11b81526001600160a01b0385166004820152602401610927565b600061062b825490565b60006106288383613e19565b6000806139f7848461393f565b60008181526002870160205260409020909150613a148683613977565b613a445760405163023280eb60e21b81526001600160a01b03808716600483015285166024820152604401610927565b95945050505050565b604080516001600160a01b0383166020820152600091015b604051602081830303815290604052805190602001209050919050565b600082815260028401602090815260408220835181546001600160a01b0319166001600160a01b03909116178155908301518391906001820190613ac69082615040565b50604082015181600201600082015181600001556020820151816001015560408201518160020155606082015181600301556080820151816004019081613b0d9190615040565b50505060608201516007820155608082015160088201805460a08501511515600160a01b026001600160a81b03199091166001600160a01b039093169290921791909117905560c08201518051613b6e91600984019160209091019061409c565b50611aa3915085905084613df5565b613b8b6005840160006140f2565b60005b818110156137e25783600501838281518110613bac57613bac614c49565b60209081029190910181015182546001808201855560009485529383902082516004909202019081559181015192820192909255604082015160028201556060909101516003909101805460ff191691151591909117905580613c0e81615001565b915050613b8e565b60006106288383613e43565b6020808201516040808401516060850151608086015160c087015160e08801519451600097613a659796910161511c565b6040517f19457468657265756d205369676e6564204d6573736167653a0a3332000000006020820152603c8101829052600090605c01613a65565b600080600080613c9d85613f36565b6040805160008152602081018083528b905260ff8516918101919091526060810183905260808101829052929550909350915060019060a0016020604051602081039080840390855afa158015613cf8573d6000803e3d6000fd5b5050604051601f190151979650505050505050565b6000818152600283016020526040812080546001600160a01b031916815581613d396001830182614113565b60006002830181815560038401829055600484018290556005840182905590613d656006850182614113565b50506000600783018190556008830180546001600160a81b0319169055613d9090600984019061416e565b5061062890508383613c16565b600085815260028701602052604090206003810183905580546001600160a01b038087166001600160a01b03199283161783556001830180549187169190921617905560068101613dee8382615040565b5061239487875b60006106288383613f65565b60008181526001830160205260408120541515610628565b6000826000018281548110613e3057613e30614c49565b9060005260206000200154905092915050565b60008181526001830160205260408120548015613f2c576000613e6760018361502d565b8554909150600090613e7b9060019061502d565b9050818114613ee0576000866000018281548110613e9b57613e9b614c49565b9060005260206000200154905080876000018481548110613ebe57613ebe614c49565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080613ef157613ef161517c565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505061062b565b600091505061062b565b60008060008351604114613f4957600080fd5b5050506020810151604082015160609092015160001a92909190565b6000818152600183016020526040812054613fac5750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561062b565b50600061062b565b6040518060e0016040528060006001600160a01b03168152602001606081526020016140086040518060a0016040528060008152602001600081526020016000815260200160008152602001606081525090565b81526020016000815260200160006001600160a01b03168152602001600015158152602001606081525090565b60405180610120016040528060006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001606081526020016060815260200160006001600160a01b03168152602001606081525090565b8280548282559060005260206000209081019282156140e2579160200282015b828111156140e257825182906140d29082615040565b50916020019190600101906140bc565b506140ee929150614188565b5090565b50805460008255600402906000526020600020908101906113ac91906141a5565b50805461411f90614c0f565b6000825580601f1061412f575050565b601f0160209004906000526020600020908101906113ac91906141d3565b50805460008255600302906000526020600020908101906113ac91906141e8565b50805460008255906000526020600020908101906113ac91905b808211156140ee57600061419c8282614113565b50600101614188565b5b808211156140ee57600080825560018201819055600282015560038101805460ff191690556004016141a6565b5b808211156140ee57600081556001016141d4565b808211156140ee5760006141fc8282614113565b61420a600183016000614113565b5060028101805460ff191690556003016141e8565b600081518084526020808501945080840160005b838110156142715781518051885283810151848901526040808201519089015260609081015115159088015260809096019590820190600101614233565b509495945050505050565b60005b8381101561429757818101518382015260200161427f565b50506000910152565b600081518084526142b881602086016020860161427c565b601f01601f19169290920160200192915050565b60008151606084526142e160608501826142a0565b9050602083015184820360208601526142fa82826142a0565b9150506040830151151560408501528091505092915050565b600082825180855260208086019550808260051b84010181860160005b8481101561435e57601f1986840301895261434c8383516142cc565b98840198925090830190600101614330565b5090979650505050505050565b80516001600160a01b031682526000610120602083015161439760208601826001600160a01b03169052565b5060408301516040850152606083015160608501526080830151608085015260a08301518160a08601526143cd8286018261421f565b91505060c083015184820360c08601526143e782826142a0565b91505060e083015161440460e08601826001600160a01b03169052565b50610100808401518583038287015261441d8382614313565b9695505050505050565b600081518084526020808501808196508360051b8101915082860160005b8581101561446f57828403895261445d84835161436b565b98850198935090840190600101614445565b5091979650505050505050565b6020815260006106286020830184614427565b80356001600160a01b03811681146144a657600080fd5b919050565b600080604083850312156144be57600080fd5b6144c78361448f565b91506144d56020840161448f565b90509250929050565b6000602082840312156144f057600080fd5b6106288261448f565b805182526020810151602083015260408101516040830152606081015160608301526000608082015160a06080850152611aa360a08501826142a0565b600060018060a01b0380835116845260208084015160e08287015261455e60e08701826142a0565b90506040850151868203604088015261457782826144f9565b9150506060850151606087015282608086015116608087015260a0850151151560a087015260c0850151925085810360c08701528083518083528383019150838160051b840101848601955060005b828110156145f457601f198583030184526145e28288516142a0565b968601969386019391506001016145c6565b5098975050505050505050565b6020815260006106286020830184614536565b60008060006060848603121561462957600080fd5b6146328461448f565b95602085013595506040909401359392505050565b60408152600061465a6040830185614427565b90508260208301529392505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b828110156146be57603f198886030184526146ac858351614536565b94509285019290850190600101614690565b5092979650505050505050565b6000806000606084860312156146e057600080fd5b6146e98461448f565b92506146f76020850161448f565b9150604084013590509250925092565b60208152600061062860208301846142cc565b634e487b7160e01b600052604160045260246000fd5b60405161010081016001600160401b03811182821017156147535761475361471a565b60405290565b604051601f8201601f191681016001600160401b03811182821017156147815761478161471a565b604052919050565b600082601f83011261479a57600080fd5b81356001600160401b038111156147b3576147b361471a565b6147c6601f8201601f1916602001614759565b8181528460208386010111156147db57600080fd5b816020850160208301376000918101602001919091529392505050565b600060a0828403121561480a57600080fd5b60405160a081016001600160401b03828210818311171561482d5761482d61471a565b8160405282935084358352602085013560208401526040850135604084015260608501356060840152608085013591508082111561486a57600080fd5b5061487785828601614789565b6080830152505092915050565b803580151581146144a657600080fd5b600082601f8301126148a557600080fd5b813560206001600160401b03808311156148c1576148c161471a565b8260051b6148d0838201614759565b93845285810183019383810190888611156148ea57600080fd5b84880192505b85831015614926578235848111156149085760008081fd5b6149168a87838c0101614789565b83525091840191908401906148f0565b98975050505050505050565b600080600080600080600060c0888a03121561494d57600080fd5b87356001600160401b038082111561496457600080fd5b818a0191508a601f83011261497857600080fd5b81358181111561498757600080fd5b8b602082850101111561499957600080fd5b6020928301995097509089013590808211156149b457600080fd5b6149c08b838c016147f8565b965060408a013595506149d560608b0161448f565b94506149e360808b01614884565b935060a08a01359150808211156149f957600080fd5b50614a068a828b01614894565b91505092959891949750929550565b60008060408385031215614a2857600080fd5b614a318361448f565b946020939093013593505050565b600060208284031215614a5157600080fd5b81356001600160401b03811115614a6757600080fd5b82016101008185031215614a7a57600080fd5b9392505050565b60008060408385031215614a9457600080fd5b614a9d8361448f565b915060208301356001600160401b03811115614ab857600080fd5b614ac485828601614789565b9150509250929050565b60008060208385031215614ae157600080fd5b82356001600160401b0380821115614af857600080fd5b818501915085601f830112614b0c57600080fd5b813581811115614b1b57600080fd5b8660208260051b8501011115614b3057600080fd5b60209290920196919550909350505050565b60008060008060808587031215614b5857600080fd5b84359350614b686020860161448f565b9250614b766040860161448f565b9396929550929360600135925050565b600080600060608486031215614b9b57600080fd5b614ba48461448f565b9250614bb26020850161448f565b915060408401356001600160401b03811115614bcd57600080fd5b614bd986828701614789565b9150509250925092565b600060208284031215614bf557600080fd5b5035919050565b602081526000610628602083018461436b565b600181811c90821680614c2357607f821691505b602082108103614c4357634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b60a081528560a0820152858760c0830137600060c087830101526000601f19601f880116820160c0838203016020840152614c9d60c08201886144f9565b604084019690965250506001600160a01b0392909216606083015215156080909101529392505050565b60208082526021908201527f43616c6c6572206973206e6f7420746865206c656467657220636f6e747261636040820152601d60fa1b606082015260800190565b6000808335601e19843603018112614d1f57600080fd5b8301803591506001600160401b03821115614d3957600080fd5b602001915036819003821315614d4e57600080fd5b9250929050565b8183823760009101908152919050565b6000808354614d7381614c0f565b60018281168015614d8b5760018114614da057614dcf565b60ff1984168752821515830287019450614dcf565b8760005260208060002060005b85811015614dc65781548a820152908401908201614dad565b50505082870194505b50929695505050505050565b60006101008236031215614dee57600080fd5b614df6614730565b8235815260208301356001600160401b0380821115614e1457600080fd5b614e2036838701614789565b60208401526040850135915080821115614e3957600080fd5b614e4536838701614789565b604084015260608501356060840152614e606080860161448f565b608084015260a0850135915080821115614e7957600080fd5b50614e8636828601614789565b60a08301525060c083013560c0820152614ea260e0840161448f565b60e082015292915050565b601f82111561327a57600081815260208120601f850160051c81016020861015614ed45750805b601f850160051c820191505b81811015612fb257828155600101614ee0565b6001600160401b03831115614f0a57614f0a61471a565b614f1e83614f188354614c0f565b83614ead565b6000601f841160018114614f525760008515614f3a5750838201355b600019600387901b1c1916600186901b1783556111cf565b600083815260209020601f19861690835b82811015614f835786850135825560209485019460019092019101614f63565b5086821015614fa05760001960f88860031b161c19848701351681555b505060018560011b0183555050505050565b634e487b7160e01b600052601160045260246000fd5b808202811582820484141761062b5761062b614fb2565b600082614ffc57634e487b7160e01b600052601260045260246000fd5b500490565b60006001820161501357615013614fb2565b5060010190565b8082018082111561062b5761062b614fb2565b8181038181111561062b5761062b614fb2565b81516001600160401b038111156150595761505961471a565b61506d816150678454614c0f565b84614ead565b602080601f8311600181146150a2576000841561508a5750858301515b600019600386901b1c1916600185901b178555612fb2565b600085815260208120601f198616915b828110156150d1578886015182559484019460019091019084016150b2565b50858210156150ef5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b6000600160ff1b820161511457615114614fb2565b506000190190565b6000875161512e818460208c0161427c565b875190830190615142818360208c0161427c565b0195865250506bffffffffffffffffffffffff19606093841b81166020860152603485019290925290911b16605482015260680192915050565b634e487b7160e01b600052603160045260246000fdfea264697066735822122032496ff885d21c941fd57e62983533d02a1526aa18f350d6eb89e09964ff8a8864736f6c63430008140033';\nconst isSuperArgs = (xs) => xs.length > 1;\nclass FineTuningServing__factory extends ethers__WEBPACK_IMPORTED_MODULE_11__.ContractFactory {\n    constructor(...args) {\n        if (isSuperArgs(args)) {\n            super(...args);\n        }\n        else {\n            super(_abi, _bytecode, args[0]);\n        }\n    }\n    getDeployTransaction(overrides) {\n        return super.getDeployTransaction(overrides || {});\n    }\n    deploy(overrides) {\n        return super.deploy(overrides || {});\n    }\n    connect(runner) {\n        return super.connect(runner);\n    }\n    static bytecode = _bytecode;\n    static abi = _abi;\n    static createInterface() {\n        return new ethers__WEBPACK_IMPORTED_MODULE_12__.Interface(_abi);\n    }\n    static connect(address, runner) {\n        return new ethers__WEBPACK_IMPORTED_MODULE_13__.Contract(address, _abi, runner);\n    }\n}\n\n// Create interfaces from the contract factories\nconst ledgerInterface = new ethers__WEBPACK_IMPORTED_MODULE_12__.Interface(LedgerManager__factory.abi);\nconst inferenceInterface = new ethers__WEBPACK_IMPORTED_MODULE_12__.Interface(InferenceServing__factory.abi);\nconst fineTuningInterface = new ethers__WEBPACK_IMPORTED_MODULE_12__.Interface(FineTuningServing__factory.abi);\nconst contractInterfaces = {\n    ledger: ledgerInterface,\n    inference: inferenceInterface,\n    fineTuning: fineTuningInterface,\n};\nfunction decodeCustomError(error) {\n    try {\n        // Type guard for error with data property\n        const errorWithData = error;\n        // Check if it's an ethers error with custom error data\n        if (errorWithData.data && typeof errorWithData.data === 'string') {\n            const errorData = errorWithData.data;\n            // Try to decode with each contract interface\n            for (const [, contractInterface] of Object.entries(contractInterfaces)) {\n                try {\n                    // Parse the custom error\n                    const decodedError = contractInterface.parseError(errorData);\n                    if (decodedError) {\n                        // Format the error message based on the error name\n                        const errorMessages = {\n                            'LedgerNotExists': 'Account does not exist. Please create an account first using \"add-account\".',\n                            'LedgerExists': 'Account already exists. Use \"deposit\" to add funds or \"get-account\" to view details.',\n                            'InsufficientBalance': 'Insufficient balance in the account.',\n                            'ServiceNotExist': 'Service provider does not exist. Please check the provider address.',\n                            'AccountNotExist': 'Sub-account does not exist for this provider.',\n                            'AccountExist': 'Sub-account already exists for this provider.',\n                            'InvalidVerifierInput': 'Invalid verification input provided.',\n                            'Unauthorized': 'Unauthorized. You do not have permission to perform this action.',\n                            'InvalidInput': 'Invalid input parameters provided.',\n                        };\n                        let message = errorMessages[decodedError.name] || `Error: ${decodedError.name}`;\n                        // Add parameter details if available\n                        if (decodedError.args && decodedError.args.length > 0) {\n                            const argDetails = decodedError.args\n                                .map((arg, index) => {\n                                // Check if it's an address\n                                if (typeof arg === 'string' && arg.startsWith('0x') && arg.length === 42) {\n                                    return `Address: ${arg}`;\n                                }\n                                return `Arg${index}: ${arg}`;\n                            })\n                                .filter(Boolean)\n                                .join(', ');\n                            if (argDetails) {\n                                message += ` (${argDetails})`;\n                            }\n                        }\n                        return message;\n                    }\n                }\n                catch {\n                    // Continue to next interface if this one doesn't match\n                    continue;\n                }\n            }\n        }\n        // Check for error reason\n        if (errorWithData.reason) {\n            return errorWithData.reason;\n        }\n        // Check for shortMessage\n        if (errorWithData.shortMessage) {\n            return errorWithData.shortMessage;\n        }\n        return null;\n    }\n    catch {\n        return null;\n    }\n}\nfunction formatError(error) {\n    // First try to decode custom error\n    const decodedError = decodeCustomError(error);\n    if (decodedError) {\n        return decodedError;\n    }\n    const errorWithMessage = error;\n    // Check for common error patterns\n    if (errorWithMessage.message) {\n        // Check for gas estimation errors\n        if (errorWithMessage.message.includes('execution reverted')) {\n            const decoded = decodeCustomError(error);\n            if (decoded) {\n                return `Transaction failed: ${decoded}`;\n            }\n            return 'Transaction execution reverted. This usually means a requirement was not met.';\n        }\n        // Check for insufficient funds\n        if (errorWithMessage.message.includes('insufficient funds')) {\n            return 'Insufficient funds for transaction. Please check your wallet balance.';\n        }\n        // Check for nonce errors\n        if (errorWithMessage.message.includes('nonce')) {\n            return 'Transaction nonce error. Please wait a moment and try again.';\n        }\n        // Check for user rejected\n        if (errorWithMessage.message.includes('user rejected') || errorWithMessage.message.includes('User denied')) {\n            return 'Transaction was rejected by the user.';\n        }\n        // Check for network errors\n        if (errorWithMessage.message.includes('network') || errorWithMessage.message.includes('timeout')) {\n            return 'Network error. Please check your connection and try again.';\n        }\n        // Check for additional specific patterns\n        if (errorWithMessage.message.includes('Deliverable not acknowledged yet')) {\n            return \"Deliverable not acknowledged yet. Please use 'acknowledge-model' to acknowledge the deliverable.\";\n        }\n        if (errorWithMessage.message.includes('EncryptedSecret not found')) {\n            return \"Secret to decrypt model not found. Please ensure the task status is 'Finished'.\";\n        }\n    }\n    // Return original error message\n    return errorWithMessage.message || String(error);\n}\n// Helper function to throw formatted errors from within SDK functions\nfunction throwFormattedError(error) {\n    const formattedMessage = formatError(error);\n    const formattedError = new Error(formattedMessage);\n    // Preserve original error properties if possible\n    if (error && typeof error === 'object') {\n        Object.assign(formattedError, error);\n        formattedError.message = formattedMessage;\n    }\n    throw formattedError;\n}\n\nlet eddsa;\nlet babyjubjub;\nasync function initBabyJub() {\n    if (!babyjubjub) {\n        babyjubjub = await (0,circomlibjs__WEBPACK_IMPORTED_MODULE_1__.buildBabyjub)();\n    }\n}\nasync function initEddsa() {\n    if (!eddsa) {\n        eddsa = await (0,circomlibjs__WEBPACK_IMPORTED_MODULE_1__.buildEddsa)();\n    }\n}\nasync function babyJubJubGeneratePrivateKey() {\n    await initBabyJub();\n    return babyjubjub.F.random();\n}\nasync function babyJubJubGeneratePublicKey(privateKey) {\n    await initEddsa();\n    return eddsa.prv2pub(privateKey);\n}\nasync function babyJubJubSignature(msg, privateKey) {\n    await initEddsa();\n    return eddsa.signPedersen(privateKey, msg);\n}\nasync function packSignature(signature) {\n    await initEddsa();\n    return eddsa.packSignature(signature);\n}\nasync function packPoint(point) {\n    await initBabyJub();\n    return babyjubjub.packPoint(point);\n}\nasync function pedersenHash(msg) {\n    const h = await (0,circomlibjs__WEBPACK_IMPORTED_MODULE_1__.buildPedersenHash)();\n    return h.hash(msg);\n}\n\nconst BYTE_SIZE = 8;\nfunction bigintToBytes(bigint, length) {\n    const bytes = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n        bytes[i] = Number((bigint >> BigInt(BYTE_SIZE * i)) & BigInt(0xff));\n    }\n    return bytes;\n}\nfunction bytesToBigint(bytes) {\n    let bigint = BigInt(0);\n    for (let i = 0; i < bytes.length; i++) {\n        bigint += BigInt(bytes[i]) << BigInt(BYTE_SIZE * i);\n    }\n    return bigint;\n}\n\nconst FIELD_SIZE = 32;\nasync function signRequests(requests, privateKey) {\n    const serializedRequestTrace = requests.map((request) => request.serialize());\n    const signatures = [];\n    for (let i = 0; i < serializedRequestTrace.length; i++) {\n        const signature = await babyJubJubSignature(serializedRequestTrace[i], privateKey);\n        signatures.push(await packSignature(signature));\n    }\n    return signatures;\n}\n\nconst BIGINT_SIZE = 16;\nasync function genKeyPair() {\n    // generate private key\n    const privkey = await babyJubJubGeneratePrivateKey();\n    // generate public key\n    const pubkey = await babyJubJubGeneratePublicKey(privkey);\n    // pack public key to FIELD_SIZE bytes\n    const packedPubkey = await packPoint(pubkey);\n    // unpack packed pubkey to bigint\n    const packedPubkey0 = bytesToBigint(packedPubkey.slice(0, BIGINT_SIZE));\n    const packedPubkey1 = bytesToBigint(packedPubkey.slice(BIGINT_SIZE));\n    // unpack private key to bigint\n    const packPrivkey0 = bytesToBigint(privkey.slice(0, BIGINT_SIZE));\n    const packPrivkey1 = bytesToBigint(privkey.slice(BIGINT_SIZE));\n    return {\n        packedPrivkey: [packPrivkey0, packPrivkey1],\n        doublePackedPubkey: [packedPubkey0, packedPubkey1],\n    };\n}\nasync function signData(data, packedPrivkey) {\n    // unpack private key to bytes\n    const packedPrivkey0 = bigintToBytes(packedPrivkey[0], BIGINT_SIZE);\n    const packedPrivkey1 = bigintToBytes(packedPrivkey[1], BIGINT_SIZE);\n    // combine bytes to Uint8Array\n    const privateKey = new Uint8Array(FIELD_SIZE);\n    privateKey.set(packedPrivkey0, 0);\n    privateKey.set(packedPrivkey1, BIGINT_SIZE);\n    // sign data\n    const signatures = await signRequests(data, privateKey);\n    return signatures;\n}\n\nconst ADDR_LENGTH = 20;\nconst NONCE_LENGTH = 8;\nconst FEE_LENGTH = 16;\nlet Request$1 = class Request {\n    nonce;\n    fee;\n    userAddress;\n    providerAddress;\n    constructor(nonce, fee, userAddress, // hexstring format with '0x' prefix\n    providerAddress // hexstring format with '0x' prefix\n    ) {\n        this.nonce = BigInt(nonce);\n        this.fee = BigInt(fee);\n        this.userAddress = BigInt(userAddress);\n        this.providerAddress = BigInt(providerAddress);\n    }\n    serialize() {\n        const buffer = new ArrayBuffer(NONCE_LENGTH + ADDR_LENGTH * 2 + FEE_LENGTH);\n        let offset = 0;\n        // write nonce (u64)\n        const nonceBytes = bigintToBytes(this.nonce, NONCE_LENGTH);\n        new Uint8Array(buffer, offset, NONCE_LENGTH).set(nonceBytes);\n        offset += NONCE_LENGTH;\n        // write fee (u128)\n        const feeBytes = bigintToBytes(this.fee, FEE_LENGTH);\n        new Uint8Array(buffer, offset, FEE_LENGTH).set(feeBytes);\n        offset += FEE_LENGTH;\n        // write userAddress (u160)\n        const userAddressBytes = bigintToBytes(this.userAddress, ADDR_LENGTH);\n        new Uint8Array(buffer, offset, ADDR_LENGTH).set(userAddressBytes);\n        offset += ADDR_LENGTH;\n        // write providerAddress (u160)\n        const providerAddressBytes = bigintToBytes(this.providerAddress, ADDR_LENGTH);\n        new Uint8Array(buffer, offset, ADDR_LENGTH).set(providerAddressBytes);\n        offset += ADDR_LENGTH;\n        return new Uint8Array(buffer);\n    }\n    static deserialize(byteArray) {\n        const expectedLength = NONCE_LENGTH + ADDR_LENGTH * 2 + FEE_LENGTH;\n        if (byteArray.length !== expectedLength) {\n            throw new Error(`Invalid byte array length for deserialization. Expected: ${expectedLength}, but got: ${byteArray.length}`);\n        }\n        let offset = 0;\n        // read nonce (u64)\n        const nonce = bytesToBigint(new Uint8Array(byteArray.slice(offset, offset + NONCE_LENGTH)));\n        offset += NONCE_LENGTH;\n        // read fee (u128)\n        const fee = bytesToBigint(new Uint8Array(byteArray.slice(offset, offset + FEE_LENGTH)));\n        offset += FEE_LENGTH;\n        // read userAddress (u160)\n        const userAddress = bytesToBigint(new Uint8Array(byteArray.slice(offset, offset + ADDR_LENGTH)));\n        offset += ADDR_LENGTH;\n        // read providerAddress (u160)\n        const providerAddress = bytesToBigint(new Uint8Array(byteArray.slice(offset, offset + ADDR_LENGTH)));\n        offset += ADDR_LENGTH;\n        return new Request(nonce.toString(), fee.toString(), '0x' + userAddress.toString(16), '0x' + providerAddress.toString(16));\n    }\n    // Getters\n    getNonce() {\n        return this.nonce;\n    }\n    getFee() {\n        return this.fee;\n    }\n    getUserAddress() {\n        return this.userAddress;\n    }\n    getProviderAddress() {\n        return this.providerAddress;\n    }\n};\n\nclass ZGServingUserBrokerBase {\n    contract;\n    metadata;\n    cache;\n    checkAccountThreshold = BigInt(100);\n    topUpTriggerThreshold = BigInt(500);\n    topUpTargetThreshold = BigInt(1000);\n    ledger;\n    constructor(contract, ledger, metadata, cache) {\n        this.contract = contract;\n        this.ledger = ledger;\n        this.metadata = metadata;\n        this.cache = cache;\n    }\n    async getProviderData() {\n        const key = `${this.contract.getUserAddress()}`;\n        const [settleSignerPrivateKey] = await Promise.all([\n            this.metadata.getSettleSignerPrivateKey(key),\n        ]);\n        return { settleSignerPrivateKey };\n    }\n    async getService(providerAddress, useCache = true) {\n        const key = providerAddress;\n        const cachedSvc = await this.cache.getItem(key);\n        if (cachedSvc && useCache) {\n            return cachedSvc;\n        }\n        try {\n            const svc = await this.contract.getService(providerAddress);\n            await this.cache.setItem(key, svc, 10 * 60 * 1000, CacheValueTypeEnum.Service);\n            return svc;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getQuote(providerAddress) {\n        try {\n            const service = await this.getService(providerAddress);\n            const url = service.url;\n            const endpoint = `${url}/v1/quote`;\n            const quoteString = await this.fetchText(endpoint, {\n                method: 'GET',\n            });\n            const ret = JSON.parse(quoteString, (_, value) => {\n                if (typeof value === 'string' && /^\\d+$/.test(value)) {\n                    return BigInt(value);\n                }\n                return value;\n            });\n            return ret;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async userAcknowledged(providerAddress) {\n        const userAddress = this.contract.getUserAddress();\n        const key = `${userAddress}_${providerAddress}_ack`;\n        const cachedSvc = await this.cache.getItem(key);\n        if (cachedSvc) {\n            return true;\n        }\n        try {\n            const account = await this.contract.getAccount(providerAddress);\n            if (account.providerPubKey[0] !== 0n &&\n                account.providerPubKey[1] !== 0n) {\n                await this.cache.setItem(key, account.providerPubKey, 10 * 60 * 1000, CacheValueTypeEnum.Other);\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async fetchText(endpoint, options) {\n        try {\n            const response = await fetch(endpoint, options);\n            if (!response.ok) {\n                throw new Error(`HTTP error! Status: ${response.status}`);\n            }\n            const buffer = await response.arrayBuffer();\n            return Buffer.from(buffer).toString('utf-8');\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getExtractor(providerAddress, useCache = true) {\n        try {\n            const svc = await this.getService(providerAddress, useCache);\n            const extractor = this.createExtractor(svc);\n            return extractor;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    createExtractor(svc) {\n        switch (svc.serviceType) {\n            case 'chatbot':\n                return new ChatBot(svc);\n            default:\n                throw new Error('Unknown service type');\n        }\n    }\n    a0giToNeuron(value) {\n        const valueStr = value.toFixed(18);\n        const parts = valueStr.split('.');\n        // Handle integer part\n        const integerPart = parts[0];\n        let integerPartAsBigInt = BigInt(integerPart) * BigInt(10 ** 18);\n        // Handle fractional part if it exists\n        if (parts.length > 1) {\n            let fractionalPart = parts[1];\n            while (fractionalPart.length < 18) {\n                fractionalPart += '0';\n            }\n            if (fractionalPart.length > 18) {\n                fractionalPart = fractionalPart.slice(0, 18); // Truncate to avoid overflow\n            }\n            const fractionalPartAsBigInt = BigInt(fractionalPart);\n            integerPartAsBigInt += fractionalPartAsBigInt;\n        }\n        return integerPartAsBigInt;\n    }\n    neuronToA0gi(value) {\n        const divisor = BigInt(10 ** 18);\n        const integerPart = value / divisor;\n        const remainder = value % divisor;\n        const decimalPart = Number(remainder) / Number(divisor);\n        return Number(integerPart) + decimalPart;\n    }\n    async getHeader(providerAddress, content, outputFee, vllmProxy) {\n        try {\n            const userAddress = this.contract.getUserAddress();\n            if (!(await this.userAcknowledged(providerAddress))) {\n                throw new Error('Provider signer is not acknowledged');\n            }\n            const extractor = await this.getExtractor(providerAddress);\n            const { settleSignerPrivateKey } = await this.getProviderData();\n            const key = userAddress;\n            let privateKey = settleSignerPrivateKey;\n            if (!privateKey) {\n                const account = await this.contract.getAccount(providerAddress);\n                const privateKeyStr = await decryptData(this.contract.signer, account.additionalInfo);\n                privateKey = strToPrivateKey(privateKeyStr);\n                console.log('Private key new:', privateKey);\n                this.metadata.storeSettleSignerPrivateKey(key, privateKey);\n            }\n            const nonce = await getNonceWithCache(this.cache);\n            const inputFee = await this.calculateInputFees(extractor, content);\n            const fee = inputFee + outputFee;\n            const request = new Request$1(nonce.toString(), fee.toString(), userAddress, providerAddress);\n            const settleSignature = await signData([request], privateKey);\n            const sig = JSON.stringify(Array.from(settleSignature[0]));\n            const requestHash = await this.calculatePedersenHash(nonce, userAddress, providerAddress);\n            return {\n                'X-Phala-Signature-Type': 'StandaloneApi',\n                Address: userAddress,\n                Fee: fee.toString(),\n                'Input-Fee': inputFee.toString(),\n                Nonce: nonce.toString(),\n                'Request-Hash': requestHash,\n                Signature: sig,\n                'VLLM-Proxy': `${vllmProxy}`,\n            };\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async calculatePedersenHash(nonce, userAddress, providerAddress) {\n        const ADDR_LENGTH = 20;\n        const NONCE_LENGTH = 8;\n        const buffer = new ArrayBuffer(NONCE_LENGTH + ADDR_LENGTH * 2);\n        let offset = 0;\n        const nonceBytes = bigintToBytes(BigInt(nonce), NONCE_LENGTH);\n        new Uint8Array(buffer, offset, NONCE_LENGTH).set(nonceBytes);\n        offset += NONCE_LENGTH;\n        new Uint8Array(buffer, offset, ADDR_LENGTH).set(bigintToBytes(BigInt(userAddress), ADDR_LENGTH));\n        offset += ADDR_LENGTH;\n        new Uint8Array(buffer, offset, ADDR_LENGTH).set(bigintToBytes(BigInt(providerAddress), ADDR_LENGTH));\n        return (0,ethers__WEBPACK_IMPORTED_MODULE_14__.hexlify)(await pedersenHash(Buffer.from(buffer)));\n    }\n    async calculateInputFees(extractor, content) {\n        const svc = await extractor.getSvcInfo();\n        const inputCount = await extractor.getInputCount(content);\n        const inputFee = BigInt(inputCount) * svc.inputPrice;\n        return inputFee;\n    }\n    async updateCachedFee(provider, fee) {\n        try {\n            const curFee = (await this.cache.getItem(provider + '_cachedFee')) || BigInt(0);\n            await this.cache.setItem(provider + '_cachedFee', BigInt(curFee) + fee, 1 * 60 * 1000, CacheValueTypeEnum.BigInt);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async clearCacheFee(provider, fee) {\n        try {\n            const curFee = (await this.cache.getItem(provider + '_cachedFee')) || BigInt(0);\n            await this.cache.setItem(provider, BigInt(curFee) + fee, 1 * 60 * 1000, CacheValueTypeEnum.BigInt);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    /**\n     * Transfer fund from ledger if fund in the inference account is less than a 500 * (inputPrice + outputPrice)\n     */\n    async topUpAccountIfNeeded(provider, content, gasPrice) {\n        try {\n            // Exit early if running in browser environment\n            if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\n                return;\n            }\n            const extractor = await this.getExtractor(provider);\n            const svc = await extractor.getSvcInfo();\n            // Calculate target and trigger thresholds\n            const targetThreshold = this.topUpTargetThreshold * (svc.inputPrice + svc.outputPrice);\n            const triggerThreshold = this.topUpTriggerThreshold * (svc.inputPrice + svc.outputPrice);\n            // Check if it's the first round\n            const isFirstRound = (await this.cache.getItem('firstRound')) !== 'false';\n            if (isFirstRound) {\n                await this.handleFirstRound(provider, triggerThreshold, targetThreshold, gasPrice);\n                return;\n            }\n            // Calculate new fee and update cached fee\n            const newFee = await this.calculateInputFees(extractor, content);\n            await this.updateCachedFee(provider, newFee);\n            // Check if we need to check the account\n            if (!(await this.shouldCheckAccount(svc)))\n                return;\n            // Re-check the account balance\n            const acc = await this.contract.getAccount(provider);\n            const lockedFund = acc.balance - acc.pendingRefund;\n            if (lockedFund < triggerThreshold) {\n                await this.ledger.transferFund(provider, 'inference', targetThreshold, gasPrice);\n            }\n            await this.clearCacheFee(provider, newFee);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async handleFirstRound(provider, triggerThreshold, targetThreshold, gasPrice) {\n        let needTransfer = false;\n        try {\n            const acc = await this.contract.getAccount(provider);\n            const lockedFund = acc.balance - acc.pendingRefund;\n            needTransfer = lockedFund < triggerThreshold;\n        }\n        catch {\n            needTransfer = true;\n        }\n        if (needTransfer) {\n            await this.ledger.transferFund(provider, 'inference', targetThreshold, gasPrice);\n        }\n        // Mark the first round as complete\n        await this.cache.setItem('firstRound', 'false', 10000000 * 60 * 1000, CacheValueTypeEnum.Other);\n    }\n    /**\n     * Check the cache fund for this provider, return true if the fund is above 1000 * (inputPrice + outputPrice)\n     * @param svc\n     */\n    async shouldCheckAccount(svc) {\n        try {\n            const key = svc.provider + '_cachedFee';\n            const usedFund = (await this.cache.getItem(key)) || BigInt(0);\n            return (usedFund >\n                this.checkAccountThreshold * (svc.inputPrice + svc.outputPrice));\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n}\n\n/**\n * AccountProcessor contains methods for creating, depositing funds, and retrieving 0G Serving Accounts.\n */\nclass AccountProcessor extends ZGServingUserBrokerBase {\n    async getAccount(provider) {\n        try {\n            return await this.contract.getAccount(provider);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getAccountWithDetail(provider) {\n        try {\n            const [account, lockTime] = await Promise.all([\n                this.contract.getAccount(provider),\n                this.contract.lockTime(),\n            ]);\n            const now = BigInt(Math.floor(Date.now() / 1000));\n            const refunds = account.refunds\n                .filter((refund) => !refund.processed)\n                .filter((refund) => refund.amount !== BigInt(0))\n                .map((refund) => ({\n                amount: refund.amount,\n                remainTime: lockTime - (now - refund.createdAt),\n            }));\n            return [account, refunds];\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async listAccount() {\n        try {\n            return await this.contract.listAccount();\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n}\n\nclass InferenceServingContract {\n    serving;\n    signer;\n    _userAddress;\n    constructor(signer, contractAddress, userAddress) {\n        this.serving = InferenceServing__factory.connect(contractAddress, signer);\n        this.signer = signer;\n        this._userAddress = userAddress;\n    }\n    lockTime() {\n        return this.serving.lockTime();\n    }\n    async listService() {\n        try {\n            const services = await this.serving.getAllServices();\n            return services;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async listAccount() {\n        try {\n            const accounts = await this.serving.getAllAccounts();\n            return accounts;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getAccount(provider) {\n        try {\n            const user = this.getUserAddress();\n            const account = await this.serving.getAccount(user, provider);\n            return account;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async acknowledgeProviderSigner(providerAddress, providerSigner) {\n        try {\n            const tx = await this.serving.acknowledgeProviderSigner(providerAddress, providerSigner);\n            const receipt = await tx.wait();\n            if (!receipt || receipt.status !== 1) {\n                const error = new Error('Transaction failed');\n                throw error;\n            }\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getService(providerAddress) {\n        try {\n            return this.serving.getService(providerAddress);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    getUserAddress() {\n        return this._userAddress;\n    }\n}\n\n/**\n * MESSAGE_FOR_ENCRYPTION_KEY is a fixed message used to derive the encryption key.\n *\n * Background:\n * To ensure a consistent and unique encryption key can be generated from a user's Ethereum wallet,\n * we utilize a fixed message combined with a signing mechanism.\n *\n * Purpose:\n * - This string is provided to the Ethereum signing function to generate a digital signature based on the user's private key.\n * - The produced signature is then hashed (using SHA-256) to create a consistent 256-bit encryption key from the same wallet.\n * - This process offers a way to protect data without storing additional keys.\n *\n * Note:\n * - The uniqueness and stability of this message are crucial; do not change it unless you fully understand the impact\n *   on the key derivation and encryption process.\n * - Because the signature is derived from the wallet's private key, it ensures that different wallets cannot produce the same key.\n */\nconst ZG_RPC_ENDPOINT_TESTNET = 'https://evmrpc-testnet.0g.ai';\nconst INDEXER_URL_TURBO = 'http://47.251.40.189:12345';\nconst TOKEN_COUNTER_MERKLE_ROOT = '0x4e8ae3790920b9971397f088fcfacbb9dad0c28ec2831f37f3481933b1fdbdbc';\nconst TOKEN_COUNTER_FILE_HASH = '26ab266a12c9ce34611aba3f82baf056dc683181236d5fa15edb8eb8c8db3872';\nconst MODEL_HASH_MAP = {\n    'distilbert-base-uncased': {\n        turbo: '0x7f2244b25cd2219dfd9d14c052982ecce409356e0f08e839b79796e270d110a7',\n        standard: '',\n        description: 'DistilBERT is a transformers model, smaller and faster than BERT, which was pretrained on the same corpus in a self-supervised fashion, using the BERT base model as a teacher. More details can be found at: https://huggingface.co/distilbert/distilbert-base-uncased',\n        tokenizer: '0x3317127671a3217583069001b2a00454ef4d1e838f8f1f4ffbe64db0ec7ed960',\n        type: 'text',\n    },\n    // mobilenet_v2: {\n    //     turbo: '0x8645816c17a8a70ebf32bcc7e621c659e8d0150b1a6bfca27f48f83010c6d12e',\n    //     standard: '',\n    //     description:\n    //         'MobileNet V2 model pre-trained on ImageNet-1k at resolution 224x224. More details can be found at: https://huggingface.co/google/mobilenet_v2_1.0_224',\n    // tokenizer:\n    //     '0xcfdb4cf199829a3cbd453dd39cea5c337a29d4be5a87bad99d76f5a33ac2dfba',\n    // type: 'image',\n    // },\n    // 'deepseek-r1-distill-qwen-1.5b': {\n    //     turbo: '0x2084fdd904c9a3317dde98147d4e7778a40e076b5b0eb469f7a8f27ae5b13e7f',\n    //     standard: '',\n    //     description:\n    //         'DeepSeek-R1-Zero, a model trained via large-scale reinforcement learning (RL) without supervised fine-tuning (SFT) as a preliminary step, demonstrated remarkable performance on reasoning. More details can be found at: https://huggingface.co/deepseek-ai/DeepSeek-R1-Distill-Qwen-1.5B',\n    // tokenizer:\n    //     '0x382842561e59d71f90c1861041989428dd2c1f664e65a56ea21f3ade216b2046',\n    // type: 'text',\n    // },\n    // 'cocktailsgd-opt-1.3b': {\n    //     turbo: '0x02ed6d3889bebad9e2cd4008066478654c0886b12ad25ea7cf7d31df3441182e',\n    //     standard: '',\n    //     description:\n    //         'CocktailSGD-opt-1.3B finetunes the Opt-1.3B langauge model with CocktailSGD, which is a novel distributed finetuning framework. More details can be found at: https://github.com/DS3Lab/CocktailSGD',\n    //     tokenizer:\n    //         '0x459311517bdeb3a955466d4e5e396944b2fdc68890de78f506261d95e6d1b000',\n    //     type: 'text',\n    // },\n    // // TODO: remove\n    // 'mock-model': {\n    //     turbo: '0xcb42b5ca9e998c82dd239ef2d20d22a4ae16b3dc0ce0a855c93b52c7c2bab6dc',\n    //     standard: '',\n    //     description: '',\n    //     tokenizer:\n    //         '0x382842561e59d71f90c1861041989428dd2c1f664e65a56ea21f3ade216b2046',\n    //     type: 'text',\n    // },\n};\n// AutomataDcapAttestation for quote verification\n// https://explorer.ata.network/address/0xE26E11B257856B0bEBc4C759aaBDdea72B64351F/contract/65536_2/readContract#F6\nconst AUTOMATA_RPC = 'https://1rpc.io/ata';\nconst AUTOMATA_CONTRACT_ADDRESS = '0xE26E11B257856B0bEBc4C759aaBDdea72B64351F';\nconst AUTOMATA_ABI = [\n    {\n        inputs: [\n            {\n                internalType: 'bytes',\n                name: 'rawQuote',\n                type: 'bytes',\n            },\n        ],\n        name: 'verifyAndAttestOnChain',\n        outputs: [\n            {\n                internalType: 'bool',\n                name: 'success',\n                type: 'bool',\n            },\n            {\n                internalType: 'bytes',\n                name: 'output',\n                type: 'bytes',\n            },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n];\n\nclass Automata {\n    provider;\n    contract;\n    constructor() {\n        this.provider = new ethers__WEBPACK_IMPORTED_MODULE_15__.JsonRpcProvider(AUTOMATA_RPC);\n        this.contract = new ethers__WEBPACK_IMPORTED_MODULE_13__.Contract(AUTOMATA_CONTRACT_ADDRESS, AUTOMATA_ABI, this.provider);\n    }\n    async verifyQuote(rawQuote) {\n        try {\n            const [success] = await this.contract.verifyAndAttestOnChain(rawQuote);\n            return success;\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n}\n\n/**\n * RequestProcessor is a subclass of ZGServingUserBroker.\n * It needs to be initialized with createZGServingUserBroker\n * before use.\n */\nclass RequestProcessor extends ZGServingUserBrokerBase {\n    automata;\n    constructor(contract, metadata, cache, ledger) {\n        super(contract, ledger, metadata, cache);\n        this.automata = new Automata();\n    }\n    async getServiceMetadata(providerAddress) {\n        const service = await this.getService(providerAddress);\n        return {\n            endpoint: `${service.url}/v1/proxy`,\n            model: service.model,\n        };\n    }\n    /*\n     * 1. To Ensure No Insufficient Balance Occurs.\n     *\n     * The provider settles accounts regularly. In addition, we will add a rule to the provider's settlement logic:\n     * if the actual balance of the customer's account is less than 500, settlement will be triggered immediately.\n     * The actual balance is defined as the customer's inference account balance minus any unsettled amounts.\n     *\n     * This way, if the customer checks their account and sees a balance greater than 500, even if the provider settles\n     * immediately, the deduction will leave about 500, ensuring that no insufficient balance situation occurs.\n     *\n     * 2. To Avoid Frequent Transfers\n     *\n     * On the customer's side, if the balance falls below 500, it should be topped up to 1000. This is to avoid frequent\n     * transfers.\n     *\n     * 3. To Avoid Having to Check the Balance on Every Customer Request\n     *\n     * Record expenditures in processResponse and maintain a total consumption amount. Every time the total expenditure\n     * reaches 1000, recheck the balance and perform a transfer if necessary.\n     *\n     * ps: The units for 500 and 1000 can be (service.inputPricePerToken + service.outputPricePerToken).\n     */\n    async getRequestHeaders(providerAddress, content, vllmProxy) {\n        try {\n            await this.topUpAccountIfNeeded(providerAddress, content);\n            if (vllmProxy === undefined) {\n                vllmProxy = true;\n            }\n            return await this.getHeader(providerAddress, content, BigInt(0), vllmProxy);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async acknowledgeProviderSigner(providerAddress, gasPrice) {\n        try {\n            try {\n                await this.contract.getAccount(providerAddress);\n            }\n            catch {\n                await this.ledger.transferFund(providerAddress, 'inference', BigInt(0), gasPrice);\n            }\n            let { quote, provider_signer, key } = await this.getQuote(providerAddress);\n            if (!quote || !provider_signer) {\n                throw new Error('Invalid quote');\n            }\n            if (!quote.startsWith('0x')) {\n                quote = '0x' + quote;\n            }\n            // const rpc = process.env.RPC_ENDPOINT\n            // bypass quote verification if testing on localhost\n            // if (!rpc || !/localhost|127\\.0\\.0\\.1/.test(rpc)) {\n            //     const isVerified = await this.automata.verifyQuote(quote)\n            //     console.log('Quote verification:', isVerified)\n            //     if (!isVerified) {\n            //         throw new Error('Quote verification failed')\n            //     }\n            //     if (nvidia_payload) {\n            //         const svc = await this.getService(providerAddress)\n            //         const valid = await Verifier.verifyRA(\n            //             svc.url,\n            //             nvidia_payload\n            //         )\n            //         console.log('nvidia payload verification:', valid)\n            //         if (!valid) {\n            //             throw new Error('nvidia payload verify failed')\n            //         }\n            //     }\n            // }\n            const account = await this.contract.getAccount(providerAddress);\n            if (account.providerPubKey[0] === key[0] &&\n                account.providerPubKey[1] === key[1]) {\n                console.log('Provider signer already acknowledged');\n                return;\n            }\n            await this.contract.acknowledgeProviderSigner(providerAddress, key);\n            const userAddress = this.contract.getUserAddress();\n            const cacheKey = `${userAddress}_${providerAddress}_ack`;\n            this.cache.setItem(cacheKey, key, 1 * 60 * 1000, CacheValueTypeEnum.Other);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n}\n\nvar VerifiabilityEnum;\n(function (VerifiabilityEnum) {\n    VerifiabilityEnum[\"OpML\"] = \"OpML\";\n    VerifiabilityEnum[\"TeeML\"] = \"TeeML\";\n    VerifiabilityEnum[\"ZKML\"] = \"ZKML\";\n})(VerifiabilityEnum || (VerifiabilityEnum = {}));\nlet ModelProcessor$1 = class ModelProcessor extends ZGServingUserBrokerBase {\n    async listService() {\n        try {\n            const services = await this.contract.listService();\n            return services;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n};\nfunction isVerifiability(value) {\n    return Object.values(VerifiabilityEnum).includes(value);\n}\n\n/**\n * The Verifier class contains methods for verifying service reliability.\n */\nclass Verifier extends ZGServingUserBrokerBase {\n    async verifyService(providerAddress) {\n        try {\n            const { valid } = await this.getSigningAddress(providerAddress, true);\n            return valid;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    /**\n     * getSigningAddress verifies whether the signing address\n     * of the signer corresponds to a valid RA.\n     *\n     * It also stores the signing address of the RA in\n     * localStorage and returns it.\n     *\n     * @param providerAddress - provider address.\n     * @param verifyRA - whether to verify the RA default is false.\n     * @returns The first return value indicates whether the RA is valid,\n     * and the second return value indicates the signing address of the RA.\n     */\n    async getSigningAddress(providerAddress, verifyRA = false, vllmProxy = true) {\n        const key = `${this.contract.getUserAddress()}_${providerAddress}`;\n        let signingKey = await this.metadata.getSigningKey(key);\n        if (!verifyRA && signingKey) {\n            return {\n                valid: null,\n                signingAddress: signingKey,\n            };\n        }\n        try {\n            const extractor = await this.getExtractor(providerAddress, false);\n            const svc = await extractor.getSvcInfo();\n            let signerRA = {\n                signing_address: '',\n                nvidia_payload: '',\n                intel_quote: '',\n            };\n            if (vllmProxy) {\n                signerRA = await Verifier.fetSignerRA(svc.url, svc.model);\n                if (!signerRA?.signing_address) {\n                    throw new Error('signing address does not exist');\n                }\n            }\n            else {\n                const { quote, provider_signer, nvidia_payload } = await this.getQuote(providerAddress);\n                signerRA = {\n                    signing_address: provider_signer,\n                    nvidia_payload: nvidia_payload,\n                    intel_quote: quote,\n                };\n            }\n            signingKey = `${this.contract.getUserAddress()}_${providerAddress}`;\n            await this.metadata.storeSigningKey(signingKey, signerRA.signing_address);\n            // TODO: use intel_quote to verify signing address\n            const valid = await Verifier.verifyRA(svc.url, signerRA.nvidia_payload);\n            return {\n                valid,\n                signingAddress: signerRA.signing_address,\n            };\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getSignerRaDownloadLink(providerAddress) {\n        try {\n            const svc = await this.getService(providerAddress);\n            return `${svc.url}/v1/proxy/attestation/report`;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getChatSignatureDownloadLink(providerAddress, chatID) {\n        try {\n            const svc = await this.getService(providerAddress);\n            return `${svc.url}/v1/proxy/signature/${chatID}`;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    static async verifyRA(providerBrokerURL, nvidia_payload) {\n        return fetch(`${providerBrokerURL}/v1/quote/verify/gpu`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Accept: 'application/json',\n            },\n            body: JSON.stringify(nvidia_payload),\n        })\n            .then((response) => {\n            if (response.status === 200) {\n                return true;\n            }\n            if (response.status === 404) {\n                throw new Error('verify RA error: 404');\n            }\n            else {\n                return false;\n            }\n        })\n            .catch((error) => {\n            if (error instanceof Error) {\n                console.error(error.message);\n            }\n            return false;\n        });\n    }\n    static async fetSignerRA(providerBrokerURL, model) {\n        return fetch(`${providerBrokerURL}/v1/proxy/attestation/report?model=${model}`, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n        })\n            .then((response) => {\n            return response.json();\n        })\n            .then((data) => {\n            if (data.nvidia_payload) {\n                try {\n                    data.nvidia_payload = JSON.parse(data.nvidia_payload);\n                }\n                catch (error) {\n                    throw Error('parsing nvidia_payload error');\n                }\n            }\n            if (data.intel_quote) {\n                try {\n                    data.intel_quote =\n                        '0x' +\n                            Buffer.from(data.intel_quote, 'base64').toString('hex');\n                }\n                catch (error) {\n                    throw Error('parsing intel_quote error');\n                }\n            }\n            return data;\n        })\n            .catch((error) => {\n            throwFormattedError(error);\n        });\n    }\n    static async fetSignatureByChatID(providerBrokerURL, chatID, model, vllmProxy) {\n        return fetch(`${providerBrokerURL}/v1/proxy/signature/${chatID}?model=${model}`, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n                'VLLM-Proxy': `${vllmProxy}`,\n            },\n        })\n            .then((response) => {\n            if (!response.ok) {\n                throw new Error('getting signature error');\n            }\n            return response.json();\n        })\n            .then((data) => {\n            return data;\n        })\n            .catch((error) => {\n            throwFormattedError(error);\n        });\n    }\n    static verifySignature(message, signature, expectedAddress) {\n        const messageHash = ethers__WEBPACK_IMPORTED_MODULE_16__.hashMessage(message);\n        const recoveredAddress = ethers__WEBPACK_IMPORTED_MODULE_9__.recoverAddress(messageHash, signature);\n        return recoveredAddress.toLowerCase() === expectedAddress.toLowerCase();\n    }\n}\n\n/**\n * ResponseProcessor is a subclass of ZGServingUserBroker.\n * It needs to be initialized with createZGServingUserBroker\n * before use.\n */\nclass ResponseProcessor extends ZGServingUserBrokerBase {\n    verifier;\n    constructor(contract, ledger, metadata, cache) {\n        super(contract, ledger, metadata, cache);\n        this.verifier = new Verifier(contract, ledger, metadata, cache);\n    }\n    async processResponse(providerAddress, content, chatID, vllmProxy) {\n        try {\n            const extractor = await this.getExtractor(providerAddress);\n            const outputFee = await this.calculateOutputFees(extractor, content);\n            await this.updateCachedFee(providerAddress, outputFee);\n            const svc = await extractor.getSvcInfo();\n            if (!isVerifiability(svc.verifiability)) {\n                return false;\n            }\n            if (!chatID) {\n                throw new Error('Chat ID does not exist');\n            }\n            if (vllmProxy === undefined) {\n                vllmProxy = true;\n            }\n            let singerRAVerificationResult = await this.verifier.getSigningAddress(providerAddress);\n            if (!singerRAVerificationResult.valid) {\n                singerRAVerificationResult =\n                    await this.verifier.getSigningAddress(providerAddress, true, vllmProxy);\n            }\n            if (!singerRAVerificationResult.valid) {\n                throw new Error('Signing address is invalid');\n            }\n            const ResponseSignature = await Verifier.fetSignatureByChatID(svc.url, chatID, svc.model, vllmProxy);\n            return Verifier.verifySignature(ResponseSignature.text, ResponseSignature.signature, singerRAVerificationResult.signingAddress);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async calculateOutputFees(extractor, content) {\n        const svc = await extractor.getSvcInfo();\n        const outputCount = await extractor.getOutputCount(content);\n        return BigInt(outputCount) * svc.outputPrice;\n    }\n}\n\nclass InferenceBroker {\n    requestProcessor;\n    responseProcessor;\n    verifier;\n    accountProcessor;\n    modelProcessor;\n    signer;\n    contractAddress;\n    ledger;\n    constructor(signer, contractAddress, ledger) {\n        this.signer = signer;\n        this.contractAddress = contractAddress;\n        this.ledger = ledger;\n    }\n    async initialize() {\n        let userAddress;\n        try {\n            userAddress = await this.signer.getAddress();\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n        const contract = new InferenceServingContract(this.signer, this.contractAddress, userAddress);\n        const metadata = new Metadata();\n        const cache = new Cache();\n        this.requestProcessor = new RequestProcessor(contract, metadata, cache, this.ledger);\n        this.responseProcessor = new ResponseProcessor(contract, this.ledger, metadata, cache);\n        this.accountProcessor = new AccountProcessor(contract, this.ledger, metadata, cache);\n        this.modelProcessor = new ModelProcessor$1(contract, this.ledger, metadata, cache);\n        this.verifier = new Verifier(contract, this.ledger, metadata, cache);\n    }\n    /**\n     * Retrieves a list of services from the contract.\n     *\n     * @returns {Promise<ServiceStructOutput[]>} A promise that resolves to an array of ServiceStructOutput objects.\n     * @throws An error if the service list cannot be retrieved.\n     */\n    listService = async () => {\n        try {\n            return await this.modelProcessor.listService();\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * Retrieves the account information for a given provider address.\n     *\n     * @param {string} providerAddress - The address of the provider identifying the account.\n     *\n     * @returns A promise that resolves to the account information.\n     *\n     * @throws Will throw an error if the account retrieval process fails.\n     */\n    getAccount = async (providerAddress) => {\n        try {\n            return await this.accountProcessor.getAccount(providerAddress);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    getAccountWithDetail = async (providerAddress) => {\n        try {\n            return await this.accountProcessor.getAccountWithDetail(providerAddress);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * checks if the user has acknowledged the provider signer.\n     *\n     * @param {string} providerAddress - The address of the provider.\n     * @returns {Promise<boolean>} A promise that resolves to a boolean indicating whether the user\n     * has acknowledged the provider signer.\n     * @throws Will throw an error if the acknowledgment check fails.\n     */\n    userAcknowledged = async (providerAddress) => {\n        try {\n            return await this.requestProcessor.userAcknowledged(providerAddress);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * Acknowledge the given provider address.\n     *\n     * @param {string} providerAddress - The address of the provider identifying the account.\n     *\n     *\n     * @throws Will throw an error if failed to acknowledge.\n     */\n    acknowledgeProviderSigner = async (providerAddress, gasPrice) => {\n        try {\n            return await this.requestProcessor.acknowledgeProviderSigner(providerAddress, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * Generates request metadata for the provider service.\n     * Includes:\n     * 1. Request endpoint for the provider service\n     * 2. Model information for the provider service\n     *\n     * @param {string} providerAddress - The address of the provider.\n     *\n     * @returns { endpoint, model } - Object containing endpoint and model.\n     *\n     * @throws An error if errors occur during the processing of the request.\n     */\n    getServiceMetadata = async (providerAddress) => {\n        try {\n            return await this.requestProcessor.getServiceMetadata(providerAddress);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * getRequestHeaders generates billing-related headers for the request\n     * when the user uses the provider service.\n     *\n     * In the 0G Serving system, a request with valid billing headers\n     * is considered a settlement proof and will be used by the provider\n     * for contract settlement.\n     *\n     * @param {string} providerAddress - The address of the provider.\n     * @param {string} content - The content being billed. For example, in a chatbot service, it is the text input by the user.\n     * @param {boolean} vllmProxy - Chat signature proxy, default is false\n     *\n     * @returns headers. Records information such as the request fee and user signature.\n     *\n     * @example\n     *\n     * const { endpoint, model } = await broker.getServiceMetadata(\n     *   providerAddress,\n     *   serviceName,\n     * );\n     *\n     * const headers = await broker.getServiceMetadata(\n     *   providerAddress,\n     *   serviceName,\n     *   content,\n     * );\n     *\n     * const openai = new OpenAI({\n     *   baseURL: endpoint,\n     *   apiKey: \"\",\n     * });\n     *\n     * const completion = await openai.chat.completions.create(\n     *   {\n     *     messages: [{ role: \"system\", content }],\n     *     model,\n     *   },\n     *   headers: {\n     *     ...headers,\n     *   },\n     * );\n     *\n     * @throws An error if errors occur during the processing of the request.\n     */\n    getRequestHeaders = async (providerAddress, content, vllmProxy) => {\n        try {\n            return await this.requestProcessor.getRequestHeaders(providerAddress, content, vllmProxy);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * processResponse is used after the user successfully obtains a response from the provider service.\n     *\n     * It will settle the fee for the response content. Additionally, if the service is verifiable,\n     * input the chat ID from the response and processResponse will determine the validity of the\n     * returned content by checking the provider service's response and corresponding signature associated\n     * with the chat ID.\n     *\n     * @param {string} providerAddress - The address of the provider.\n     * @param {string} content - The main content returned by the service. For example, in the case of a chatbot service,\n     * it would be the response text.\n     * @param {string} chatID - Only for verifiable services. You can provide the chat ID obtained from the response to\n     * automatically download the response signature. The function will verify the reliability of the response\n     * using the service's signing address.\n     * @param {boolean} vllmProxy - Chat signature proxy, default is true\n     *\n     * @returns A boolean value. True indicates the returned content is valid, otherwise it is invalid.\n     *\n     * @throws An error if any issues occur during the processing of the response.\n     */\n    processResponse = async (providerAddress, content, chatID, vllmProxy) => {\n        try {\n            return await this.responseProcessor.processResponse(providerAddress, content, chatID, vllmProxy);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * verifyService is used to verify the reliability of the service.\n     *\n     * @param {string} providerAddress - The address of the provider.\n     *\n     * @returns A <boolean | null> value. True indicates the service is reliable, otherwise it is unreliable.\n     *\n     * @throws An error if errors occur during the verification process.\n     */\n    verifyService = async (providerAddress) => {\n        try {\n            return await this.verifier.verifyService(providerAddress);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * getSignerRaDownloadLink returns the download link for the Signer RA.\n     *\n     * It can be provided to users who wish to manually verify the Signer RA.\n     *\n     * @param {string} providerAddress - provider address.\n     *\n     * @returns Download link.\n     */\n    getSignerRaDownloadLink = async (providerAddress) => {\n        try {\n            return await this.verifier.getSignerRaDownloadLink(providerAddress);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * getChatSignatureDownloadLink returns the download link for the signature of a single chat.\n     *\n     * It can be provided to users who wish to manually verify the content of a single chat.\n     *\n     * @param {string} providerAddress - provider address.\n     * @param {string} chatID - ID of the chat.\n     *\n     * @remarks To verify the chat signature, use the following code:\n     *\n     * ```typescript\n     * const messageHash = ethers.hashMessage(messageToBeVerified)\n     * const recoveredAddress = ethers.recoverAddress(messageHash, signature)\n     * const isValid = recoveredAddress.toLowerCase() === signingAddress.toLowerCase()\n     * ```\n     *\n     * @returns Download link.\n     */\n    getChatSignatureDownloadLink = async (providerAddress, chatID) => {\n        try {\n            return await this.verifier.getChatSignatureDownloadLink(providerAddress, chatID);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n}\n/**\n * createInferenceBroker is used to initialize ZGServingUserBroker\n *\n * @param signer - Signer from ethers.js.\n * @param contractAddress - 0G Serving contract address, use default address if not provided.\n *\n * @returns broker instance.\n *\n * @throws An error if the broker cannot be initialized.\n */\nasync function createInferenceBroker(signer, contractAddress, ledger) {\n    const broker = new InferenceBroker(signer, contractAddress, ledger);\n    try {\n        await broker.initialize();\n        return broker;\n    }\n    catch (error) {\n        throw error;\n    }\n}\n\nclass BrokerBase {\n    contract;\n    ledger;\n    servingProvider;\n    constructor(contract, ledger, servingProvider) {\n        this.contract = contract;\n        this.ledger = ledger;\n        this.servingProvider = servingProvider;\n    }\n}\n\nconst TIMEOUT_MS$1 = 300_000;\nclass FineTuningServingContract {\n    serving;\n    signer;\n    _userAddress;\n    _gasPrice;\n    _maxGasPrice;\n    _step;\n    constructor(signer, contractAddress, userAddress, gasPrice, maxGasPrice, step) {\n        this.serving = FineTuningServing__factory.connect(contractAddress, signer);\n        this.signer = signer;\n        this._userAddress = userAddress;\n        this._gasPrice = gasPrice;\n        if (maxGasPrice) {\n            this._maxGasPrice = BigInt(maxGasPrice);\n        }\n        this._step = step || 11;\n    }\n    lockTime() {\n        return this.serving.lockTime();\n    }\n    async sendTx(name, txArgs, txOptions) {\n        if (txOptions.gasPrice === undefined) {\n            txOptions.gasPrice = (await this.signer.provider?.getFeeData())?.gasPrice;\n            // Add a delay to avoid too frequent RPC calls\n            await new Promise((resolve) => setTimeout(resolve, 1000));\n        }\n        else {\n            txOptions.gasPrice = BigInt(txOptions.gasPrice);\n        }\n        while (true) {\n            try {\n                console.log('sending tx with gas price', txOptions.gasPrice);\n                const tx = await this.serving.getFunction(name)(...txArgs, txOptions);\n                console.log('tx hash:', tx.hash);\n                const receipt = (await Promise.race([\n                    tx.wait(),\n                    new Promise((_, reject) => setTimeout(() => reject(new Error('Get Receipt timeout, try set higher gas price')), TIMEOUT_MS$1)),\n                ]));\n                this.checkReceipt(receipt);\n                break;\n            }\n            catch (error) {\n                if (error.message ===\n                    'Get Receipt timeout, try set higher gas price') {\n                    const nonce = await this.signer.getNonce();\n                    const pendingNonce = await this.signer.provider?.getTransactionCount(this._userAddress, 'pending');\n                    if (pendingNonce !== undefined &&\n                        pendingNonce - nonce > 5 &&\n                        txOptions.nonce === undefined) {\n                        console.warn(`Significant gap detected between pending nonce (${pendingNonce}) and current nonce (${nonce}). This may indicate skipped or missing transactions. Using the current confirmed nonce for the transaction.`);\n                        txOptions.nonce = nonce;\n                    }\n                }\n                if (this._maxGasPrice === undefined) {\n                    throwFormattedError(error);\n                }\n                let errorMessage = '';\n                if (error.message) {\n                    errorMessage = error.message;\n                }\n                else if (error.info?.error?.message) {\n                    errorMessage = error.info.error.message;\n                }\n                const shouldRetry = RETRY_ERROR_SUBSTRINGS.some((substr) => errorMessage.includes(substr));\n                if (!shouldRetry) {\n                    throwFormattedError(error);\n                }\n                console.log('Retrying transaction with higher gas price due to:', errorMessage);\n                let currentGasPrice = txOptions.gasPrice;\n                if (currentGasPrice >= this._maxGasPrice) {\n                    throwFormattedError(error);\n                }\n                currentGasPrice =\n                    (currentGasPrice * BigInt(this._step)) / BigInt(10);\n                if (currentGasPrice > this._maxGasPrice) {\n                    currentGasPrice = this._maxGasPrice;\n                }\n                txOptions.gasPrice = currentGasPrice;\n            }\n        }\n    }\n    async listService() {\n        try {\n            const services = await this.serving.getAllServices();\n            return services;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async listAccount() {\n        try {\n            const accounts = await this.serving.getAllAccounts();\n            return accounts;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getAccount(provider) {\n        try {\n            const user = this.getUserAddress();\n            const account = await this.serving.getAccount(user, provider);\n            return account;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async acknowledgeProviderSigner(providerAddress, providerSigner, gasPrice) {\n        try {\n            const txOptions = {};\n            if (gasPrice || this._gasPrice) {\n                txOptions.gasPrice = gasPrice || this._gasPrice;\n            }\n            await this.sendTx('acknowledgeProviderSigner', [providerAddress, providerSigner], txOptions);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async acknowledgeDeliverable(providerAddress, index, gasPrice) {\n        try {\n            const txOptions = {};\n            if (gasPrice || this._gasPrice) {\n                txOptions.gasPrice = gasPrice || this._gasPrice;\n            }\n            await this.sendTx('acknowledgeDeliverable', [providerAddress, index], txOptions);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getService(providerAddress) {\n        try {\n            return this.serving.getService(providerAddress);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getDeliverable(providerAddress, index) {\n        try {\n            const user = this.getUserAddress();\n            return this.serving.getDeliverable(user, providerAddress, index);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    getUserAddress() {\n        return this._userAddress;\n    }\n    checkReceipt(receipt) {\n        if (!receipt) {\n            throw new Error('Transaction failed with no receipt');\n        }\n        if (receipt.status !== 1) {\n            throw new Error('Transaction reverted');\n        }\n    }\n}\n\nasync function upload(privateKey, dataPath, gasPrice, maxGasPrice) {\n    try {\n        const fileSize = await getFileContentSize(dataPath);\n        return new Promise((resolve, reject) => {\n            const command = path__WEBPACK_IMPORTED_MODULE_3___default().join(__dirname, '..', '..', '..', '..', 'binary', '0g-storage-client');\n            const args = [\n                'upload',\n                '--url',\n                ZG_RPC_ENDPOINT_TESTNET,\n                '--key',\n                privateKey,\n                '--indexer',\n                INDEXER_URL_TURBO,\n                '--file',\n                dataPath,\n                '--skip-tx=false',\n                '--log-level=debug',\n            ];\n            if (gasPrice) {\n                args.push('--gas-price', gasPrice.toString());\n            }\n            if (maxGasPrice) {\n                args.push('--max-gas-price', maxGasPrice.toString());\n            }\n            const process = (0,child_process__WEBPACK_IMPORTED_MODULE_2__.spawn)(command, args);\n            process.stdout.on('data', (data) => {\n                console.log(`${data}`);\n            });\n            process.stderr.on('data', (data) => {\n                console.error(`${data}`);\n            });\n            process.on('close', (code) => {\n                if (code !== 0) {\n                    reject(new Error(`Process exited with code ${code}`));\n                }\n                else {\n                    console.log(`File size: ${fileSize} bytes`);\n                    resolve();\n                }\n            });\n            process.on('error', (err) => {\n                reject(err);\n            });\n        });\n    }\n    catch (err) {\n        console.error(err);\n        throw err;\n    }\n}\nasync function download(dataPath, dataRoot) {\n    return new Promise((resolve, reject) => {\n        const command = path__WEBPACK_IMPORTED_MODULE_3___default().join(__dirname, '..', '..', '..', '..', 'binary', '0g-storage-client');\n        const args = [\n            'download',\n            '--file',\n            dataPath,\n            '--indexer',\n            INDEXER_URL_TURBO,\n            '--roots',\n            dataRoot,\n        ];\n        const process = (0,child_process__WEBPACK_IMPORTED_MODULE_2__.spawn)(command, args);\n        let log = '';\n        process.stdout.on('data', (data) => {\n            const output = data.toString();\n            log += output;\n            console.log(output);\n        });\n        process.stderr.on('data', (data) => {\n            const errorOutput = data.toString();\n            log += errorOutput;\n            console.error(errorOutput);\n        });\n        process.on('close', (code) => {\n            if (code !== 0) {\n                return reject(new Error(`Process exited with code ${code}`));\n            }\n            if (!log\n                .trim()\n                .endsWith('Succeeded to validate the downloaded file')) {\n                return reject(new Error('Failed to download the file'));\n            }\n            resolve();\n        });\n        process.on('error', (err) => {\n            reject(err);\n        });\n    });\n}\nasync function getFileContentSize(filePath) {\n    try {\n        const fileHandle = await fs_promises__WEBPACK_IMPORTED_MODULE_4__.open(filePath, 'r');\n        try {\n            const stats = await fileHandle.stat();\n            return stats.size;\n        }\n        finally {\n            await fileHandle.close();\n        }\n    }\n    catch (err) {\n        throw new Error(`Error processing file: ${err instanceof Error ? err.message : String(err)}`);\n    }\n}\n\n// Dynamic imports for Node.js specific modules\nlet fs;\nlet os;\nlet path;\nlet AdmZip;\nlet spawn;\nlet exec;\nlet createHash;\nlet createReadStream;\nasync function initNodeModules() {\n    if (isBrowser()) {\n        throw new Error('Token calculation functions are not available in browser environment. Please use these functions in a Node.js environment.');\n    }\n    if (!fs) {\n        fs =\n            (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs/promises */ \"fs/promises\", 23))).default ||\n                (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs/promises */ \"fs/promises\", 23)));\n        os = (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! os */ \"os\", 23))).default || (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! os */ \"os\", 23)));\n        path = (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! path */ \"path\", 23))).default || (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! path */ \"path\", 23)));\n        AdmZip = (await __webpack_require__.e(/*! import() */ \"vendor-chunks/@0glabs\").then(__webpack_require__.bind(__webpack_require__, /*! ./adm-zip-86f30d47.js */ \"(ssr)/./node_modules/@0glabs/0g-serving-broker/lib.esm/adm-zip-86f30d47.js\")).then(function (n) { return n.a; })).default;\n        const childProcess = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! child_process */ \"child_process\", 23));\n        spawn = childProcess.spawn;\n        exec = childProcess.exec;\n        const crypto = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ \"crypto\", 23));\n        createHash = crypto.createHash;\n        createReadStream = (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23))).createReadStream;\n    }\n}\n// Re-export download with browser check\nasync function safeDynamicImport() {\n    if (isBrowser()) {\n        throw new Error('ZG Storage operations are not available in browser environment.');\n    }\n    const { download } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/@0glabs\").then(__webpack_require__.bind(__webpack_require__, /*! ./index-b52942d2.js */ \"(ssr)/./node_modules/@0glabs/0g-serving-broker/lib.esm/index-b52942d2.js\"));\n    return { download };\n}\nasync function calculateTokenSizeViaExe(tokenizerRootHash, datasetPath, datasetType, tokenCounterMerkleRoot, tokenCounterFileHash) {\n    await initNodeModules();\n    const { download } = await safeDynamicImport();\n    const executorDir = path.join(__dirname, '..', '..', '..', '..', 'binary');\n    const binaryFile = path.join(executorDir, 'token_counter');\n    let needDownload = false;\n    try {\n        await fs.access(binaryFile);\n        console.log('calculating file Hash');\n        const hash = await calculateFileHash(binaryFile);\n        console.log('file hash: ', hash);\n        if (tokenCounterFileHash !== hash) {\n            console.log(`file hash mismatch, expected: `, tokenCounterFileHash);\n            needDownload = true;\n        }\n    }\n    catch (error) {\n        console.log(`File ${binaryFile} does not exist.`);\n        needDownload = true;\n    }\n    if (needDownload) {\n        try {\n            await fs.unlink(binaryFile);\n        }\n        catch (error) {\n            console.error(`Failed to delete ${binaryFile}:`, error);\n        }\n        console.log(`Downloading ${binaryFile}`);\n        await download(binaryFile, tokenCounterMerkleRoot);\n        await fs.chmod(binaryFile, 0o755);\n    }\n    return await calculateTokenSize(tokenizerRootHash, datasetPath, datasetType, binaryFile, []);\n}\nasync function calculateTokenSizeViaPython(tokenizerRootHash, datasetPath, datasetType) {\n    await initNodeModules();\n    const isPythonInstalled = await checkPythonInstalled();\n    if (!isPythonInstalled) {\n        throw new Error('Python is required but not installed. Please install Python first.');\n    }\n    for (const packageName of ['transformers', 'datasets']) {\n        const isPackageInstalled = await checkPackageInstalled(packageName);\n        if (!isPackageInstalled) {\n            console.log(`${packageName} is not installed. Installing...`);\n            try {\n                await installPackage(packageName);\n            }\n            catch (error) {\n                throw new Error(`Failed to install ${packageName}: ${error}`);\n            }\n        }\n    }\n    const projectRoot = path.resolve(__dirname, '../../../../');\n    return await calculateTokenSize(tokenizerRootHash, datasetPath, datasetType, 'python3', [path.join(projectRoot, 'token.counter', 'token_counter.py')]);\n}\nasync function calculateTokenSize(tokenizerRootHash, datasetPath, datasetType, executor, args) {\n    const { download } = await safeDynamicImport();\n    const tmpDir = await fs.mkdtemp(`${os.tmpdir()}${path.sep}`);\n    console.log(`current temporary directory ${tmpDir}`);\n    const tokenizerPath = path.join(tmpDir, 'tokenizer.zip');\n    await download(tokenizerPath, tokenizerRootHash);\n    const subDirectories = await getSubdirectories(tmpDir);\n    unzipFile(tokenizerPath, tmpDir);\n    const newDirectories = new Set();\n    for (const item of await getSubdirectories(tmpDir)) {\n        if (!subDirectories.has(item)) {\n            newDirectories.add(item);\n        }\n    }\n    if (newDirectories.size !== 1) {\n        throw new Error('Invalid tokenizer directory');\n    }\n    const tokenizerUnzipPath = path.join(tmpDir, Array.from(newDirectories)[0]);\n    let datasetUnzipPath = datasetPath;\n    if (await isZipFile(datasetPath)) {\n        unzipFile(datasetPath, tmpDir);\n        datasetUnzipPath = path.join(tmpDir, 'data');\n        try {\n            await fs.access(datasetUnzipPath);\n        }\n        catch (error) {\n            await fs.mkdir(datasetUnzipPath, { recursive: true });\n        }\n    }\n    return runExecutor(executor, [\n        ...args,\n        datasetUnzipPath,\n        datasetType,\n        tokenizerUnzipPath,\n    ])\n        .then((output) => {\n        console.log('token_counter script output:', output);\n        if (!output || typeof output !== 'string') {\n            throw new Error('Invalid output from token counter');\n        }\n        const [num1, num2] = output\n            .split(' ')\n            .map((str) => parseInt(str, 10));\n        if (isNaN(num1) || isNaN(num2)) {\n            throw new Error('Invalid number');\n        }\n        return num1;\n    })\n        .catch((error) => {\n        console.error('Error running Python script:', error);\n        throwFormattedError(error);\n    });\n}\nfunction checkPythonInstalled() {\n    return new Promise((resolve, reject) => {\n        exec('python3 --version', (error, stdout, stderr) => {\n            if (error) {\n                console.error('Python is not installed or not in PATH');\n                resolve(false);\n            }\n            else {\n                resolve(true);\n            }\n        });\n    });\n}\nfunction checkPackageInstalled(packageName) {\n    return new Promise((resolve, reject) => {\n        exec(`pip show ${packageName}`, (error, stdout, stderr) => {\n            if (error) {\n                resolve(false);\n            }\n            else {\n                resolve(true);\n            }\n        });\n    });\n}\nfunction installPackage(packageName) {\n    return new Promise((resolve, reject) => {\n        exec(`pip install ${packageName}`, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Failed to install ${packageName}`);\n                reject(error);\n            }\n            else {\n                console.log(`${packageName} installed successfully`);\n                resolve();\n            }\n        });\n    });\n}\nfunction runExecutor(executor, args) {\n    return new Promise((resolve, reject) => {\n        console.log(`Run ${executor} ${args}`);\n        const pythonProcess = spawn(executor, [...args]);\n        let output = '';\n        let errorOutput = '';\n        pythonProcess.stdout.on('data', (data) => {\n            output += data.toString();\n        });\n        pythonProcess.stderr.on('data', (data) => {\n            errorOutput += data.toString();\n            console.error(`Python error: ${errorOutput}`);\n        });\n        pythonProcess.on('close', (code) => {\n            if (code === 0) {\n                resolve(output.trim());\n            }\n            else {\n                reject(`Python script failed with code ${code}: ${errorOutput.trim()}`);\n            }\n        });\n    });\n}\nfunction unzipFile(zipFilePath, targetDir) {\n    try {\n        const zip = new AdmZip(zipFilePath);\n        zip.extractAllTo(targetDir, true);\n        console.log(`Successfully unzipped to ${targetDir}`);\n    }\n    catch (error) {\n        console.error('Error during unzipping:', error);\n        throw error;\n    }\n}\nasync function isZipFile(targetPath) {\n    try {\n        const stats = await fs.stat(targetPath);\n        return (stats.isFile() && path.extname(targetPath).toLowerCase() === '.zip');\n    }\n    catch (error) {\n        return false;\n    }\n}\nasync function getSubdirectories(dirPath) {\n    try {\n        const entries = await fs.readdir(dirPath, { withFileTypes: true });\n        const subdirectories = new Set(entries\n            .filter((entry) => entry.isDirectory()) // Only keep directories\n            .map((entry) => entry.name));\n        return subdirectories;\n    }\n    catch (error) {\n        console.error('Error reading directory:', error);\n        return new Set();\n    }\n}\nasync function calculateFileHash(filePath, algorithm = 'sha256') {\n    return new Promise((resolve, reject) => {\n        const hash = createHash(algorithm);\n        const stream = createReadStream(filePath);\n        stream.on('data', (chunk) => {\n            hash.update(chunk);\n        });\n        stream.on('end', () => {\n            resolve(hash.digest('hex'));\n        });\n        stream.on('error', (err) => {\n            reject(err);\n        });\n    });\n}\n\nclass ModelProcessor extends BrokerBase {\n    async listModel() {\n        const services = await this.contract.listService();\n        let customizedModels = [];\n        for (const service of services) {\n            if (service.models.length !== 0) {\n                const url = service.url;\n                const models = await this.servingProvider.getCustomizedModels(url);\n                for (const item of models) {\n                    customizedModels.push([\n                        item.name,\n                        {\n                            description: item.description,\n                            provider: service.provider,\n                        },\n                    ]);\n                }\n            }\n        }\n        return [Object.entries(MODEL_HASH_MAP), customizedModels];\n    }\n    async uploadDataset(privateKey, dataPath, gasPrice, maxGasPrice) {\n        await upload(privateKey, dataPath, gasPrice);\n    }\n    async calculateToken(datasetPath, usePython, preTrainedModelName, providerAddress) {\n        let tokenizer;\n        let dataType;\n        if (preTrainedModelName in MODEL_HASH_MAP) {\n            tokenizer = MODEL_HASH_MAP[preTrainedModelName].tokenizer;\n            dataType = MODEL_HASH_MAP[preTrainedModelName].type;\n        }\n        else {\n            if (providerAddress === undefined) {\n                throw new Error('Provider address is required for customized model');\n            }\n            let model = await this.servingProvider.getCustomizedModel(providerAddress, preTrainedModelName);\n            tokenizer = model.tokenizer;\n            dataType = model.dataType;\n        }\n        let dataSize = 0;\n        if (usePython) {\n            dataSize = await calculateTokenSizeViaPython(tokenizer, datasetPath, dataType);\n        }\n        else {\n            dataSize = await calculateTokenSizeViaExe(tokenizer, datasetPath, dataType, TOKEN_COUNTER_MERKLE_ROOT, TOKEN_COUNTER_FILE_HASH);\n        }\n        console.log(`The token size for the dataset ${datasetPath} is ${dataSize}`);\n    }\n    async downloadDataset(dataPath, dataRoot) {\n        download(dataPath, dataRoot);\n    }\n    async acknowledgeModel(providerAddress, dataPath, gasPrice) {\n        try {\n            const account = await this.contract.getAccount(providerAddress);\n            const latestDeliverable = account.deliverables[account.deliverables.length - 1];\n            if (!latestDeliverable) {\n                throw new Error('No deliverable found');\n            }\n            await download(dataPath, hexToRoots(latestDeliverable.modelRootHash));\n            await this.contract.acknowledgeDeliverable(providerAddress, account.deliverables.length - 1, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async decryptModel(providerAddress, encryptedModelPath, decryptedModelPath) {\n        try {\n            const account = await this.contract.getAccount(providerAddress);\n            const latestDeliverable = account.deliverables[account.deliverables.length - 1];\n            if (!latestDeliverable) {\n                throw new Error('No deliverable found');\n            }\n            if (!latestDeliverable.acknowledged) {\n                throw new Error('Deliverable not acknowledged yet');\n            }\n            if (!latestDeliverable.encryptedSecret) {\n                throw new Error('EncryptedSecret not found');\n            }\n            const secret = await eciesDecrypt(this.contract.signer, latestDeliverable.encryptedSecret);\n            await aesGCMDecryptToFile(secret, encryptedModelPath, decryptedModelPath, account.providerSigner);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n        return;\n    }\n}\n\n// Browser-safe function to avoid readline dependency\nasync function askUser(question) {\n    if (isBrowser()) {\n        throw new Error('Interactive input operations are not available in browser environment. Please use these functions in a Node.js environment.');\n    }\n    // Only import readline in Node.js environment\n    try {\n        const readline = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! readline */ \"readline\", 23));\n        const rl = readline.createInterface({\n            input: process.stdin,\n            output: process.stdout,\n        });\n        return new Promise((resolve) => {\n            rl.question(question, (answer) => {\n                rl.close();\n                resolve(answer.trim());\n            });\n        });\n    }\n    catch (error) {\n        throw new Error('readline module is not available. This function can only be used in Node.js environment.');\n    }\n}\n// Browser-safe function to avoid fs dependency\nasync function readFileContent(filePath) {\n    if (isBrowser()) {\n        throw new Error('File system operations are not available in browser environment. Please use these functions in a Node.js environment.');\n    }\n    try {\n        const fs = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs/promises */ \"fs/promises\", 23));\n        return await fs.readFile(filePath, 'utf-8');\n    }\n    catch (error) {\n        throw new Error('fs module is not available. This function can only be used in Node.js environment.');\n    }\n}\nclass ServiceProcessor extends BrokerBase {\n    automata;\n    constructor(contract, ledger, servingProvider) {\n        super(contract, ledger, servingProvider);\n        this.automata = new Automata();\n    }\n    async getLockTime() {\n        try {\n            const lockTime = await this.contract.lockTime();\n            return lockTime;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getAccount(provider) {\n        try {\n            const account = await this.contract.getAccount(provider);\n            return account;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getAccountWithDetail(provider) {\n        try {\n            const account = await this.contract.getAccount(provider);\n            const lockTime = await this.getLockTime();\n            const now = BigInt(Math.floor(Date.now() / 1000)); // Converts milliseconds to seconds\n            const refunds = account.refunds\n                .filter((refund) => !refund.processed)\n                .filter((refund) => refund.amount !== BigInt(0))\n                .map((refund) => ({\n                amount: refund.amount,\n                remainTime: lockTime - (now - refund.createdAt),\n            }));\n            return { account, refunds };\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async listService() {\n        try {\n            const services = await this.contract.listService();\n            return services;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async acknowledgeProviderSigner(providerAddress, gasPrice) {\n        try {\n            try {\n                await this.contract.getAccount(providerAddress);\n            }\n            catch {\n                await this.ledger.transferFund(providerAddress, 'fine-tuning', BigInt(0), gasPrice);\n            }\n            let { quote, provider_signer } = await this.servingProvider.getQuote(providerAddress);\n            if (!quote || !provider_signer) {\n                throw new Error('Invalid quote');\n            }\n            if (!quote.startsWith('0x')) {\n                quote = '0x' + quote;\n            }\n            const rpc = process.env.RPC_ENDPOINT;\n            // bypass quote verification if testing on localhost\n            if (!rpc || !/localhost|127\\.0\\.0\\.1/.test(rpc)) {\n                const isVerified = await this.automata.verifyQuote(quote);\n                console.log('Quote verification:', isVerified);\n                if (!isVerified) {\n                    throw new Error('Quote verification failed');\n                }\n            }\n            const account = await this.contract.getAccount(providerAddress);\n            if (account.providerSigner === provider_signer) {\n                console.log('Provider signer already acknowledged');\n                return;\n            }\n            await this.contract.acknowledgeProviderSigner(providerAddress, provider_signer, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async createTask(providerAddress, preTrainedModelName, dataSize, datasetHash, trainingPath, gasPrice) {\n        try {\n            let preTrainedModelHash;\n            if (preTrainedModelName in MODEL_HASH_MAP) {\n                preTrainedModelHash = MODEL_HASH_MAP[preTrainedModelName].turbo;\n            }\n            else {\n                const model = await this.servingProvider.getCustomizedModel(providerAddress, preTrainedModelName);\n                preTrainedModelHash = model.hash;\n                console.log(`customized model hash: ${preTrainedModelHash}`);\n            }\n            const service = await this.contract.getService(providerAddress);\n            const trainingParams = await readFileContent(trainingPath);\n            const parsedParams = this.verifyTrainingParams(trainingParams);\n            const trainEpochs = (parsedParams.num_train_epochs || parsedParams.total_steps) ?? 3;\n            const fee = service.pricePerToken * BigInt(dataSize) * BigInt(trainEpochs);\n            console.log(`Estimated fee: ${fee} (neuron), data size: ${dataSize}, train epochs: ${trainEpochs}, price per token: ${service.pricePerToken} (neuron)`);\n            const account = await this.contract.getAccount(providerAddress);\n            if (account.balance - account.pendingRefund < fee) {\n                await this.ledger.transferFund(providerAddress, 'fine-tuning', fee, gasPrice);\n            }\n            const nonce = getNonce();\n            const signature = await signRequest(this.contract.signer, this.contract.getUserAddress(), BigInt(nonce), datasetHash, fee);\n            let wait = false;\n            const counter = await this.servingProvider.getPendingTaskCounter(providerAddress);\n            if (counter > 0) {\n                while (true) {\n                    const answer = await askUser(`There are ${counter} tasks in the queue. Do you want to continue? (yes/no): `);\n                    if (answer.toLowerCase() === 'yes' ||\n                        answer.toLowerCase() === 'y') {\n                        wait = true;\n                        break;\n                    }\n                    else if (['no', 'n'].includes(answer.toLowerCase())) {\n                        throw new Error('User opted not to continue due to pending tasks in the queue.');\n                    }\n                    else {\n                        console.log('Invalid input. Please respond with yes/y or no/n.');\n                    }\n                }\n            }\n            const task = {\n                userAddress: this.contract.getUserAddress(),\n                datasetHash,\n                trainingParams,\n                preTrainedModelHash,\n                fee: fee.toString(),\n                nonce: nonce.toString(),\n                signature,\n                wait,\n            };\n            return await this.servingProvider.createTask(providerAddress, task);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async cancelTask(providerAddress, taskID) {\n        try {\n            const signature = await signTaskID(this.contract.signer, taskID);\n            return await this.servingProvider.cancelTask(providerAddress, signature, taskID);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async listTask(providerAddress) {\n        try {\n            return await this.servingProvider.listTask(providerAddress, this.contract.getUserAddress());\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getTask(providerAddress, taskID) {\n        try {\n            if (!taskID) {\n                const tasks = await this.servingProvider.listTask(providerAddress, this.contract.getUserAddress(), true);\n                if (tasks.length === 0) {\n                    throw new Error('No task found');\n                }\n                return tasks[0];\n            }\n            return await this.servingProvider.getTask(providerAddress, this.contract.getUserAddress(), taskID);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    // 8. [`call provider`] call provider task progress api to get task progress\n    async getLog(providerAddress, taskID) {\n        if (!taskID) {\n            const tasks = await this.servingProvider.listTask(providerAddress, this.contract.getUserAddress(), true);\n            taskID = tasks[0].id;\n            if (tasks.length === 0 || !taskID) {\n                throw new Error('No task found');\n            }\n        }\n        return this.servingProvider.getLog(providerAddress, this.contract.getUserAddress(), taskID);\n    }\n    async modelUsage(providerAddress, preTrainedModelName, output) {\n        try {\n            return await this.servingProvider.getCustomizedModelDetailUsage(providerAddress, preTrainedModelName, output);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    verifyTrainingParams(trainingParams) {\n        try {\n            return JSON.parse(trainingParams);\n        }\n        catch (err) {\n            const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred';\n            throw new Error(`Invalid JSON in trainingPath file: ${errorMessage}`);\n        }\n    }\n}\n\nfunction bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {toString} = Object.prototype;\nconst {getPrototypeOf} = Object;\n\nconst kindOf = (cache => thing => {\n    const str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type) => {\n  type = type.toLowerCase();\n  return (thing) => kindOf(thing) === type\n};\n\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {isArray} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest('undefined');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest('string');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction = typeOfTest('function');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest('number');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = (thing) => thing !== null && typeof thing === 'object';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = (val) => {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);\n};\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = (thing) => {\n  let kind;\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) || (\n      isFunction(thing.append) && (\n        (kind = kindOf(thing)) === 'formdata' ||\n        // detect form-data instance\n        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')\n      )\n    )\n  )\n};\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest('URLSearchParams');\n\nconst [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = (str) => str.trim ?\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\n\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : global)\n})();\n\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  const {caseless} = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  };\n\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {allOwnKeys});\n  return a;\n};\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = (content) => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n};\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n};\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n};\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n};\n\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = (thing) => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n};\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[Symbol.iterator];\n\n  const iterator = generator.call(obj);\n\n  let result;\n\n  while ((result = iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n};\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n};\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest('HTMLFormElement');\n\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g,\n    function replacer(m, p1, p2) {\n      return p1.toUpperCase() + p2;\n    }\n  );\n};\n\n/* Creating a function that will check if an object has a property. */\nconst hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest('RegExp');\n\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n\n  forEach(descriptors, (descriptor, name) => {\n    let ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n\n  Object.defineProperties(obj, reducedDescriptors);\n};\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = (obj) => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    const value = obj[name];\n\n    if (!isFunction(value)) return;\n\n    descriptor.enumerable = false;\n\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n};\n\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n\n  const define = (arr) => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  };\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n\n  return obj;\n};\n\nconst noop = () => {};\n\nconst toFiniteNumber = (value, defaultValue) => {\n  return value != null && Number.isFinite(value = +value) ? value : defaultValue;\n};\n\nconst ALPHA = 'abcdefghijklmnopqrstuvwxyz';\n\nconst DIGIT = '0123456789';\n\nconst ALPHABET = {\n  DIGIT,\n  ALPHA,\n  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT\n};\n\nconst generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {\n  let str = '';\n  const {length} = alphabet;\n  while (size--) {\n    str += alphabet[Math.random() * length|0];\n  }\n\n  return str;\n};\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);\n}\n\nconst toJSONObject = (obj) => {\n  const stack = new Array(10);\n\n  const visit = (source, i) => {\n\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      if(!('toJSON' in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n\n        stack[i] = undefined;\n\n        return target;\n      }\n    }\n\n    return source;\n  };\n\n  return visit(obj, 0);\n};\n\nconst isAsyncFn = kindOfTest('AsyncFunction');\n\nconst isThenable = (thing) =>\n  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n\n// original code\n// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34\n\nconst _setImmediate = ((setImmediateSupported, postMessageSupported) => {\n  if (setImmediateSupported) {\n    return setImmediate;\n  }\n\n  return postMessageSupported ? ((token, callbacks) => {\n    _global.addEventListener(\"message\", ({source, data}) => {\n      if (source === _global && data === token) {\n        callbacks.length && callbacks.shift()();\n      }\n    }, false);\n\n    return (cb) => {\n      callbacks.push(cb);\n      _global.postMessage(token, \"*\");\n    }\n  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);\n})(\n  typeof setImmediate === 'function',\n  isFunction(_global.postMessage)\n);\n\nconst asap = typeof queueMicrotask !== 'undefined' ?\n  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);\n\n// *********************\n\nvar utils$1 = {\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isReadableStream,\n  isRequest,\n  isResponse,\n  isHeaders,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty,\n  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  ALPHABET,\n  generateString,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable,\n  setImmediate: _setImmediate,\n  asap\n};\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  if (response) {\n    this.response = response;\n    this.status = response.status ? response.status : null;\n  }\n}\n\nutils$1.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: utils$1.toJSONObject(this.config),\n      code: this.code,\n      status: this.status\n    };\n  }\n});\n\nconst prototype$1 = AxiosError.prototype;\nconst descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED',\n  'ERR_NOT_SUPPORT',\n  'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype$1, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(prototype$1);\n\n  utils$1.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== 'isAxiosError';\n  });\n\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n\n  axiosError.cause = error;\n\n  axiosError.name = error.name;\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\n// eslint-disable-next-line strict\nvar httpAdapter = null;\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils$1.isArray(arr) && !arr.some(isVisitable);\n}\n\nconst predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils$1.isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils$1.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils$1.isUndefined(source[option]);\n  });\n\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);\n\n  if (!utils$1.isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils$1.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (!useBlob && utils$1.isBlob(value)) {\n      throw new AxiosError('Blob is not supported. Use a Buffer instead.');\n    }\n\n    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n\n    if (value && !path && typeof value === 'object') {\n      if (utils$1.endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (utils$1.isArray(value) && isFlatArray(value)) ||\n        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !(utils$1.isUndefined(el) || el === null) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  const stack = [];\n\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n\n  function build(value, path) {\n    if (utils$1.isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n\n    stack.push(value);\n\n    utils$1.forEach(value, function each(el, key) {\n      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(\n        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!utils$1.isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode$1(str) {\n  const charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && toFormData(params, this, options);\n}\n\nconst prototype = AxiosURLSearchParams.prototype;\n\nprototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nprototype.toString = function toString(encoder) {\n  const _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode$1);\n  } : encode$1;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?(object|Function)} options\n *\n * @returns {string} The formatted url\n */\nfunction buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  \n  const _encode = options && options.encode || encode;\n\n  if (utils$1.isFunction(options)) {\n    options = {\n      serialize: options\n    };\n  } \n\n  const serializeFn = options && options.serialize;\n\n  let serializedParams;\n\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils$1.isURLSearchParams(params) ?\n      params.toString() :\n      new AxiosURLSearchParams(params, options).toString(_encode);\n  }\n\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf(\"#\");\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n}\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    utils$1.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n\nvar InterceptorManager$1 = InterceptorManager;\n\nvar transitionalDefaults = {\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n};\n\nvar URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;\n\nvar FormData$1 = typeof FormData !== 'undefined' ? FormData : null;\n\nvar Blob$1 = typeof Blob !== 'undefined' ? Blob : null;\n\nvar platform$1 = {\n  isBrowser: true,\n  classes: {\n    URLSearchParams: URLSearchParams$1,\n    FormData: FormData$1,\n    Blob: Blob$1\n  },\n  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n};\n\nconst hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nconst _navigator = typeof navigator === 'object' && navigator || undefined;\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */\nconst hasStandardBrowserEnv = hasBrowserEnv &&\n  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);\n\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nconst hasStandardBrowserWebWorkerEnv = (() => {\n  return (\n    typeof WorkerGlobalScope !== 'undefined' &&\n    // eslint-disable-next-line no-undef\n    self instanceof WorkerGlobalScope &&\n    typeof self.importScripts === 'function'\n  );\n})();\n\nconst origin = hasBrowserEnv && window.location.href || 'http://localhost';\n\nvar utils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    hasBrowserEnv: hasBrowserEnv,\n    hasStandardBrowserEnv: hasStandardBrowserEnv,\n    hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,\n    navigator: _navigator,\n    origin: origin\n});\n\nvar platform = {\n  ...utils,\n  ...platform$1\n};\n\nfunction toURLEncodedForm(data, options) {\n  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({\n    visitor: function(value, key, path, helpers) {\n      if (platform.isNode && utils$1.isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    }\n  }, options));\n}\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils$1.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n\n    if (name === '__proto__') return true;\n\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && utils$1.isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (utils$1.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !utils$1.isObject(target[name])) {\n      target[name] = [];\n    }\n\n    const result = buildPath(path, value, target[name], index);\n\n    if (result && utils$1.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {\n    const obj = {};\n\n    utils$1.forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils$1.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils$1.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nconst defaults = {\n\n  transitional: transitionalDefaults,\n\n  adapter: ['xhr', 'http', 'fetch'],\n\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || '';\n    const hasJSONContentType = contentType.indexOf('application/json') > -1;\n    const isObjectPayload = utils$1.isObject(data);\n\n    if (isObjectPayload && utils$1.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    const isFormData = utils$1.isFormData(data);\n\n    if (isFormData) {\n      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n    }\n\n    if (utils$1.isArrayBuffer(data) ||\n      utils$1.isBuffer(data) ||\n      utils$1.isStream(data) ||\n      utils$1.isFile(data) ||\n      utils$1.isBlob(data) ||\n      utils$1.isReadableStream(data)\n    ) {\n      return data;\n    }\n    if (utils$1.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils$1.isURLSearchParams(data)) {\n      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n      return data.toString();\n    }\n\n    let isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        const _FormData = this.env && this.env.FormData;\n\n        return toFormData(\n          isFileList ? {'files[]': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      headers.setContentType('application/json', false);\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === 'json';\n\n    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {\n      return data;\n    }\n\n    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*',\n      'Content-Type': undefined\n    }\n  }\n};\n\nutils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {\n  defaults.headers[method] = {};\n});\n\nvar defaults$1 = defaults;\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils$1.toObjectSet([\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n]);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\nvar parseHeaders = rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n\n  rawHeaders && rawHeaders.split('\\n').forEach(function parser(line) {\n    i = line.indexOf(':');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n\n    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {\n      return;\n    }\n\n    if (key === 'set-cookie') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils$1.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils$1.isString(value)) return;\n\n  if (utils$1.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils$1.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils$1.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils$1.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite);\n    } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else if (utils$1.isHeaders(header)) {\n      for (const [key, value] of header.entries()) {\n        setHeader(value, key, rewrite);\n      }\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils$1.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils$1.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils$1.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils$1.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils$1.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils$1.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils$1.forEach(this, (value, header) => {\n      const key = utils$1.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils$1.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\nutils$1.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\nutils$1.freezeMethods(AxiosHeaders);\n\nvar AxiosHeaders$1 = AxiosHeaders;\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nfunction transformData(fns, response) {\n  const config = this || defaults$1;\n  const context = response || config;\n  const headers = AxiosHeaders$1.from(context.headers);\n  let data = context.data;\n\n  utils$1.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n\n  headers.normalize();\n\n  return data;\n}\n\nfunction isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\n\nutils$1.inherits(CanceledError, AxiosError, {\n  __CANCEL__: true\n});\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nfunction settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new AxiosError(\n      'Request failed with status code ' + response.status,\n      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n}\n\nfunction parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n}\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\n/**\n * Throttle decorator\n * @param {Function} fn\n * @param {Number} freq\n * @return {Function}\n */\nfunction throttle(fn, freq) {\n  let timestamp = 0;\n  let threshold = 1000 / freq;\n  let lastArgs;\n  let timer;\n\n  const invoke = (args, now = Date.now()) => {\n    timestamp = now;\n    lastArgs = null;\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    fn.apply(null, args);\n  };\n\n  const throttled = (...args) => {\n    const now = Date.now();\n    const passed = now - timestamp;\n    if ( passed >= threshold) {\n      invoke(args, now);\n    } else {\n      lastArgs = args;\n      if (!timer) {\n        timer = setTimeout(() => {\n          timer = null;\n          invoke(lastArgs);\n        }, threshold - passed);\n      }\n    }\n  };\n\n  const flush = () => lastArgs && invoke(lastArgs);\n\n  return [throttled, flush];\n}\n\nconst progressEventReducer = (listener, isDownloadStream, freq = 3) => {\n  let bytesNotified = 0;\n  const _speedometer = speedometer(50, 250);\n\n  return throttle(e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n\n    bytesNotified = loaded;\n\n    const data = {\n      loaded,\n      total,\n      progress: total ? (loaded / total) : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e,\n      lengthComputable: total != null,\n      [isDownloadStream ? 'download' : 'upload']: true\n    };\n\n    listener(data);\n  }, freq);\n};\n\nconst progressEventDecorator = (total, throttled) => {\n  const lengthComputable = total != null;\n\n  return [(loaded) => throttled[0]({\n    lengthComputable,\n    total,\n    loaded\n  }), throttled[1]];\n};\n\nconst asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));\n\nvar isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {\n  url = new URL(url, platform.origin);\n\n  return (\n    origin.protocol === url.protocol &&\n    origin.host === url.host &&\n    (isMSIE || origin.port === url.port)\n  );\n})(\n  new URL(platform.origin),\n  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)\n) : () => true;\n\nvar cookies = platform.hasStandardBrowserEnv ?\n\n  // Standard browser envs support document.cookie\n  {\n    write(name, value, expires, path, domain, secure) {\n      const cookie = [name + '=' + encodeURIComponent(value)];\n\n      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());\n\n      utils$1.isString(path) && cookie.push('path=' + path);\n\n      utils$1.isString(domain) && cookie.push('domain=' + domain);\n\n      secure === true && cookie.push('secure');\n\n      document.cookie = cookie.join('; ');\n    },\n\n    read(name) {\n      const match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return (match ? decodeURIComponent(match[3]) : null);\n    },\n\n    remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  }\n\n  :\n\n  // Non-standard browser env (web workers, react-native) lack needed support.\n  {\n    write() {},\n    read() {\n      return null;\n    },\n    remove() {}\n  };\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nfunction isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nfunction combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/?\\/$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n}\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nfunction buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n\nconst headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nfunction mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n\n  function getMergedValue(target, source, prop, caseless) {\n    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {\n      return utils$1.merge.call({caseless}, target, source);\n    } else if (utils$1.isPlainObject(source)) {\n      return utils$1.merge({}, source);\n    } else if (utils$1.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, prop , caseless) {\n    if (!utils$1.isUndefined(b)) {\n      return getMergedValue(a, b, prop , caseless);\n    } else if (!utils$1.isUndefined(a)) {\n      return getMergedValue(undefined, a, prop , caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils$1.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils$1.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils$1.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    withXSRFToken: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)\n  };\n\n  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n}\n\nvar resolveConfig = (config) => {\n  const newConfig = mergeConfig({}, config);\n\n  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;\n\n  newConfig.headers = headers = AxiosHeaders$1.from(headers);\n\n  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);\n\n  // HTTP basic authentication\n  if (auth) {\n    headers.set('Authorization', 'Basic ' +\n      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))\n    );\n  }\n\n  let contentType;\n\n  if (utils$1.isFormData(data)) {\n    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {\n      headers.setContentType(undefined); // Let the browser set it\n    } else if ((contentType = headers.getContentType()) !== false) {\n      // fix semicolon duplication issue for ReactNative FormData implementation\n      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];\n      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));\n    }\n  }\n\n  // Add xsrf header\n  // This is only done if running in a standard browser environment.\n  // Specifically not if we're in a web worker, or react-native.\n\n  if (platform.hasStandardBrowserEnv) {\n    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));\n\n    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {\n      // Add xsrf header\n      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);\n\n      if (xsrfValue) {\n        headers.set(xsrfHeaderName, xsrfValue);\n      }\n    }\n  }\n\n  return newConfig;\n};\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\nvar xhrAdapter = isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    const _config = resolveConfig(config);\n    let requestData = _config.data;\n    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();\n    let {responseType, onUploadProgress, onDownloadProgress} = _config;\n    let onCanceled;\n    let uploadThrottled, downloadThrottled;\n    let flushUpload, flushDownload;\n\n    function done() {\n      flushUpload && flushUpload(); // flush events\n      flushDownload && flushDownload(); // flush events\n\n      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);\n\n      _config.signal && _config.signal.removeEventListener('abort', onCanceled);\n    }\n\n    let request = new XMLHttpRequest();\n\n    request.open(_config.method.toUpperCase(), _config.url, true);\n\n    // Set the request timeout in MS\n    request.timeout = _config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = AxiosHeaders$1.from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = _config.transitional || transitionalDefaults;\n      if (_config.timeoutErrorMessage) {\n        timeoutErrorMessage = _config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils$1.isUndefined(_config.withCredentials)) {\n      request.withCredentials = !!_config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = _config.responseType;\n    }\n\n    // Handle progress if needed\n    if (onDownloadProgress) {\n      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));\n      request.addEventListener('progress', downloadThrottled);\n    }\n\n    // Not all browsers support upload events\n    if (onUploadProgress && request.upload) {\n      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));\n\n      request.upload.addEventListener('progress', uploadThrottled);\n\n      request.upload.addEventListener('loadend', flushUpload);\n    }\n\n    if (_config.cancelToken || _config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);\n      if (_config.signal) {\n        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(_config.url);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n};\n\nconst composeSignals = (signals, timeout) => {\n  const {length} = (signals = signals ? signals.filter(Boolean) : []);\n\n  if (timeout || length) {\n    let controller = new AbortController();\n\n    let aborted;\n\n    const onabort = function (reason) {\n      if (!aborted) {\n        aborted = true;\n        unsubscribe();\n        const err = reason instanceof Error ? reason : this.reason;\n        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));\n      }\n    };\n\n    let timer = timeout && setTimeout(() => {\n      timer = null;\n      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));\n    }, timeout);\n\n    const unsubscribe = () => {\n      if (signals) {\n        timer && clearTimeout(timer);\n        timer = null;\n        signals.forEach(signal => {\n          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);\n        });\n        signals = null;\n      }\n    };\n\n    signals.forEach((signal) => signal.addEventListener('abort', onabort));\n\n    const {signal} = controller;\n\n    signal.unsubscribe = () => utils$1.asap(unsubscribe);\n\n    return signal;\n  }\n};\n\nvar composeSignals$1 = composeSignals;\n\nconst streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n};\n\nconst readBytes = async function* (iterable, chunkSize) {\n  for await (const chunk of readStream(iterable)) {\n    yield* streamChunk(chunk, chunkSize);\n  }\n};\n\nconst readStream = async function* (stream) {\n  if (stream[Symbol.asyncIterator]) {\n    yield* stream;\n    return;\n  }\n\n  const reader = stream.getReader();\n  try {\n    for (;;) {\n      const {done, value} = await reader.read();\n      if (done) {\n        break;\n      }\n      yield value;\n    }\n  } finally {\n    await reader.cancel();\n  }\n};\n\nconst trackStream = (stream, chunkSize, onProgress, onFinish) => {\n  const iterator = readBytes(stream, chunkSize);\n\n  let bytes = 0;\n  let done;\n  let _onFinish = (e) => {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  };\n\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        const {done, value} = await iterator.next();\n\n        if (done) {\n         _onFinish();\n          controller.close();\n          return;\n        }\n\n        let len = value.byteLength;\n        if (onProgress) {\n          let loadedBytes = bytes += len;\n          onProgress(loadedBytes);\n        }\n        controller.enqueue(new Uint8Array(value));\n      } catch (err) {\n        _onFinish(err);\n        throw err;\n      }\n    },\n    cancel(reason) {\n      _onFinish(reason);\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  })\n};\n\nconst isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';\nconst isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';\n\n// used only inside the fetch adapter\nconst encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\n    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n    async (str) => new Uint8Array(await new Response(str).arrayBuffer())\n);\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false\n  }\n};\n\nconst supportsRequestStream = isReadableStreamSupported && test(() => {\n  let duplexAccessed = false;\n\n  const hasContentType = new Request(platform.origin, {\n    body: new ReadableStream(),\n    method: 'POST',\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    },\n  }).headers.has('Content-Type');\n\n  return duplexAccessed && !hasContentType;\n});\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst supportsResponseStream = isReadableStreamSupported &&\n  test(() => utils$1.isReadableStream(new Response('').body));\n\n\nconst resolvers = {\n  stream: supportsResponseStream && ((res) => res.body)\n};\n\nisFetchSupported && (((res) => {\n  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res) => res[type]() :\n      (_, config) => {\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n      });\n  });\n})(new Response));\n\nconst getBodyLength = async (body) => {\n  if (body == null) {\n    return 0;\n  }\n\n  if(utils$1.isBlob(body)) {\n    return body.size;\n  }\n\n  if(utils$1.isSpecCompliantForm(body)) {\n    const _request = new Request(platform.origin, {\n      method: 'POST',\n      body,\n    });\n    return (await _request.arrayBuffer()).byteLength;\n  }\n\n  if(utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {\n    return body.byteLength;\n  }\n\n  if(utils$1.isURLSearchParams(body)) {\n    body = body + '';\n  }\n\n  if(utils$1.isString(body)) {\n    return (await encodeText(body)).byteLength;\n  }\n};\n\nconst resolveBodyLength = async (headers, body) => {\n  const length = utils$1.toFiniteNumber(headers.getContentLength());\n\n  return length == null ? getBodyLength(body) : length;\n};\n\nvar fetchAdapter = isFetchSupported && (async (config) => {\n  let {\n    url,\n    method,\n    data,\n    signal,\n    cancelToken,\n    timeout,\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    headers,\n    withCredentials = 'same-origin',\n    fetchOptions\n  } = resolveConfig(config);\n\n  responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n\n  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n\n  let request;\n\n  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n  });\n\n  let requestContentLength;\n\n  try {\n    if (\n      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\n      (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n    ) {\n      let _request = new Request(url, {\n        method: 'POST',\n        body: data,\n        duplex: \"half\"\n      });\n\n      let contentTypeHeader;\n\n      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n        headers.setContentType(contentTypeHeader);\n      }\n\n      if (_request.body) {\n        const [onProgress, flush] = progressEventDecorator(\n          requestContentLength,\n          progressEventReducer(asyncDecorator(onUploadProgress))\n        );\n\n        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n      }\n    }\n\n    if (!utils$1.isString(withCredentials)) {\n      withCredentials = withCredentials ? 'include' : 'omit';\n    }\n\n    // Cloudflare Workers throws when credentials are defined\n    // see https://github.com/cloudflare/workerd/issues/902\n    const isCredentialsSupported = \"credentials\" in Request.prototype;\n    request = new Request(url, {\n      ...fetchOptions,\n      signal: composedSignal,\n      method: method.toUpperCase(),\n      headers: headers.normalize().toJSON(),\n      body: data,\n      duplex: \"half\",\n      credentials: isCredentialsSupported ? withCredentials : undefined\n    });\n\n    let response = await fetch(request);\n\n    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {\n      const options = {};\n\n      ['status', 'statusText', 'headers'].forEach(prop => {\n        options[prop] = response[prop];\n      });\n\n      const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));\n\n      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(\n        responseContentLength,\n        progressEventReducer(asyncDecorator(onDownloadProgress), true)\n      ) || [];\n\n      response = new Response(\n        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n          flush && flush();\n          unsubscribe && unsubscribe();\n        }),\n        options\n      );\n    }\n\n    responseType = responseType || 'text';\n\n    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);\n\n    !isStreamResponse && unsubscribe && unsubscribe();\n\n    return await new Promise((resolve, reject) => {\n      settle(resolve, reject, {\n        data: responseData,\n        headers: AxiosHeaders$1.from(response.headers),\n        status: response.status,\n        statusText: response.statusText,\n        config,\n        request\n      });\n    })\n  } catch (err) {\n    unsubscribe && unsubscribe();\n\n    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {\n      throw Object.assign(\n        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),\n        {\n          cause: err.cause || err\n        }\n      )\n    }\n\n    throw AxiosError.from(err, err && err.code, config, request);\n  }\n});\n\nconst knownAdapters = {\n  http: httpAdapter,\n  xhr: xhrAdapter,\n  fetch: fetchAdapter\n};\n\nutils$1.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', {value});\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', {value});\n  }\n});\n\nconst renderReason = (reason) => `- ${reason}`;\n\nconst isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;\n\nvar adapters = {\n  getAdapter: (adapters) => {\n    adapters = utils$1.isArray(adapters) ? adapters : [adapters];\n\n    const {length} = adapters;\n    let nameOrAdapter;\n    let adapter;\n\n    const rejectedReasons = {};\n\n    for (let i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      let id;\n\n      adapter = nameOrAdapter;\n\n      if (!isResolvedHandle(nameOrAdapter)) {\n        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n\n        if (adapter === undefined) {\n          throw new AxiosError(`Unknown adapter '${id}'`);\n        }\n      }\n\n      if (adapter) {\n        break;\n      }\n\n      rejectedReasons[id || '#' + i] = adapter;\n    }\n\n    if (!adapter) {\n\n      const reasons = Object.entries(rejectedReasons)\n        .map(([id, state]) => `adapter ${id} ` +\n          (state === false ? 'is not supported by the environment' : 'is not available in the build')\n        );\n\n      let s = length ?\n        (reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0])) :\n        'as no adapter specified';\n\n      throw new AxiosError(\n        `There is no suitable adapter to dispatch the request ` + s,\n        'ERR_NOT_SUPPORT'\n      );\n    }\n\n    return adapter;\n  },\n  adapters: knownAdapters\n};\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new CanceledError(null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nfunction dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  config.headers = AxiosHeaders$1.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.transformRequest\n  );\n\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }\n\n  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      config.transformResponse,\n      response\n    );\n\n    response.headers = AxiosHeaders$1.from(response.headers);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          config.transformResponse,\n          reason.response\n        );\n        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n}\n\nconst VERSION = \"1.7.9\";\n\nconst validators$1 = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {\n  validators$1[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators$1.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new AxiosError(\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\nvalidators$1.spelling = function spelling(correctSpelling) {\n  return (value, opt) => {\n    // eslint-disable-next-line no-console\n    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);\n    return true;\n  }\n};\n\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\nvar validator = {\n  assertOptions,\n  validators: validators$1\n};\n\nconst validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig;\n    this.interceptors = {\n      request: new InterceptorManager$1(),\n      response: new InterceptorManager$1()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  async request(configOrUrl, config) {\n    try {\n      return await this._request(configOrUrl, config);\n    } catch (err) {\n      if (err instanceof Error) {\n        let dummy = {};\n\n        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());\n\n        // slice off the Error: ... line\n        const stack = dummy.stack ? dummy.stack.replace(/^.+\\n/, '') : '';\n        try {\n          if (!err.stack) {\n            err.stack = stack;\n            // match without the 2 top stack lines\n          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\\n.+\\n/, ''))) {\n            err.stack += '\\n' + stack;\n          }\n        } catch (e) {\n          // ignore the case where \"stack\" is an un-writable property\n        }\n      }\n\n      throw err;\n    }\n  }\n\n  _request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios('example/url'[, config]) a la fetch API\n    if (typeof configOrUrl === 'string') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n\n    config = mergeConfig(this.defaults, config);\n\n    const {transitional, paramsSerializer, headers} = config;\n\n    if (transitional !== undefined) {\n      validator.assertOptions(transitional, {\n        silentJSONParsing: validators.transitional(validators.boolean),\n        forcedJSONParsing: validators.transitional(validators.boolean),\n        clarifyTimeoutError: validators.transitional(validators.boolean)\n      }, false);\n    }\n\n    if (paramsSerializer != null) {\n      if (utils$1.isFunction(paramsSerializer)) {\n        config.paramsSerializer = {\n          serialize: paramsSerializer\n        };\n      } else {\n        validator.assertOptions(paramsSerializer, {\n          encode: validators.function,\n          serialize: validators.function\n        }, true);\n      }\n    }\n\n    validator.assertOptions(config, {\n      baseUrl: validators.spelling('baseURL'),\n      withXsrfToken: validators.spelling('withXSRFToken')\n    }, true);\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n\n    // Flatten headers\n    let contextHeaders = headers && utils$1.merge(\n      headers.common,\n      headers[config.method]\n    );\n\n    headers && utils$1.forEach(\n      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n      (method) => {\n        delete headers[method];\n      }\n    );\n\n    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n        return;\n      }\n\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    let promise;\n    let i = 0;\n    let len;\n\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift.apply(chain, requestInterceptorChain);\n      chain.push.apply(chain, responseInterceptorChain);\n      len = chain.length;\n\n      promise = Promise.resolve(config);\n\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n\n      return promise;\n    }\n\n    len = requestInterceptorChain.length;\n\n    let newConfig = config;\n\n    i = 0;\n\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    i = 0;\n    len = responseInterceptorChain.length;\n\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n\n    return promise;\n  }\n\n  getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    return buildURL(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\nutils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\nvar Axios$1 = Axios;\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  toAbortSignal() {\n    const controller = new AbortController();\n\n    const abort = (err) => {\n      controller.abort(err);\n    };\n\n    this.subscribe(abort);\n\n    controller.signal.unsubscribe = () => this.unsubscribe(abort);\n\n    return controller.signal;\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\nvar CancelToken$1 = CancelToken;\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nfunction spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nfunction isAxiosError(payload) {\n  return utils$1.isObject(payload) && (payload.isAxiosError === true);\n}\n\nconst HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511,\n};\n\nObject.entries(HttpStatusCode).forEach(([key, value]) => {\n  HttpStatusCode[value] = key;\n});\n\nvar HttpStatusCode$1 = HttpStatusCode;\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new Axios$1(defaultConfig);\n  const instance = bind(Axios$1.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});\n\n  // Copy context to instance\n  utils$1.extend(instance, context, null, {allOwnKeys: true});\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios = createInstance(defaults$1);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios$1;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = CanceledError;\naxios.CancelToken = CancelToken$1;\naxios.isCancel = isCancel;\naxios.VERSION = VERSION;\naxios.toFormData = toFormData;\n\n// Expose AxiosError class\naxios.AxiosError = AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = spread;\n\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError;\n\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig;\n\naxios.AxiosHeaders = AxiosHeaders$1;\n\naxios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);\n\naxios.getAdapter = adapters.getAdapter;\n\naxios.HttpStatusCode = HttpStatusCode$1;\n\naxios.default = axios;\n\n// this module should only have a default export\nvar axios$1 = axios;\n\nclass Provider {\n    contract;\n    constructor(contract) {\n        this.contract = contract;\n    }\n    async fetchJSON(endpoint, options) {\n        try {\n            const response = await fetch(endpoint, options);\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error);\n            }\n            return response.json();\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async fetchText(endpoint, options) {\n        try {\n            const response = await fetch(endpoint, options);\n            if (!response.ok) {\n                throw new Error(`HTTP error! Status: ${response.status}`);\n            }\n            const buffer = await response.arrayBuffer();\n            return Buffer.from(buffer).toString('utf-8');\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getProviderUrl(providerAddress) {\n        try {\n            const service = await this.contract.getService(providerAddress);\n            return service.url;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getQuote(providerAddress) {\n        try {\n            const url = await this.getProviderUrl(providerAddress);\n            const endpoint = `${url}/v1/quote`;\n            const quoteString = await this.fetchText(endpoint, {\n                method: 'GET',\n            });\n            const ret = JSON.parse(quoteString);\n            return ret;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async createTask(providerAddress, task) {\n        try {\n            const url = await this.getProviderUrl(providerAddress);\n            const userAddress = this.contract.getUserAddress();\n            const endpoint = `${url}/v1/user/${userAddress}/task`;\n            const response = await this.fetchJSON(endpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(task),\n            });\n            return response.id;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                throw new Error(`Failed to create task: ${error.message}`);\n            }\n            throw new Error('Failed to create task');\n        }\n    }\n    async cancelTask(providerAddress, signature, taskID) {\n        try {\n            const url = await this.getProviderUrl(providerAddress);\n            const userAddress = this.contract.getUserAddress();\n            const endpoint = `${url}/v1/user/${userAddress}/task/${taskID}/cancel`;\n            const response = await this.fetchText(endpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    signature: signature,\n                }),\n            });\n            return response;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getTask(providerAddress, userAddress, taskID) {\n        try {\n            const url = await this.getProviderUrl(providerAddress);\n            const endpoint = `${url}/v1/user/${encodeURIComponent(userAddress)}/task/${taskID}`;\n            console.log('url', url);\n            console.log('endpoint', endpoint);\n            return this.fetchJSON(endpoint, { method: 'GET' });\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async listTask(providerAddress, userAddress, latest = false) {\n        try {\n            const url = await this.getProviderUrl(providerAddress);\n            let endpoint = `${url}/v1/user/${encodeURIComponent(userAddress)}/task`;\n            if (latest) {\n                endpoint += '?latest=true';\n            }\n            return this.fetchJSON(endpoint, { method: 'GET' });\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getPendingTaskCounter(providerAddress) {\n        try {\n            const url = await this.getProviderUrl(providerAddress);\n            const endpoint = `${url}/v1/task/pending`;\n            return Number(await this.fetchText(endpoint, {\n                method: 'GET',\n            }));\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getLog(providerAddress, userAddress, taskID) {\n        try {\n            const url = await this.getProviderUrl(providerAddress);\n            const endpoint = `${url}/v1/user/${userAddress}/task/${taskID}/log`;\n            return this.fetchText(endpoint, { method: 'GET' });\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getCustomizedModels(url) {\n        try {\n            const endpoint = `${url}/v1/model`;\n            const response = await this.fetchJSON(endpoint, { method: 'GET' });\n            return response;\n        }\n        catch (error) {\n            console.error(`Failed to get customized models: ${error}`);\n            return [];\n        }\n    }\n    async getCustomizedModel(providerAddress, moduleName) {\n        try {\n            const url = await this.getProviderUrl(providerAddress);\n            const endpoint = `${url}/v1/model/${moduleName}`;\n            const response = await this.fetchJSON(endpoint, { method: 'GET' });\n            return response;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getCustomizedModelDetailUsage(providerAddress, moduleName, outputPath) {\n        try {\n            const url = await this.getProviderUrl(providerAddress);\n            const endpoint = `${url}/v1/model/desc/${moduleName}`;\n            let destFile = outputPath;\n            try {\n                const stats = await fs_promises__WEBPACK_IMPORTED_MODULE_4__.stat(outputPath);\n                if (stats.isDirectory()) {\n                    destFile = path__WEBPACK_IMPORTED_MODULE_3__.join(outputPath, `${moduleName}.zip`);\n                }\n                await fs_promises__WEBPACK_IMPORTED_MODULE_4__.unlink(destFile);\n            }\n            catch (err) { }\n            const response = await axios$1({\n                method: 'get',\n                url: endpoint,\n                responseType: 'arraybuffer',\n            });\n            await fs_promises__WEBPACK_IMPORTED_MODULE_4__.writeFile(destFile, response.data);\n            console.log(`Model downloaded and saved to ${destFile}`);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n}\n\nclass FineTuningBroker {\n    signer;\n    fineTuningCA;\n    ledger;\n    modelProcessor;\n    serviceProcessor;\n    serviceProvider;\n    _gasPrice;\n    _maxGasPrice;\n    _step;\n    constructor(signer, fineTuningCA, ledger, gasPrice, maxGasPrice, step) {\n        this.signer = signer;\n        this.fineTuningCA = fineTuningCA;\n        this.ledger = ledger;\n        this._gasPrice = gasPrice;\n        this._maxGasPrice = maxGasPrice;\n        this._step = step;\n    }\n    async initialize() {\n        let userAddress;\n        try {\n            userAddress = await this.signer.getAddress();\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n        const contract = new FineTuningServingContract(this.signer, this.fineTuningCA, userAddress, this._gasPrice, this._maxGasPrice, this._step);\n        this.serviceProvider = new Provider(contract);\n        this.modelProcessor = new ModelProcessor(contract, this.ledger, this.serviceProvider);\n        this.serviceProcessor = new ServiceProcessor(contract, this.ledger, this.serviceProvider);\n    }\n    listService = async () => {\n        try {\n            return await this.serviceProcessor.listService();\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    getLockedTime = async () => {\n        try {\n            return await this.serviceProcessor.getLockTime();\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    getAccount = async (providerAddress) => {\n        try {\n            return await this.serviceProcessor.getAccount(providerAddress);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    getAccountWithDetail = async (providerAddress) => {\n        try {\n            return await this.serviceProcessor.getAccountWithDetail(providerAddress);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    acknowledgeProviderSigner = async (providerAddress, gasPrice) => {\n        try {\n            return await this.serviceProcessor.acknowledgeProviderSigner(providerAddress, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    listModel = () => {\n        try {\n            return this.modelProcessor.listModel();\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    modelUsage = (providerAddress, preTrainedModelName, output) => {\n        try {\n            return this.serviceProcessor.modelUsage(providerAddress, preTrainedModelName, output);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    uploadDataset = async (dataPath, gasPrice, maxGasPrice) => {\n        try {\n            await this.modelProcessor.uploadDataset(this.signer.privateKey, dataPath, gasPrice || this._gasPrice, maxGasPrice || this._maxGasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    downloadDataset = async (dataPath, dataRoot) => {\n        try {\n            await this.modelProcessor.downloadDataset(dataPath, dataRoot);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    calculateToken = async (datasetPath, preTrainedModelName, usePython, providerAddress) => {\n        try {\n            await this.modelProcessor.calculateToken(datasetPath, usePython, preTrainedModelName, providerAddress);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    createTask = async (providerAddress, preTrainedModelName, dataSize, datasetHash, trainingPath, gasPrice) => {\n        try {\n            return await this.serviceProcessor.createTask(providerAddress, preTrainedModelName, dataSize, datasetHash, trainingPath, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    cancelTask = async (providerAddress, taskID) => {\n        try {\n            return await this.serviceProcessor.cancelTask(providerAddress, taskID);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    listTask = async (providerAddress) => {\n        try {\n            return await this.serviceProcessor.listTask(providerAddress);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    getTask = async (providerAddress, taskID) => {\n        try {\n            const task = await this.serviceProcessor.getTask(providerAddress, taskID);\n            return task;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    getLog = async (providerAddress, taskID) => {\n        try {\n            return await this.serviceProcessor.getLog(providerAddress, taskID);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    acknowledgeModel = async (providerAddress, dataPath, gasPrice) => {\n        try {\n            return await this.modelProcessor.acknowledgeModel(providerAddress, dataPath, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    decryptModel = async (providerAddress, encryptedModelPath, decryptedModelPath) => {\n        try {\n            return await this.modelProcessor.decryptModel(providerAddress, encryptedModelPath, decryptedModelPath);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n}\n/**\n * createFineTuningBroker is used to initialize ZGServingUserBroker\n *\n * @param signer - Signer from ethers.js.\n * @param contractAddress - 0G Serving contract address, use default address if not provided.\n * @param ledger - Ledger broker instance.\n * @param gasPrice - Gas price for transactions. If not provided, the gas price will be calculated automatically.\n *\n * @returns broker instance.\n *\n * @throws An error if the broker cannot be initialized.\n */\nasync function createFineTuningBroker(signer, contractAddress, ledger, gasPrice, maxGasPrice, step) {\n    const broker = new FineTuningBroker(signer, contractAddress, ledger, gasPrice, maxGasPrice, step);\n    try {\n        await broker.initialize();\n        return broker;\n    }\n    catch (error) {\n        throw error;\n    }\n}\n\n/**\n * LedgerProcessor contains methods for creating, depositing funds, and retrieving 0G Compute Network Ledgers.\n */\nclass LedgerProcessor {\n    metadata;\n    cache;\n    ledgerContract;\n    inferenceContract;\n    fineTuningContract;\n    constructor(metadata, cache, ledgerContract, inferenceContract, fineTuningContract) {\n        this.metadata = metadata;\n        this.ledgerContract = ledgerContract;\n        this.inferenceContract = inferenceContract;\n        this.fineTuningContract = fineTuningContract;\n        this.cache = cache;\n    }\n    async getLedger() {\n        try {\n            const ledger = await this.ledgerContract.getLedger();\n            return ledger;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getLedgerWithDetail() {\n        try {\n            const ledger = await this.ledgerContract.getLedger();\n            const ledgerInfo = [\n                ledger.totalBalance,\n                ledger.totalBalance - ledger.availableBalance,\n            ];\n            const infers = await Promise.all(ledger.inferenceProviders.map(async (provider) => {\n                const account = await this.inferenceContract.getAccount(provider);\n                return [provider, account.balance, account.pendingRefund];\n            }));\n            if (typeof this.fineTuningContract == 'undefined') {\n                return { ledgerInfo, infers, fines: [] };\n            }\n            const fines = await Promise.all(ledger.fineTuningProviders.map(async (provider) => {\n                const account = await this.fineTuningContract?.getAccount(provider);\n                return [provider, account.balance, account.pendingRefund];\n            }));\n            return { ledgerInfo, infers, fines };\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async listLedger() {\n        try {\n            const ledgers = await this.ledgerContract.listLedger();\n            return ledgers;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async addLedger(balance, gasPrice) {\n        try {\n            try {\n                const ledger = await this.getLedger();\n                if (ledger) {\n                    throw new Error('Ledger already exists, with balance: ' +\n                        this.neuronToA0gi(ledger.totalBalance) +\n                        ' A0GI');\n                }\n            }\n            catch (error) { }\n            const { settleSignerPublicKey, settleSignerEncryptedPrivateKey } = await this.createSettleSignerKey();\n            await this.ledgerContract.addLedger(settleSignerPublicKey, this.a0giToNeuron(balance), settleSignerEncryptedPrivateKey, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async deleteLedger(gasPrice) {\n        try {\n            await this.ledgerContract.deleteLedger(gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async depositFund(balance, gasPrice) {\n        try {\n            const amount = this.a0giToNeuron(balance).toString();\n            await this.ledgerContract.depositFund(amount, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async refund(balance, gasPrice) {\n        try {\n            const amount = this.a0giToNeuron(balance).toString();\n            await this.ledgerContract.refund(amount, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async transferFund(to, serviceTypeStr, balance, gasPrice) {\n        try {\n            const amount = balance.toString();\n            await this.ledgerContract.transferFund(to, serviceTypeStr, amount, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async retrieveFund(serviceTypeStr, gasPrice) {\n        try {\n            const ledger = await this.getLedgerWithDetail();\n            const providers = serviceTypeStr == 'inference' ? ledger.infers : ledger.fines;\n            if (!providers) {\n                throw new Error('No providers found, please ensure you are using Wallet instance to create the broker');\n            }\n            const providerAddresses = providers\n                .filter((x) => x[1] - x[2] > 0n)\n                .map((x) => x[0]);\n            await this.ledgerContract.retrieveFund(providerAddresses, serviceTypeStr, gasPrice);\n            if (serviceTypeStr == 'inference') {\n                await this.cache.setItem('firstRound', 'true', 10000000 * 60 * 1000, CacheValueTypeEnum.Other);\n            }\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async createSettleSignerKey() {\n        try {\n            // [pri, pub]\n            const keyPair = await genKeyPair();\n            const key = `${this.ledgerContract.getUserAddress()}`;\n            this.metadata.storeSettleSignerPrivateKey(key, keyPair.packedPrivkey);\n            const settleSignerEncryptedPrivateKey = await encryptData(this.ledgerContract.signer, privateKeyToStr(keyPair.packedPrivkey));\n            return {\n                settleSignerEncryptedPrivateKey,\n                settleSignerPublicKey: keyPair.doublePackedPubkey,\n            };\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    a0giToNeuron(value) {\n        const valueStr = value.toFixed(18);\n        const parts = valueStr.split('.');\n        // Handle integer part\n        const integerPart = parts[0];\n        let integerPartAsBigInt = BigInt(integerPart) * BigInt(10 ** 18);\n        // Handle fractional part if it exists\n        if (parts.length > 1) {\n            let fractionalPart = parts[1];\n            while (fractionalPart.length < 18) {\n                fractionalPart += '0';\n            }\n            if (fractionalPart.length > 18) {\n                fractionalPart = fractionalPart.slice(0, 18); // Truncate to avoid overflow\n            }\n            const fractionalPartAsBigInt = BigInt(fractionalPart);\n            integerPartAsBigInt += fractionalPartAsBigInt;\n        }\n        return integerPartAsBigInt;\n    }\n    neuronToA0gi(value) {\n        const divisor = BigInt(10 ** 18);\n        const integerPart = value / divisor;\n        const remainder = value % divisor;\n        const decimalPart = Number(remainder) / Number(divisor);\n        return Number(integerPart) + decimalPart;\n    }\n}\n\nconst TIMEOUT_MS = 300_000;\nclass LedgerManagerContract {\n    ledger;\n    signer;\n    _userAddress;\n    _gasPrice;\n    _maxGasPrice;\n    _step;\n    constructor(signer, contractAddress, userAddress, gasPrice, maxGasPrice, step) {\n        this.ledger = LedgerManager__factory.connect(contractAddress, signer);\n        this.signer = signer;\n        this._userAddress = userAddress;\n        this._gasPrice = gasPrice;\n        this._maxGasPrice = maxGasPrice;\n        this._step = step || 1.1;\n    }\n    async sendTx(name, txArgs, txOptions) {\n        if (txOptions.gasPrice === undefined) {\n            txOptions.gasPrice = (await this.signer.provider?.getFeeData())?.gasPrice;\n            // Add a delay to avoid too frequent RPC calls\n            await new Promise((resolve) => setTimeout(resolve, 1000));\n        }\n        else {\n            txOptions.gasPrice = BigInt(txOptions.gasPrice);\n        }\n        while (true) {\n            try {\n                console.log('sending tx with gas price', txOptions.gasPrice);\n                const tx = await this.ledger.getFunction(name)(...txArgs, txOptions);\n                console.log('tx hash:', tx.hash);\n                const receipt = (await Promise.race([\n                    tx.wait(),\n                    new Promise((_, reject) => setTimeout(() => reject(new Error('Get Receipt timeout')), TIMEOUT_MS)),\n                ]));\n                this.checkReceipt(receipt);\n                break;\n            }\n            catch (error) {\n                if (error.message ===\n                    'Get Receipt timeout, try set higher gas price') {\n                    const nonce = await this.signer.getNonce();\n                    const pendingNonce = await this.signer.provider?.getTransactionCount(this._userAddress, 'pending');\n                    if (pendingNonce !== undefined &&\n                        pendingNonce - nonce > 5 &&\n                        txOptions.nonce === undefined) {\n                        console.warn(`Significant gap detected between pending nonce (${pendingNonce}) and current nonce (${nonce}). This may indicate skipped or missing transactions. Using the current confirmed nonce for the transaction.`);\n                        txOptions.nonce = nonce;\n                    }\n                }\n                if (this._maxGasPrice === undefined) {\n                    throwFormattedError(error);\n                }\n                let errorMessage = '';\n                if (error.message) {\n                    errorMessage = error.message;\n                }\n                else if (error.info?.error?.message) {\n                    errorMessage = error.info.error.message;\n                }\n                const shouldRetry = RETRY_ERROR_SUBSTRINGS.some((substr) => errorMessage.includes(substr));\n                if (!shouldRetry) {\n                    throwFormattedError(error);\n                }\n                console.log('Retrying transaction with higher gas price due to:', errorMessage);\n                let currentGasPrice = txOptions.gasPrice;\n                if (currentGasPrice >= this._maxGasPrice) {\n                    throwFormattedError(error);\n                }\n                currentGasPrice =\n                    (currentGasPrice * BigInt(this._step)) / BigInt(10);\n                if (currentGasPrice > this._maxGasPrice) {\n                    currentGasPrice = this._maxGasPrice;\n                }\n                txOptions.gasPrice = currentGasPrice;\n            }\n        }\n    }\n    async addLedger(signer, balance, settleSignerEncryptedPrivateKey, gasPrice) {\n        try {\n            const txOptions = { value: balance };\n            if (gasPrice || this._gasPrice) {\n                txOptions.gasPrice = gasPrice || this._gasPrice;\n            }\n            await this.sendTx('addLedger', [signer, settleSignerEncryptedPrivateKey], txOptions);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async listLedger() {\n        try {\n            const ledgers = await this.ledger.getAllLedgers();\n            return ledgers;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async getLedger() {\n        try {\n            const user = this.getUserAddress();\n            const ledger = await this.ledger.getLedger(user);\n            return ledger;\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async depositFund(balance, gasPrice) {\n        try {\n            const txOptions = { value: balance };\n            if (gasPrice || this._gasPrice) {\n                txOptions.gasPrice = gasPrice || this._gasPrice;\n            }\n            await this.sendTx('depositFund', [], txOptions);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async refund(amount, gasPrice) {\n        try {\n            const txOptions = {};\n            if (gasPrice || this._gasPrice) {\n                txOptions.gasPrice = gasPrice || this._gasPrice;\n            }\n            await this.sendTx('refund', [amount], txOptions);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async transferFund(provider, serviceTypeStr, amount, gasPrice) {\n        try {\n            const txOptions = {};\n            if (gasPrice || this._gasPrice) {\n                txOptions.gasPrice = gasPrice || this._gasPrice;\n            }\n            await this.sendTx('transferFund', [provider, serviceTypeStr, amount], txOptions);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async retrieveFund(providers, serviceTypeStr, gasPrice) {\n        try {\n            const txOptions = {};\n            if (gasPrice || this._gasPrice) {\n                txOptions.gasPrice = gasPrice || this._gasPrice;\n            }\n            await this.sendTx('retrieveFund', [providers, serviceTypeStr], txOptions);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    async deleteLedger(gasPrice) {\n        try {\n            const txOptions = {};\n            if (gasPrice || this._gasPrice) {\n                txOptions.gasPrice = gasPrice || this._gasPrice;\n            }\n            await this.sendTx('deleteLedger', [], txOptions);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    }\n    getUserAddress() {\n        return this._userAddress;\n    }\n    checkReceipt(receipt) {\n        if (!receipt) {\n            throw new Error('Transaction failed with no receipt');\n        }\n        if (receipt.status !== 1) {\n            throw new Error('Transaction reverted');\n        }\n    }\n}\n\nclass LedgerBroker {\n    ledger;\n    signer;\n    ledgerCA;\n    inferenceCA;\n    fineTuningCA;\n    gasPrice;\n    maxGasPrice;\n    step;\n    constructor(signer, ledgerCA, inferenceCA, fineTuningCA, gasPrice, maxGasPrice, step) {\n        this.signer = signer;\n        this.ledgerCA = ledgerCA;\n        this.inferenceCA = inferenceCA;\n        this.fineTuningCA = fineTuningCA;\n        this.gasPrice = gasPrice;\n        this.maxGasPrice = maxGasPrice;\n        this.step = step;\n    }\n    async initialize() {\n        let userAddress;\n        try {\n            userAddress = await this.signer.getAddress();\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n        const ledgerContract = new LedgerManagerContract(this.signer, this.ledgerCA, userAddress, this.gasPrice, this.maxGasPrice, this.step);\n        const inferenceContract = new InferenceServingContract(this.signer, this.inferenceCA, userAddress);\n        let fineTuningContract;\n        if (this.signer instanceof ethers__WEBPACK_IMPORTED_MODULE_17__.Wallet) {\n            fineTuningContract = new FineTuningServingContract(this.signer, this.fineTuningCA, userAddress);\n        }\n        const metadata = new Metadata();\n        const cache = new Cache();\n        this.ledger = new LedgerProcessor(metadata, cache, ledgerContract, inferenceContract, fineTuningContract);\n    }\n    /**\n     * Adds a new ledger to the contract.\n     *\n     * @param {number} balance - The initial balance to be assigned to the new ledger. Units are in A0GI.\n     * @param {number} gasPrice - The gas price to be used for the transaction. If not provided,\n     *                            the default/auto-generated gas price will be used. Units are in neuron.\n     *\n     * @throws  An error if the ledger creation fails.\n     *\n     * @remarks\n     * When creating an ledger, a key pair is also created to sign the request.\n     */\n    addLedger = async (balance, gasPrice) => {\n        try {\n            return await this.ledger.addLedger(balance, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * Retrieves the ledger information for current wallet address.\n     *\n     * @returns A promise that resolves to the ledger information.\n     *\n     * @throws Will throw an error if the ledger retrieval process fails.\n     */\n    getLedger = async () => {\n        try {\n            return await this.ledger.getLedger();\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * Deposits a specified amount of funds into Ledger corresponding to the current wallet address.\n     *\n     * @param {string} amount - The amount of funds to be deposited. Units are in A0GI.\n     * @param {number} gasPrice - The gas price to be used for the transaction. If not provided,\n     *                            the default/auto-generated gas price will be used. Units are in neuron.\n     *\n     * @throws  An error if the deposit fails.\n     */\n    depositFund = async (amount, gasPrice) => {\n        try {\n            return await this.ledger.depositFund(amount, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * Refunds a specified amount using the ledger.\n     *\n     * @param amount - The amount to be refunded.\n     * @param {number} gasPrice - The gas price to be used for the transaction. If not provided,\n     *                            the default/auto-generated gas price will be used. Units are in neuron.\n     *\n     * @returns A promise that resolves when the refund is processed.\n     * @throws Will throw an error if the refund process fails.\n     *\n     * @remarks The amount should be a positive number.\n     */\n    refund = async (amount, gasPrice) => {\n        try {\n            return await this.ledger.refund(amount, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * Transfers a specified amount of funds to a provider for a given service type.\n     *\n     * @param provider - The address of the provider to whom the funds are being transferred.\n     * @param serviceTypeStr - The type of service for which the funds are being transferred.\n     *                         It can be either 'inference' or 'fine-tuning'.\n     * @param amount - The amount of funds to be transferred. Units are in neuron.\n     * @param {number} gasPrice - The gas price to be used for the transaction. If not provided,\n     *                            the default/auto-generated gas price will be used. Units are in neuron.\n     *\n     * @returns A promise that resolves with the result of the fund transfer operation.\n     * @throws Will throw an error if the fund transfer operation fails.\n     */\n    transferFund = async (provider, serviceTypeStr, amount, gasPrice) => {\n        try {\n            return await this.ledger.transferFund(provider, serviceTypeStr, amount, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * Retrieves funds from the all sub-accounts (for inference and fine-tuning) of the current wallet address.\n     *\n     * @param serviceTypeStr - The type of service for which the funds are being retrieved.\n     *                         It can be either 'inference' or 'fine-tuning'.\n     * @param {number} gasPrice - The gas price to be used for the transaction. If not provided,\n     *                            the default/auto-generated gas price will be used. Units are in neuron.\n     *\n     * @returns A promise that resolves with the result of the fund retrieval operation.\n     * @throws Will throw an error if the fund retrieval operation fails.\n     */\n    retrieveFund = async (serviceTypeStr, gasPrice) => {\n        try {\n            return await this.ledger.retrieveFund(serviceTypeStr, gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n    /**\n     * Deletes the ledger corresponding to the current wallet address.\n     *\n     * @param {number} gasPrice - The gas price to be used for the transaction. If not provided,\n     *                           the default/auto-generated gas price will be used. Units are in neuron.\n     *\n     * @throws  An error if the deletion fails.\n     */\n    deleteLedger = async (gasPrice) => {\n        try {\n            return await this.ledger.deleteLedger(gasPrice);\n        }\n        catch (error) {\n            throwFormattedError(error);\n        }\n    };\n}\n/**\n * createLedgerBroker is used to initialize LedgerBroker\n *\n * @param signer - Signer from ethers.js.\n * @param ledgerCA - Ledger contract address, use default address if not provided.\n *\n * @returns broker instance.\n *\n * @throws An error if the broker cannot be initialized.\n */\nasync function createLedgerBroker(signer, ledgerCA, inferenceCA, fineTuningCA, gasPrice, maxGasPrice, step) {\n    const broker = new LedgerBroker(signer, ledgerCA, inferenceCA, fineTuningCA, gasPrice, maxGasPrice, step);\n    try {\n        await broker.initialize();\n        return broker;\n    }\n    catch (error) {\n        throw error;\n    }\n}\n\nclass ZGComputeNetworkBroker {\n    ledger;\n    inference;\n    fineTuning;\n    constructor(ledger, inferenceBroker, fineTuningBroker) {\n        this.ledger = ledger;\n        this.inference = inferenceBroker;\n        this.fineTuning = fineTuningBroker;\n    }\n}\n/**\n * createZGComputeNetworkBroker is used to initialize ZGComputeNetworkBroker\n *\n * @param signer - Signer from ethers.js.\n * @param ledgerCA - 0G Compute Network Ledger Contact address, use default address if not provided.\n * @param inferenceCA - 0G Compute Network Inference Serving contract address, use default address if not provided.\n * @param fineTuningCA - 0G Compute Network Fine Tuning Serving contract address, use default address if not provided.\n * @param gasPrice - Gas price for transactions. If not provided, the gas price will be calculated automatically.\n *\n * @returns broker instance.\n *\n * @throws An error if the broker cannot be initialized.\n */\nasync function createZGComputeNetworkBroker(signer, ledgerCA = '0x20f6E41b27fB6437B6ED61a42DcddB6328749F84', inferenceCA = '0x9A30Ae15ee33Bbd777113c9C64b31d7f717C97A0', fineTuningCA = '0x4c871c46D901990987EBf39Cb8a16fC73390a4E5', gasPrice, maxGasPrice, step) {\n    try {\n        const ledger = await createLedgerBroker(signer, ledgerCA, inferenceCA, fineTuningCA, gasPrice, maxGasPrice, step);\n        const inferenceBroker = await createInferenceBroker(signer, inferenceCA, ledger);\n        let fineTuningBroker;\n        if (signer instanceof ethers__WEBPACK_IMPORTED_MODULE_17__.Wallet) {\n            fineTuningBroker = await createFineTuningBroker(signer, fineTuningCA, ledger, gasPrice, maxGasPrice, step);\n        }\n        const broker = new ZGComputeNetworkBroker(ledger, inferenceBroker, fineTuningBroker);\n        return broker;\n    }\n    catch (error) {\n        throw error;\n    }\n}\n\n\n//# sourceMappingURL=index-1e77a467.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQDBnbGFicy8wZy1zZXJ2aW5nLWJyb2tlci9saWIuZXNtL2luZGV4LTFlNzdhNDY3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVGO0FBQ3REO0FBQ3lDO0FBQ3pCO0FBQ2xCO0FBQ0U7QUFDRzs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxr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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwrQ0FBK0M7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELCtDQUErQztBQUMxRztBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdDQUFnQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLGVBQWU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9EQUFlO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFTO0FBQzVCO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQVE7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9EQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFTO0FBQzVCO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQVE7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdEQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLGFBQWEsdUJBQXVCLE1BQU07QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFHO0FBQ2Q7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBLDJCQUEyQixvQkFBb0IsSUFBSTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUyxHQUFHLFNBQVM7QUFDNUMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtDQUFrQztBQUNsQyxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGdDQUFnQyxXQUFXLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHLEdBQUcsV0FBVztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixlQUFlOztBQUV6QztBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxRQUFRO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsV0FBVyxjQUFjO0FBQzVCLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixDQUFDOztBQUVEO0FBQ0Esb0RBQW9ELFlBQVk7O0FBRWhFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxzQkFBc0I7QUFDbkMsWUFBWTtBQUNaO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvREFBb0Q7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDLHdDQUF3Qzs7QUFFeEM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxTQUFTLFFBQVE7O0FBRWpCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBLFdBQVcsUUFBUTs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRCxPQUFPO0FBQ1AsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0MsTUFBTTtBQUNOO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBLENBQUM7O0FBRUQsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFFBQVE7QUFDbkI7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5REFBeUQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUNBQXFDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixhQUFhLHVCQUF1QixNQUFNO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMkNBQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkNBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvaEI7QUFDcGhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vMGctaW5mZXJlbmNlLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AMGdsYWJzLzBnLXNlcnZpbmctYnJva2VyL2xpYi5lc20vaW5kZXgtMWU3N2E0NjcuanM/YjVkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBldGhlcnMsIENvbnRyYWN0RmFjdG9yeSwgSW50ZXJmYWNlLCBDb250cmFjdCwgaGV4bGlmeSwgV2FsbGV0IH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCBDcnlwdG9KUyBmcm9tICdjcnlwdG8tanMnO1xuaW1wb3J0IHsgYnVpbGRQZWRlcnNlbkhhc2gsIGJ1aWxkQmFieWp1YiwgYnVpbGRFZGRzYSB9IGZyb20gJ2NpcmNvbWxpYmpzJztcbmltcG9ydCB7IHNwYXduIGFzIHNwYXduJDEgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIHBhdGgkMSBmcm9tICdwYXRoJztcbmltcG9ydCBwYXRoX19kZWZhdWx0IGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgZnMkMSBmcm9tICdmcy9wcm9taXNlcyc7XG5cbmNsYXNzIEV4dHJhY3RvciB7XG59XG5cbmNsYXNzIENoYXRCb3QgZXh0ZW5kcyBFeHRyYWN0b3Ige1xuICAgIHN2Y0luZm87XG4gICAgY29uc3RydWN0b3Ioc3ZjSW5mbykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN2Y0luZm8gPSBzdmNJbmZvO1xuICAgIH1cbiAgICBnZXRTdmNJbmZvKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc3ZjSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIGdldElucHV0Q291bnQoY29udGVudCkge1xuICAgICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHV0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IGVuY29kZWQgPSB1dGY4RW5jb2Rlci5lbmNvZGUoY29udGVudCk7XG4gICAgICAgIHJldHVybiBlbmNvZGVkLmxlbmd0aDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0T3V0cHV0Q291bnQoY29udGVudCkge1xuICAgICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHV0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IGVuY29kZWQgPSB1dGY4RW5jb2Rlci5lbmNvZGUoY29udGVudCk7XG4gICAgICAgIHJldHVybiBlbmNvZGVkLmxlbmd0aDtcbiAgICB9XG59XG5cbi8qKlxuICogTUVTU0FHRV9GT1JfRU5DUllQVElPTl9LRVkgaXMgYSBmaXhlZCBtZXNzYWdlIHVzZWQgdG8gZGVyaXZlIHRoZSBlbmNyeXB0aW9uIGtleS5cbiAqXG4gKiBCYWNrZ3JvdW5kOlxuICogVG8gZW5zdXJlIGEgY29uc2lzdGVudCBhbmQgdW5pcXVlIGVuY3J5cHRpb24ga2V5IGNhbiBiZSBnZW5lcmF0ZWQgZnJvbSBhIHVzZXIncyBFdGhlcmV1bSB3YWxsZXQsXG4gKiB3ZSB1dGlsaXplIGEgZml4ZWQgbWVzc2FnZSBjb21iaW5lZCB3aXRoIGEgc2lnbmluZyBtZWNoYW5pc20uXG4gKlxuICogUHVycG9zZTpcbiAqIC0gVGhpcyBzdHJpbmcgaXMgcHJvdmlkZWQgdG8gdGhlIEV0aGVyZXVtIHNpZ25pbmcgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBkaWdpdGFsIHNpZ25hdHVyZSBiYXNlZCBvbiB0aGUgdXNlcidzIHByaXZhdGUga2V5LlxuICogLSBUaGUgcHJvZHVjZWQgc2lnbmF0dXJlIGlzIHRoZW4gaGFzaGVkICh1c2luZyBTSEEtMjU2KSB0byBjcmVhdGUgYSBjb25zaXN0ZW50IDI1Ni1iaXQgZW5jcnlwdGlvbiBrZXkgZnJvbSB0aGUgc2FtZSB3YWxsZXQuXG4gKiAtIFRoaXMgcHJvY2VzcyBvZmZlcnMgYSB3YXkgdG8gcHJvdGVjdCBkYXRhIHdpdGhvdXQgc3RvcmluZyBhZGRpdGlvbmFsIGtleXMuXG4gKlxuICogTm90ZTpcbiAqIC0gVGhlIHVuaXF1ZW5lc3MgYW5kIHN0YWJpbGl0eSBvZiB0aGlzIG1lc3NhZ2UgYXJlIGNydWNpYWw7IGRvIG5vdCBjaGFuZ2UgaXQgdW5sZXNzIHlvdSBmdWxseSB1bmRlcnN0YW5kIHRoZSBpbXBhY3RcbiAqICAgb24gdGhlIGtleSBkZXJpdmF0aW9uIGFuZCBlbmNyeXB0aW9uIHByb2Nlc3MuXG4gKiAtIEJlY2F1c2UgdGhlIHNpZ25hdHVyZSBpcyBkZXJpdmVkIGZyb20gdGhlIHdhbGxldCdzIHByaXZhdGUga2V5LCBpdCBlbnN1cmVzIHRoYXQgZGlmZmVyZW50IHdhbGxldHMgY2Fubm90IHByb2R1Y2UgdGhlIHNhbWUga2V5LlxuICovXG5jb25zdCBNRVNTQUdFX0ZPUl9FTkNSWVBUSU9OX0tFWSA9ICdNRVNTQUdFX0ZPUl9FTkNSWVBUSU9OX0tFWSc7XG4vLyBEZWZpbmUgd2hpY2ggZXJyb3JzIHRvIHJldHJ5IG9uXG5jb25zdCBSRVRSWV9FUlJPUl9TVUJTVFJJTkdTID0gW1xuICAgICd0cmFuc2FjdGlvbiB1bmRlcnByaWNlZCcsXG4gICAgJ3JlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkJyxcbiAgICAnZmVlIHRvbyBsb3cnLFxuICAgICdtZW1wb29sJyxcbl07XG5cbnZhciBkaXN0ID0ge307XG5cbnZhciB1dGlscyQ1ID0ge307XG5cbnZhciBfYXNzZXJ0JDEgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkX2Fzc2VydCQxO1xuXG5mdW5jdGlvbiByZXF1aXJlX2Fzc2VydCQxICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2Fzc2VydCQxKSByZXR1cm4gX2Fzc2VydCQxO1xuXHRoYXNSZXF1aXJlZF9hc3NlcnQkMSA9IDE7XG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBhc3NlcnRpb24gaGVscGVycy5cblx0ICogQG1vZHVsZVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnQkMSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdF9hc3NlcnQkMS5hYm9vbCA9IGFib29sO1xuXHRfYXNzZXJ0JDEuYWJ5dGVzID0gYWJ5dGVzO1xuXHRfYXNzZXJ0JDEuYWV4aXN0cyA9IGFleGlzdHM7XG5cdF9hc3NlcnQkMS5haGFzaCA9IGFoYXNoO1xuXHRfYXNzZXJ0JDEuYW51bWJlciA9IGFudW1iZXI7XG5cdF9hc3NlcnQkMS5hb3V0cHV0ID0gYW91dHB1dDtcblx0X2Fzc2VydCQxLmlzQnl0ZXMgPSBpc0J5dGVzO1xuXHRmdW5jdGlvbiBhbnVtYmVyKG4pIHtcblx0ICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBnb3QgJyArIG4pO1xuXHR9XG5cdC8vIGNvcGllZCBmcm9tIHV0aWxzXG5cdGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuXHQgICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xuXHR9XG5cdGZ1bmN0aW9uIGFieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG5cdCAgICBpZiAoIWlzQnl0ZXMoYikpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG5cdCAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICcgKyBsZW5ndGhzICsgJywgZ290IGxlbmd0aD0nICsgYi5sZW5ndGgpO1xuXHR9XG5cdGZ1bmN0aW9uIGFoYXNoKGgpIHtcblx0ICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuXHQgICAgYW51bWJlcihoLm91dHB1dExlbik7XG5cdCAgICBhbnVtYmVyKGguYmxvY2tMZW4pO1xuXHR9XG5cdGZ1bmN0aW9uIGFleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG5cdCAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcblx0ICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xuXHR9XG5cdGZ1bmN0aW9uIGFvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuXHQgICAgYWJ5dGVzKG91dCk7XG5cdCAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG5cdCAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJyArIG1pbik7XG5cdCAgICB9XG5cdH1cblx0ZnVuY3Rpb24gYWJvb2woYikge1xuXHQgICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBib29sZWFuIGV4cGVjdGVkLCBub3QgJHtifWApO1xuXHR9XG5cdFxuXHRyZXR1cm4gX2Fzc2VydCQxO1xufVxuXG52YXIgaGFzUmVxdWlyZWRVdGlscyQzO1xuXG5mdW5jdGlvbiByZXF1aXJlVXRpbHMkMyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFV0aWxzJDMpIHJldHVybiB1dGlscyQ1O1xuXHRoYXNSZXF1aXJlZFV0aWxzJDMgPSAxO1xuXHQoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0ZXhwb3J0cy53cmFwQ2lwaGVyID0gZXhwb3J0cy5IYXNoID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuaXNMRSA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMudTMyID0gZXhwb3J0cy51OCA9IHZvaWQgMDtcblx0XHRleHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuXHRcdGV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG5cdFx0ZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyO1xuXHRcdGV4cG9ydHMuYnl0ZXNUb051bWJlckJFID0gYnl0ZXNUb051bWJlckJFO1xuXHRcdGV4cG9ydHMubnVtYmVyVG9CeXRlc0JFID0gbnVtYmVyVG9CeXRlc0JFO1xuXHRcdGV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcblx0XHRleHBvcnRzLmJ5dGVzVG9VdGY4ID0gYnl0ZXNUb1V0Zjg7XG5cdFx0ZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcblx0XHRleHBvcnRzLm92ZXJsYXBCeXRlcyA9IG92ZXJsYXBCeXRlcztcblx0XHRleHBvcnRzLmNvbXBsZXhPdmVybGFwQnl0ZXMgPSBjb21wbGV4T3ZlcmxhcEJ5dGVzO1xuXHRcdGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcblx0XHRleHBvcnRzLmNoZWNrT3B0cyA9IGNoZWNrT3B0cztcblx0XHRleHBvcnRzLmVxdWFsQnl0ZXMgPSBlcXVhbEJ5dGVzO1xuXHRcdGV4cG9ydHMuZ2V0T3V0cHV0ID0gZ2V0T3V0cHV0O1xuXHRcdGV4cG9ydHMuc2V0QmlnVWludDY0ID0gc2V0QmlnVWludDY0O1xuXHRcdGV4cG9ydHMudTY0TGVuZ3RocyA9IHU2NExlbmd0aHM7XG5cdFx0ZXhwb3J0cy5pc0FsaWduZWQzMiA9IGlzQWxpZ25lZDMyO1xuXHRcdGV4cG9ydHMuY29weUJ5dGVzID0gY29weUJ5dGVzO1xuXHRcdGV4cG9ydHMuY2xlYW4gPSBjbGVhbjtcblx0XHQvKipcblx0XHQgKiBVdGlsaXRpZXMgZm9yIGhleCwgYnl0ZXMsIENTUFJORy5cblx0XHQgKiBAbW9kdWxlXG5cdFx0ICovXG5cdFx0LyohIG5vYmxlLWNpcGhlcnMgLSBNSVQgTGljZW5zZSAoYykgMjAyMyBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cblx0XHRjb25zdCBfYXNzZXJ0X2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVfYXNzZXJ0JDEoKTtcblx0XHQvLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5cdFx0Y29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuXHRcdGV4cG9ydHMudTggPSB1ODtcblx0XHRjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG5cdFx0ZXhwb3J0cy51MzIgPSB1MzI7XG5cdFx0Ly8gQ2FzdCBhcnJheSB0byB2aWV3XG5cdFx0Y29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuXHRcdGV4cG9ydHMuY3JlYXRlVmlldyA9IGNyZWF0ZVZpZXc7XG5cdFx0Ly8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBjaXBoZXJzOlxuXHRcdC8vIGVhcmx5LXRocm93IGFuIGVycm9yIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBCRSB5ZXQuXG5cdFx0ZXhwb3J0cy5pc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcblx0XHRpZiAoIWV4cG9ydHMuaXNMRSlcblx0XHQgICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG5cdFx0Ly8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcblx0XHRjb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuXHRcdC8qKlxuXHRcdCAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG5cdFx0ICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJ5dGVzKShieXRlcyk7XG5cdFx0ICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuXHRcdCAgICBsZXQgaGV4ID0gJyc7XG5cdFx0ICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHQgICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIGhleDtcblx0XHR9XG5cdFx0Ly8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcblx0XHRjb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcblx0XHRmdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoKSB7XG5cdFx0ICAgIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KVxuXHRcdCAgICAgICAgcmV0dXJuIGNoIC0gYXNjaWlzLl8wOyAvLyAnMicgPT4gNTAtNDhcblx0XHQgICAgaWYgKGNoID49IGFzY2lpcy5BICYmIGNoIDw9IGFzY2lpcy5GKVxuXHRcdCAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuXHRcdCAgICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpXG5cdFx0ICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLmEgLSAxMCk7IC8vICdiJyA9PiA5OC0oOTctMTApXG5cdFx0ICAgIHJldHVybjtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcblx0XHQgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcblx0XHQgICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuXHRcdCAgICBjb25zdCBhbCA9IGhsIC8gMjtcblx0XHQgICAgaWYgKGhsICUgMilcblx0XHQgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcblx0XHQgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG5cdFx0ICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG5cdFx0ICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcblx0XHQgICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcblx0XHQgICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gbXVsdGlwbHkgZmlyc3Qgb2N0ZXQsIGUuZy4gJ2EzJyA9PiAxMCoxNiszID0+IDE2MCArIDMgPT4gMTYzXG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIGFycmF5O1xuXHRcdH1cblx0XHRmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuXHRcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuXHRcdCAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiAnMHgnICsgaGV4KTsgLy8gQmlnIEVuZGlhblxuXHRcdH1cblx0XHQvLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cblx0XHRmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcblx0XHQgICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuXHRcdCAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcblx0XHR9XG5cdFx0Ly8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cblx0XHQvLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cblx0XHQvLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5cdFx0Y29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG5cdFx0ZXhwb3J0cy5uZXh0VGljayA9IG5leHRUaWNrO1xuXHRcdC8qKlxuXHRcdCAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG5cdFx0ICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcblx0XHQgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIGV4cGVjdGVkJyk7XG5cdFx0ICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogQGV4YW1wbGUgYnl0ZXNUb1V0ZjgobmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKSkgLy8gJ2FiYydcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBieXRlc1RvVXRmOChieXRlcykge1xuXHRcdCAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cblx0XHQgKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cblx0XHQgKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG5cdFx0ICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG5cdFx0ICAgIGVsc2UgaWYgKCgwLCBfYXNzZXJ0X2pzXzEuaXNCeXRlcykoZGF0YSkpXG5cdFx0ICAgICAgICBkYXRhID0gY29weUJ5dGVzKGRhdGEpO1xuXHRcdCAgICBlbHNlXG5cdFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGRhdGEpO1xuXHRcdCAgICByZXR1cm4gZGF0YTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2tzIGlmIHR3byBVOEEgdXNlIHNhbWUgdW5kZXJseWluZyBidWZmZXIgYW5kIG92ZXJsYXBzICh3aWxsIGNvcnJ1cHQgYW5kIGJyZWFrIGlmIGlucHV0IGFuZCBvdXRwdXQgc2FtZSlcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBvdmVybGFwQnl0ZXMoYSwgYikge1xuXHRcdCAgICByZXR1cm4gKGEuYnVmZmVyID09PSBiLmJ1ZmZlciAmJiAvLyBwcm9iYWJseSB3aWxsIGZhaWwgd2l0aCBzb21lIG9ic2N1cmUgcHJveGllcywgYnV0IHRoaXMgaXMgYmVzdCB3ZSBjYW4gZG9cblx0XHQgICAgICAgIGEuYnl0ZU9mZnNldCA8IGIuYnl0ZU9mZnNldCArIGIuYnl0ZUxlbmd0aCAmJiAvLyBhIHN0YXJ0cyBiZWZvcmUgYiBlbmRcblx0XHQgICAgICAgIGIuYnl0ZU9mZnNldCA8IGEuYnl0ZU9mZnNldCArIGEuYnl0ZUxlbmd0aCAvLyBiIHN0YXJ0cyBiZWZvcmUgYSBlbmRcblx0XHQgICAgKTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogSWYgaW5wdXQgYW5kIG91dHB1dCBvdmVybGFwIGFuZCBpbnB1dCBzdGFydHMgYmVmb3JlIG91dHB1dCwgd2Ugd2lsbCBvdmVyd3JpdGUgZW5kIG9mIGlucHV0IGJlZm9yZVxuXHRcdCAqIHdlIHN0YXJ0IHByb2Nlc3NpbmcgaXQsIHNvIHRoaXMgaXMgbm90IHN1cHBvcnRlZCBmb3IgbW9zdCBjaXBoZXJzIChleGNlcHQgY2hhY2hhL3NhbHNlLCB3aGljaCBkZXNpZ25lZCB3aXRoIHRoaXMpXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gY29tcGxleE92ZXJsYXBCeXRlcyhpbnB1dCwgb3V0cHV0KSB7XG5cdFx0ICAgIC8vIFRoaXMgaXMgdmVyeSBjdXJzZWQuIEl0IHdvcmtzIHNvbWVob3csIGJ1dCBJJ20gY29tcGxldGVseSB1bnN1cmUsXG5cdFx0ICAgIC8vIHJlYXNvbmluZyBhYm91dCBvdmVybGFwcGluZyBhbGlnbmVkIHdpbmRvd3MgaXMgdmVyeSBoYXJkLlxuXHRcdCAgICBpZiAob3ZlcmxhcEJ5dGVzKGlucHV0LCBvdXRwdXQpICYmIGlucHV0LmJ5dGVPZmZzZXQgPCBvdXRwdXQuYnl0ZU9mZnNldClcblx0XHQgICAgICAgIHRocm93IG5ldyBFcnJvcignY29tcGxleCBvdmVybGFwIG9mIGlucHV0IGFuZCBvdXRwdXQgaXMgbm90IHN1cHBvcnRlZCcpO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcblx0XHQgICAgbGV0IHN1bSA9IDA7XG5cdFx0ICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuXHRcdCAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKGEpO1xuXHRcdCAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuXHRcdCAgICB9XG5cdFx0ICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG5cdFx0ICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuXHRcdCAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuXHRcdCAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiByZXM7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuXHRcdCAgICBpZiAob3B0cyA9PSBudWxsIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jylcblx0XHQgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGRlZmluZWQnKTtcblx0XHQgICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG5cdFx0ICAgIHJldHVybiBtZXJnZWQ7XG5cdFx0fVxuXHRcdC8vIENvbXBhcmVzIDIgdThhLXMgaW4ga2luZGEgY29uc3RhbnQgdGltZVxuXHRcdGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYSwgYikge1xuXHRcdCAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuXHRcdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICBsZXQgZGlmZiA9IDA7XG5cdFx0ICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcblx0XHQgICAgICAgIGRpZmYgfD0gYVtpXSBeIGJbaV07XG5cdFx0ICAgIHJldHVybiBkaWZmID09PSAwO1xuXHRcdH1cblx0XHQvLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuXHRcdGNsYXNzIEhhc2gge1xuXHRcdH1cblx0XHRleHBvcnRzLkhhc2ggPSBIYXNoO1xuXHRcdC8qKlxuXHRcdCAqIEBfX05PX1NJREVfRUZGRUNUU19fXG5cdFx0ICovXG5cdFx0Y29uc3Qgd3JhcENpcGhlciA9IChwYXJhbXMsIGNvbnN0cnVjdG9yKSA9PiB7XG5cdFx0ICAgIGZ1bmN0aW9uIHdyYXBwZWRDaXBoZXIoa2V5LCAuLi5hcmdzKSB7XG5cdFx0ICAgICAgICAvLyBWYWxpZGF0ZSBrZXlcblx0XHQgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJ5dGVzKShrZXkpO1xuXHRcdCAgICAgICAgLy8gVmFsaWRhdGUgbm9uY2UgaWYgbm9uY2VMZW5ndGggaXMgcHJlc2VudFxuXHRcdCAgICAgICAgaWYgKHBhcmFtcy5ub25jZUxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBhcmdzWzBdO1xuXHRcdCAgICAgICAgICAgIGlmICghbm9uY2UpXG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm9uY2UgLyBpdiByZXF1aXJlZCcpO1xuXHRcdCAgICAgICAgICAgIGlmIChwYXJhbXMudmFyU2l6ZU5vbmNlKVxuXHRcdCAgICAgICAgICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmFieXRlcykobm9uY2UpO1xuXHRcdCAgICAgICAgICAgIGVsc2Vcblx0XHQgICAgICAgICAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKG5vbmNlLCBwYXJhbXMubm9uY2VMZW5ndGgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLy8gVmFsaWRhdGUgQUFEIGlmIHRhZ0xlbmd0aCBwcmVzZW50XG5cdFx0ICAgICAgICBjb25zdCB0YWdsID0gcGFyYW1zLnRhZ0xlbmd0aDtcblx0XHQgICAgICAgIGlmICh0YWdsICYmIGFyZ3NbMV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJ5dGVzKShhcmdzWzFdKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IGNpcGhlciA9IGNvbnN0cnVjdG9yKGtleSwgLi4uYXJncyk7XG5cdFx0ICAgICAgICBjb25zdCBjaGVja091dHB1dCA9IChmbkxlbmd0aCwgb3V0cHV0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgaWYgKG91dHB1dCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChmbkxlbmd0aCAhPT0gMilcblx0XHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2lwaGVyIG91dHB1dCBub3Qgc3VwcG9ydGVkJyk7XG5cdFx0ICAgICAgICAgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJ5dGVzKShvdXRwdXQpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH07XG5cdFx0ICAgICAgICAvLyBDcmVhdGUgd3JhcHBlZCBjaXBoZXIgd2l0aCB2YWxpZGF0aW9uIGFuZCBzaW5nbGUtdXNlIGVuY3J5cHRpb25cblx0XHQgICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcblx0XHQgICAgICAgIGNvbnN0IHdyQ2lwaGVyID0ge1xuXHRcdCAgICAgICAgICAgIGVuY3J5cHQoZGF0YSwgb3V0cHV0KSB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpXG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBlbmNyeXB0KCkgdHdpY2Ugd2l0aCBzYW1lIGtleSArIG5vbmNlJyk7XG5cdFx0ICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJ5dGVzKShkYXRhKTtcblx0XHQgICAgICAgICAgICAgICAgY2hlY2tPdXRwdXQoY2lwaGVyLmVuY3J5cHQubGVuZ3RoLCBvdXRwdXQpO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gY2lwaGVyLmVuY3J5cHQoZGF0YSwgb3V0cHV0KTtcblx0XHQgICAgICAgICAgICB9LFxuXHRcdCAgICAgICAgICAgIGRlY3J5cHQoZGF0YSwgb3V0cHV0KSB7XG5cdFx0ICAgICAgICAgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJ5dGVzKShkYXRhKTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHRhZ2wgJiYgZGF0YS5sZW5ndGggPCB0YWdsKVxuXHRcdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgbGVuZ3RoOiBzbWFsbGVyIHRoYW4gdGFnTGVuZ3RoPScgKyB0YWdsKTtcblx0XHQgICAgICAgICAgICAgICAgY2hlY2tPdXRwdXQoY2lwaGVyLmRlY3J5cHQubGVuZ3RoLCBvdXRwdXQpO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gY2lwaGVyLmRlY3J5cHQoZGF0YSwgb3V0cHV0KTtcblx0XHQgICAgICAgICAgICB9LFxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgICAgIHJldHVybiB3ckNpcGhlcjtcblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuYXNzaWduKHdyYXBwZWRDaXBoZXIsIHBhcmFtcyk7XG5cdFx0ICAgIHJldHVybiB3cmFwcGVkQ2lwaGVyO1xuXHRcdH07XG5cdFx0ZXhwb3J0cy53cmFwQ2lwaGVyID0gd3JhcENpcGhlcjtcblx0XHRmdW5jdGlvbiBnZXRPdXRwdXQoZXhwZWN0ZWRMZW5ndGgsIG91dCwgb25seUFsaWduZWQgPSB0cnVlKSB7XG5cdFx0ICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZClcblx0XHQgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShleHBlY3RlZExlbmd0aCk7XG5cdFx0ICAgIGlmIChvdXQubGVuZ3RoICE9PSBleHBlY3RlZExlbmd0aClcblx0XHQgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBvdXRwdXQgbGVuZ3RoLCBleHBlY3RlZCAnICsgZXhwZWN0ZWRMZW5ndGggKyAnLCBnb3Q6ICcgKyBvdXQubGVuZ3RoKTtcblx0XHQgICAgaWYgKG9ubHlBbGlnbmVkICYmICFpc0FsaWduZWQzMihvdXQpKVxuXHRcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG91dHB1dCwgbXVzdCBiZSBhbGlnbmVkJyk7XG5cdFx0ICAgIHJldHVybiBvdXQ7XG5cdFx0fVxuXHRcdC8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcblx0XHRmdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcblx0XHQgICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcblx0XHQgICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG5cdFx0ICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuXHRcdCAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcblx0XHQgICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuXHRcdCAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcblx0XHQgICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcblx0XHQgICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcblx0XHQgICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcblx0XHQgICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gdTY0TGVuZ3RocyhjaXBoZXJ0ZXh0LCBBQUQpIHtcblx0XHQgICAgY29uc3QgbnVtID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXHRcdCAgICBjb25zdCB2aWV3ID0gKDAsIGV4cG9ydHMuY3JlYXRlVmlldykobnVtKTtcblx0XHQgICAgc2V0QmlnVWludDY0KHZpZXcsIDAsIEJpZ0ludChBQUQgPyBBQUQubGVuZ3RoIDogMCksIHRydWUpO1xuXHRcdCAgICBzZXRCaWdVaW50NjQodmlldywgOCwgQmlnSW50KGNpcGhlcnRleHQubGVuZ3RoKSwgdHJ1ZSk7XG5cdFx0ICAgIHJldHVybiBudW07XG5cdFx0fVxuXHRcdC8vIElzIGJ5dGUgYXJyYXkgYWxpZ25lZCB0byA0IGJ5dGUgb2Zmc2V0ICh1MzIpP1xuXHRcdGZ1bmN0aW9uIGlzQWxpZ25lZDMyKGJ5dGVzKSB7XG5cdFx0ICAgIHJldHVybiBieXRlcy5ieXRlT2Zmc2V0ICUgNCA9PT0gMDtcblx0XHR9XG5cdFx0Ly8gY29weSBieXRlcyB0byBuZXcgdThhIChhbGlnbmVkKS4gQmVjYXVzZSBCdWZmZXIuc2xpY2UgaXMgYnJva2VuLlxuXHRcdGZ1bmN0aW9uIGNvcHlCeXRlcyhieXRlcykge1xuXHRcdCAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGJ5dGVzKTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gY2xlYW4oLi4uYXJyYXlzKSB7XG5cdFx0ICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ICAgICAgICBhcnJheXNbaV0uZmlsbCgwKTtcblx0XHQgICAgfVxuXHRcdH1cblx0XHRcblx0fSAodXRpbHMkNSkpO1xuXHRyZXR1cm4gdXRpbHMkNTtcbn1cblxudmFyIGNvbmZpZyA9IHt9O1xuXG52YXIgY29uc3RzID0ge307XG5cbnZhciBoYXNSZXF1aXJlZENvbnN0cztcblxuZnVuY3Rpb24gcmVxdWlyZUNvbnN0cyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENvbnN0cykgcmV0dXJuIGNvbnN0cztcblx0aGFzUmVxdWlyZWRDb25zdHMgPSAxO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0Y29uc3RzLkFFQURfVEFHX0xFTkdUSCA9IGNvbnN0cy5YQ0hBQ0hBMjBfTk9OQ0VfTEVOR1RIID0gY29uc3RzLkNVUlZFMjU1MTlfUFVCTElDX0tFWV9TSVpFID0gY29uc3RzLkVUSF9QVUJMSUNfS0VZX1NJWkUgPSBjb25zdHMuVU5DT01QUkVTU0VEX1BVQkxJQ19LRVlfU0laRSA9IGNvbnN0cy5DT01QUkVTU0VEX1BVQkxJQ19LRVlfU0laRSA9IGNvbnN0cy5TRUNSRVRfS0VZX0xFTkdUSCA9IHZvaWQgMDtcblx0Ly8gZWxsaXB0aWNcblx0Y29uc3RzLlNFQ1JFVF9LRVlfTEVOR1RIID0gMzI7XG5cdGNvbnN0cy5DT01QUkVTU0VEX1BVQkxJQ19LRVlfU0laRSA9IDMzO1xuXHRjb25zdHMuVU5DT01QUkVTU0VEX1BVQkxJQ19LRVlfU0laRSA9IDY1O1xuXHRjb25zdHMuRVRIX1BVQkxJQ19LRVlfU0laRSA9IDY0O1xuXHRjb25zdHMuQ1VSVkUyNTUxOV9QVUJMSUNfS0VZX1NJWkUgPSAzMjtcblx0Ly8gc3ltbWV0cmljXG5cdGNvbnN0cy5YQ0hBQ0hBMjBfTk9OQ0VfTEVOR1RIID0gMjQ7XG5cdGNvbnN0cy5BRUFEX1RBR19MRU5HVEggPSAxNjtcblx0cmV0dXJuIGNvbnN0cztcbn1cblxudmFyIGhhc1JlcXVpcmVkQ29uZmlnO1xuXG5mdW5jdGlvbiByZXF1aXJlQ29uZmlnICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ29uZmlnKSByZXR1cm4gY29uZmlnO1xuXHRoYXNSZXF1aXJlZENvbmZpZyA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0XHRleHBvcnRzLmVwaGVtZXJhbEtleVNpemUgPSBleHBvcnRzLnN5bW1ldHJpY05vbmNlTGVuZ3RoID0gZXhwb3J0cy5zeW1tZXRyaWNBbGdvcml0aG0gPSBleHBvcnRzLmlzSGtkZktleUNvbXByZXNzZWQgPSBleHBvcnRzLmlzRXBoZW1lcmFsS2V5Q29tcHJlc3NlZCA9IGV4cG9ydHMuZWxsaXB0aWNDdXJ2ZSA9IGV4cG9ydHMuRUNJRVNfQ09ORklHID0gdm9pZCAwO1xuXHRcdHZhciBjb25zdHNfMSA9IHJlcXVpcmVDb25zdHMoKTtcblx0XHR2YXIgQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHRcdCAgICBmdW5jdGlvbiBDb25maWcoKSB7XG5cdFx0ICAgICAgICB0aGlzLmVsbGlwdGljQ3VydmUgPSBcInNlY3AyNTZrMVwiO1xuXHRcdCAgICAgICAgdGhpcy5pc0VwaGVtZXJhbEtleUNvbXByZXNzZWQgPSBmYWxzZTsgLy8gc2VjcDI1NmsxIG9ubHlcblx0XHQgICAgICAgIHRoaXMuaXNIa2RmS2V5Q29tcHJlc3NlZCA9IGZhbHNlOyAvLyBzZWNwMjU2azEgb25seVxuXHRcdCAgICAgICAgdGhpcy5zeW1tZXRyaWNBbGdvcml0aG0gPSBcImFlcy0yNTYtZ2NtXCI7XG5cdFx0ICAgICAgICB0aGlzLnN5bW1ldHJpY05vbmNlTGVuZ3RoID0gMTY7IC8vIGFlcy0yNTYtZ2NtIG9ubHlcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gQ29uZmlnO1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5FQ0lFU19DT05GSUcgPSBuZXcgQ29uZmlnKCk7XG5cdFx0dmFyIGVsbGlwdGljQ3VydmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBleHBvcnRzLkVDSUVTX0NPTkZJRy5lbGxpcHRpY0N1cnZlOyB9O1xuXHRcdGV4cG9ydHMuZWxsaXB0aWNDdXJ2ZSA9IGVsbGlwdGljQ3VydmU7XG5cdFx0dmFyIGlzRXBoZW1lcmFsS2V5Q29tcHJlc3NlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4cG9ydHMuRUNJRVNfQ09ORklHLmlzRXBoZW1lcmFsS2V5Q29tcHJlc3NlZDsgfTtcblx0XHRleHBvcnRzLmlzRXBoZW1lcmFsS2V5Q29tcHJlc3NlZCA9IGlzRXBoZW1lcmFsS2V5Q29tcHJlc3NlZDtcblx0XHR2YXIgaXNIa2RmS2V5Q29tcHJlc3NlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4cG9ydHMuRUNJRVNfQ09ORklHLmlzSGtkZktleUNvbXByZXNzZWQ7IH07XG5cdFx0ZXhwb3J0cy5pc0hrZGZLZXlDb21wcmVzc2VkID0gaXNIa2RmS2V5Q29tcHJlc3NlZDtcblx0XHR2YXIgc3ltbWV0cmljQWxnb3JpdGhtID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhwb3J0cy5FQ0lFU19DT05GSUcuc3ltbWV0cmljQWxnb3JpdGhtOyB9O1xuXHRcdGV4cG9ydHMuc3ltbWV0cmljQWxnb3JpdGhtID0gc3ltbWV0cmljQWxnb3JpdGhtO1xuXHRcdHZhciBzeW1tZXRyaWNOb25jZUxlbmd0aCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4cG9ydHMuRUNJRVNfQ09ORklHLnN5bW1ldHJpY05vbmNlTGVuZ3RoOyB9O1xuXHRcdGV4cG9ydHMuc3ltbWV0cmljTm9uY2VMZW5ndGggPSBzeW1tZXRyaWNOb25jZUxlbmd0aDtcblx0XHR2YXIgZXBoZW1lcmFsS2V5U2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgdmFyIG1hcHBpbmcgPSB7XG5cdFx0ICAgICAgICBzZWNwMjU2azE6IGV4cG9ydHMuRUNJRVNfQ09ORklHLmlzRXBoZW1lcmFsS2V5Q29tcHJlc3NlZFxuXHRcdCAgICAgICAgICAgID8gY29uc3RzXzEuQ09NUFJFU1NFRF9QVUJMSUNfS0VZX1NJWkVcblx0XHQgICAgICAgICAgICA6IGNvbnN0c18xLlVOQ09NUFJFU1NFRF9QVUJMSUNfS0VZX1NJWkUsXG5cdFx0ICAgICAgICB4MjU1MTk6IGNvbnN0c18xLkNVUlZFMjU1MTlfUFVCTElDX0tFWV9TSVpFLFxuXHRcdCAgICAgICAgZWQyNTUxOTogY29uc3RzXzEuQ1VSVkUyNTUxOV9QVUJMSUNfS0VZX1NJWkUsXG5cdFx0ICAgIH07XG5cdFx0ICAgIGlmIChleHBvcnRzLkVDSUVTX0NPTkZJRy5lbGxpcHRpY0N1cnZlIGluIG1hcHBpbmcpIHtcblx0XHQgICAgICAgIHJldHVybiBtYXBwaW5nW2V4cG9ydHMuRUNJRVNfQ09ORklHLmVsbGlwdGljQ3VydmVdO1xuXHRcdCAgICB9IC8qIHY4IGlnbm9yZSBuZXh0IDIgKi9cblx0XHQgICAgZWxzZSB7XG5cdFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG5cdFx0ICAgIH1cblx0XHR9O1xuXHRcdGV4cG9ydHMuZXBoZW1lcmFsS2V5U2l6ZSA9IGVwaGVtZXJhbEtleVNpemU7IFxuXHR9IChjb25maWcpKTtcblx0cmV0dXJuIGNvbmZpZztcbn1cblxudmFyIGtleXMgPSB7fTtcblxudmFyIFByaXZhdGVLZXkgPSB7fTtcblxudmFyIHV0aWxzJDQgPSB7fTtcblxudmFyIGVsbGlwdGljID0ge307XG5cbnZhciB3ZWJjcnlwdG8gPSB7fTtcblxudmFyIGNyeXB0byQyID0ge307XG5cbnZhciBoYXNSZXF1aXJlZENyeXB0byQxO1xuXG5mdW5jdGlvbiByZXF1aXJlQ3J5cHRvJDEgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRDcnlwdG8kMSkgcmV0dXJuIGNyeXB0byQyO1xuXHRoYXNSZXF1aXJlZENyeXB0byQxID0gMTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNyeXB0byQyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0Y3J5cHRvJDIuY3J5cHRvID0gdm9pZCAwO1xuXHRjcnlwdG8kMi5jcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuXHRcblx0cmV0dXJuIGNyeXB0byQyO1xufVxuXG52YXIgaGFzUmVxdWlyZWRXZWJjcnlwdG87XG5cbmZ1bmN0aW9uIHJlcXVpcmVXZWJjcnlwdG8gKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRXZWJjcnlwdG8pIHJldHVybiB3ZWJjcnlwdG87XG5cdGhhc1JlcXVpcmVkV2ViY3J5cHRvID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRcdGV4cG9ydHMuZ2NtID0gZXhwb3J0cy5jdHIgPSBleHBvcnRzLmNiYyA9IGV4cG9ydHMudXRpbHMgPSB2b2lkIDA7XG5cdFx0ZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuXHRcdGV4cG9ydHMuZ2V0V2ViY3J5cHRvU3VidGxlID0gZ2V0V2ViY3J5cHRvU3VidGxlO1xuXHRcdGV4cG9ydHMubWFuYWdlZE5vbmNlID0gbWFuYWdlZE5vbmNlO1xuXHRcdC8qKlxuXHRcdCAqIFdlYkNyeXB0by1iYXNlZCBBRVMgZ2NtL2N0ci9jYmMsIGBtYW5hZ2VkTm9uY2VgIGFuZCBgcmFuZG9tQnl0ZXNgLlxuXHRcdCAqIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuXHRcdCAqIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cblx0XHQgKiBGb3Igbm9kZS5qcywgcGFja2FnZS5qcyBvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG5cdFx0ICogZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cblx0XHQgKiBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cblx0XHQgKiBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuXHRcdCAqIEBtb2R1bGVcblx0XHQgKi9cblx0XHQvLyBVc2UgZnVsbCBwYXRoIHNvIHRoYXQgTm9kZS5qcyBjYW4gcmV3cml0ZSBpdCB0byBgY3J5cHRvTm9kZS5qc2AuXG5cdFx0Y29uc3QgY3J5cHRvXzEgPSByZXF1aXJlQ3J5cHRvJDEoKTtcblx0XHRjb25zdCBfYXNzZXJ0X2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVfYXNzZXJ0JDEoKTtcblx0XHRjb25zdCB1dGlsc19qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMkMygpO1xuXHRcdC8qKlxuXHRcdCAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcblx0XHQgICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdCAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBMZWdhY3kgTm9kZS5qcyBjb21wYXRpYmlsaXR5XG5cdFx0ICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdCAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by5yYW5kb21CeXRlcyhieXRlc0xlbmd0aCk7XG5cdFx0ICAgIH1cblx0XHQgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBnZXRXZWJjcnlwdG9TdWJ0bGUoKSB7XG5cdFx0ICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5zdWJ0bGUgPT09ICdvYmplY3QnICYmIGNyeXB0b18xLmNyeXB0by5zdWJ0bGUgIT0gbnVsbClcblx0XHQgICAgICAgIHJldHVybiBjcnlwdG9fMS5jcnlwdG8uc3VidGxlO1xuXHRcdCAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5zdWJ0bGUgbXVzdCBiZSBkZWZpbmVkJyk7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFVzZXMgQ1NQUkcgZm9yIG5vbmNlLCBub25jZSBpbmplY3RlZCBpbiBjaXBoZXJ0ZXh0LlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogY29uc3QgZ2NtID0gbWFuYWdlZE5vbmNlKGFlcy5nY20pO1xuXHRcdCAqIGNvbnN0IGNpcGhyID0gZ2NtKGtleSkuZW5jcnlwdChkYXRhKTtcblx0XHQgKiBjb25zdCBwbGFpbiA9IGdjbShrZXkpLmRlY3J5cHQoY2lwaCk7XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbWFuYWdlZE5vbmNlKGZuKSB7XG5cdFx0ICAgIGNvbnN0IHsgbm9uY2VMZW5ndGggfSA9IGZuO1xuXHRcdCAgICAoMCwgX2Fzc2VydF9qc18xLmFudW1iZXIpKG5vbmNlTGVuZ3RoKTtcblx0XHQgICAgcmV0dXJuICgoa2V5LCAuLi5hcmdzKSA9PiAoe1xuXHRcdCAgICAgICAgZW5jcnlwdChwbGFpbnRleHQsIC4uLmFyZ3NFbmMpIHtcblx0XHQgICAgICAgICAgICBjb25zdCBub25jZSA9IHJhbmRvbUJ5dGVzKG5vbmNlTGVuZ3RoKTtcblx0XHQgICAgICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gZm4oa2V5LCBub25jZSwgLi4uYXJncykuZW5jcnlwdChwbGFpbnRleHQsIC4uLmFyZ3NFbmMpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IG91dCA9ICgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKShub25jZSwgY2lwaGVydGV4dCk7XG5cdFx0ICAgICAgICAgICAgY2lwaGVydGV4dC5maWxsKDApO1xuXHRcdCAgICAgICAgICAgIHJldHVybiBvdXQ7XG5cdFx0ICAgICAgICB9LFxuXHRcdCAgICAgICAgZGVjcnlwdChjaXBoZXJ0ZXh0LCAuLi5hcmdzRGVjKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIG5vbmNlTGVuZ3RoKTtcblx0XHQgICAgICAgICAgICBjb25zdCBkYXRhID0gY2lwaGVydGV4dC5zdWJhcnJheShub25jZUxlbmd0aCk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZuKGtleSwgbm9uY2UsIC4uLmFyZ3MpLmRlY3J5cHQoZGF0YSwgLi4uYXJnc0RlYyk7XG5cdFx0ICAgICAgICB9LFxuXHRcdCAgICB9KSk7XG5cdFx0fVxuXHRcdC8vIE92ZXJyaWRhYmxlXG5cdFx0Ly8gQFRPRE9cblx0XHRleHBvcnRzLnV0aWxzID0ge1xuXHRcdCAgICBhc3luYyBlbmNyeXB0KGtleSwga2V5UGFyYW1zLCBjcnlwdFBhcmFtcywgcGxhaW50ZXh0KSB7XG5cdFx0ICAgICAgICBjb25zdCBjciA9IGdldFdlYmNyeXB0b1N1YnRsZSgpO1xuXHRcdCAgICAgICAgY29uc3QgaUtleSA9IGF3YWl0IGNyLmltcG9ydEtleSgncmF3Jywga2V5LCBrZXlQYXJhbXMsIHRydWUsIFsnZW5jcnlwdCddKTtcblx0XHQgICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBhd2FpdCBjci5lbmNyeXB0KGNyeXB0UGFyYW1zLCBpS2V5LCBwbGFpbnRleHQpO1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQpO1xuXHRcdCAgICB9LFxuXHRcdCAgICBhc3luYyBkZWNyeXB0KGtleSwga2V5UGFyYW1zLCBjcnlwdFBhcmFtcywgY2lwaGVydGV4dCkge1xuXHRcdCAgICAgICAgY29uc3QgY3IgPSBnZXRXZWJjcnlwdG9TdWJ0bGUoKTtcblx0XHQgICAgICAgIGNvbnN0IGlLZXkgPSBhd2FpdCBjci5pbXBvcnRLZXkoJ3JhdycsIGtleSwga2V5UGFyYW1zLCB0cnVlLCBbJ2RlY3J5cHQnXSk7XG5cdFx0ICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBhd2FpdCBjci5kZWNyeXB0KGNyeXB0UGFyYW1zLCBpS2V5LCBjaXBoZXJ0ZXh0KTtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShwbGFpbnRleHQpO1xuXHRcdCAgICB9LFxuXHRcdH07XG5cdFx0Y29uc3QgbW9kZSA9IHtcblx0XHQgICAgQ0JDOiAnQUVTLUNCQycsXG5cdFx0ICAgIENUUjogJ0FFUy1DVFInLFxuXHRcdCAgICBHQ006ICdBRVMtR0NNJyxcblx0XHR9O1xuXHRcdGZ1bmN0aW9uIGdldENyeXB0UGFyYW1zKGFsZ28sIG5vbmNlLCBBQUQpIHtcblx0XHQgICAgaWYgKGFsZ28gPT09IG1vZGUuQ0JDKVxuXHRcdCAgICAgICAgcmV0dXJuIHsgbmFtZTogbW9kZS5DQkMsIGl2OiBub25jZSB9O1xuXHRcdCAgICBpZiAoYWxnbyA9PT0gbW9kZS5DVFIpXG5cdFx0ICAgICAgICByZXR1cm4geyBuYW1lOiBtb2RlLkNUUiwgY291bnRlcjogbm9uY2UsIGxlbmd0aDogNjQgfTtcblx0XHQgICAgaWYgKGFsZ28gPT09IG1vZGUuR0NNKSB7XG5cdFx0ICAgICAgICBpZiAoQUFEKVxuXHRcdCAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IG1vZGUuR0NNLCBpdjogbm9uY2UsIGFkZGl0aW9uYWxEYXRhOiBBQUQgfTtcblx0XHQgICAgICAgIGVsc2Vcblx0XHQgICAgICAgICAgICByZXR1cm4geyBuYW1lOiBtb2RlLkdDTSwgaXY6IG5vbmNlIH07XG5cdFx0ICAgIH1cblx0XHQgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGFlcyBibG9jayBtb2RlJyk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlKGFsZ28pIHtcblx0XHQgICAgcmV0dXJuIChrZXksIG5vbmNlLCBBQUQpID0+IHtcblx0XHQgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJ5dGVzKShrZXkpO1xuXHRcdCAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKG5vbmNlKTtcblx0XHQgICAgICAgIGNvbnN0IGtleVBhcmFtcyA9IHsgbmFtZTogYWxnbywgbGVuZ3RoOiBrZXkubGVuZ3RoICogOCB9O1xuXHRcdCAgICAgICAgY29uc3QgY3J5cHRQYXJhbXMgPSBnZXRDcnlwdFBhcmFtcyhhbGdvLCBub25jZSwgQUFEKTtcblx0XHQgICAgICAgIGxldCBjb25zdW1lZCA9IGZhbHNlO1xuXHRcdCAgICAgICAgcmV0dXJuIHtcblx0XHQgICAgICAgICAgICAvLyBrZXlMZW5ndGgsXG5cdFx0ICAgICAgICAgICAgZW5jcnlwdChwbGFpbnRleHQpIHtcblx0XHQgICAgICAgICAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKHBsYWludGV4dCk7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChjb25zdW1lZClcblx0XHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQoKSB0d2ljZSB3aXRoIHNhbWUga2V5IC8gbm9uY2UnKTtcblx0XHQgICAgICAgICAgICAgICAgY29uc3VtZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy51dGlscy5lbmNyeXB0KGtleSwga2V5UGFyYW1zLCBjcnlwdFBhcmFtcywgcGxhaW50ZXh0KTtcblx0XHQgICAgICAgICAgICB9LFxuXHRcdCAgICAgICAgICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuXHRcdCAgICAgICAgICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmFieXRlcykoY2lwaGVydGV4dCk7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLnV0aWxzLmRlY3J5cHQoa2V5LCBrZXlQYXJhbXMsIGNyeXB0UGFyYW1zLCBjaXBoZXJ0ZXh0KTtcblx0XHQgICAgICAgICAgICB9LFxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgfTtcblx0XHR9XG5cdFx0LyoqIEFFUy1DQkMsIG5hdGl2ZSB3ZWJjcnlwdG8gdmVyc2lvbiAqL1xuXHRcdGV4cG9ydHMuY2JjID0gKCgpID0+IGdlbmVyYXRlKG1vZGUuQ0JDKSkoKTtcblx0XHQvKiogQUVTLUNUUiwgbmF0aXZlIHdlYmNyeXB0byB2ZXJzaW9uICovXG5cdFx0ZXhwb3J0cy5jdHIgPSAoKCkgPT4gZ2VuZXJhdGUobW9kZS5DVFIpKSgpO1xuXHRcdC8qKiBBRVMtR0NNLCBuYXRpdmUgd2ViY3J5cHRvIHZlcnNpb24gKi9cblx0XHRleHBvcnRzLmdjbSA9IFxuXHRcdC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuZXJhdGUobW9kZS5HQ00pKSgpO1xuXHRcdC8vIC8vIFR5cGUgdGVzdHNcblx0XHQvLyBpbXBvcnQgeyBzaXYsIGdjbSwgY3RyLCBlY2IsIGNiYyB9IGZyb20gJy4uL2Flcy5qcyc7XG5cdFx0Ly8gaW1wb3J0IHsgeHNhbHNhMjBwb2x5MTMwNSB9IGZyb20gJy4uL3NhbHNhLmpzJztcblx0XHQvLyBpbXBvcnQgeyBjaGFjaGEyMHBvbHkxMzA1LCB4Y2hhY2hhMjBwb2x5MTMwNSB9IGZyb20gJy4uL2NoYWNoYS5qcyc7XG5cdFx0Ly8gY29uc3Qgd3NpdiA9IG1hbmFnZWROb25jZShzaXYpO1xuXHRcdC8vIGNvbnN0IHdnY20gPSBtYW5hZ2VkTm9uY2UoZ2NtKTtcblx0XHQvLyBjb25zdCB3Y3RyID0gbWFuYWdlZE5vbmNlKGN0cik7XG5cdFx0Ly8gY29uc3Qgd2NiYyA9IG1hbmFnZWROb25jZShjYmMpO1xuXHRcdC8vIGNvbnN0IHdzYWxzYXBvbHkgPSBtYW5hZ2VkTm9uY2UoeHNhbHNhMjBwb2x5MTMwNSk7XG5cdFx0Ly8gY29uc3Qgd2NoYWNoYSA9IG1hbmFnZWROb25jZShjaGFjaGEyMHBvbHkxMzA1KTtcblx0XHQvLyBjb25zdCB3eGNoYWNoYSA9IG1hbmFnZWROb25jZSh4Y2hhY2hhMjBwb2x5MTMwNSk7XG5cdFx0Ly8gLy8gc2hvdWxkIGZhaWxcblx0XHQvLyBjb25zdCB3Y2JjMiA9IG1hbmFnZWROb25jZShtYW5hZ2VkTm9uY2UoY2JjKSk7XG5cdFx0Ly8gY29uc3Qgd2N0ciA9IG1hbmFnZWROb25jZShjdHIpO1xuXHRcdFxuXHR9ICh3ZWJjcnlwdG8pKTtcblx0cmV0dXJuIHdlYmNyeXB0bztcbn1cblxudmFyIGVkMjU1MTkgPSB7fTtcblxudmFyIHNoYTUxMiA9IHt9O1xuXG52YXIgX21kID0ge307XG5cbnZhciBfYXNzZXJ0ID0ge307XG5cbnZhciBoYXNSZXF1aXJlZF9hc3NlcnQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfYXNzZXJ0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2Fzc2VydCkgcmV0dXJuIF9hc3NlcnQ7XG5cdGhhc1JlcXVpcmVkX2Fzc2VydCA9IDE7XG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBhc3NlcnRpb24gaGVscGVycy5cblx0ICogQG1vZHVsZVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRfYXNzZXJ0LmFudW1iZXIgPSBhbnVtYmVyO1xuXHRfYXNzZXJ0LmFieXRlcyA9IGFieXRlcztcblx0X2Fzc2VydC5haGFzaCA9IGFoYXNoO1xuXHRfYXNzZXJ0LmFleGlzdHMgPSBhZXhpc3RzO1xuXHRfYXNzZXJ0LmFvdXRwdXQgPSBhb3V0cHV0O1xuXHQvKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgcG9zaXRpdmUgaW50ZWdlci4gKi9cblx0ZnVuY3Rpb24gYW51bWJlcihuKSB7XG5cdCAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9zaXRpdmUgaW50ZWdlciBleHBlY3RlZCwgZ290ICcgKyBuKTtcblx0fVxuXHQvKiogSXMgbnVtYmVyIGFuIFVpbnQ4QXJyYXk/IENvcGllZCBmcm9tIHV0aWxzIGZvciBwZXJmLiAqL1xuXHRmdW5jdGlvbiBpc0J5dGVzKGEpIHtcblx0ICAgIHJldHVybiBhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKTtcblx0fVxuXHQvKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gKi9cblx0ZnVuY3Rpb24gYWJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcblx0ICAgIGlmICghaXNCeXRlcyhiKSlcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcblx0ICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggJyArIGxlbmd0aHMgKyAnLCBnb3QgbGVuZ3RoPScgKyBiLmxlbmd0aCk7XG5cdH1cblx0LyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIGhhc2ggKi9cblx0ZnVuY3Rpb24gYWhhc2goaCkge1xuXHQgICAgaWYgKHR5cGVvZiBoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG5cdCAgICBhbnVtYmVyKGgub3V0cHV0TGVuKTtcblx0ICAgIGFudW1iZXIoaC5ibG9ja0xlbik7XG5cdH1cblx0LyoqIEFzc2VydHMgYSBoYXNoIGluc3RhbmNlIGhhcyBub3QgYmVlbiBkZXN0cm95ZWQgLyBmaW5pc2hlZCAqL1xuXHRmdW5jdGlvbiBhZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuXHQgICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG5cdCAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcblx0fVxuXHQvKiogQXNzZXJ0cyBvdXRwdXQgaXMgcHJvcGVybHktc2l6ZWQgYnl0ZSBhcnJheSAqL1xuXHRmdW5jdGlvbiBhb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcblx0ICAgIGFieXRlcyhvdXQpO1xuXHQgICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuXHQgICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICcgKyBtaW4pO1xuXHQgICAgfVxuXHR9XG5cdFxuXHRyZXR1cm4gX2Fzc2VydDtcbn1cblxudmFyIHV0aWxzJDMgPSB7fTtcblxudmFyIGNyeXB0byQxID0ge307XG5cbnZhciBoYXNSZXF1aXJlZENyeXB0bztcblxuZnVuY3Rpb24gcmVxdWlyZUNyeXB0byAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENyeXB0bykgcmV0dXJuIGNyeXB0byQxO1xuXHRoYXNSZXF1aXJlZENyeXB0byA9IDE7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcnlwdG8kMSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGNyeXB0byQxLmNyeXB0byA9IHZvaWQgMDtcblx0Y3J5cHRvJDEuY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcblx0XG5cdHJldHVybiBjcnlwdG8kMTtcbn1cblxudmFyIGhhc1JlcXVpcmVkVXRpbHMkMjtcblxuZnVuY3Rpb24gcmVxdWlyZVV0aWxzJDIgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRVdGlscyQyKSByZXR1cm4gdXRpbHMkMztcblx0aGFzUmVxdWlyZWRVdGlscyQyID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0LyoqXG5cdFx0ICogVXRpbGl0aWVzIGZvciBoZXgsIGJ5dGVzLCBDU1BSTkcuXG5cdFx0ICogQG1vZHVsZVxuXHRcdCAqL1xuXHRcdC8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0ZXhwb3J0cy5IYXNoID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuYnl0ZVN3YXBJZkJFID0gZXhwb3J0cy5pc0xFID0gdm9pZCAwO1xuXHRcdGV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG5cdFx0ZXhwb3J0cy51OCA9IHU4O1xuXHRcdGV4cG9ydHMudTMyID0gdTMyO1xuXHRcdGV4cG9ydHMuY3JlYXRlVmlldyA9IGNyZWF0ZVZpZXc7XG5cdFx0ZXhwb3J0cy5yb3RyID0gcm90cjtcblx0XHRleHBvcnRzLnJvdGwgPSByb3RsO1xuXHRcdGV4cG9ydHMuYnl0ZVN3YXAgPSBieXRlU3dhcDtcblx0XHRleHBvcnRzLmJ5dGVTd2FwMzIgPSBieXRlU3dhcDMyO1xuXHRcdGV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG5cdFx0ZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcblx0XHRleHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcblx0XHRleHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG5cdFx0ZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcblx0XHRleHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG5cdFx0ZXhwb3J0cy5jaGVja09wdHMgPSBjaGVja09wdHM7XG5cdFx0ZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSB3cmFwQ29uc3RydWN0b3I7XG5cdFx0ZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzO1xuXHRcdGV4cG9ydHMud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMgPSB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cztcblx0XHRleHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG5cdFx0Ly8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG5cdFx0Ly8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuXHRcdC8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuXHRcdC8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG5cdFx0Ly8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG5cdFx0Ly8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5cdFx0Y29uc3QgY3J5cHRvXzEgPSByZXF1aXJlQ3J5cHRvKCk7XG5cdFx0Y29uc3QgX2Fzc2VydF9qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlX2Fzc2VydCgpO1xuXHRcdC8vIGV4cG9ydCB7IGlzQnl0ZXMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuXHRcdC8vIFdlIGNhbid0IHJldXNlIGlzQnl0ZXMgZnJvbSBfYXNzZXJ0LCBiZWNhdXNlIHNvbWVob3cgdGhpcyBjYXVzZXMgaHVnZSBwZXJmIGlzc3Vlc1xuXHRcdGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuXHRcdCAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG5cdFx0fVxuXHRcdC8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcblx0XHRmdW5jdGlvbiB1OChhcnIpIHtcblx0XHQgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHUzMihhcnIpIHtcblx0XHQgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcblx0XHR9XG5cdFx0Ly8gQ2FzdCBhcnJheSB0byB2aWV3XG5cdFx0ZnVuY3Rpb24gY3JlYXRlVmlldyhhcnIpIHtcblx0XHQgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuXHRcdH1cblx0XHQvKiogVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5cdFx0ZnVuY3Rpb24gcm90cih3b3JkLCBzaGlmdCkge1xuXHRcdCAgICByZXR1cm4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG5cdFx0fVxuXHRcdC8qKiBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5cdFx0ZnVuY3Rpb24gcm90bCh3b3JkLCBzaGlmdCkge1xuXHRcdCAgICByZXR1cm4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcblx0XHR9XG5cdFx0LyoqIElzIGN1cnJlbnQgcGxhdGZvcm0gbGl0dGxlLWVuZGlhbj8gTW9zdCBhcmUuIEJpZy1FbmRpYW4gcGxhdGZvcm06IElCTSAqL1xuXHRcdGV4cG9ydHMuaXNMRSA9ICgoKSA9PiBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0KSgpO1xuXHRcdC8vIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzJcblx0XHRmdW5jdGlvbiBieXRlU3dhcCh3b3JkKSB7XG5cdFx0ICAgIHJldHVybiAoKCh3b3JkIDw8IDI0KSAmIDB4ZmYwMDAwMDApIHxcblx0XHQgICAgICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG5cdFx0ICAgICAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG5cdFx0ICAgICAgICAoKHdvcmQgPj4+IDI0KSAmIDB4ZmYpKTtcblx0XHR9XG5cdFx0LyoqIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybSAqL1xuXHRcdGV4cG9ydHMuYnl0ZVN3YXBJZkJFID0gZXhwb3J0cy5pc0xFXG5cdFx0ICAgID8gKG4pID0+IG5cblx0XHQgICAgOiAobikgPT4gYnl0ZVN3YXAobik7XG5cdFx0LyoqIEluIHBsYWNlIGJ5dGUgc3dhcCBmb3IgVWludDMyQXJyYXkgKi9cblx0XHRmdW5jdGlvbiBieXRlU3dhcDMyKGFycikge1xuXHRcdCAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdCAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcblx0XHQgICAgfVxuXHRcdH1cblx0XHQvLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuXHRcdGNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG5cdFx0LyoqXG5cdFx0ICogQ29udmVydCBieXRlIGFycmF5IHRvIGhleCBzdHJpbmcuXG5cdFx0ICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcblx0XHQgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKGJ5dGVzKTtcblx0XHQgICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG5cdFx0ICAgIGxldCBoZXggPSAnJztcblx0XHQgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdCAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gaGV4O1xuXHRcdH1cblx0XHQvLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuXHRcdGNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9O1xuXHRcdGZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2gpIHtcblx0XHQgICAgaWYgKGNoID49IGFzY2lpcy5fMCAmJiBjaCA8PSBhc2NpaXMuXzkpXG5cdFx0ICAgICAgICByZXR1cm4gY2ggLSBhc2NpaXMuXzA7IC8vICcyJyA9PiA1MC00OFxuXHRcdCAgICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpXG5cdFx0ICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLkEgLSAxMCk7IC8vICdCJyA9PiA2Ni0oNjUtMTApXG5cdFx0ICAgIGlmIChjaCA+PSBhc2NpaXMuYSAmJiBjaCA8PSBhc2NpaXMuZilcblx0XHQgICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcblx0XHQgICAgcmV0dXJuO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBDb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheS5cblx0XHQgKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuXHRcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuXHRcdCAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG5cdFx0ICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuXHRcdCAgICBpZiAoaGwgJSAyKVxuXHRcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuXHRcdCAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcblx0XHQgICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcblx0XHQgICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuXHRcdCAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuXHRcdCAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yOyAvLyBtdWx0aXBseSBmaXJzdCBvY3RldCwgZS5nLiAnYTMnID0+IDEwKjE2KzMgPT4gMTYwICsgMyA9PiAxNjNcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gYXJyYXk7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG5cdFx0ICogQ2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG5cdFx0ICogbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuXHRcdCAqL1xuXHRcdGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuXHRcdGV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcblx0XHQvKiogUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZy4gKi9cblx0XHRhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG5cdFx0ICAgIGxldCB0cyA9IERhdGUubm93KCk7XG5cdFx0ICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuXHRcdCAgICAgICAgY2IoaSk7XG5cdFx0ICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuXHRcdCAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcblx0XHQgICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG5cdFx0ICAgICAgICAgICAgY29udGludWU7XG5cdFx0ICAgICAgICBhd2FpdCAoMCwgZXhwb3J0cy5uZXh0VGljaykoKTtcblx0XHQgICAgICAgIHRzICs9IGRpZmY7XG5cdFx0ICAgIH1cblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogQ29udmVydCBKUyBzdHJpbmcgdG8gYnl0ZSBhcnJheS5cblx0XHQgKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuXHRcdCAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG5cdFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3V0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICcgKyB0eXBlb2Ygc3RyKTtcblx0XHQgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxuXHRcdH1cblx0XHQvKipcblx0XHQgKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuXHRcdCAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuXHRcdCAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcblx0XHQgICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcblx0XHQgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKGRhdGEpO1xuXHRcdCAgICByZXR1cm4gZGF0YTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG5cdFx0ICAgIGxldCBzdW0gPSAwO1xuXHRcdCAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuXHRcdCAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcblx0XHQgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJ5dGVzKShhKTtcblx0XHQgICAgICAgIHN1bSArPSBhLmxlbmd0aDtcblx0XHQgICAgfVxuXHRcdCAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuXHRcdCAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuXHRcdCAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcblx0XHQgICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcblx0XHQgICAgICAgIHBhZCArPSBhLmxlbmd0aDtcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gcmVzO1xuXHRcdH1cblx0XHQvKiogRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2UgKi9cblx0XHRjbGFzcyBIYXNoIHtcblx0XHQgICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG5cdFx0ICAgIGNsb25lKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuXHRcdCAgICB9XG5cdFx0fVxuXHRcdGV4cG9ydHMuSGFzaCA9IEhhc2g7XG5cdFx0ZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG5cdFx0ICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYge30udG9TdHJpbmcuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG5cdFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcblx0XHQgICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG5cdFx0ICAgIHJldHVybiBtZXJnZWQ7XG5cdFx0fVxuXHRcdC8qKiBXcmFwcyBoYXNoIGZ1bmN0aW9uLCBjcmVhdGluZyBhbiBpbnRlcmZhY2Ugb24gdG9wIG9mIGl0ICovXG5cdFx0ZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG5cdFx0ICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcblx0XHQgICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcblx0XHQgICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcblx0XHQgICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG5cdFx0ICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG5cdFx0ICAgIHJldHVybiBoYXNoQztcblx0XHR9XG5cdFx0ZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcblx0XHQgICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcblx0XHQgICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuXHRcdCAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuXHRcdCAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcblx0XHQgICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuXHRcdCAgICByZXR1cm4gaGFzaEM7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG5cdFx0ICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG5cdFx0ICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcblx0XHQgICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcblx0XHQgICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG5cdFx0ICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcblx0XHQgICAgcmV0dXJuIGhhc2hDO1xuXHRcdH1cblx0XHQvKiogQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIFBSTkcuIFVzZXMgaW50ZXJuYWwgT1MtbGV2ZWwgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLiAqL1xuXHRcdGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcblx0XHQgICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdCAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBMZWdhY3kgTm9kZS5qcyBjb21wYXRpYmlsaXR5XG5cdFx0ICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdCAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by5yYW5kb21CeXRlcyhieXRlc0xlbmd0aCk7XG5cdFx0ICAgIH1cblx0XHQgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xuXHRcdH1cblx0XHRcblx0fSAodXRpbHMkMykpO1xuXHRyZXR1cm4gdXRpbHMkMztcbn1cblxudmFyIGhhc1JlcXVpcmVkX21kO1xuXG5mdW5jdGlvbiByZXF1aXJlX21kICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX21kKSByZXR1cm4gX21kO1xuXHRoYXNSZXF1aXJlZF9tZCA9IDE7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfbWQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRfbWQuSGFzaE1EID0gdm9pZCAwO1xuXHRfbWQuc2V0QmlnVWludDY0ID0gc2V0QmlnVWludDY0O1xuXHRfbWQuQ2hpID0gQ2hpO1xuXHRfbWQuTWFqID0gTWFqO1xuXHQvKipcblx0ICogSW50ZXJuYWwgTWVya2xlLURhbWdhcmQgaGFzaCB1dGlscy5cblx0ICogQG1vZHVsZVxuXHQgKi9cblx0Y29uc3QgX2Fzc2VydF9qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlX2Fzc2VydCgpO1xuXHRjb25zdCB1dGlsc19qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMkMigpO1xuXHQvKiogUG9seWZpbGwgZm9yIFNhZmFyaSAxNC4gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc19kYXRhdmlld19zZXRiaWd1aW50NjQgKi9cblx0ZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG5cdCAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuXHQgICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG5cdCAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcblx0ICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuXHQgICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuXHQgICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG5cdCAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuXHQgICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcblx0ICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG5cdCAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xuXHR9XG5cdC8qKiBDaG9pY2U6IGEgPyBiIDogYyAqL1xuXHRmdW5jdGlvbiBDaGkoYSwgYiwgYykge1xuXHQgICAgcmV0dXJuIChhICYgYikgXiAofmEgJiBjKTtcblx0fVxuXHQvKiogTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1dHMgaXMgdHJ1ZS4gKi9cblx0ZnVuY3Rpb24gTWFqKGEsIGIsIGMpIHtcblx0ICAgIHJldHVybiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG5cdH1cblx0LyoqXG5cdCAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG5cdCAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuXHQgKi9cblx0Y2xhc3MgSGFzaE1EIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcblx0ICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuXHQgICAgICAgIHN1cGVyKCk7XG5cdCAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuXHQgICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuXHQgICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuXHQgICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG5cdCAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMubGVuZ3RoID0gMDtcblx0ICAgICAgICB0aGlzLnBvcyA9IDA7XG5cdCAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblx0ICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcblx0ICAgICAgICB0aGlzLnZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KSh0aGlzLmJ1ZmZlcik7XG5cdCAgICB9XG5cdCAgICB1cGRhdGUoZGF0YSkge1xuXHQgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWV4aXN0cykodGhpcyk7XG5cdCAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuXHQgICAgICAgIGRhdGEgPSAoMCwgdXRpbHNfanNfMS50b0J5dGVzKShkYXRhKTtcblx0ICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcblx0ICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG5cdCAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuXHQgICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3Ncblx0ICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKGRhdGEpO1xuXHQgICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG5cdCAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG5cdCAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG5cdCAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdCAgICBkaWdlc3RJbnRvKG91dCkge1xuXHQgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWV4aXN0cykodGhpcyk7XG5cdCAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hb3V0cHV0KShvdXQsIHRoaXMpO1xuXHQgICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuXHQgICAgICAgIC8vIFBhZGRpbmdcblx0ICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuXHQgICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cblx0ICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG5cdCAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuXHQgICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuXHQgICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuXHQgICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcblx0ICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG5cdCAgICAgICAgLy8gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cblx0ICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG5cdCAgICAgICAgICAgIHBvcyA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuXHQgICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuXHQgICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuXHQgICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuXHQgICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuXHQgICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cblx0ICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG5cdCAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuXHQgICAgICAgIGNvbnN0IG92aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykob3V0KTtcblx0ICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcblx0ICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuXHQgICAgICAgIGlmIChsZW4gJSA0KVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcblx0ICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuXHQgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcblx0ICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuXHQgICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcblx0ICAgIH1cblx0ICAgIGRpZ2VzdCgpIHtcblx0ICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuXHQgICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuXHQgICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuXHQgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuXHQgICAgICAgIHJldHVybiByZXM7XG5cdCAgICB9XG5cdCAgICBfY2xvbmVJbnRvKHRvKSB7XG5cdCAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG5cdCAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuXHQgICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG5cdCAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuXHQgICAgICAgIHRvLnBvcyA9IHBvcztcblx0ICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuXHQgICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcblx0ICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG5cdCAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcblx0ICAgICAgICByZXR1cm4gdG87XG5cdCAgICB9XG5cdH1cblx0X21kLkhhc2hNRCA9IEhhc2hNRDtcblx0XG5cdHJldHVybiBfbWQ7XG59XG5cbnZhciBfdTY0ID0ge307XG5cbnZhciBoYXNSZXF1aXJlZF91NjQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfdTY0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX3U2NCkgcmV0dXJuIF91NjQ7XG5cdGhhc1JlcXVpcmVkX3U2NCA9IDE7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdTY0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0X3U2NC5hZGQ1TCA9IF91NjQuYWRkNUggPSBfdTY0LmFkZDRIID0gX3U2NC5hZGQ0TCA9IF91NjQuYWRkM0ggPSBfdTY0LmFkZDNMID0gX3U2NC5yb3RsQkwgPSBfdTY0LnJvdGxCSCA9IF91NjQucm90bFNMID0gX3U2NC5yb3RsU0ggPSBfdTY0LnJvdHIzMkwgPSBfdTY0LnJvdHIzMkggPSBfdTY0LnJvdHJCTCA9IF91NjQucm90ckJIID0gX3U2NC5yb3RyU0wgPSBfdTY0LnJvdHJTSCA9IF91NjQuc2hyU0wgPSBfdTY0LnNoclNIID0gX3U2NC50b0JpZyA9IHZvaWQgMDtcblx0X3U2NC5mcm9tQmlnID0gZnJvbUJpZztcblx0X3U2NC5zcGxpdCA9IHNwbGl0O1xuXHRfdTY0LmFkZCA9IGFkZDtcblx0LyoqXG5cdCAqIEludGVybmFsIGhlbHBlcnMgZm9yIHU2NC4gQmlnVWludDY0QXJyYXkgaXMgdG9vIHNsb3cgYXMgcGVyIDIwMjUsIHNvIHdlIGltcGxlbWVudCBpdCB1c2luZyBVaW50MzJBcnJheS5cblx0ICogQHRvZG8gcmUtY2hlY2sgaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MjIxMjU4OFxuXHQgKiBAbW9kdWxlXG5cdCAqL1xuXHRjb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5cdGNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcblx0ZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG5cdCAgICBpZiAobGUpXG5cdCAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcblx0ICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcblx0fVxuXHRmdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcblx0ICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcblx0ICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcblx0ICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuXHQgICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFtBaCwgQWxdO1xuXHR9XG5cdGNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG5cdF91NjQudG9CaWcgPSB0b0JpZztcblx0Ly8gZm9yIFNoaWZ0IGluIFswLCAzMilcblx0Y29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5cdF91NjQuc2hyU0ggPSBzaHJTSDtcblx0Y29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuXHRfdTY0LnNoclNMID0gc2hyU0w7XG5cdC8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuXHRjb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuXHRfdTY0LnJvdHJTSCA9IHJvdHJTSDtcblx0Y29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcblx0X3U2NC5yb3RyU0wgPSByb3RyU0w7XG5cdC8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cblx0Y29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5cdF91NjQucm90ckJIID0gcm90ckJIO1xuXHRjb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcblx0X3U2NC5yb3RyQkwgPSByb3RyQkw7XG5cdC8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5cdGNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5cdF91NjQucm90cjMySCA9IHJvdHIzMkg7XG5cdGNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG5cdF91NjQucm90cjMyTCA9IHJvdHIzMkw7XG5cdC8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5cdGNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5cdF91NjQucm90bFNIID0gcm90bFNIO1xuXHRjb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuXHRfdTY0LnJvdGxTTCA9IHJvdGxTTDtcblx0Ly8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5cdGNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuXHRfdTY0LnJvdGxCSCA9IHJvdGxCSDtcblx0Y29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG5cdF91NjQucm90bEJMID0gcm90bEJMO1xuXHQvLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcblx0Ly8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cblx0ZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG5cdCAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG5cdCAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcblx0fVxuXHQvLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5cdGNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcblx0X3U2NC5hZGQzTCA9IGFkZDNMO1xuXHRjb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcblx0X3U2NC5hZGQzSCA9IGFkZDNIO1xuXHRjb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcblx0X3U2NC5hZGQ0TCA9IGFkZDRMO1xuXHRjb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcblx0X3U2NC5hZGQ0SCA9IGFkZDRIO1xuXHRjb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuXHRfdTY0LmFkZDVMID0gYWRkNUw7XG5cdGNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuXHRfdTY0LmFkZDVIID0gYWRkNUg7XG5cdC8vIHByZXR0aWVyLWlnbm9yZVxuXHRjb25zdCB1NjQgPSB7XG5cdCAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXG5cdCAgICBzaHJTSCwgc2hyU0wsXG5cdCAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG5cdCAgICByb3RyMzJILCByb3RyMzJMLFxuXHQgICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuXHQgICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxuXHR9O1xuXHRfdTY0LmRlZmF1bHQgPSB1NjQ7XG5cdFxuXHRyZXR1cm4gX3U2NDtcbn1cblxudmFyIGhhc1JlcXVpcmVkU2hhNTEyO1xuXG5mdW5jdGlvbiByZXF1aXJlU2hhNTEyICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkU2hhNTEyKSByZXR1cm4gc2hhNTEyO1xuXHRoYXNSZXF1aXJlZFNoYTUxMiA9IDE7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaGE1MTIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRzaGE1MTIuc2hhMzg0ID0gc2hhNTEyLnNoYTUxMl8yNTYgPSBzaGE1MTIuc2hhNTEyXzIyNCA9IHNoYTUxMi5zaGE1MTIgPSBzaGE1MTIuU0hBMzg0ID0gc2hhNTEyLlNIQTUxMl8yNTYgPSBzaGE1MTIuU0hBNTEyXzIyNCA9IHNoYTUxMi5TSEE1MTIgPSB2b2lkIDA7XG5cdC8qKlxuXHQgKiBTSEEyLTUxMiBhLmsuYS4gc2hhNTEyIGFuZCBzaGEzODQuIEl0IGlzIHNsb3dlciB0aGFuIHNoYTI1NiBpbiBqcyBiZWNhdXNlIHU2NCBvcGVyYXRpb25zIGFyZSBzbG93LlxuXHQgKlxuXHQgKiBDaGVjayBvdXQgW1JGQyA0NjM0XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzQ2MzQpIGFuZFxuXHQgKiBbdGhlIHBhcGVyIG9uIHRydW5jYXRlZCBTSEE1MTIvMjU2XShodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEwLzU0OC5wZGYpLlxuXHQgKiBAbW9kdWxlXG5cdCAqL1xuXHRjb25zdCBfbWRfanNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZV9tZCgpO1xuXHRjb25zdCBfdTY0X2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVfdTY0KCk7XG5cdGNvbnN0IHV0aWxzX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVVdGlscyQyKCk7XG5cdC8vIFJvdW5kIGNvbnRhbnRzIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5KTpcblx0Ly8gcHJldHRpZXItaWdub3JlXG5cdGNvbnN0IFtTSEE1MTJfS2gsIFNIQTUxMl9LbF0gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IF91NjRfanNfMS5kZWZhdWx0LnNwbGl0KFtcblx0ICAgICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxuXHQgICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG5cdCAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcblx0ICAgICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxuXHQgICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG5cdCAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1Jyxcblx0ICAgICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxuXHQgICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG5cdCAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcblx0ICAgICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxuXHQgICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG5cdCAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4Jyxcblx0ICAgICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxuXHQgICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG5cdCAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcblx0ICAgICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxuXHQgICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG5cdCAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcblx0ICAgICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxuXHQgICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcblx0XS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcblx0Ly8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG5cdGNvbnN0IFNIQTUxMl9XX0ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcblx0Y29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuXHRjbGFzcyBTSEE1MTIgZXh0ZW5kcyBfbWRfanNfMS5IYXNoTUQge1xuXHQgICAgY29uc3RydWN0b3IoKSB7XG5cdCAgICAgICAgc3VwZXIoMTI4LCA2NCwgMTYsIGZhbHNlKTtcblx0ICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cblx0ICAgICAgICAvLyBBbHNvIGxvb2tzIGNsZWFuZXIgYW5kIGVhc2llciB0byB2ZXJpZnkgd2l0aCBzcGVjLlxuXHQgICAgICAgIC8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuXHQgICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG5cdCAgICAgICAgdGhpcy5BaCA9IDB4NmEwOWU2NjcgfCAwO1xuXHQgICAgICAgIHRoaXMuQWwgPSAweGYzYmNjOTA4IHwgMDtcblx0ICAgICAgICB0aGlzLkJoID0gMHhiYjY3YWU4NSB8IDA7XG5cdCAgICAgICAgdGhpcy5CbCA9IDB4ODRjYWE3M2IgfCAwO1xuXHQgICAgICAgIHRoaXMuQ2ggPSAweDNjNmVmMzcyIHwgMDtcblx0ICAgICAgICB0aGlzLkNsID0gMHhmZTk0ZjgyYiB8IDA7XG5cdCAgICAgICAgdGhpcy5EaCA9IDB4YTU0ZmY1M2EgfCAwO1xuXHQgICAgICAgIHRoaXMuRGwgPSAweDVmMWQzNmYxIHwgMDtcblx0ICAgICAgICB0aGlzLkVoID0gMHg1MTBlNTI3ZiB8IDA7XG5cdCAgICAgICAgdGhpcy5FbCA9IDB4YWRlNjgyZDEgfCAwO1xuXHQgICAgICAgIHRoaXMuRmggPSAweDliMDU2ODhjIHwgMDtcblx0ICAgICAgICB0aGlzLkZsID0gMHgyYjNlNmMxZiB8IDA7XG5cdCAgICAgICAgdGhpcy5HaCA9IDB4MWY4M2Q5YWIgfCAwO1xuXHQgICAgICAgIHRoaXMuR2wgPSAweGZiNDFiZDZiIHwgMDtcblx0ICAgICAgICB0aGlzLkhoID0gMHg1YmUwY2QxOSB8IDA7XG5cdCAgICAgICAgdGhpcy5IbCA9IDB4MTM3ZTIxNzkgfCAwO1xuXHQgICAgfVxuXHQgICAgLy8gcHJldHRpZXItaWdub3JlXG5cdCAgICBnZXQoKSB7XG5cdCAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcblx0ICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcblx0ICAgIH1cblx0ICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuXHQgICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG5cdCAgICAgICAgdGhpcy5BaCA9IEFoIHwgMDtcblx0ICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuXHQgICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG5cdCAgICAgICAgdGhpcy5CbCA9IEJsIHwgMDtcblx0ICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuXHQgICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG5cdCAgICAgICAgdGhpcy5EaCA9IERoIHwgMDtcblx0ICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuXHQgICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG5cdCAgICAgICAgdGhpcy5FbCA9IEVsIHwgMDtcblx0ICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuXHQgICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG5cdCAgICAgICAgdGhpcy5HaCA9IEdoIHwgMDtcblx0ICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuXHQgICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG5cdCAgICAgICAgdGhpcy5IbCA9IEhsIHwgMDtcblx0ICAgIH1cblx0ICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG5cdCAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNjQgd29yZHMgd1sxNi4uNzldIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG5cdCAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuXHQgICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcblx0ICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IHZpZXcuZ2V0VWludDMyKChvZmZzZXQgKz0gNCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG5cdCAgICAgICAgICAgIC8vIHMwIDo9ICh3W2ktMTVdIHJpZ2h0cm90YXRlIDEpIHhvciAod1tpLTE1XSByaWdodHJvdGF0ZSA4KSB4b3IgKHdbaS0xNV0gcmlnaHRzaGlmdCA3KVxuXHQgICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcblx0ICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG5cdCAgICAgICAgICAgIGNvbnN0IHMwaCA9IF91NjRfanNfMS5kZWZhdWx0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIF91NjRfanNfMS5kZWZhdWx0LnNoclNIKFcxNWgsIFcxNWwsIDcpO1xuXHQgICAgICAgICAgICBjb25zdCBzMGwgPSBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiBfdTY0X2pzXzEuZGVmYXVsdC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcblx0ICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcblx0ICAgICAgICAgICAgY29uc3QgVzJoID0gU0hBNTEyX1dfSFtpIC0gMl0gfCAwO1xuXHQgICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG5cdCAgICAgICAgICAgIGNvbnN0IHMxaCA9IF91NjRfanNfMS5kZWZhdWx0LnJvdHJTSChXMmgsIFcybCwgMTkpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiBfdTY0X2pzXzEuZGVmYXVsdC5zaHJTSChXMmgsIFcybCwgNik7XG5cdCAgICAgICAgICAgIGNvbnN0IHMxbCA9IF91NjRfanNfMS5kZWZhdWx0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiBfdTY0X2pzXzEuZGVmYXVsdC5zaHJTTChXMmgsIFcybCwgNik7XG5cdCAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG5cdCAgICAgICAgICAgIGNvbnN0IFNVTWwgPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQ0TChzMGwsIHMxbCwgU0hBNTEyX1dfTFtpIC0gN10sIFNIQTUxMl9XX0xbaSAtIDE2XSk7XG5cdCAgICAgICAgICAgIGNvbnN0IFNVTWggPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG5cdCAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcblx0ICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcblx0ICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuXHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuXHQgICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXG5cdCAgICAgICAgICAgIGNvbnN0IHNpZ21hMWggPSBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0goRWgsIEVsLCAxNCkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0goRWgsIEVsLCAxOCkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyQkgoRWgsIEVsLCA0MSk7XG5cdCAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0woRWgsIEVsLCAxNCkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0woRWgsIEVsLCAxOCkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyQkwoRWgsIEVsLCA0MSk7XG5cdCAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcblx0ICAgICAgICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XG5cdCAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuXHQgICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXG5cdCAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuXHQgICAgICAgICAgICBjb25zdCBUMWxsID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkNUwoSGwsIHNpZ21hMWwsIENISWwsIFNIQTUxMl9LbFtpXSwgU0hBNTEyX1dfTFtpXSk7XG5cdCAgICAgICAgICAgIGNvbnN0IFQxaCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuXHQgICAgICAgICAgICBjb25zdCBUMWwgPSBUMWxsIHwgMDtcblx0ICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuXHQgICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKEFoLCBBbCwgMjgpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJIKEFoLCBBbCwgMzQpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJIKEFoLCBBbCwgMzkpO1xuXHQgICAgICAgICAgICBjb25zdCBzaWdtYTBsID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNMKEFoLCBBbCwgMjgpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJMKEFoLCBBbCwgMzQpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJMKEFoLCBBbCwgMzkpO1xuXHQgICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuXHQgICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuXHQgICAgICAgICAgICBIaCA9IEdoIHwgMDtcblx0ICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG5cdCAgICAgICAgICAgIEdoID0gRmggfCAwO1xuXHQgICAgICAgICAgICBHbCA9IEZsIHwgMDtcblx0ICAgICAgICAgICAgRmggPSBFaCB8IDA7XG5cdCAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuXHQgICAgICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xuXHQgICAgICAgICAgICBEaCA9IENoIHwgMDtcblx0ICAgICAgICAgICAgRGwgPSBDbCB8IDA7XG5cdCAgICAgICAgICAgIENoID0gQmggfCAwO1xuXHQgICAgICAgICAgICBDbCA9IEJsIHwgMDtcblx0ICAgICAgICAgICAgQmggPSBBaCB8IDA7XG5cdCAgICAgICAgICAgIEJsID0gQWwgfCAwO1xuXHQgICAgICAgICAgICBjb25zdCBBbGwgPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQzTChUMWwsIHNpZ21hMGwsIE1BSmwpO1xuXHQgICAgICAgICAgICBBaCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcblx0ICAgICAgICAgICAgQWwgPSBBbGwgfCAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuXHQgICAgICAgICh7IGg6IEFoLCBsOiBBbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcblx0ICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIEJoIHwgMCwgQmwgfCAwKSk7XG5cdCAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuXHQgICAgICAgICh7IGg6IERoLCBsOiBEbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcblx0ICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIEVoIHwgMCwgRWwgfCAwKSk7XG5cdCAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuXHQgICAgICAgICh7IGg6IEdoLCBsOiBHbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcblx0ICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIEhoIHwgMCwgSGwgfCAwKSk7XG5cdCAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuXHQgICAgfVxuXHQgICAgcm91bmRDbGVhbigpIHtcblx0ICAgICAgICBTSEE1MTJfV19ILmZpbGwoMCk7XG5cdCAgICAgICAgU0hBNTEyX1dfTC5maWxsKDApO1xuXHQgICAgfVxuXHQgICAgZGVzdHJveSgpIHtcblx0ICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuXHQgICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuXHQgICAgfVxuXHR9XG5cdHNoYTUxMi5TSEE1MTIgPSBTSEE1MTI7XG5cdGNsYXNzIFNIQTUxMl8yMjQgZXh0ZW5kcyBTSEE1MTIge1xuXHQgICAgY29uc3RydWN0b3IoKSB7XG5cdCAgICAgICAgc3VwZXIoKTtcblx0ICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuXHQgICAgICAgIHRoaXMuQWggPSAweDhjM2QzN2M4IHwgMDtcblx0ICAgICAgICB0aGlzLkFsID0gMHgxOTU0NGRhMiB8IDA7XG5cdCAgICAgICAgdGhpcy5CaCA9IDB4NzNlMTk5NjYgfCAwO1xuXHQgICAgICAgIHRoaXMuQmwgPSAweDg5ZGNkNGQ2IHwgMDtcblx0ICAgICAgICB0aGlzLkNoID0gMHgxZGZhYjdhZSB8IDA7XG5cdCAgICAgICAgdGhpcy5DbCA9IDB4MzJmZjljODIgfCAwO1xuXHQgICAgICAgIHRoaXMuRGggPSAweDY3OWRkNTE0IHwgMDtcblx0ICAgICAgICB0aGlzLkRsID0gMHg1ODJmOWZjZiB8IDA7XG5cdCAgICAgICAgdGhpcy5FaCA9IDB4MGY2ZDJiNjkgfCAwO1xuXHQgICAgICAgIHRoaXMuRWwgPSAweDdiZDQ0ZGE4IHwgMDtcblx0ICAgICAgICB0aGlzLkZoID0gMHg3N2UzNmY3MyB8IDA7XG5cdCAgICAgICAgdGhpcy5GbCA9IDB4MDRjNDg5NDIgfCAwO1xuXHQgICAgICAgIHRoaXMuR2ggPSAweDNmOWQ4NWE4IHwgMDtcblx0ICAgICAgICB0aGlzLkdsID0gMHg2YTFkMzZjOCB8IDA7XG5cdCAgICAgICAgdGhpcy5IaCA9IDB4MTExMmU2YWQgfCAwO1xuXHQgICAgICAgIHRoaXMuSGwgPSAweDkxZDY5MmExIHwgMDtcblx0ICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuXHQgICAgfVxuXHR9XG5cdHNoYTUxMi5TSEE1MTJfMjI0ID0gU0hBNTEyXzIyNDtcblx0Y2xhc3MgU0hBNTEyXzI1NiBleHRlbmRzIFNIQTUxMiB7XG5cdCAgICBjb25zdHJ1Y3RvcigpIHtcblx0ICAgICAgICBzdXBlcigpO1xuXHQgICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG5cdCAgICAgICAgdGhpcy5BaCA9IDB4MjIzMTIxOTQgfCAwO1xuXHQgICAgICAgIHRoaXMuQWwgPSAweGZjMmJmNzJjIHwgMDtcblx0ICAgICAgICB0aGlzLkJoID0gMHg5ZjU1NWZhMyB8IDA7XG5cdCAgICAgICAgdGhpcy5CbCA9IDB4Yzg0YzY0YzIgfCAwO1xuXHQgICAgICAgIHRoaXMuQ2ggPSAweDIzOTNiODZiIHwgMDtcblx0ICAgICAgICB0aGlzLkNsID0gMHg2ZjUzYjE1MSB8IDA7XG5cdCAgICAgICAgdGhpcy5EaCA9IDB4OTYzODc3MTkgfCAwO1xuXHQgICAgICAgIHRoaXMuRGwgPSAweDU5NDBlYWJkIHwgMDtcblx0ICAgICAgICB0aGlzLkVoID0gMHg5NjI4M2VlMiB8IDA7XG5cdCAgICAgICAgdGhpcy5FbCA9IDB4YTg4ZWZmZTMgfCAwO1xuXHQgICAgICAgIHRoaXMuRmggPSAweGJlNWUxZTI1IHwgMDtcblx0ICAgICAgICB0aGlzLkZsID0gMHg1Mzg2Mzk5MiB8IDA7XG5cdCAgICAgICAgdGhpcy5HaCA9IDB4MmIwMTk5ZmMgfCAwO1xuXHQgICAgICAgIHRoaXMuR2wgPSAweDJjODViOGFhIHwgMDtcblx0ICAgICAgICB0aGlzLkhoID0gMHgwZWI3MmRkYyB8IDA7XG5cdCAgICAgICAgdGhpcy5IbCA9IDB4ODFjNTJjYTIgfCAwO1xuXHQgICAgICAgIHRoaXMub3V0cHV0TGVuID0gMzI7XG5cdCAgICB9XG5cdH1cblx0c2hhNTEyLlNIQTUxMl8yNTYgPSBTSEE1MTJfMjU2O1xuXHRjbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuXHQgICAgY29uc3RydWN0b3IoKSB7XG5cdCAgICAgICAgc3VwZXIoKTtcblx0ICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuXHQgICAgICAgIHRoaXMuQWggPSAweGNiYmI5ZDVkIHwgMDtcblx0ICAgICAgICB0aGlzLkFsID0gMHhjMTA1OWVkOCB8IDA7XG5cdCAgICAgICAgdGhpcy5CaCA9IDB4NjI5YTI5MmEgfCAwO1xuXHQgICAgICAgIHRoaXMuQmwgPSAweDM2N2NkNTA3IHwgMDtcblx0ICAgICAgICB0aGlzLkNoID0gMHg5MTU5MDE1YSB8IDA7XG5cdCAgICAgICAgdGhpcy5DbCA9IDB4MzA3MGRkMTcgfCAwO1xuXHQgICAgICAgIHRoaXMuRGggPSAweDE1MmZlY2Q4IHwgMDtcblx0ICAgICAgICB0aGlzLkRsID0gMHhmNzBlNTkzOSB8IDA7XG5cdCAgICAgICAgdGhpcy5FaCA9IDB4NjczMzI2NjcgfCAwO1xuXHQgICAgICAgIHRoaXMuRWwgPSAweGZmYzAwYjMxIHwgMDtcblx0ICAgICAgICB0aGlzLkZoID0gMHg4ZWI0NGE4NyB8IDA7XG5cdCAgICAgICAgdGhpcy5GbCA9IDB4Njg1ODE1MTEgfCAwO1xuXHQgICAgICAgIHRoaXMuR2ggPSAweGRiMGMyZTBkIHwgMDtcblx0ICAgICAgICB0aGlzLkdsID0gMHg2NGY5OGZhNyB8IDA7XG5cdCAgICAgICAgdGhpcy5IaCA9IDB4NDdiNTQ4MWQgfCAwO1xuXHQgICAgICAgIHRoaXMuSGwgPSAweGJlZmE0ZmE0IHwgMDtcblx0ICAgICAgICB0aGlzLm91dHB1dExlbiA9IDQ4O1xuXHQgICAgfVxuXHR9XG5cdHNoYTUxMi5TSEEzODQgPSBTSEEzODQ7XG5cdC8qKiBTSEEyLTUxMiBoYXNoIGZ1bmN0aW9uLiAqL1xuXHRzaGE1MTIuc2hhNTEyID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBNTEyKCkpO1xuXHQvKiogU0hBMi01MTIvMjI0IFwidHJ1bmNhdGVkXCIgaGFzaCBmdW5jdGlvbiwgd2l0aCBpbXByb3ZlZCByZXNpc3RhbmNlIHRvIGxlbmd0aCBleHRlbnNpb24gYXR0YWNrcy4gKi9cblx0c2hhNTEyLnNoYTUxMl8yMjQgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuXHQvKiogU0hBMi01MTIvMjU2IFwidHJ1bmNhdGVkXCIgaGFzaCBmdW5jdGlvbiwgd2l0aCBpbXByb3ZlZCByZXNpc3RhbmNlIHRvIGxlbmd0aCBleHRlbnNpb24gYXR0YWNrcy4gKi9cblx0c2hhNTEyLnNoYTUxMl8yNTYgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuXHQvKiogU0hBMi0zODQgaGFzaCBmdW5jdGlvbi4gKi9cblx0c2hhNTEyLnNoYTM4NCA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTM4NCgpKTtcblx0XG5cdHJldHVybiBzaGE1MTI7XG59XG5cbnZhciBjdXJ2ZSA9IHt9O1xuXG52YXIgbW9kdWxhciA9IHt9O1xuXG52YXIgdXRpbHMkMiA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRVdGlscyQxO1xuXG5mdW5jdGlvbiByZXF1aXJlVXRpbHMkMSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFV0aWxzJDEpIHJldHVybiB1dGlscyQyO1xuXHRoYXNSZXF1aXJlZFV0aWxzJDEgPSAxO1xuXHQvKipcblx0ICogSGV4LCBieXRlcyBhbmQgbnVtYmVyIHV0aWxpdGllcy5cblx0ICogQG1vZHVsZVxuXHQgKi9cblx0LyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkodXRpbHMkMiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdHV0aWxzJDIubm90SW1wbGVtZW50ZWQgPSB1dGlscyQyLmJpdE1hc2sgPSB2b2lkIDA7XG5cdHV0aWxzJDIuaXNCeXRlcyA9IGlzQnl0ZXM7XG5cdHV0aWxzJDIuYWJ5dGVzID0gYWJ5dGVzO1xuXHR1dGlscyQyLmFib29sID0gYWJvb2w7XG5cdHV0aWxzJDIuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG5cdHV0aWxzJDIubnVtYmVyVG9IZXhVbnBhZGRlZCA9IG51bWJlclRvSGV4VW5wYWRkZWQ7XG5cdHV0aWxzJDIuaGV4VG9OdW1iZXIgPSBoZXhUb051bWJlcjtcblx0dXRpbHMkMi5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcblx0dXRpbHMkMi5ieXRlc1RvTnVtYmVyQkUgPSBieXRlc1RvTnVtYmVyQkU7XG5cdHV0aWxzJDIuYnl0ZXNUb051bWJlckxFID0gYnl0ZXNUb051bWJlckxFO1xuXHR1dGlscyQyLm51bWJlclRvQnl0ZXNCRSA9IG51bWJlclRvQnl0ZXNCRTtcblx0dXRpbHMkMi5udW1iZXJUb0J5dGVzTEUgPSBudW1iZXJUb0J5dGVzTEU7XG5cdHV0aWxzJDIubnVtYmVyVG9WYXJCeXRlc0JFID0gbnVtYmVyVG9WYXJCeXRlc0JFO1xuXHR1dGlscyQyLmVuc3VyZUJ5dGVzID0gZW5zdXJlQnl0ZXM7XG5cdHV0aWxzJDIuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcblx0dXRpbHMkMi5lcXVhbEJ5dGVzID0gZXF1YWxCeXRlcztcblx0dXRpbHMkMi51dGY4VG9CeXRlcyA9IHV0ZjhUb0J5dGVzO1xuXHR1dGlscyQyLmluUmFuZ2UgPSBpblJhbmdlO1xuXHR1dGlscyQyLmFJblJhbmdlID0gYUluUmFuZ2U7XG5cdHV0aWxzJDIuYml0TGVuID0gYml0TGVuO1xuXHR1dGlscyQyLmJpdEdldCA9IGJpdEdldDtcblx0dXRpbHMkMi5iaXRTZXQgPSBiaXRTZXQ7XG5cdHV0aWxzJDIuY3JlYXRlSG1hY0RyYmcgPSBjcmVhdGVIbWFjRHJiZztcblx0dXRpbHMkMi52YWxpZGF0ZU9iamVjdCA9IHZhbGlkYXRlT2JqZWN0O1xuXHR1dGlscyQyLm1lbW9pemVkID0gbWVtb2l6ZWQ7XG5cdC8vIDEwMCBsaW5lcyBvZiBjb2RlIGluIHRoZSBmaWxlIGFyZSBkdXBsaWNhdGVkIGZyb20gbm9ibGUtaGFzaGVzICh1dGlscykuXG5cdC8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG5cdC8vIFVzZXIgbWF5IG9wdC1pbiBpbnRvIHVzaW5nIGRpZmZlcmVudCBoYXNoaW5nIGxpYnJhcnkuIFRoaXMgd2F5LCBub2JsZS1oYXNoZXNcblx0Ly8gd29uJ3QgYmUgaW5jbHVkZWQgaW50byB0aGVpciBidW5kbGUuXG5cdGNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5cdGNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5cdGNvbnN0IF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XG5cdGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuXHQgICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xuXHR9XG5cdGZ1bmN0aW9uIGFieXRlcyhpdGVtKSB7XG5cdCAgICBpZiAoIWlzQnl0ZXMoaXRlbSkpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG5cdH1cblx0ZnVuY3Rpb24gYWJvb2wodGl0bGUsIHZhbHVlKSB7XG5cdCAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBib29sZWFuIGV4cGVjdGVkLCBnb3QgJyArIHZhbHVlKTtcblx0fVxuXHQvLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuXHRjb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuXHQvKipcblx0ICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuXHQgKi9cblx0ZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuXHQgICAgYWJ5dGVzKGJ5dGVzKTtcblx0ICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuXHQgICAgbGV0IGhleCA9ICcnO1xuXHQgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gaGV4O1xuXHR9XG5cdGZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG5cdCAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuXHQgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gJzAnICsgaGV4IDogaGV4O1xuXHR9XG5cdGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuXHQgICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcblx0ICAgIHJldHVybiBoZXggPT09ICcnID8gXzBuIDogQmlnSW50KCcweCcgKyBoZXgpOyAvLyBCaWcgRW5kaWFuXG5cdH1cblx0Ly8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcblx0Y29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgQTogNjUsIEY6IDcwLCBhOiA5NywgZjogMTAyIH07XG5cdGZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2gpIHtcblx0ICAgIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KVxuXHQgICAgICAgIHJldHVybiBjaCAtIGFzY2lpcy5fMDsgLy8gJzInID0+IDUwLTQ4XG5cdCAgICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpXG5cdCAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuXHQgICAgaWYgKGNoID49IGFzY2lpcy5hICYmIGNoIDw9IGFzY2lpcy5mKVxuXHQgICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcblx0ICAgIHJldHVybjtcblx0fVxuXHQvKipcblx0ICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuXHQgKi9cblx0ZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcblx0ICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG5cdCAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG5cdCAgICBjb25zdCBhbCA9IGhsIC8gMjtcblx0ICAgIGlmIChobCAlIDIpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuXHQgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG5cdCAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuXHQgICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuXHQgICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcblx0ICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yOyAvLyBtdWx0aXBseSBmaXJzdCBvY3RldCwgZS5nLiAnYTMnID0+IDEwKjE2KzMgPT4gMTYwICsgMyA9PiAxNjNcblx0ICAgIH1cblx0ICAgIHJldHVybiBhcnJheTtcblx0fVxuXHQvLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cblx0ZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG5cdCAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xuXHR9XG5cdGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuXHQgICAgYWJ5dGVzKGJ5dGVzKTtcblx0ICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG5cdH1cblx0ZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuXHQgICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG5cdH1cblx0ZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuXHQgICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcblx0fVxuXHQvLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcblx0ZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcblx0ICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xuXHR9XG5cdC8qKlxuXHQgKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG5cdCAqIFZhbGlkYXRlcyBvdXRwdXQgbGVuZ3RoLlxuXHQgKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cblx0ICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcblx0ICogQHBhcmFtIGhleCBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcblx0ICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG5cdCAqIEByZXR1cm5zXG5cdCAqL1xuXHRmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuXHQgICAgbGV0IHJlcztcblx0ICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY2F1c2U6ICcgKyBlKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChpc0J5dGVzKGhleCkpIHtcblx0ICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG5cdCAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuXHQgICAgICAgIHJlcyA9IFVpbnQ4QXJyYXkuZnJvbShoZXgpO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheScpO1xuXHQgICAgfVxuXHQgICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcblx0ICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBvZiBsZW5ndGggJyArIGV4cGVjdGVkTGVuZ3RoICsgJyBleHBlY3RlZCwgZ290ICcgKyBsZW4pO1xuXHQgICAgcmV0dXJuIHJlcztcblx0fVxuXHQvKipcblx0ICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG5cdCAqL1xuXHRmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcblx0ICAgIGxldCBzdW0gPSAwO1xuXHQgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuXHQgICAgICAgIGFieXRlcyhhKTtcblx0ICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG5cdCAgICB9XG5cdCAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuXHQgICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuXHQgICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcblx0ICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzO1xuXHR9XG5cdC8vIENvbXBhcmVzIDIgdThhLXMgaW4ga2luZGEgY29uc3RhbnQgdGltZVxuXHRmdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcblx0ICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgbGV0IGRpZmYgPSAwO1xuXHQgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuXHQgICAgICAgIGRpZmYgfD0gYVtpXSBeIGJbaV07XG5cdCAgICByZXR1cm4gZGlmZiA9PT0gMDtcblx0fVxuXHQvKipcblx0ICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcblx0ICovXG5cdGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuXHQgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIGV4cGVjdGVkJyk7XG5cdCAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG5cdH1cblx0Ly8gSXMgcG9zaXRpdmUgYmlnaW50XG5cdGNvbnN0IGlzUG9zQmlnID0gKG4pID0+IHR5cGVvZiBuID09PSAnYmlnaW50JyAmJiBfMG4gPD0gbjtcblx0ZnVuY3Rpb24gaW5SYW5nZShuLCBtaW4sIG1heCkge1xuXHQgICAgcmV0dXJuIGlzUG9zQmlnKG4pICYmIGlzUG9zQmlnKG1pbikgJiYgaXNQb3NCaWcobWF4KSAmJiBtaW4gPD0gbiAmJiBuIDwgbWF4O1xuXHR9XG5cdC8qKlxuXHQgKiBBc3NlcnRzIG1pbiA8PSBuIDwgbWF4LiBOT1RFOiBJdCdzIDwgbWF4IGFuZCBub3QgPD0gbWF4LlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBhSW5SYW5nZSgneCcsIHgsIDFuLCAyNTZuKTsgLy8gd291bGQgYXNzdW1lIHggaXMgaW4gKDFuLi4yNTVuKVxuXHQgKi9cblx0ZnVuY3Rpb24gYUluUmFuZ2UodGl0bGUsIG4sIG1pbiwgbWF4KSB7XG5cdCAgICAvLyBXaHkgbWluIDw9IG4gPCBtYXggYW5kIG5vdCBhIChtaW4gPCBuIDwgbWF4KSBPUiBiIChtaW4gPD0gbiA8PSBtYXgpP1xuXHQgICAgLy8gY29uc2lkZXIgUD0yNTZuLCBtaW49MG4sIG1heD1QXG5cdCAgICAvLyAtIGEgZm9yIG1pbj0wIHdvdWxkIHJlcXVpcmUgLTE6ICAgICAgICAgIGBpblJhbmdlKCd4JywgeCwgLTFuLCBQKWBcblx0ICAgIC8vIC0gYiB3b3VsZCBjb21tb25seSByZXF1aXJlIHN1YnRyYWN0aW9uOiAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUCAtIDFuKWBcblx0ICAgIC8vIC0gb3VyIHdheSBpcyB0aGUgY2xlYW5lc3Q6ICAgICAgICAgICAgICAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUClcblx0ICAgIGlmICghaW5SYW5nZShuLCBtaW4sIG1heCkpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCB2YWxpZCAnICsgdGl0bGUgKyAnOiAnICsgbWluICsgJyA8PSBuIDwgJyArIG1heCArICcsIGdvdCAnICsgbik7XG5cdH1cblx0Ly8gQml0IG9wZXJhdGlvbnNcblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG5cdCAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuXHQgKi9cblx0ZnVuY3Rpb24gYml0TGVuKG4pIHtcblx0ICAgIGxldCBsZW47XG5cdCAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG5cdCAgICAgICAgO1xuXHQgICAgcmV0dXJuIGxlbjtcblx0fVxuXHQvKipcblx0ICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuXHQgKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG5cdCAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG5cdCAqL1xuXHRmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG5cdCAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xuXHR9XG5cdC8qKlxuXHQgKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBiaXRTZXQobiwgcG9zLCB2YWx1ZSkge1xuXHQgICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG5cdH1cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cblx0ICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcblx0ICovXG5cdGNvbnN0IGJpdE1hc2sgPSAobikgPT4gKF8ybiA8PCBCaWdJbnQobiAtIDEpKSAtIF8xbjtcblx0dXRpbHMkMi5iaXRNYXNrID0gYml0TWFzaztcblx0Ly8gRFJCR1xuXHRjb25zdCB1OG4gPSAoZGF0YSkgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxuXHRjb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcblx0LyoqXG5cdCAqIE1pbmltYWwgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cblx0ICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcblx0ICogQGV4YW1wbGVcblx0ICogICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RSQkc8S2V5PigzMiwgMzIsIGhtYWMpO1xuXHQgKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuXHQgKi9cblx0ZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuXHQgICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuXHQgICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuXHQgICAgaWYgKHR5cGVvZiBobWFjRm4gIT09ICdmdW5jdGlvbicpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdCAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcblx0ICAgIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cblx0ICAgIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcblx0ICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG5cdCAgICBjb25zdCByZXNldCA9ICgpID0+IHtcblx0ICAgICAgICB2LmZpbGwoMSk7XG5cdCAgICAgICAgay5maWxsKDApO1xuXHQgICAgICAgIGkgPSAwO1xuXHQgICAgfTtcblx0ICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcblx0ICAgIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKCkpID0+IHtcblx0ICAgICAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuXHQgICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG5cdCAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuXHQgICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG5cdCAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuXHQgICAgfTtcblx0ICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcblx0ICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuXHQgICAgICAgIGlmIChpKysgPj0gMTAwMClcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuXHQgICAgICAgIGxldCBsZW4gPSAwO1xuXHQgICAgICAgIGNvbnN0IG91dCA9IFtdO1xuXHQgICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuXHQgICAgICAgICAgICB2ID0gaCgpO1xuXHQgICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcblx0ICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuXHQgICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuXHQgICAgfTtcblx0ICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcblx0ICAgICAgICByZXNldCgpO1xuXHQgICAgICAgIHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG5cdCAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG5cdCAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuXHQgICAgICAgICAgICByZXNlZWQoKTtcblx0ICAgICAgICByZXNldCgpO1xuXHQgICAgICAgIHJldHVybiByZXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGdlblVudGlsO1xuXHR9XG5cdC8vIFZhbGlkYXRpbmcgY3VydmVzIGFuZCBmaWVsZHNcblx0Y29uc3QgdmFsaWRhdG9yRm5zID0ge1xuXHQgICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50Jyxcblx0ICAgIGZ1bmN0aW9uOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuXHQgICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuXHQgICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcblx0ICAgIHN0cmluZ09yVWludDhBcnJheTogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgaXNCeXRlcyh2YWwpLFxuXHQgICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcblx0ICAgIGFycmF5OiAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCksXG5cdCAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuXHQgICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcblx0fTtcblx0Ly8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5cdGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG5cdCAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuXHQgICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuXHQgICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB2YWxpZGF0b3IgZnVuY3Rpb24nKTtcblx0ICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcblx0ICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFyYW0gJyArIFN0cmluZyhmaWVsZE5hbWUpICsgJyBpcyBpbnZhbGlkLiBFeHBlY3RlZCAnICsgdHlwZSArICcsIGdvdCAnICsgdmFsKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcblx0ICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuXHQgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcblx0ICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG5cdCAgICByZXR1cm4gb2JqZWN0O1xuXHR9XG5cdC8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcblx0Ly8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcblx0Ly8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcblx0Ly8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuXHQvLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuXHQvLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcblx0Ly8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG5cdC8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuXHQvKipcblx0ICogdGhyb3dzIG5vdCBpbXBsZW1lbnRlZCBlcnJvclxuXHQgKi9cblx0Y29uc3Qgbm90SW1wbGVtZW50ZWQgPSAoKSA9PiB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXHR1dGlscyQyLm5vdEltcGxlbWVudGVkID0gbm90SW1wbGVtZW50ZWQ7XG5cdC8qKlxuXHQgKiBNZW1vaXplcyAoY2FjaGVzKSBjb21wdXRhdGlvbiByZXN1bHQuXG5cdCAqIFVzZXMgV2Vha01hcDogdGhlIHZhbHVlIGlzIGdvaW5nIGF1dG8tY2xlYW5lZCBieSBHQyBhZnRlciBsYXN0IHJlZmVyZW5jZSBpcyByZW1vdmVkLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWVtb2l6ZWQoZm4pIHtcblx0ICAgIGNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cdCAgICByZXR1cm4gKGFyZywgLi4uYXJncykgPT4ge1xuXHQgICAgICAgIGNvbnN0IHZhbCA9IG1hcC5nZXQoYXJnKTtcblx0ICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBmbihhcmcsIC4uLmFyZ3MpO1xuXHQgICAgICAgIG1hcC5zZXQoYXJnLCBjb21wdXRlZCk7XG5cdCAgICAgICAgcmV0dXJuIGNvbXB1dGVkO1xuXHQgICAgfTtcblx0fVxuXHRcblx0cmV0dXJuIHV0aWxzJDI7XG59XG5cbnZhciBoYXNSZXF1aXJlZE1vZHVsYXI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVNb2R1bGFyICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkTW9kdWxhcikgcmV0dXJuIG1vZHVsYXI7XG5cdGhhc1JlcXVpcmVkTW9kdWxhciA9IDE7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGFyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0bW9kdWxhci5pc05lZ2F0aXZlTEUgPSB2b2lkIDA7XG5cdG1vZHVsYXIubW9kID0gbW9kO1xuXHRtb2R1bGFyLnBvdyA9IHBvdztcblx0bW9kdWxhci5wb3cyID0gcG93Mjtcblx0bW9kdWxhci5pbnZlcnQgPSBpbnZlcnQ7XG5cdG1vZHVsYXIudG9uZWxsaVNoYW5rcyA9IHRvbmVsbGlTaGFua3M7XG5cdG1vZHVsYXIuRnBTcXJ0ID0gRnBTcXJ0O1xuXHRtb2R1bGFyLnZhbGlkYXRlRmllbGQgPSB2YWxpZGF0ZUZpZWxkO1xuXHRtb2R1bGFyLkZwUG93ID0gRnBQb3c7XG5cdG1vZHVsYXIuRnBJbnZlcnRCYXRjaCA9IEZwSW52ZXJ0QmF0Y2g7XG5cdG1vZHVsYXIuRnBEaXYgPSBGcERpdjtcblx0bW9kdWxhci5GcExlZ2VuZHJlID0gRnBMZWdlbmRyZTtcblx0bW9kdWxhci5GcElzU3F1YXJlID0gRnBJc1NxdWFyZTtcblx0bW9kdWxhci5uTGVuZ3RoID0gbkxlbmd0aDtcblx0bW9kdWxhci5GaWVsZCA9IEZpZWxkO1xuXHRtb2R1bGFyLkZwU3FydE9kZCA9IEZwU3FydE9kZDtcblx0bW9kdWxhci5GcFNxcnRFdmVuID0gRnBTcXJ0RXZlbjtcblx0bW9kdWxhci5oYXNoVG9Qcml2YXRlU2NhbGFyID0gaGFzaFRvUHJpdmF0ZVNjYWxhcjtcblx0bW9kdWxhci5nZXRGaWVsZEJ5dGVzTGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aDtcblx0bW9kdWxhci5nZXRNaW5IYXNoTGVuZ3RoID0gZ2V0TWluSGFzaExlbmd0aDtcblx0bW9kdWxhci5tYXBIYXNoVG9GaWVsZCA9IG1hcEhhc2hUb0ZpZWxkO1xuXHQvKipcblx0ICogVXRpbHMgZm9yIG1vZHVsYXIgZGl2aXNpb24gYW5kIGZpbml0ZSBmaWVsZHMuXG5cdCAqIEEgZmluaXRlIGZpZWxkIG92ZXIgMTEgaXMgaW50ZWdlciBudW1iZXIgb3BlcmF0aW9ucyBgbW9kIDExYC5cblx0ICogVGhlcmUgaXMgbm8gZGl2aXNpb246IGl0IGlzIHJlcGxhY2VkIGJ5IG1vZHVsYXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZS5cblx0ICogQG1vZHVsZVxuXHQgKi9cblx0LyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuXHRjb25zdCB1dGlsc19qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMkMSgpO1xuXHQvLyBwcmV0dGllci1pZ25vcmVcblx0Y29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiksIF8zbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMyk7XG5cdC8vIHByZXR0aWVyLWlnbm9yZVxuXHRjb25zdCBfNG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDQpLCBfNW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDUpLCBfOG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDgpO1xuXHQvLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcblx0ZnVuY3Rpb24gbW9kKGEsIGIpIHtcblx0ICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuXHQgICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xuXHR9XG5cdC8qKlxuXHQgKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG5cdCAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cblx0ICogQHRvZG8gdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5cdCAqIEBleGFtcGxlXG5cdCAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG5cdCAqL1xuXHRmdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG5cdCAgICBpZiAocG93ZXIgPCBfMG4pXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGV4cG9uZW50LCBuZWdhdGl2ZXMgdW5zdXBwb3J0ZWQnKTtcblx0ICAgIGlmIChtb2R1bG8gPD0gXzBuKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBtb2R1bHVzJyk7XG5cdCAgICBpZiAobW9kdWxvID09PSBfMW4pXG5cdCAgICAgICAgcmV0dXJuIF8wbjtcblx0ICAgIGxldCByZXMgPSBfMW47XG5cdCAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcblx0ICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG5cdCAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xuXHQgICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuXHQgICAgICAgIHBvd2VyID4+PSBfMW47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzO1xuXHR9XG5cdC8qKiBEb2VzIGB4XigyXnBvd2VyKWAgbW9kIHAuIGBwb3cyKDMwLCA0KWAgPT0gYDMwXigyXjQpYCAqL1xuXHRmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcblx0ICAgIGxldCByZXMgPSB4O1xuXHQgICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcblx0ICAgICAgICByZXMgKj0gcmVzO1xuXHQgICAgICAgIHJlcyAlPSBtb2R1bG87XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzO1xuXHR9XG5cdC8qKlxuXHQgKiBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG8uXG5cdCAqIEltcGxlbWVudGVkIHVzaW5nIFtFdWNsaWRlYW4gR0NEXShodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtLykuXG5cdCAqL1xuXHRmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcblx0ICAgIGlmIChudW1iZXIgPT09IF8wbilcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZXhwZWN0ZWQgbm9uLXplcm8gbnVtYmVyJyk7XG5cdCAgICBpZiAobW9kdWxvIDw9IF8wbilcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgbW9kdWx1cywgZ290ICcgKyBtb2R1bG8pO1xuXHQgICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG5cdCAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG5cdCAgICBsZXQgYiA9IG1vZHVsbztcblx0ICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuXHQgICAgbGV0IHggPSBfMG4sIHUgPSBfMW47XG5cdCAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG5cdCAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuXHQgICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcblx0ICAgICAgICBjb25zdCByID0gYiAlIGE7XG5cdCAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcblx0ICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcblx0ICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB1ID0gbTtcblx0ICAgIH1cblx0ICAgIGNvbnN0IGdjZCA9IGI7XG5cdCAgICBpZiAoZ2NkICE9PSBfMW4pXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG5cdCAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG5cdH1cblx0LyoqXG5cdCAqIFRvbmVsbGktU2hhbmtzIHNxdWFyZSByb290IHNlYXJjaCBhbGdvcml0aG0uXG5cdCAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcblx0ICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG5cdCAqIFdpbGwgc3RhcnQgYW4gaW5maW5pdGUgbG9vcCBpZiBmaWVsZCBvcmRlciBQIGlzIG5vdCBwcmltZS5cblx0ICogQHBhcmFtIFAgZmllbGQgb3JkZXJcblx0ICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuXHQgKi9cblx0ZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG5cdCAgICAvLyBMZWdlbmRyZSBjb25zdGFudDogdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcCksXG5cdCAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuXHQgICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcblx0ICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKVxuXHQgICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcblx0ICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcblx0ICAgIGxldCBRLCBTLCBaO1xuXHQgICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG5cdCAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG5cdCAgICBmb3IgKFEgPSBQIC0gXzFuLCBTID0gMDsgUSAlIF8ybiA9PT0gXzBuOyBRIC89IF8ybiwgUysrKVxuXHQgICAgICAgIDtcblx0ICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG5cdCAgICBmb3IgKFogPSBfMm47IFogPCBQICYmIHBvdyhaLCBsZWdlbmRyZUMsIFApICE9PSBQIC0gXzFuOyBaKyspIHtcblx0ICAgICAgICAvLyBDcmFzaCBpbnN0ZWFkIG9mIGluZmluaXR5IGxvb3AsIHdlIGNhbm5vdCByZWFzb25hYmxlIGNvdW50IHVudGlsIFAuXG5cdCAgICAgICAgaWYgKFogPiAxMDAwKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290OiBsaWtlbHkgbm9uLXByaW1lIFAnKTtcblx0ICAgIH1cblx0ICAgIC8vIEZhc3QtcGF0aFxuXHQgICAgaWYgKFMgPT09IDEpIHtcblx0ICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0KEZwLCBuKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcblx0ICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIC8vIFNsb3ctcGF0aFxuXHQgICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG5cdCAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG5cdCAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuXHQgICAgICAgIGxldCByID0gUztcblx0ICAgICAgICAvLyBUT0RPOiB3aWxsIGZhaWwgYXQgRnAyL2V0Y1xuXHQgICAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTsgLy8gd2lsbCB1cGRhdGUgYm90aCB4IGFuZCBiXG5cdCAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG5cdCAgICAgICAgbGV0IGIgPSBGcC5wb3cobiwgUSk7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3Jcblx0ICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG5cdCAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG5cdCAgICAgICAgICAgIC8vIEZpbmQgbSBzdWNoIGJeKDJebSk9PTFcblx0ICAgICAgICAgICAgbGV0IG0gPSAxO1xuXHQgICAgICAgICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIHQyID0gRnAuc3FyKHQyKTsgLy8gdDIgKj0gdDJcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuXHQgICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuXHQgICAgICAgICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2Vcblx0ICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2Vcblx0ICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG5cdCAgICAgICAgICAgIHIgPSBtO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4geDtcblx0ICAgIH07XG5cdH1cblx0LyoqXG5cdCAqIFNxdWFyZSByb290IGZvciBhIGZpbml0ZSBmaWVsZC4gSXQgd2lsbCB0cnkgdG8gY2hlY2sgaWYgb3B0aW1pemF0aW9ucyBhcmUgYXBwbGljYWJsZSBhbmQgZmFsbCBiYWNrIHRvIDQ6XG5cdCAqXG5cdCAqIDEuIFAg4omhIDMgKG1vZCA0KVxuXHQgKiAyLiBQIOKJoSA1IChtb2QgOClcblx0ICogMy4gUCDiiaEgOSAobW9kIDE2KVxuXHQgKiA0LiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cblx0ICpcblx0ICogRGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuXHQgKiBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cblx0ICovXG5cdGZ1bmN0aW9uIEZwU3FydChQKSB7XG5cdCAgICAvLyBQIOKJoSAzIChtb2QgNClcblx0ICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxuXHQgICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuXHQgICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG5cdCAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuXHQgICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuXHQgICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcblx0ICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuXHQgICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG5cdCAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxuXHQgICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuXHQgICAgICAgICAgICByZXR1cm4gcm9vdDtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcblx0ICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcblx0ICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG5cdCAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcblx0ICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG5cdCAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcblx0ICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuXHQgICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuXHQgICAgICAgICAgICByZXR1cm4gcm9vdDtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuXHQgICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG5cdH1cblx0Ly8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5cdGNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG5cdG1vZHVsYXIuaXNOZWdhdGl2ZUxFID0gaXNOZWdhdGl2ZUxFO1xuXHQvLyBwcmV0dGllci1pZ25vcmVcblx0Y29uc3QgRklFTERfRklFTERTID0gW1xuXHQgICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcblx0ICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG5cdCAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcblx0XTtcblx0ZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuXHQgICAgY29uc3QgaW5pdGlhbCA9IHtcblx0ICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG5cdCAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG5cdCAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcblx0ICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG5cdCAgICB9O1xuXHQgICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG5cdCAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuXHQgICAgICAgIHJldHVybiBtYXA7XG5cdCAgICB9LCBpbml0aWFsKTtcblx0ICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS52YWxpZGF0ZU9iamVjdCkoZmllbGQsIG9wdHMpO1xuXHR9XG5cdC8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG5cdC8qKlxuXHQgKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuXHQgKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBGcFBvdyhmLCBudW0sIHBvd2VyKSB7XG5cdCAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuXHQgICAgLy8gVE9ETzogYmVuY2htYXJrIVxuXHQgICAgaWYgKHBvd2VyIDwgXzBuKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBleHBvbmVudCwgbmVnYXRpdmVzIHVuc3VwcG9ydGVkJyk7XG5cdCAgICBpZiAocG93ZXIgPT09IF8wbilcblx0ICAgICAgICByZXR1cm4gZi5PTkU7XG5cdCAgICBpZiAocG93ZXIgPT09IF8xbilcblx0ICAgICAgICByZXR1cm4gbnVtO1xuXHQgICAgbGV0IHAgPSBmLk9ORTtcblx0ICAgIGxldCBkID0gbnVtO1xuXHQgICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG5cdCAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuXHQgICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG5cdCAgICAgICAgZCA9IGYuc3FyKGQpO1xuXHQgICAgICAgIHBvd2VyID4+PSBfMW47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcDtcblx0fVxuXHQvKipcblx0ICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuXHQgKiBgaW52KDApYCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBoZXJlOiBtYWtlIHN1cmUgdG8gdGhyb3cgYW4gZXJyb3IuXG5cdCAqL1xuXHRmdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcblx0ICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG5cdCAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG5cdCAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuXHQgICAgICAgIGlmIChmLmlzMChudW0pKVxuXHQgICAgICAgICAgICByZXR1cm4gYWNjO1xuXHQgICAgICAgIHRtcFtpXSA9IGFjYztcblx0ICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuXHQgICAgfSwgZi5PTkUpO1xuXHQgICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuXHQgICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG5cdCAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG5cdCAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuXHQgICAgICAgIGlmIChmLmlzMChudW0pKVxuXHQgICAgICAgICAgICByZXR1cm4gYWNjO1xuXHQgICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcblx0ICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuXHQgICAgfSwgaW52ZXJ0ZWQpO1xuXHQgICAgcmV0dXJuIHRtcDtcblx0fVxuXHRmdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuXHQgICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xuXHR9XG5cdC8qKlxuXHQgKiBMZWdlbmRyZSBzeW1ib2wuXG5cdCAqICogKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcCksIHF1YWRyYXRpYyByZXNpZHVlXG5cdCAqICogKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApLCBxdWFkcmF0aWMgbm9uIHJlc2lkdWVcblx0ICogKiAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuXHQgKi9cblx0ZnVuY3Rpb24gRnBMZWdlbmRyZShvcmRlcikge1xuXHQgICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChvcmRlciAtIF8xbikgLyBfMm47IC8vIEludGVnZXIgYXJpdGhtZXRpY1xuXHQgICAgcmV0dXJuIChmLCB4KSA9PiBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcblx0fVxuXHQvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cblx0ZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG5cdCAgICBjb25zdCBsZWdlbmRyZSA9IEZwTGVnZW5kcmUoZi5PUkRFUik7XG5cdCAgICByZXR1cm4gKHgpID0+IHtcblx0ICAgICAgICBjb25zdCBwID0gbGVnZW5kcmUoZiwgeCk7XG5cdCAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuXHQgICAgfTtcblx0fVxuXHQvLyBDVVJWRS5uIGxlbmd0aHNcblx0ZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG5cdCAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cblx0ICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuXHQgICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcblx0ICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xuXHR9XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLlxuXHQgKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuXHQgKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuXHQgKiAqIGIpIHNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcblx0ICogKiBjKSBPYmplY3QuZnJlZXplXG5cdCAqIEZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG5cdCAqIFNlY3VyaXR5IG5vdGU6IG9wZXJhdGlvbnMgZG9uJ3QgY2hlY2sgJ2lzVmFsaWQnIGZvciBhbGwgZWxlbWVudHMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsXG5cdCAqIGl0IGlzIGNhbGxlciByZXNwb25zaWJpbGl0eSB0byBjaGVjayB0aGlzLlxuXHQgKiBUaGlzIGlzIGxvdy1sZXZlbCBjb2RlLCBwbGVhc2UgbWFrZSBzdXJlIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuXHQgKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG5cdCAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcblx0ICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cblx0ICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcblx0ICovXG5cdGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuXHQgICAgaWYgKE9SREVSIDw9IF8wbilcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSID4gMCwgZ290ICcgKyBPUkRFUik7XG5cdCAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcblx0ICAgIGlmIChCWVRFUyA+IDIwNDgpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkOiBleHBlY3RlZCBPUkRFUiBvZiA8PSAyMDQ4IGJ5dGVzJyk7XG5cdCAgICBsZXQgc3FydFA7IC8vIGNhY2hlZCBzcXJ0UFxuXHQgICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuXHQgICAgICAgIE9SREVSLFxuXHQgICAgICAgIGlzTEUsXG5cdCAgICAgICAgQklUUyxcblx0ICAgICAgICBCWVRFUyxcblx0ICAgICAgICBNQVNLOiAoMCwgdXRpbHNfanNfMS5iaXRNYXNrKShCSVRTKSxcblx0ICAgICAgICBaRVJPOiBfMG4sXG5cdCAgICAgICAgT05FOiBfMW4sXG5cdCAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG5cdCAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJyArIHR5cGVvZiBudW0pO1xuXHQgICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcblx0ICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcblx0ICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG5cdCAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuXHQgICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuXHQgICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG5cdCAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcblx0ICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuXHQgICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuXHQgICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG5cdCAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG5cdCAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuXHQgICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuXHQgICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuXHQgICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuXHQgICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuXHQgICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHxcblx0ICAgICAgICAgICAgKChuKSA9PiB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXNxcnRQKVxuXHQgICAgICAgICAgICAgICAgICAgIHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzcXJ0UChmLCBuKTtcblx0ICAgICAgICAgICAgfSksXG5cdCAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcblx0ICAgICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xuXHQgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcblx0ICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG5cdCAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyAoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzTEUpKG51bSwgQllURVMpIDogKDAsIHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0JFKShudW0sIEJZVEVTKSksXG5cdCAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcblx0ICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkLmZyb21CeXRlczogZXhwZWN0ZWQgJyArIEJZVEVTICsgJyBieXRlcywgZ290ICcgKyBieXRlcy5sZW5ndGgpO1xuXHQgICAgICAgICAgICByZXR1cm4gaXNMRSA/ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkoYnl0ZXMpIDogKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShieXRlcyk7XG5cdCAgICAgICAgfSxcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG5cdH1cblx0ZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcblx0ICAgIGlmICghRnAuaXNPZGQpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkXCIpO1xuXHQgICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcblx0ICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG5cdH1cblx0ZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG5cdCAgICBpZiAoIUZwLmlzT2RkKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcblx0ICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG5cdCAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xuXHR9XG5cdC8qKlxuXHQgKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG5cdCAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG5cdCAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cblx0ICogQGRlcHJlY2F0ZWQgdXNlIGBtYXBLZXlUb0ZpZWxkYCBpbnN0ZWFkXG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuXHQgICAgaGFzaCA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncHJpdmF0ZUhhc2gnLCBoYXNoKTtcblx0ICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcblx0ICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuXHQgICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAnICsgbWluTGVuICsgJy0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJyArIGhhc2hMZW4pO1xuXHQgICAgY29uc3QgbnVtID0gaXNMRSA/ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkoaGFzaCkgOiAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKGhhc2gpO1xuXHQgICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xuXHR9XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cblx0ICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuXHQgKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuXHQgKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG5cdCAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcblx0ICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuXHQgICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcblx0fVxuXHQvKipcblx0ICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuXHQgKiBieSBmaWVsZCBvcmRlci5cblx0ICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG5cdCAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG5cdCAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcblx0ICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG5cdCAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xuXHR9XG5cdC8qKlxuXHQgKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG5cdCAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcblx0ICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuXHQgKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cblx0ICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG5cdCAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG5cdCAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcblx0ICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuXHQgKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG5cdCAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuXHQgKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcblx0ICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG5cdCAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG5cdCAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuXHQgICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuXHQgICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgJyArIG1pbkxlbiArICctMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICcgKyBsZW4pO1xuXHQgICAgY29uc3QgbnVtID0gaXNMRSA/ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkoa2V5KSA6ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkoa2V5KTtcblx0ICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcblx0ICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcblx0ICAgIHJldHVybiBpc0xFID8gKDAsIHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0xFKShyZWR1Y2VkLCBmaWVsZExlbikgOiAoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzQkUpKHJlZHVjZWQsIGZpZWxkTGVuKTtcblx0fVxuXHRcblx0cmV0dXJuIG1vZHVsYXI7XG59XG5cbnZhciBoYXNSZXF1aXJlZEN1cnZlO1xuXG5mdW5jdGlvbiByZXF1aXJlQ3VydmUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRDdXJ2ZSkgcmV0dXJuIGN1cnZlO1xuXHRoYXNSZXF1aXJlZEN1cnZlID0gMTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0Y3VydmUud05BRiA9IHdOQUY7XG5cdGN1cnZlLnBpcHBlbmdlciA9IHBpcHBlbmdlcjtcblx0Y3VydmUucHJlY29tcHV0ZU1TTVVuc2FmZSA9IHByZWNvbXB1dGVNU01VbnNhZmU7XG5cdGN1cnZlLnZhbGlkYXRlQmFzaWMgPSB2YWxpZGF0ZUJhc2ljO1xuXHQvKipcblx0ICogTWV0aG9kcyBmb3IgZWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gYnkgc2NhbGFycy5cblx0ICogQ29udGFpbnMgd05BRiwgcGlwcGVuZ2VyXG5cdCAqIEBtb2R1bGVcblx0ICovXG5cdC8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cblx0Y29uc3QgbW9kdWxhcl9qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlTW9kdWxhcigpO1xuXHRjb25zdCB1dGlsc19qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMkMSgpO1xuXHRjb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5cdGNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcblx0ZnVuY3Rpb24gY29uc3RUaW1lTmVnYXRlKGNvbmRpdGlvbiwgaXRlbSkge1xuXHQgICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcblx0ICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xuXHR9XG5cdGZ1bmN0aW9uIHZhbGlkYXRlVyhXLCBiaXRzKSB7XG5cdCAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKFcpIHx8IFcgPD0gMCB8fCBXID4gYml0cylcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgd2luZG93IHNpemUsIGV4cGVjdGVkIFsxLi4nICsgYml0cyArICddLCBnb3QgVz0nICsgVyk7XG5cdH1cblx0ZnVuY3Rpb24gY2FsY1dPcHRzKFcsIGJpdHMpIHtcblx0ICAgIHZhbGlkYXRlVyhXLCBiaXRzKTtcblx0ICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2Vcblx0ICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG5cdCAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG5cdH1cblx0ZnVuY3Rpb24gdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKSB7XG5cdCAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGV4cGVjdGVkJyk7XG5cdCAgICBwb2ludHMuZm9yRWFjaCgocCwgaSkgPT4ge1xuXHQgICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBjKSlcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50IGF0IGluZGV4ICcgKyBpKTtcblx0ICAgIH0pO1xuXHR9XG5cdGZ1bmN0aW9uIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZCkge1xuXHQgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjYWxhcnMpKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBleHBlY3RlZCcpO1xuXHQgICAgc2NhbGFycy5mb3JFYWNoKChzLCBpKSA9PiB7XG5cdCAgICAgICAgaWYgKCFmaWVsZC5pc1ZhbGlkKHMpKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyIGF0IGluZGV4ICcgKyBpKTtcblx0ICAgIH0pO1xuXHR9XG5cdC8vIFNpbmNlIHBvaW50cyBpbiBkaWZmZXJlbnQgZ3JvdXBzIGNhbm5vdCBiZSBlcXVhbCAoZGlmZmVyZW50IG9iamVjdCBjb25zdHJ1Y3RvciksXG5cdC8vIHdlIGNhbiBoYXZlIHNpbmdsZSBwbGFjZSB0byBzdG9yZSBwcmVjb21wdXRlc1xuXHRjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcblx0Y29uc3QgcG9pbnRXaW5kb3dTaXplcyA9IG5ldyBXZWFrTWFwKCk7IC8vIFRoaXMgYWxsb3dzIHVzZSBtYWtlIHBvaW50cyBpbW11dGFibGUgKG5vdGhpbmcgY2hhbmdlcyBpbnNpZGUpXG5cdGZ1bmN0aW9uIGdldFcoUCkge1xuXHQgICAgcmV0dXJuIHBvaW50V2luZG93U2l6ZXMuZ2V0KFApIHx8IDE7XG5cdH1cblx0LyoqXG5cdCAqIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cblx0ICogU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG5cdCAqIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuXHQgKiAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcblx0ICogLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuXHQgKiAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG5cdCAqIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuXHQgKiAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG5cdCAqIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG5cdCAqXG5cdCAqIEB0b2RvIFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy5cblx0ICogVGhpcyB3b3VsZCBhbGxvdyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5cdCAqL1xuXHRmdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuXHQgICAgICAgIGhhc1ByZWNvbXB1dGVzKGVsbSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZ2V0VyhlbG0pICE9PSAxO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG5cdCAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbiwgcCA9IGMuWkVSTykge1xuXHQgICAgICAgICAgICBsZXQgZCA9IGVsbTtcblx0ICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcblx0ICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuXHQgICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcblx0ICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuXHQgICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBwO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuXHQgICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuXHQgICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcblx0ICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcblx0ICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG5cdCAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuXHQgICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cblx0ICAgICAgICAgKiBAcGFyYW0gZWxtIFBvaW50IGluc3RhbmNlXG5cdCAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcblx0ICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcblx0ICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XG5cdCAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuXHQgICAgICAgICAgICBsZXQgcCA9IGVsbTtcblx0ICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuXHQgICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuXHQgICAgICAgICAgICAgICAgYmFzZSA9IHA7XG5cdCAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcblx0ICAgICAgICAgICAgICAgIC8vID0xLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuXHQgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuXHQgICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG5cdCAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuXHQgICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG5cdCAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcblx0ICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hlY2sgdGhhdCBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyPyB3TkFGIGJlaGF2aW91cyBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlXG5cdCAgICAgICAgICAgIC8vIEJ1dCBuZWVkIHRvIGNhcmVmdWxseSByZW1vdmUgb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmVcblx0ICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XG5cdCAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuXHQgICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcblx0ICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cblx0ICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuXHQgICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuXHQgICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuXHQgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcblx0ICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuXHQgICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcblx0ICAgICAgICAgICAgICAgIC8vIFNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG5cdCAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuXHQgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cblx0ICAgICAgICAgICAgICAgIC8vICsyMjQgPT4gMjU2IC0gMzJcblx0ICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgbiArPSBfMW47XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcblx0ICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcblx0ICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG5cdCAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG5cdCAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cblx0ICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cblx0ICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG5cdCAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuXHQgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG5cdCAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcblx0ICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuXHQgICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIEpJVC1jb21waWxlciBzaG91bGQgbm90IGVsaW1pbmF0ZSBmIGhlcmUsIHNpbmNlIGl0IHdpbGwgbGF0ZXIgYmUgdXNlZCBpbiBub3JtYWxpemVaKClcblx0ICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuXHQgICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuXHQgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcblx0ICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG5cdCAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEltcGxlbWVudHMgZWMgdW5zYWZlIChub24gY29uc3QtdGltZSkgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cblx0ICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuXHQgICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcblx0ICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuXHQgICAgICAgICAqIEBwYXJhbSBhY2MgYWNjdW11bGF0b3IgcG9pbnQgdG8gYWRkIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvblxuXHQgICAgICAgICAqIEByZXR1cm5zIHBvaW50XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgd05BRlVuc2FmZShXLCBwcmVjb21wdXRlcywgbiwgYWNjID0gYy5aRVJPKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gY2FsY1dPcHRzKFcsIGJpdHMpO1xuXHQgICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuXHQgICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG5cdCAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG5cdCAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuXHQgICAgICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcblx0ICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gTm8gbmVlZCB0byBnbyBvdmVyIGVtcHR5IHNjYWxhclxuXHQgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG5cdCAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuXHQgICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cblx0ICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG5cdCAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuXHQgICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuXHQgICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMClcblx0ICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGxldCBjdXJyID0gcHJlY29tcHV0ZXNbb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMV07IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG5cdCAgICAgICAgICAgICAgICBpZiAod2JpdHMgPCAwKVxuXHQgICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyLm5lZ2F0ZSgpO1xuXHQgICAgICAgICAgICAgICAgLy8gTk9URTogYnkgcmUtdXNpbmcgYWNjLCB3ZSBjYW4gc2F2ZSBhIGxvdCBvZiBhZGRpdGlvbnMgaW4gY2FzZSBvZiBNU01cblx0ICAgICAgICAgICAgICAgIGFjYyA9IGFjYy5hZGQoY3Vycik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGFjYztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSkge1xuXHQgICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcblx0ICAgICAgICAgICAgbGV0IGNvbXAgPSBwb2ludFByZWNvbXB1dGVzLmdldChQKTtcblx0ICAgICAgICAgICAgaWYgKCFjb21wKSB7XG5cdCAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuXHQgICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpXG5cdCAgICAgICAgICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gY29tcDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHdOQUZDYWNoZWQoUCwgbiwgdHJhbnNmb3JtKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IFcgPSBnZXRXKFApO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIHRoaXMuZ2V0UHJlY29tcHV0ZXMoVywgUCwgdHJhbnNmb3JtKSwgbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB3TkFGQ2FjaGVkVW5zYWZlKFAsIG4sIHRyYW5zZm9ybSwgcHJldikge1xuXHQgICAgICAgICAgICBjb25zdCBXID0gZ2V0VyhQKTtcblx0ICAgICAgICAgICAgaWYgKFcgPT09IDEpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnNhZmVMYWRkZXIoUCwgbiwgcHJldik7IC8vIEZvciBXPTEgbGFkZGVyIGlzIH54MiBmYXN0ZXJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRlVuc2FmZShXLCB0aGlzLmdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSksIG4sIHByZXYpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy8gV2UgY2FsY3VsYXRlIHByZWNvbXB1dGVzIGZvciBlbGxpcHRpYyBjdXJ2ZSBwb2ludCBtdWx0aXBsaWNhdGlvblxuXHQgICAgICAgIC8vIHVzaW5nIHdpbmRvd2VkIG1ldGhvZC4gVGhpcyBzcGVjaWZpZXMgd2luZG93IHNpemUgYW5kXG5cdCAgICAgICAgLy8gc3RvcmVzIHByZWNvbXB1dGVkIHZhbHVlcy4gVXN1YWxseSBvbmx5IGJhc2UgcG9pbnQgd291bGQgYmUgcHJlY29tcHV0ZWQuXG5cdCAgICAgICAgc2V0V2luZG93U2l6ZShQLCBXKSB7XG5cdCAgICAgICAgICAgIHZhbGlkYXRlVyhXLCBiaXRzKTtcblx0ICAgICAgICAgICAgcG9pbnRXaW5kb3dTaXplcy5zZXQoUCwgVyk7XG5cdCAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKFApO1xuXHQgICAgICAgIH0sXG5cdCAgICB9O1xuXHR9XG5cdC8qKlxuXHQgKiBQaXBwZW5nZXIgYWxnb3JpdGhtIGZvciBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cblx0ICogMzB4IGZhc3RlciB2cyBuYWl2ZSBhZGRpdGlvbiBvbiBMPTQwOTYsIDEweCBmYXN0ZXIgd2l0aCBwcmVjb21wdXRlcy5cblx0ICogRm9yIE49MjU0Yml0LCBMPTEsIGl0IGRvZXM6IDEwMjQgQUREICsgMjU0IERCTC4gRm9yIEw9NTogMTUzNiBBREQgKyAyNTQgREJMLlxuXHQgKiBBbGdvcml0aG1pY2FsbHkgY29uc3RhbnQtdGltZSAoZm9yIHNhbWUgTCksIGV2ZW4gd2hlbiAxIHBvaW50ICsgc2NhbGFyLCBvciB3aGVuIHNjYWxhciA9IDAuXG5cdCAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG5cdCAqIEBwYXJhbSBwb2ludHMgYXJyYXkgb2YgTCBjdXJ2ZSBwb2ludHNcblx0ICogQHBhcmFtIHNjYWxhcnMgYXJyYXkgb2YgTCBzY2FsYXJzIChha2EgcHJpdmF0ZSBrZXlzIC8gYmlnaW50cylcblx0ICovXG5cdGZ1bmN0aW9uIHBpcHBlbmdlcihjLCBmaWVsZE4sIHBvaW50cywgc2NhbGFycykge1xuXHQgICAgLy8gSWYgd2Ugc3BsaXQgc2NhbGFycyBieSBzb21lIHdpbmRvdyAobGV0J3Mgc2F5IDggYml0cyksIGV2ZXJ5IGNodW5rIHdpbGwgb25seVxuXHQgICAgLy8gdGFrZSAyNTYgYnVja2V0cyBldmVuIGlmIHRoZXJlIGFyZSA0MDk2IHNjYWxhcnMsIGFsc28gcmUtdXNlcyBkb3VibGUuXG5cdCAgICAvLyBUT0RPOlxuXHQgICAgLy8gLSBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDI0Lzc1MC5wZGZcblx0ICAgIC8vIC0gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzEwMjg3XG5cdCAgICAvLyAwIGlzIGFjY2VwdGVkIGluIHNjYWxhcnNcblx0ICAgIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYyk7XG5cdCAgICB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGROKTtcblx0ICAgIGlmIChwb2ludHMubGVuZ3RoICE9PSBzY2FsYXJzLmxlbmd0aClcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5cyBvZiBwb2ludHMgYW5kIHNjYWxhcnMgbXVzdCBoYXZlIGVxdWFsIGxlbmd0aCcpO1xuXHQgICAgY29uc3QgemVybyA9IGMuWkVSTztcblx0ICAgIGNvbnN0IHdiaXRzID0gKDAsIHV0aWxzX2pzXzEuYml0TGVuKShCaWdJbnQocG9pbnRzLmxlbmd0aCkpO1xuXHQgICAgY29uc3Qgd2luZG93U2l6ZSA9IHdiaXRzID4gMTIgPyB3Yml0cyAtIDMgOiB3Yml0cyA+IDQgPyB3Yml0cyAtIDIgOiB3Yml0cyA/IDIgOiAxOyAvLyBpbiBiaXRzXG5cdCAgICBjb25zdCBNQVNLID0gKDEgPDwgd2luZG93U2l6ZSkgLSAxO1xuXHQgICAgY29uc3QgYnVja2V0cyA9IG5ldyBBcnJheShNQVNLICsgMSkuZmlsbCh6ZXJvKTsgLy8gKzEgZm9yIHplcm8gYXJyYXlcblx0ICAgIGNvbnN0IGxhc3RCaXRzID0gTWF0aC5mbG9vcigoZmllbGROLkJJVFMgLSAxKSAvIHdpbmRvd1NpemUpICogd2luZG93U2l6ZTtcblx0ICAgIGxldCBzdW0gPSB6ZXJvO1xuXHQgICAgZm9yIChsZXQgaSA9IGxhc3RCaXRzOyBpID49IDA7IGkgLT0gd2luZG93U2l6ZSkge1xuXHQgICAgICAgIGJ1Y2tldHMuZmlsbCh6ZXJvKTtcblx0ICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNjYWxhcnMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgY29uc3Qgc2NhbGFyID0gc2NhbGFyc1tqXTtcblx0ICAgICAgICAgICAgY29uc3Qgd2JpdHMgPSBOdW1iZXIoKHNjYWxhciA+PiBCaWdJbnQoaSkpICYgQmlnSW50KE1BU0spKTtcblx0ICAgICAgICAgICAgYnVja2V0c1t3Yml0c10gPSBidWNrZXRzW3diaXRzXS5hZGQocG9pbnRzW2pdKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbGV0IHJlc0kgPSB6ZXJvOyAvLyBub3QgdXNpbmcgdGhpcyB3aWxsIGRvIHNtYWxsIHNwZWVkLXVwLCBidXQgd2lsbCBsb3NlIGN0XG5cdCAgICAgICAgLy8gU2tpcCBmaXJzdCBidWNrZXQsIGJlY2F1c2UgaXQgaXMgemVyb1xuXHQgICAgICAgIGZvciAobGV0IGogPSBidWNrZXRzLmxlbmd0aCAtIDEsIHN1bUkgPSB6ZXJvOyBqID4gMDsgai0tKSB7XG5cdCAgICAgICAgICAgIHN1bUkgPSBzdW1JLmFkZChidWNrZXRzW2pdKTtcblx0ICAgICAgICAgICAgcmVzSSA9IHJlc0kuYWRkKHN1bUkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzdW0gPSBzdW0uYWRkKHJlc0kpO1xuXHQgICAgICAgIGlmIChpICE9PSAwKVxuXHQgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcblx0ICAgICAgICAgICAgICAgIHN1bSA9IHN1bS5kb3VibGUoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBzdW07XG5cdH1cblx0LyoqXG5cdCAqIFByZWNvbXB1dGVkIG11bHRpLXNjYWxhciBtdWx0aXBsaWNhdGlvbiAoTVNNLCBQYSArIFFiICsgUmMgKyAuLi4pLlxuXHQgKiBAcGFyYW0gYyBDdXJ2ZSBQb2ludCBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuXHQgKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG5cdCAqIEByZXR1cm5zIGZ1bmN0aW9uIHdoaWNoIG11bHRpcGxpZXMgcG9pbnRzIHdpdGggc2NhYXJzXG5cdCAqL1xuXHRmdW5jdGlvbiBwcmVjb21wdXRlTVNNVW5zYWZlKGMsIGZpZWxkTiwgcG9pbnRzLCB3aW5kb3dTaXplKSB7XG5cdCAgICAvKipcblx0ICAgICAqIFBlcmZvcm1hbmNlIEFuYWx5c2lzIG9mIFdpbmRvdy1iYXNlZCBQcmVjb21wdXRhdGlvblxuXHQgICAgICpcblx0ICAgICAqIEJhc2UgQ2FzZSAoMjU2LWJpdCBzY2FsYXIsIDgtYml0IHdpbmRvdyk6XG5cdCAgICAgKiAtIFN0YW5kYXJkIHByZWNvbXB1dGF0aW9uIHJlcXVpcmVzOlxuXHQgICAgICogICAtIDMxIGFkZGl0aW9ucyBwZXIgc2NhbGFyIMOXIDI1NiBzY2FsYXJzID0gNyw5MzYgb3BzXG5cdCAgICAgKiAgIC0gUGx1cyAyNTUgc3VtbWFyeSBhZGRpdGlvbnMgPSA4LDE5MSB0b3RhbCBvcHNcblx0ICAgICAqICAgTm90ZTogU3VtbWFyeSBhZGRpdGlvbnMgY2FuIGJlIG9wdGltaXplZCB2aWEgYWNjdW11bGF0b3Jcblx0ICAgICAqXG5cdCAgICAgKiBDaHVua2VkIFByZWNvbXB1dGF0aW9uIEFuYWx5c2lzOlxuXHQgICAgICogLSBVc2luZyAzMiBjaHVua3MgcmVxdWlyZXM6XG5cdCAgICAgKiAgIC0gMjU1IGFkZGl0aW9ucyBwZXIgY2h1bmtcblx0ICAgICAqICAgLSAyNTYgZG91YmxpbmdzXG5cdCAgICAgKiAgIC0gVG90YWw6ICgyNTUgw5cgMzIpICsgMjU2ID0gOCw0MTYgb3BzXG5cdCAgICAgKlxuXHQgICAgICogTWVtb3J5IFVzYWdlIENvbXBhcmlzb246XG5cdCAgICAgKiBXaW5kb3cgU2l6ZSB8IFN0YW5kYXJkIFBvaW50cyB8IENodW5rZWQgUG9pbnRzXG5cdCAgICAgKiAtLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tXG5cdCAgICAgKiAgICAgNC1iaXQgICB8ICAgICA1MjAgICAgICAgICB8ICAgICAgMTVcblx0ICAgICAqICAgICA4LWJpdCAgIHwgICAgNCwyMjQgICAgICAgIHwgICAgIDI1NVxuXHQgICAgICogICAgMTAtYml0ICAgfCAgIDEzLDgyNCAgICAgICAgfCAgIDEsMDIzXG5cdCAgICAgKiAgICAxNi1iaXQgICB8ICA1NTcsMDU2ICAgICAgICB8ICA2NSw1MzVcblx0ICAgICAqXG5cdCAgICAgKiBLZXkgQWR2YW50YWdlczpcblx0ICAgICAqIDEuIEVuYWJsZXMgbGFyZ2VyIHdpbmRvdyBzaXplcyBkdWUgdG8gcmVkdWNlZCBtZW1vcnkgb3ZlcmhlYWRcblx0ICAgICAqIDIuIE1vcmUgZWZmaWNpZW50IGZvciBzbWFsbGVyIHNjYWxhciBjb3VudHM6XG5cdCAgICAgKiAgICAtIDE2IGNodW5rczogKDE2IMOXIDI1NSkgKyAyNTYgPSA0LDMzNiBvcHNcblx0ICAgICAqICAgIC0gfjJ4IGZhc3RlciB0aGFuIHN0YW5kYXJkIDgsMTkxIG9wc1xuXHQgICAgICpcblx0ICAgICAqIExpbWl0YXRpb25zOlxuXHQgICAgICogLSBOb3Qgc3VpdGFibGUgZm9yIHBsYWluIHByZWNvbXB1dGVzIChyZXF1aXJlcyAyNTYgY29uc3RhbnQgZG91YmxpbmdzKVxuXHQgICAgICogLSBQZXJmb3JtYW5jZSBkZWdyYWRlcyB3aXRoIGxhcmdlciBzY2FsYXIgY291bnRzOlxuXHQgICAgICogICAtIE9wdGltYWwgZm9yIH4yNTYgc2NhbGFyc1xuXHQgICAgICogICAtIExlc3MgZWZmaWNpZW50IGZvciA0MDk2KyBzY2FsYXJzIChQaXBwZW5nZXIgcHJlZmVycmVkKVxuXHQgICAgICovXG5cdCAgICB2YWxpZGF0ZVcod2luZG93U2l6ZSwgZmllbGROLkJJVFMpO1xuXHQgICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcblx0ICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG5cdCAgICBjb25zdCB0YWJsZVNpemUgPSAyICoqIHdpbmRvd1NpemUgLSAxOyAvLyB0YWJsZSBzaXplICh3aXRob3V0IHplcm8pXG5cdCAgICBjb25zdCBjaHVua3MgPSBNYXRoLmNlaWwoZmllbGROLkJJVFMgLyB3aW5kb3dTaXplKTsgLy8gY2h1bmtzIG9mIGl0ZW1cblx0ICAgIGNvbnN0IE1BU0sgPSBCaWdJbnQoKDEgPDwgd2luZG93U2l6ZSkgLSAxKTtcblx0ICAgIGNvbnN0IHRhYmxlcyA9IHBvaW50cy5tYXAoKHApID0+IHtcblx0ICAgICAgICBjb25zdCByZXMgPSBbXTtcblx0ICAgICAgICBmb3IgKGxldCBpID0gMCwgYWNjID0gcDsgaSA8IHRhYmxlU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgIHJlcy5wdXNoKGFjYyk7XG5cdCAgICAgICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXM7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiAoc2NhbGFycykgPT4ge1xuXHQgICAgICAgIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZE4pO1xuXHQgICAgICAgIGlmIChzY2FsYXJzLmxlbmd0aCA+IHBvaW50cy5sZW5ndGgpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBtdXN0IGJlIHNtYWxsZXIgdGhhbiBhcnJheSBvZiBwb2ludHMnKTtcblx0ICAgICAgICBsZXQgcmVzID0gemVybztcblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rczsgaSsrKSB7XG5cdCAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gZG91YmxlIGlmIGFjY3VtdWxhdG9yIGlzIHN0aWxsIHplcm8uXG5cdCAgICAgICAgICAgIGlmIChyZXMgIT09IHplcm8pXG5cdCAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcblx0ICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuZG91YmxlKCk7XG5cdCAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoY2h1bmtzICogd2luZG93U2l6ZSAtIChpICsgMSkgKiB3aW5kb3dTaXplKTtcblx0ICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzY2FsYXJzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBuID0gc2NhbGFyc1tqXTtcblx0ICAgICAgICAgICAgICAgIGNvbnN0IGN1cnIgPSBOdW1iZXIoKG4gPj4gc2hpZnRCeSkgJiBNQVNLKTtcblx0ICAgICAgICAgICAgICAgIGlmICghY3Vycilcblx0ICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCB6ZXJvIHNjYWxhcnMgY2h1bmtzXG5cdCAgICAgICAgICAgICAgICByZXMgPSByZXMuYWRkKHRhYmxlc1tqXVtjdXJyIC0gMV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXM7XG5cdCAgICB9O1xuXHR9XG5cdGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcblx0ICAgICgwLCBtb2R1bGFyX2pzXzEudmFsaWRhdGVGaWVsZCkoY3VydmUuRnApO1xuXHQgICAgKDAsIHV0aWxzX2pzXzEudmFsaWRhdGVPYmplY3QpKGN1cnZlLCB7XG5cdCAgICAgICAgbjogJ2JpZ2ludCcsXG5cdCAgICAgICAgaDogJ2JpZ2ludCcsXG5cdCAgICAgICAgR3g6ICdmaWVsZCcsXG5cdCAgICAgICAgR3k6ICdmaWVsZCcsXG5cdCAgICB9LCB7XG5cdCAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuXHQgICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG5cdCAgICB9KTtcblx0ICAgIC8vIFNldCBkZWZhdWx0c1xuXHQgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuXHQgICAgICAgIC4uLigwLCBtb2R1bGFyX2pzXzEubkxlbmd0aCkoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG5cdCAgICAgICAgLi4uY3VydmUsXG5cdCAgICAgICAgLi4ueyBwOiBjdXJ2ZS5GcC5PUkRFUiB9LFxuXHQgICAgfSk7XG5cdH1cblx0XG5cdHJldHVybiBjdXJ2ZTtcbn1cblxudmFyIGVkd2FyZHMgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkRWR3YXJkcztcblxuZnVuY3Rpb24gcmVxdWlyZUVkd2FyZHMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRFZHdhcmRzKSByZXR1cm4gZWR3YXJkcztcblx0aGFzUmVxdWlyZWRFZHdhcmRzID0gMTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGVkd2FyZHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRlZHdhcmRzLnR3aXN0ZWRFZHdhcmRzID0gdHdpc3RlZEVkd2FyZHM7XG5cdC8qKlxuXHQgKiBUd2lzdGVkIEVkd2FyZHMgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiBheMKyICsgecKyID0gMSArIGR4wrJ5wrIuXG5cdCAqIEZvciBkZXNpZ24gcmF0aW9uYWxlIG9mIHR5cGVzIC8gZXhwb3J0cywgc2VlIHdlaWVyc3RyYXNzIG1vZHVsZSBkb2N1bWVudGF0aW9uLlxuXHQgKiBAbW9kdWxlXG5cdCAqL1xuXHQvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5cdGNvbnN0IGN1cnZlX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVDdXJ2ZSgpO1xuXHRjb25zdCBtb2R1bGFyX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVNb2R1bGFyKCk7XG5cdGNvbnN0IHV0ID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMkMSgpO1xuXHRjb25zdCB1dGlsc19qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMkMSgpO1xuXHQvLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcblx0Ly8gcHJldHRpZXItaWdub3JlXG5cdGNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF84biA9IEJpZ0ludCg4KTtcblx0Ly8gdmVyaWZpY2F0aW9uIHJ1bGUgaXMgZWl0aGVyIHppcDIxNSBvciByZmM4MDMyIC8gbmlzdDE4Ni01LiBDb25zdWx0IGZyb21IZXg6XG5cdGNvbnN0IFZFUklGWV9ERUZBVUxUID0geyB6aXAyMTU6IHRydWUgfTtcblx0ZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG5cdCAgICBjb25zdCBvcHRzID0gKDAsIGN1cnZlX2pzXzEudmFsaWRhdGVCYXNpYykoY3VydmUpO1xuXHQgICAgdXQudmFsaWRhdGVPYmplY3QoY3VydmUsIHtcblx0ICAgICAgICBoYXNoOiAnZnVuY3Rpb24nLFxuXHQgICAgICAgIGE6ICdiaWdpbnQnLFxuXHQgICAgICAgIGQ6ICdiaWdpbnQnLFxuXHQgICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuXHQgICAgfSwge1xuXHQgICAgICAgIGFkanVzdFNjYWxhckJ5dGVzOiAnZnVuY3Rpb24nLFxuXHQgICAgICAgIGRvbWFpbjogJ2Z1bmN0aW9uJyxcblx0ICAgICAgICB1dlJhdGlvOiAnZnVuY3Rpb24nLFxuXHQgICAgICAgIG1hcFRvQ3VydmU6ICdmdW5jdGlvbicsXG5cdCAgICB9KTtcblx0ICAgIC8vIFNldCBkZWZhdWx0c1xuXHQgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xuXHR9XG5cdC8qKlxuXHQgKiBDcmVhdGVzIFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZSB3aXRoIEVkRFNBIHNpZ25hdHVyZXMuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGltcG9ydCB7IEZpZWxkIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyJztcblx0ICogLy8gQmVmb3JlIHRoYXQsIGRlZmluZSBCaWdJbnQtczogYSwgZCwgcCwgbiwgR3gsIEd5LCBoXG5cdCAqIGNvbnN0IGN1cnZlID0gdHdpc3RlZEVkd2FyZHMoeyBhLCBkLCBGcDogRmllbGQocCksIG4sIEd4LCBHeSwgaCB9KVxuXHQgKi9cblx0ZnVuY3Rpb24gdHdpc3RlZEVkd2FyZHMoY3VydmVEZWYpIHtcblx0ICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcblx0ICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSLCBwcmVoYXNoOiBwcmVoYXNoLCBoYXNoOiBjSGFzaCwgcmFuZG9tQnl0ZXMsIG5CeXRlTGVuZ3RoLCBoOiBjb2ZhY3RvciwgfSA9IENVUlZFO1xuXHQgICAgLy8gSW1wb3J0YW50OlxuXHQgICAgLy8gVGhlcmUgYXJlIHNvbWUgcGxhY2VzIHdoZXJlIEZwLkJZVEVTIGlzIHVzZWQgaW5zdGVhZCBvZiBuQnl0ZUxlbmd0aC5cblx0ICAgIC8vIFNvIGZhciwgZXZlcnl0aGluZyBoYXMgYmVlbiB0ZXN0ZWQgd2l0aCBjdXJ2ZXMgb2YgRnAuQllURVMgPT0gbkJ5dGVMZW5ndGguXG5cdCAgICAvLyBUT0RPOiB0ZXN0IGFuZCBmaW5kIGN1cnZlcyB3aGljaCBiZWhhdmUgb3RoZXJ3aXNlLlxuXHQgICAgY29uc3QgTUFTSyA9IF8ybiA8PCAoQmlnSW50KG5CeXRlTGVuZ3RoICogOCkgLSBfMW4pO1xuXHQgICAgY29uc3QgbW9kUCA9IEZwLmNyZWF0ZTsgLy8gRnVuY3Rpb24gb3ZlcnJpZGVzXG5cdCAgICBjb25zdCBGbiA9ICgwLCBtb2R1bGFyX2pzXzEuRmllbGQpKENVUlZFLm4sIENVUlZFLm5CaXRMZW5ndGgpO1xuXHQgICAgLy8gc3FydCh1L3YpXG5cdCAgICBjb25zdCB1dlJhdGlvID0gQ1VSVkUudXZSYXRpbyB8fFxuXHQgICAgICAgICgodSwgdikgPT4ge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSwgdmFsdWU6IEZwLnNxcnQodSAqIEZwLmludih2KSkgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIHZhbHVlOiBfMG4gfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgY29uc3QgYWRqdXN0U2NhbGFyQnl0ZXMgPSBDVVJWRS5hZGp1c3RTY2FsYXJCeXRlcyB8fCAoKGJ5dGVzKSA9PiBieXRlcyk7IC8vIE5PT1Bcblx0ICAgIGNvbnN0IGRvbWFpbiA9IENVUlZFLmRvbWFpbiB8fFxuXHQgICAgICAgICgoZGF0YSwgY3R4LCBwaGZsYWcpID0+IHtcblx0ICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuYWJvb2wpKCdwaGZsYWcnLCBwaGZsYWcpO1xuXHQgICAgICAgICAgICBpZiAoY3R4Lmxlbmd0aCB8fCBwaGZsYWcpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHRzL3ByZS1oYXNoIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG5cdCAgICAgICAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgICAgIH0pOyAvLyBOT09QXG5cdCAgICAvLyAwIDw9IG4gPCBNQVNLXG5cdCAgICAvLyBDb29yZGluYXRlcyBsYXJnZXIgdGhhbiBGcC5PUkRFUiBhcmUgYWxsb3dlZCBmb3IgemlwMjE1XG5cdCAgICBmdW5jdGlvbiBhQ29vcmRpbmF0ZSh0aXRsZSwgbikge1xuXHQgICAgICAgIHV0LmFJblJhbmdlKCdjb29yZGluYXRlICcgKyB0aXRsZSwgbiwgXzBuLCBNQVNLKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGFzc2VydFBvaW50KG90aGVyKSB7XG5cdCAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZW5kZWRQb2ludCBleHBlY3RlZCcpO1xuXHQgICAgfVxuXHQgICAgLy8gQ29udmVydHMgRXh0ZW5kZWQgcG9pbnQgdG8gZGVmYXVsdCAoeCwgeSkgY29vcmRpbmF0ZXMuXG5cdCAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cblx0ICAgIGNvbnN0IHRvQWZmaW5lTWVtbyA9ICgwLCB1dGlsc19qc18xLm1lbW9pemVkKSgocCwgaXopID0+IHtcblx0ICAgICAgICBjb25zdCB7IGV4OiB4LCBleTogeSwgZXo6IHogfSA9IHA7XG5cdCAgICAgICAgY29uc3QgaXMwID0gcC5pczAoKTtcblx0ICAgICAgICBpZiAoaXogPT0gbnVsbClcblx0ICAgICAgICAgICAgaXogPSBpczAgPyBfOG4gOiBGcC5pbnYoeik7IC8vIDggd2FzIGNob3NlbiBhcmJpdHJhcmlseVxuXHQgICAgICAgIGNvbnN0IGF4ID0gbW9kUCh4ICogaXopO1xuXHQgICAgICAgIGNvbnN0IGF5ID0gbW9kUCh5ICogaXopO1xuXHQgICAgICAgIGNvbnN0IHp6ID0gbW9kUCh6ICogaXopO1xuXHQgICAgICAgIGlmIChpczApXG5cdCAgICAgICAgICAgIHJldHVybiB7IHg6IF8wbiwgeTogXzFuIH07XG5cdCAgICAgICAgaWYgKHp6ICE9PSBfMW4pXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuXHQgICAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xuXHQgICAgfSk7XG5cdCAgICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSAoMCwgdXRpbHNfanNfMS5tZW1vaXplZCkoKHApID0+IHtcblx0ICAgICAgICBjb25zdCB7IGEsIGQgfSA9IENVUlZFO1xuXHQgICAgICAgIGlmIChwLmlzMCgpKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpOyAvLyBUT0RPOiBvcHRpbWl6ZSwgd2l0aCB2YXJzIGJlbG93P1xuXHQgICAgICAgIC8vIEVxdWF0aW9uIGluIGFmZmluZSBjb29yZGluYXRlczogYXjCsiArIHnCsiA9IDEgKyBkeMKyecKyXG5cdCAgICAgICAgLy8gRXF1YXRpb24gaW4gcHJvamVjdGl2ZSBjb29yZGluYXRlcyAoWC9aLCBZL1osIFopOiAgKGFYwrIgKyBZwrIpWsKyID0gWuKBtCArIGRYwrJZwrJcblx0ICAgICAgICBjb25zdCB7IGV4OiBYLCBleTogWSwgZXo6IFosIGV0OiBUIH0gPSBwO1xuXHQgICAgICAgIGNvbnN0IFgyID0gbW9kUChYICogWCk7IC8vIFjCslxuXHQgICAgICAgIGNvbnN0IFkyID0gbW9kUChZICogWSk7IC8vIFnCslxuXHQgICAgICAgIGNvbnN0IFoyID0gbW9kUChaICogWik7IC8vIFrCslxuXHQgICAgICAgIGNvbnN0IFo0ID0gbW9kUChaMiAqIFoyKTsgLy8gWuKBtFxuXHQgICAgICAgIGNvbnN0IGFYMiA9IG1vZFAoWDIgKiBhKTsgLy8gYVjCslxuXHQgICAgICAgIGNvbnN0IGxlZnQgPSBtb2RQKFoyICogbW9kUChhWDIgKyBZMikpOyAvLyAoYVjCsiArIFnCsilawrJcblx0ICAgICAgICBjb25zdCByaWdodCA9IG1vZFAoWjQgKyBtb2RQKGQgKiBtb2RQKFgyICogWTIpKSk7IC8vIFrigbQgKyBkWMKyWcKyXG5cdCAgICAgICAgaWYgKGxlZnQgIT09IHJpZ2h0KVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCAoMSknKTtcblx0ICAgICAgICAvLyBJbiBFeHRlbmRlZCBjb29yZGluYXRlcyB3ZSBhbHNvIGhhdmUgVCwgd2hpY2ggaXMgeCp5PVQvWjogY2hlY2sgWCpZID09IFoqVFxuXHQgICAgICAgIGNvbnN0IFhZID0gbW9kUChYICogWSk7XG5cdCAgICAgICAgY29uc3QgWlQgPSBtb2RQKFogKiBUKTtcblx0ICAgICAgICBpZiAoWFkgIT09IFpUKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCAoMiknKTtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH0pO1xuXHQgICAgLy8gRXh0ZW5kZWQgUG9pbnQgd29ya3MgaW4gZXh0ZW5kZWQgY29vcmRpbmF0ZXM6ICh4LCB5LCB6LCB0KSDiiIsgKHg9eC96LCB5PXkveiwgdD14eSkuXG5cdCAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud2lzdGVkX0Vkd2FyZHNfY3VydmUjRXh0ZW5kZWRfY29vcmRpbmF0ZXNcblx0ICAgIGNsYXNzIFBvaW50IHtcblx0ICAgICAgICBjb25zdHJ1Y3RvcihleCwgZXksIGV6LCBldCkge1xuXHQgICAgICAgICAgICB0aGlzLmV4ID0gZXg7XG5cdCAgICAgICAgICAgIHRoaXMuZXkgPSBleTtcblx0ICAgICAgICAgICAgdGhpcy5leiA9IGV6O1xuXHQgICAgICAgICAgICB0aGlzLmV0ID0gZXQ7XG5cdCAgICAgICAgICAgIGFDb29yZGluYXRlKCd4JywgZXgpO1xuXHQgICAgICAgICAgICBhQ29vcmRpbmF0ZSgneScsIGV5KTtcblx0ICAgICAgICAgICAgYUNvb3JkaW5hdGUoJ3onLCBleik7XG5cdCAgICAgICAgICAgIGFDb29yZGluYXRlKCd0JywgZXQpO1xuXHQgICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBnZXQgeCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBnZXQgeSgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG5cdCAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuZGVkIHBvaW50IG5vdCBhbGxvd2VkJyk7XG5cdCAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcblx0ICAgICAgICAgICAgYUNvb3JkaW5hdGUoJ3gnLCB4KTtcblx0ICAgICAgICAgICAgYUNvb3JkaW5hdGUoJ3knLCB5KTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBfMW4sIG1vZFAoeCAqIHkpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5leikpO1xuXHQgICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTXVsdGlzY2FsYXIgTXVsdGlwbGljYXRpb25cblx0ICAgICAgICBzdGF0aWMgbXNtKHBvaW50cywgc2NhbGFycykge1xuXHQgICAgICAgICAgICByZXR1cm4gKDAsIGN1cnZlX2pzXzEucGlwcGVuZ2VyKShQb2ludCwgRm4sIHBvaW50cywgc2NhbGFycyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG5cdCAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuXHQgICAgICAgICAgICB3bmFmLnNldFdpbmRvd1NpemUodGhpcywgd2luZG93U2l6ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE5vdCByZXF1aXJlZCBmb3IgZnJvbUhleCgpLCB3aGljaCBhbHdheXMgY3JlYXRlcyB2YWxpZCBwb2ludHMuXG5cdCAgICAgICAgLy8gQ291bGQgYmUgdXNlZnVsIGZvciBmcm9tQWZmaW5lKCkuXG5cdCAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG5cdCAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cblx0ICAgICAgICBlcXVhbHMob3RoZXIpIHtcblx0ICAgICAgICAgICAgYXNzZXJ0UG9pbnQob3RoZXIpO1xuXHQgICAgICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxLCBlejogWjEgfSA9IHRoaXM7XG5cdCAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgyLCBleTogWTIsIGV6OiBaMiB9ID0gb3RoZXI7XG5cdCAgICAgICAgICAgIGNvbnN0IFgxWjIgPSBtb2RQKFgxICogWjIpO1xuXHQgICAgICAgICAgICBjb25zdCBYMloxID0gbW9kUChYMiAqIFoxKTtcblx0ICAgICAgICAgICAgY29uc3QgWTFaMiA9IG1vZFAoWTEgKiBaMik7XG5cdCAgICAgICAgICAgIGNvbnN0IFkyWjEgPSBtb2RQKFkyICogWjEpO1xuXHQgICAgICAgICAgICByZXR1cm4gWDFaMiA9PT0gWDJaMSAmJiBZMVoyID09PSBZMloxO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpczAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbmVnYXRlKCkge1xuXHQgICAgICAgICAgICAvLyBGbGlwcyBwb2ludCBzaWduIHRvIGEgbmVnYXRpdmUgb25lICgteCwgeSBpbiBhZmZpbmUgY29vcmRzKVxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KG1vZFAoLXRoaXMuZXgpLCB0aGlzLmV5LCB0aGlzLmV6LCBtb2RQKC10aGlzLmV0KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEZhc3QgYWxnbyBmb3IgZG91YmxpbmcgRXh0ZW5kZWQgUG9pbnQuXG5cdCAgICAgICAgLy8gaHR0cHM6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC5odG1sI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2Rcblx0ICAgICAgICAvLyBDb3N0OiA0TSArIDRTICsgMSphICsgNmFkZCArIDEqMi5cblx0ICAgICAgICBkb3VibGUoKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IHsgYSB9ID0gQ1VSVkU7XG5cdCAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgxLCBleTogWTEsIGV6OiBaMSB9ID0gdGhpcztcblx0ICAgICAgICAgICAgY29uc3QgQSA9IG1vZFAoWDEgKiBYMSk7IC8vIEEgPSBYMTJcblx0ICAgICAgICAgICAgY29uc3QgQiA9IG1vZFAoWTEgKiBZMSk7IC8vIEIgPSBZMTJcblx0ICAgICAgICAgICAgY29uc3QgQyA9IG1vZFAoXzJuICogbW9kUChaMSAqIFoxKSk7IC8vIEMgPSAyKloxMlxuXHQgICAgICAgICAgICBjb25zdCBEID0gbW9kUChhICogQSk7IC8vIEQgPSBhKkFcblx0ICAgICAgICAgICAgY29uc3QgeDF5MSA9IFgxICsgWTE7XG5cdCAgICAgICAgICAgIGNvbnN0IEUgPSBtb2RQKG1vZFAoeDF5MSAqIHgxeTEpIC0gQSAtIEIpOyAvLyBFID0gKFgxK1kxKTItQS1CXG5cdCAgICAgICAgICAgIGNvbnN0IEcgPSBEICsgQjsgLy8gRyA9IEQrQlxuXHQgICAgICAgICAgICBjb25zdCBGID0gRyAtIEM7IC8vIEYgPSBHLUNcblx0ICAgICAgICAgICAgY29uc3QgSCA9IEQgLSBCOyAvLyBIID0gRC1CXG5cdCAgICAgICAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7IC8vIFgzID0gRSpGXG5cdCAgICAgICAgICAgIGNvbnN0IFkzID0gbW9kUChHICogSCk7IC8vIFkzID0gRypIXG5cdCAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7IC8vIFQzID0gRSpIXG5cdCAgICAgICAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7IC8vIFozID0gRipHXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBGYXN0IGFsZ28gZm9yIGFkZGluZyAyIEV4dGVuZGVkIFBvaW50cy5cblx0ICAgICAgICAvLyBodHRwczovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLmh0bWwjYWRkaXRpb24tYWRkLTIwMDgtaHdjZFxuXHQgICAgICAgIC8vIENvc3Q6IDlNICsgMSphICsgMSpkICsgN2FkZC5cblx0ICAgICAgICBhZGQob3RoZXIpIHtcblx0ICAgICAgICAgICAgYXNzZXJ0UG9pbnQob3RoZXIpO1xuXHQgICAgICAgICAgICBjb25zdCB7IGEsIGQgfSA9IENVUlZFO1xuXHQgICAgICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxLCBlejogWjEsIGV0OiBUMSB9ID0gdGhpcztcblx0ICAgICAgICAgICAgY29uc3QgeyBleDogWDIsIGV5OiBZMiwgZXo6IFoyLCBldDogVDIgfSA9IG90aGVyO1xuXHQgICAgICAgICAgICAvLyBGYXN0ZXIgYWxnbyBmb3IgYWRkaW5nIDIgRXh0ZW5kZWQgUG9pbnRzIHdoZW4gY3VydmUncyBhPS0xLlxuXHQgICAgICAgICAgICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQtMS5odG1sI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2QtNFxuXHQgICAgICAgICAgICAvLyBDb3N0OiA4TSArIDhhZGQgKyAyKjIuXG5cdCAgICAgICAgICAgIC8vIE5vdGU6IEl0IGRvZXMgbm90IGNoZWNrIHdoZXRoZXIgdGhlIGBvdGhlcmAgcG9pbnQgaXMgdmFsaWQuXG5cdCAgICAgICAgICAgIGlmIChhID09PSBCaWdJbnQoLTEpKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBBID0gbW9kUCgoWTEgLSBYMSkgKiAoWTIgKyBYMikpO1xuXHQgICAgICAgICAgICAgICAgY29uc3QgQiA9IG1vZFAoKFkxICsgWDEpICogKFkyIC0gWDIpKTtcblx0ICAgICAgICAgICAgICAgIGNvbnN0IEYgPSBtb2RQKEIgLSBBKTtcblx0ICAgICAgICAgICAgICAgIGlmIChGID09PSBfMG4pXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG91YmxlKCk7IC8vIFNhbWUgcG9pbnQuIFRlc3RzIHNheSBpdCBkb2Vzbid0IGFmZmVjdCB0aW1pbmdcblx0ICAgICAgICAgICAgICAgIGNvbnN0IEMgPSBtb2RQKFoxICogXzJuICogVDIpO1xuXHQgICAgICAgICAgICAgICAgY29uc3QgRCA9IG1vZFAoVDEgKiBfMm4gKiBaMik7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBFID0gRCArIEM7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBHID0gQiArIEE7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBIID0gRCAtIEM7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpO1xuXHQgICAgICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTtcblx0ICAgICAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY29uc3QgQSA9IG1vZFAoWDEgKiBYMik7IC8vIEEgPSBYMSpYMlxuXHQgICAgICAgICAgICBjb25zdCBCID0gbW9kUChZMSAqIFkyKTsgLy8gQiA9IFkxKlkyXG5cdCAgICAgICAgICAgIGNvbnN0IEMgPSBtb2RQKFQxICogZCAqIFQyKTsgLy8gQyA9IFQxKmQqVDJcblx0ICAgICAgICAgICAgY29uc3QgRCA9IG1vZFAoWjEgKiBaMik7IC8vIEQgPSBaMSpaMlxuXHQgICAgICAgICAgICBjb25zdCBFID0gbW9kUCgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBBIC0gQik7IC8vIEUgPSAoWDErWTEpKihYMitZMiktQS1CXG5cdCAgICAgICAgICAgIGNvbnN0IEYgPSBEIC0gQzsgLy8gRiA9IEQtQ1xuXHQgICAgICAgICAgICBjb25zdCBHID0gRCArIEM7IC8vIEcgPSBEK0Ncblx0ICAgICAgICAgICAgY29uc3QgSCA9IG1vZFAoQiAtIGEgKiBBKTsgLy8gSCA9IEItYSpBXG5cdCAgICAgICAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7IC8vIFgzID0gRSpGXG5cdCAgICAgICAgICAgIGNvbnN0IFkzID0gbW9kUChHICogSCk7IC8vIFkzID0gRypIXG5cdCAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7IC8vIFQzID0gRSpIXG5cdCAgICAgICAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7IC8vIFozID0gRipHXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB3TkFGKG4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBuLCBQb2ludC5ub3JtYWxpemVaKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQ29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi5cblx0ICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcblx0ICAgICAgICAgICAgY29uc3QgbiA9IHNjYWxhcjtcblx0ICAgICAgICAgICAgdXQuYUluUmFuZ2UoJ3NjYWxhcicsIG4sIF8xbiwgQ1VSVkVfT1JERVIpOyAvLyAxIDw9IHNjYWxhciA8IExcblx0ICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG5cdCAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwLCBmXSlbMF07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cblx0ICAgICAgICAvLyBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuXHQgICAgICAgIC8vIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLlxuXHQgICAgICAgIC8vIERvZXMgTk9UIGFsbG93IHNjYWxhcnMgaGlnaGVyIHRoYW4gQ1VSVkUubi5cblx0ICAgICAgICAvLyBBY2NlcHRzIG9wdGlvbmFsIGFjY3VtdWxhdG9yIHRvIG1lcmdlIHdpdGggbXVsdGlwbHkgKGltcG9ydGFudCBmb3Igc3BhcnNlIHNjYWxhcnMpXG5cdCAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyLCBhY2MgPSBQb2ludC5aRVJPKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IG4gPSBzY2FsYXI7XG5cdCAgICAgICAgICAgIHV0LmFJblJhbmdlKCdzY2FsYXInLCBuLCBfMG4sIENVUlZFX09SREVSKTsgLy8gMCA8PSBzY2FsYXIgPCBMXG5cdCAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gSTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkgfHwgbiA9PT0gXzFuKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWRVbnNhZmUodGhpcywgbiwgUG9pbnQubm9ybWFsaXplWiwgYWNjKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQ2hlY2tzIGlmIHBvaW50IGlzIG9mIHNtYWxsIG9yZGVyLlxuXHQgICAgICAgIC8vIElmIHlvdSBhZGQgc29tZXRoaW5nIHRvIHNtYWxsIG9yZGVyIHBvaW50LCB5b3Ugd2lsbCBoYXZlIFwiZGlydHlcIlxuXHQgICAgICAgIC8vIHBvaW50IHdpdGggdG9yc2lvbiBjb21wb25lbnQuXG5cdCAgICAgICAgLy8gTXVsdGlwbGllcyBwb2ludCBieSBjb2ZhY3RvciBhbmQgY2hlY2tzIGlmIHRoZSByZXN1bHQgaXMgMC5cblx0ICAgICAgICBpc1NtYWxsT3JkZXIoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKS5pczAoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTXVsdGlwbGllcyBwb2ludCBieSBjdXJ2ZSBvcmRlciBhbmQgY2hlY2tzIGlmIHRoZSByZXN1bHQgaXMgMC5cblx0ICAgICAgICAvLyBSZXR1cm5zIGBmYWxzZWAgaXMgdGhlIHBvaW50IGlzIGRpcnR5LlxuXHQgICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBDVVJWRV9PUkRFUikuaXMwKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIENvbnZlcnRzIEV4dGVuZGVkIHBvaW50IHRvIGRlZmF1bHQgKHgsIHkpIGNvb3JkaW5hdGVzLlxuXHQgICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuXHQgICAgICAgIHRvQWZmaW5lKGl6KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0b0FmZmluZU1lbW8odGhpcywgaXopO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuXHQgICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yIH0gPSBDVVJWRTtcblx0ICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoY29mYWN0b3IpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuXHQgICAgICAgIC8vIFVzZXMgYWxnbyBmcm9tIFJGQzgwMzIgNS4xLjMuXG5cdCAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4LCB6aXAyMTUgPSBmYWxzZSkge1xuXHQgICAgICAgICAgICBjb25zdCB7IGQsIGEgfSA9IENVUlZFO1xuXHQgICAgICAgICAgICBjb25zdCBsZW4gPSBGcC5CWVRFUztcblx0ICAgICAgICAgICAgaGV4ID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdwb2ludEhleCcsIGhleCwgbGVuKTsgLy8gY29weSBoZXggdG8gYSBuZXcgYXJyYXlcblx0ICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuYWJvb2wpKCd6aXAyMTUnLCB6aXAyMTUpO1xuXHQgICAgICAgICAgICBjb25zdCBub3JtZWQgPSBoZXguc2xpY2UoKTsgLy8gY29weSBhZ2Fpbiwgd2UnbGwgbWFuaXB1bGF0ZSBpdFxuXHQgICAgICAgICAgICBjb25zdCBsYXN0Qnl0ZSA9IGhleFtsZW4gLSAxXTsgLy8gc2VsZWN0IGxhc3QgYnl0ZVxuXHQgICAgICAgICAgICBub3JtZWRbbGVuIC0gMV0gPSBsYXN0Qnl0ZSAmIH4weDgwOyAvLyBjbGVhciBsYXN0IGJpdFxuXHQgICAgICAgICAgICBjb25zdCB5ID0gdXQuYnl0ZXNUb051bWJlckxFKG5vcm1lZCk7XG5cdCAgICAgICAgICAgIC8vIHppcDIxNT10cnVlIGlzIGdvb2QgZm9yIGNvbnNlbnN1cy1jcml0aWNhbCBhcHBzLiA9ZmFsc2UgZm9sbG93cyBSRkM4MDMyIC8gTklTVDE4Ni01LlxuXHQgICAgICAgICAgICAvLyBSRkM4MDMyIHByb2hpYml0cyA+PSBwLCBidXQgWklQMjE1IGRvZXNuJ3Rcblx0ICAgICAgICAgICAgLy8gemlwMjE1PXRydWU6ICAwIDw9IHkgPCBNQVNLICgyXjI1NiBmb3IgZWQyNTUxOSlcblx0ICAgICAgICAgICAgLy8gemlwMjE1PWZhbHNlOiAwIDw9IHkgPCBQICgyXjI1NS0xOSBmb3IgZWQyNTUxOSlcblx0ICAgICAgICAgICAgY29uc3QgbWF4ID0gemlwMjE1ID8gTUFTSyA6IEZwLk9SREVSO1xuXHQgICAgICAgICAgICB1dC5hSW5SYW5nZSgncG9pbnRIZXgueScsIHksIF8wbiwgbWF4KTtcblx0ICAgICAgICAgICAgLy8gRWQyNTUxOTogeMKyID0gKHnCsi0xKS8oZHnCsisxKSBtb2QgcC4gRWQ0NDg6IHjCsiA9ICh5wrItMSkvKGR5wrItMSkgbW9kIHAuIEdlbmVyaWMgY2FzZTpcblx0ICAgICAgICAgICAgLy8gYXjCsit5wrI9MStkeMKyecKyID0+IHnCsi0xPWR4wrJ5wrItYXjCsiA9PiB5wrItMT14wrIoZHnCsi1hKSA9PiB4wrI9KHnCsi0xKS8oZHnCsi1hKVxuXHQgICAgICAgICAgICBjb25zdCB5MiA9IG1vZFAoeSAqIHkpOyAvLyBkZW5vbWluYXRvciBpcyBhbHdheXMgbm9uLTAgbW9kIHAuXG5cdCAgICAgICAgICAgIGNvbnN0IHUgPSBtb2RQKHkyIC0gXzFuKTsgLy8gdSA9IHnCsiAtIDFcblx0ICAgICAgICAgICAgY29uc3QgdiA9IG1vZFAoZCAqIHkyIC0gYSk7IC8vIHYgPSBkIHnCsiArIDEuXG5cdCAgICAgICAgICAgIGxldCB7IGlzVmFsaWQsIHZhbHVlOiB4IH0gPSB1dlJhdGlvKHUsIHYpOyAvLyDiiJoodS92KVxuXHQgICAgICAgICAgICBpZiAoIWlzVmFsaWQpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50LmZyb21IZXg6IGludmFsaWQgeSBjb29yZGluYXRlJyk7XG5cdCAgICAgICAgICAgIGNvbnN0IGlzWE9kZCA9ICh4ICYgXzFuKSA9PT0gXzFuOyAvLyBUaGVyZSBhcmUgMiBzcXVhcmUgcm9vdHMuIFVzZSB4XzAgYml0IHRvIHNlbGVjdCBwcm9wZXJcblx0ICAgICAgICAgICAgY29uc3QgaXNMYXN0Qnl0ZU9kZCA9IChsYXN0Qnl0ZSAmIDB4ODApICE9PSAwOyAvLyB4XzAsIGxhc3QgYml0XG5cdCAgICAgICAgICAgIGlmICghemlwMjE1ICYmIHggPT09IF8wbiAmJiBpc0xhc3RCeXRlT2RkKVxuXHQgICAgICAgICAgICAgICAgLy8gaWYgeD0wIGFuZCB4XzAgPSAxLCBmYWlsXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50LmZyb21IZXg6IHg9MCBhbmQgeF8wPTEnKTtcblx0ICAgICAgICAgICAgaWYgKGlzTGFzdEJ5dGVPZGQgIT09IGlzWE9kZClcblx0ICAgICAgICAgICAgICAgIHggPSBtb2RQKC14KTsgLy8gaWYgeF8wICE9IHggbW9kIDIsIHNldCB4ID0gcC14XG5cdCAgICAgICAgICAgIHJldHVybiBQb2ludC5mcm9tQWZmaW5lKHsgeCwgeSB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZLZXkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGdldEV4dGVuZGVkUHVibGljS2V5KHByaXZLZXkpLnBvaW50O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0b1Jhd0J5dGVzKCkge1xuXHQgICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcblx0ICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB1dC5udW1iZXJUb0J5dGVzTEUoeSwgRnAuQllURVMpOyAvLyBlYWNoIHkgaGFzIDIgeCB2YWx1ZXMgKHgsIC15KVxuXHQgICAgICAgICAgICBieXRlc1tieXRlcy5sZW5ndGggLSAxXSB8PSB4ICYgXzFuID8gMHg4MCA6IDA7IC8vIHdoZW4gY29tcHJlc3NpbmcsIGl0J3MgZW5vdWdoIHRvIHN0b3JlIHlcblx0ICAgICAgICAgICAgcmV0dXJuIGJ5dGVzOyAvLyBhbmQgdXNlIHRoZSBsYXN0IGJ5dGUgdG8gZW5jb2RlIHNpZ24gb2YgeFxuXHQgICAgICAgIH1cblx0ICAgICAgICB0b0hleCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKCkpOyAvLyBTYW1lIGFzIHRvUmF3Qnl0ZXMsIGJ1dCByZXR1cm5zIHN0cmluZy5cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgXzFuLCBtb2RQKENVUlZFLkd4ICogQ1VSVkUuR3kpKTtcblx0ICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoXzBuLCBfMW4sIF8xbiwgXzBuKTsgLy8gMCwgMSwgMSwgMFxuXHQgICAgY29uc3QgeyBCQVNFOiBHLCBaRVJPOiBJIH0gPSBQb2ludDtcblx0ICAgIGNvbnN0IHduYWYgPSAoMCwgY3VydmVfanNfMS53TkFGKShQb2ludCwgbkJ5dGVMZW5ndGggKiA4KTtcblx0ICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuXHQgICAgICAgIHJldHVybiAoMCwgbW9kdWxhcl9qc18xLm1vZCkoYSwgQ1VSVkVfT1JERVIpO1xuXHQgICAgfVxuXHQgICAgLy8gTGl0dGxlLWVuZGlhbiBTSEE1MTIgd2l0aCBtb2R1bG8gblxuXHQgICAgZnVuY3Rpb24gbW9kTl9MRShoYXNoKSB7XG5cdCAgICAgICAgcmV0dXJuIG1vZE4odXQuYnl0ZXNUb051bWJlckxFKGhhc2gpKTtcblx0ICAgIH1cblx0ICAgIC8qKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBjcmVhdGVzIHB1YmxpYyBrZXkgYW5kIG90aGVyIHN0dWZmLiBSRkM4MDMyIDUuMS41ICovXG5cdCAgICBmdW5jdGlvbiBnZXRFeHRlbmRlZFB1YmxpY0tleShrZXkpIHtcblx0ICAgICAgICBjb25zdCBsZW4gPSBGcC5CWVRFUztcblx0ICAgICAgICBrZXkgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3ByaXZhdGUga2V5Jywga2V5LCBsZW4pO1xuXHQgICAgICAgIC8vIEhhc2ggcHJpdmF0ZSBrZXkgd2l0aCBjdXJ2ZSdzIGhhc2ggZnVuY3Rpb24gdG8gcHJvZHVjZSB1bmlmb3JtaW5nbHkgcmFuZG9tIGlucHV0XG5cdCAgICAgICAgLy8gQ2hlY2sgYnl0ZSBsZW5ndGhzOiBlbnN1cmUoNjQsIGgoZW5zdXJlKDMyLCBrZXkpKSlcblx0ICAgICAgICBjb25zdCBoYXNoZWQgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ2hhc2hlZCBwcml2YXRlIGtleScsIGNIYXNoKGtleSksIDIgKiBsZW4pO1xuXHQgICAgICAgIGNvbnN0IGhlYWQgPSBhZGp1c3RTY2FsYXJCeXRlcyhoYXNoZWQuc2xpY2UoMCwgbGVuKSk7IC8vIGNsZWFyIGZpcnN0IGhhbGYgYml0cywgcHJvZHVjZSBGRVxuXHQgICAgICAgIGNvbnN0IHByZWZpeCA9IGhhc2hlZC5zbGljZShsZW4sIDIgKiBsZW4pOyAvLyBzZWNvbmQgaGFsZiBpcyBjYWxsZWQga2V5IHByZWZpeCAoNS4xLjYpXG5cdCAgICAgICAgY29uc3Qgc2NhbGFyID0gbW9kTl9MRShoZWFkKTsgLy8gVGhlIGFjdHVhbCBwcml2YXRlIHNjYWxhclxuXHQgICAgICAgIGNvbnN0IHBvaW50ID0gRy5tdWx0aXBseShzY2FsYXIpOyAvLyBQb2ludCBvbiBFZHdhcmRzIGN1cnZlIGFrYSBwdWJsaWMga2V5XG5cdCAgICAgICAgY29uc3QgcG9pbnRCeXRlcyA9IHBvaW50LnRvUmF3Qnl0ZXMoKTsgLy8gVWludDhBcnJheSByZXByZXNlbnRhdGlvblxuXHQgICAgICAgIHJldHVybiB7IGhlYWQsIHByZWZpeCwgc2NhbGFyLCBwb2ludCwgcG9pbnRCeXRlcyB9O1xuXHQgICAgfVxuXHQgICAgLy8gQ2FsY3VsYXRlcyBFZERTQSBwdWIga2V5LiBSRkM4MDMyIDUuMS41LiBQcml2a2V5IGlzIGhhc2hlZC4gVXNlIGZpcnN0IGhhbGYgd2l0aCAzIGJpdHMgY2xlYXJlZFxuXHQgICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZLZXkpIHtcblx0ICAgICAgICByZXR1cm4gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkocHJpdktleSkucG9pbnRCeXRlcztcblx0ICAgIH1cblx0ICAgIC8vIGludCgnTEUnLCBTSEE1MTIoZG9tMihGLCBDKSB8fCBtc2dzKSkgbW9kIE5cblx0ICAgIGZ1bmN0aW9uIGhhc2hEb21haW5Ub1NjYWxhcihjb250ZXh0ID0gbmV3IFVpbnQ4QXJyYXkoKSwgLi4ubXNncykge1xuXHQgICAgICAgIGNvbnN0IG1zZyA9IHV0LmNvbmNhdEJ5dGVzKC4uLm1zZ3MpO1xuXHQgICAgICAgIHJldHVybiBtb2ROX0xFKGNIYXNoKGRvbWFpbihtc2csICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnY29udGV4dCcsIGNvbnRleHQpLCAhIXByZWhhc2gpKSk7XG5cdCAgICB9XG5cdCAgICAvKiogU2lnbnMgbWVzc2FnZSB3aXRoIHByaXZhdGVLZXkuIFJGQzgwMzIgNS4xLjYgKi9cblx0ICAgIGZ1bmN0aW9uIHNpZ24obXNnLCBwcml2S2V5LCBvcHRpb25zID0ge30pIHtcblx0ICAgICAgICBtc2cgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtc2cpO1xuXHQgICAgICAgIGlmIChwcmVoYXNoKVxuXHQgICAgICAgICAgICBtc2cgPSBwcmVoYXNoKG1zZyk7IC8vIGZvciBlZDI1NTE5cGggZXRjLlxuXHQgICAgICAgIGNvbnN0IHsgcHJlZml4LCBzY2FsYXIsIHBvaW50Qnl0ZXMgfSA9IGdldEV4dGVuZGVkUHVibGljS2V5KHByaXZLZXkpO1xuXHQgICAgICAgIGNvbnN0IHIgPSBoYXNoRG9tYWluVG9TY2FsYXIob3B0aW9ucy5jb250ZXh0LCBwcmVmaXgsIG1zZyk7IC8vIHIgPSBkb20yKEYsIEMpIHx8IHByZWZpeCB8fCBQSChNKVxuXHQgICAgICAgIGNvbnN0IFIgPSBHLm11bHRpcGx5KHIpLnRvUmF3Qnl0ZXMoKTsgLy8gUiA9IHJHXG5cdCAgICAgICAgY29uc3QgayA9IGhhc2hEb21haW5Ub1NjYWxhcihvcHRpb25zLmNvbnRleHQsIFIsIHBvaW50Qnl0ZXMsIG1zZyk7IC8vIFIgfHwgQSB8fCBQSChNKVxuXHQgICAgICAgIGNvbnN0IHMgPSBtb2ROKHIgKyBrICogc2NhbGFyKTsgLy8gUyA9IChyICsgayAqIHMpIG1vZCBMXG5cdCAgICAgICAgdXQuYUluUmFuZ2UoJ3NpZ25hdHVyZS5zJywgcywgXzBuLCBDVVJWRV9PUkRFUik7IC8vIDAgPD0gcyA8IGxcblx0ICAgICAgICBjb25zdCByZXMgPSB1dC5jb25jYXRCeXRlcyhSLCB1dC5udW1iZXJUb0J5dGVzTEUocywgRnAuQllURVMpKTtcblx0ICAgICAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdyZXN1bHQnLCByZXMsIEZwLkJZVEVTICogMik7IC8vIDY0LWJ5dGUgc2lnbmF0dXJlXG5cdCAgICB9XG5cdCAgICBjb25zdCB2ZXJpZnlPcHRzID0gVkVSSUZZX0RFRkFVTFQ7XG5cdCAgICAvKipcblx0ICAgICAqIFZlcmlmaWVzIEVkRFNBIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgYW5kIHB1YmxpYyBrZXkuIFJGQzgwMzIgNS4xLjcuXG5cdCAgICAgKiBBbiBleHRlbmRlZCBncm91cCBlcXVhdGlvbiBpcyBjaGVja2VkLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnLCBtc2csIHB1YmxpY0tleSwgb3B0aW9ucyA9IHZlcmlmeU9wdHMpIHtcblx0ICAgICAgICBjb25zdCB7IGNvbnRleHQsIHppcDIxNSB9ID0gb3B0aW9ucztcblx0ICAgICAgICBjb25zdCBsZW4gPSBGcC5CWVRFUzsgLy8gVmVyaWZpZXMgRWREU0Egc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBhbmQgcHVibGljIGtleS4gUkZDODAzMiA1LjEuNy5cblx0ICAgICAgICBzaWcgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3NpZ25hdHVyZScsIHNpZywgMiAqIGxlbik7IC8vIEFuIGV4dGVuZGVkIGdyb3VwIGVxdWF0aW9uIGlzIGNoZWNrZWQuXG5cdCAgICAgICAgbXNnID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdtZXNzYWdlJywgbXNnKTtcblx0ICAgICAgICBwdWJsaWNLZXkgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgbGVuKTtcblx0ICAgICAgICBpZiAoemlwMjE1ICE9PSB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmFib29sKSgnemlwMjE1JywgemlwMjE1KTtcblx0ICAgICAgICBpZiAocHJlaGFzaClcblx0ICAgICAgICAgICAgbXNnID0gcHJlaGFzaChtc2cpOyAvLyBmb3IgZWQyNTUxOXBoLCBldGNcblx0ICAgICAgICBjb25zdCBzID0gdXQuYnl0ZXNUb051bWJlckxFKHNpZy5zbGljZShsZW4sIDIgKiBsZW4pKTtcblx0ICAgICAgICBsZXQgQSwgUiwgU0I7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgLy8gemlwMjE1PXRydWUgaXMgZ29vZCBmb3IgY29uc2Vuc3VzLWNyaXRpY2FsIGFwcHMuID1mYWxzZSBmb2xsb3dzIFJGQzgwMzIgLyBOSVNUMTg2LTUuXG5cdCAgICAgICAgICAgIC8vIHppcDIxNT10cnVlOiAgMCA8PSB5IDwgTUFTSyAoMl4yNTYgZm9yIGVkMjU1MTkpXG5cdCAgICAgICAgICAgIC8vIHppcDIxNT1mYWxzZTogMCA8PSB5IDwgUCAoMl4yNTUtMTkgZm9yIGVkMjU1MTkpXG5cdCAgICAgICAgICAgIEEgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSwgemlwMjE1KTtcblx0ICAgICAgICAgICAgUiA9IFBvaW50LmZyb21IZXgoc2lnLnNsaWNlKDAsIGxlbiksIHppcDIxNSk7XG5cdCAgICAgICAgICAgIFNCID0gRy5tdWx0aXBseVVuc2FmZShzKTsgLy8gMCA8PSBzIDwgbCBpcyBkb25lIGluc2lkZVxuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIXppcDIxNSAmJiBBLmlzU21hbGxPcmRlcigpKVxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgY29uc3QgayA9IGhhc2hEb21haW5Ub1NjYWxhcihjb250ZXh0LCBSLnRvUmF3Qnl0ZXMoKSwgQS50b1Jhd0J5dGVzKCksIG1zZyk7XG5cdCAgICAgICAgY29uc3QgUmtBID0gUi5hZGQoQS5tdWx0aXBseVVuc2FmZShrKSk7XG5cdCAgICAgICAgLy8gRXh0ZW5kZWQgZ3JvdXAgZXF1YXRpb25cblx0ICAgICAgICAvLyBbOF1bU11CID0gWzhdUiArIFs4XVtrXUEnXG5cdCAgICAgICAgcmV0dXJuIFJrQS5zdWJ0cmFjdChTQikuY2xlYXJDb2ZhY3RvcigpLmVxdWFscyhQb2ludC5aRVJPKTtcblx0ICAgIH1cblx0ICAgIEcuX3NldFdpbmRvd1NpemUoOCk7IC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cblx0ICAgIGNvbnN0IHV0aWxzID0ge1xuXHQgICAgICAgIGdldEV4dGVuZGVkUHVibGljS2V5LFxuXHQgICAgICAgIC8vIGVkMjU1MTkgcHJpdmF0ZSBrZXlzIGFyZSB1bmlmb3JtIDMyYi4gTm8gbmVlZCB0byBjaGVjayBmb3IgbW9kdWxvIGJpYXMsIGxpa2UgaW4gc2VjcDI1NmsxLlxuXHQgICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSxcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBXZSdyZSBkb2luZyBzY2FsYXIgbXVsdGlwbGljYXRpb24gKHVzZWQgaW4gZ2V0UHVibGljS2V5IGV0Yykgd2l0aCBwcmVjb21wdXRlZCBCQVNFX1BPSU5UXG5cdCAgICAgICAgICogdmFsdWVzLiBUaGlzIHNsb3dzIGRvd24gZmlyc3QgZ2V0UHVibGljS2V5KCkgYnkgbWlsbGlzZWNvbmRzIChzZWUgU3BlZWQgc2VjdGlvbiksXG5cdCAgICAgICAgICogYnV0IGFsbG93cyB0byBzcGVlZC11cCBzdWJzZXF1ZW50IGdldFB1YmxpY0tleSgpIGNhbGxzIHVwIHRvIDIweC5cblx0ICAgICAgICAgKiBAcGFyYW0gd2luZG93U2l6ZSAyLCA0LCA4LCAxNlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuXHQgICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcblx0ICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuXHQgICAgICAgIH0sXG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICBDVVJWRSxcblx0ICAgICAgICBnZXRQdWJsaWNLZXksXG5cdCAgICAgICAgc2lnbixcblx0ICAgICAgICB2ZXJpZnksXG5cdCAgICAgICAgRXh0ZW5kZWRQb2ludDogUG9pbnQsXG5cdCAgICAgICAgdXRpbHMsXG5cdCAgICB9O1xuXHR9XG5cdFxuXHRyZXR1cm4gZWR3YXJkcztcbn1cblxudmFyIGhhc2hUb0N1cnZlID0ge307XG5cbnZhciBoYXNSZXF1aXJlZEhhc2hUb0N1cnZlO1xuXG5mdW5jdGlvbiByZXF1aXJlSGFzaFRvQ3VydmUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRIYXNoVG9DdXJ2ZSkgcmV0dXJuIGhhc2hUb0N1cnZlO1xuXHRoYXNSZXF1aXJlZEhhc2hUb0N1cnZlID0gMTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGhhc2hUb0N1cnZlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0aGFzaFRvQ3VydmUuZXhwYW5kX21lc3NhZ2VfeG1kID0gZXhwYW5kX21lc3NhZ2VfeG1kO1xuXHRoYXNoVG9DdXJ2ZS5leHBhbmRfbWVzc2FnZV94b2YgPSBleHBhbmRfbWVzc2FnZV94b2Y7XG5cdGhhc2hUb0N1cnZlLmhhc2hfdG9fZmllbGQgPSBoYXNoX3RvX2ZpZWxkO1xuXHRoYXNoVG9DdXJ2ZS5pc29nZW55TWFwID0gaXNvZ2VueU1hcDtcblx0aGFzaFRvQ3VydmUuY3JlYXRlSGFzaGVyID0gY3JlYXRlSGFzaGVyO1xuXHRjb25zdCBtb2R1bGFyX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVNb2R1bGFyKCk7XG5cdGNvbnN0IHV0aWxzX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVVdGlscyQxKCk7XG5cdC8vIE9jdGV0IFN0cmVhbSB0byBJbnRlZ2VyLiBcInNwZWNcIiBpbXBsZW1lbnRhdGlvbiBvZiBvczJpcCBpcyAyLjV4IHNsb3dlciB2cyBieXRlc1RvTnVtYmVyQkUuXG5cdGNvbnN0IG9zMmlwID0gdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkU7XG5cdC8vIEludGVnZXIgdG8gT2N0ZXQgU3RyZWFtIChudW1iZXJUb0J5dGVzQkUpXG5cdGZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcblx0ICAgIGFudW0odmFsdWUpO1xuXHQgICAgYW51bShsZW5ndGgpO1xuXHQgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSlcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgSTJPU1AgaW5wdXQ6ICcgKyB2YWx1ZSk7XG5cdCAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XG5cdCAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG5cdCAgICAgICAgdmFsdWUgPj4+PSA4O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG5cdH1cblx0ZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcblx0ICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcblx0ICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGFycjtcblx0fVxuXHRmdW5jdGlvbiBhbnVtKGl0ZW0pIHtcblx0ICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaXRlbSkpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcblx0fVxuXHQvKipcblx0ICogUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0cy5cblx0ICogW1JGQyA5MzgwIDUuMy4xXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4xKS5cblx0ICovXG5cdGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuXHQgICAgKDAsIHV0aWxzX2pzXzEuYWJ5dGVzKShtc2cpO1xuXHQgICAgKDAsIHV0aWxzX2pzXzEuYWJ5dGVzKShEU1QpO1xuXHQgICAgYW51bShsZW5JbkJ5dGVzKTtcblx0ICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcblx0ICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuXHQgICAgICAgIERTVCA9IEgoKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKCgwLCB1dGlsc19qc18xLnV0ZjhUb0J5dGVzKSgnSDJDLU9WRVJTSVpFLURTVC0nKSwgRFNUKSk7XG5cdCAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG5cdCAgICBjb25zdCBlbGwgPSBNYXRoLmNlaWwobGVuSW5CeXRlcyAvIGJfaW5fYnl0ZXMpO1xuXHQgICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBlbGwgPiAyNTUpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94bWQ6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuXHQgICAgY29uc3QgRFNUX3ByaW1lID0gKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuXHQgICAgY29uc3QgWl9wYWQgPSBpMm9zcCgwLCByX2luX2J5dGVzKTtcblx0ICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG5cdCAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG5cdCAgICBjb25zdCBiXzAgPSBIKCgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKShaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcblx0ICAgIGJbMF0gPSBIKCgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKShiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcblx0ICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XG5cdCAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcblx0ICAgICAgICBiW2ldID0gSCgoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoLi4uYXJncykpO1xuXHQgICAgfVxuXHQgICAgY29uc3QgcHNldWRvX3JhbmRvbV9ieXRlcyA9ICgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSguLi5iKTtcblx0ICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xuXHR9XG5cdC8qKlxuXHQgKiBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYW4gZXh0ZW5kYWJsZS1vdXRwdXQgZnVuY3Rpb24gKFhPRikgSC5cblx0ICogMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG5cdCAqIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG5cdCAqICAgIGEgcmFuZG9tIG9yYWNsZSB1bmRlciBhIHJlYXNvbmFibGUgY3J5cHRvZ3JhcGhpYyBhc3N1bXB0aW9uLlxuXHQgKiBbUkZDIDkzODAgNS4zLjJdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG5cdCAgICAoMCwgdXRpbHNfanNfMS5hYnl0ZXMpKG1zZyk7XG5cdCAgICAoMCwgdXRpbHNfanNfMS5hYnl0ZXMpKERTVCk7XG5cdCAgICBhbnVtKGxlbkluQnl0ZXMpO1xuXHQgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuXHQgICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG5cdCAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuXHQgICAgICAgIGNvbnN0IGRrTGVuID0gTWF0aC5jZWlsKCgyICogaykgLyA4KTtcblx0ICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSgoMCwgdXRpbHNfanNfMS51dGY4VG9CeXRlcykoJ0gyQy1PVkVSU0laRS1EU1QtJykpLnVwZGF0ZShEU1QpLmRpZ2VzdCgpO1xuXHQgICAgfVxuXHQgICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBEU1QubGVuZ3RoID4gMjU1KVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcblx0ICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuXHQgICAgICAgIC51cGRhdGUobXNnKVxuXHQgICAgICAgIC51cGRhdGUoaTJvc3AobGVuSW5CeXRlcywgMikpXG5cdCAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuXHQgICAgICAgIC51cGRhdGUoRFNUKVxuXHQgICAgICAgIC51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpXG5cdCAgICAgICAgLmRpZ2VzdCgpKTtcblx0fVxuXHQvKipcblx0ICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGLlxuXHQgKiBbUkZDIDkzODAgNS4yXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMikuXG5cdCAqIEBwYXJhbSBtc2cgYSBieXRlIHN0cmluZyBjb250YWluaW5nIHRoZSBtZXNzYWdlIHRvIGhhc2hcblx0ICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcblx0ICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuXHQgKiBAcmV0dXJucyBbdV8wLCAuLi4sIHVfKGNvdW50IC0gMSldLCBhIGxpc3Qgb2YgZmllbGQgZWxlbWVudHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNoX3RvX2ZpZWxkKG1zZywgY291bnQsIG9wdGlvbnMpIHtcblx0ICAgICgwLCB1dGlsc19qc18xLnZhbGlkYXRlT2JqZWN0KShvcHRpb25zLCB7XG5cdCAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5Jyxcblx0ICAgICAgICBwOiAnYmlnaW50Jyxcblx0ICAgICAgICBtOiAnaXNTYWZlSW50ZWdlcicsXG5cdCAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuXHQgICAgICAgIGhhc2g6ICdoYXNoJyxcblx0ICAgIH0pO1xuXHQgICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcblx0ICAgICgwLCB1dGlsc19qc18xLmFieXRlcykobXNnKTtcblx0ICAgIGFudW0oY291bnQpO1xuXHQgICAgY29uc3QgRFNUID0gdHlwZW9mIF9EU1QgPT09ICdzdHJpbmcnID8gKDAsIHV0aWxzX2pzXzEudXRmOFRvQnl0ZXMpKF9EU1QpIDogX0RTVDtcblx0ICAgIGNvbnN0IGxvZzJwID0gcC50b1N0cmluZygyKS5sZW5ndGg7XG5cdCAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuXHQgICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcblx0ICAgIGxldCBwcmI7IC8vIHBzZXVkb19yYW5kb21fYnl0ZXNcblx0ICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG5cdCAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuXHQgICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuXHQgICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG5cdCAgICAgICAgcHJiID0gbXNnO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmQgbXVzdCBiZSBcInhtZFwiIG9yIFwieG9mXCInKTtcblx0ICAgIH1cblx0ICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuXHQgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcblx0ICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuXHQgICAgICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xuXHQgICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG5cdCAgICAgICAgICAgIGVbal0gPSAoMCwgbW9kdWxhcl9qc18xLm1vZCkob3MyaXAodHYpLCBwKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdVtpXSA9IGU7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdTtcblx0fVxuXHRmdW5jdGlvbiBpc29nZW55TWFwKGZpZWxkLCBtYXApIHtcblx0ICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG5cdCAgICBjb25zdCBDT0VGRiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcblx0ICAgIHJldHVybiAoeCwgeSkgPT4ge1xuXHQgICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcblx0ICAgICAgICB4ID0gZmllbGQuZGl2KHhOdW0sIHhEZW4pOyAvLyB4TnVtIC8geERlblxuXHQgICAgICAgIHkgPSBmaWVsZC5tdWwoeSwgZmllbGQuZGl2KHlOdW0sIHlEZW4pKTsgLy8geSAqICh5TnVtIC8geURldilcblx0ICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG5cdCAgICB9O1xuXHR9XG5cdC8qKiBDcmVhdGVzIGhhc2gtdG8tY3VydmUgbWV0aG9kcyBmcm9tIEVDIFBvaW50IGFuZCBtYXBUb0N1cnZlIGZ1bmN0aW9uLiAqL1xuXHRmdW5jdGlvbiBjcmVhdGVIYXNoZXIoUG9pbnQsIG1hcFRvQ3VydmUsIGRlZikge1xuXHQgICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuXHQgICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcblx0ICAgICAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuXHQgICAgICAgICAgICBjb25zdCB1MCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSk7XG5cdCAgICAgICAgICAgIGNvbnN0IHUxID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMV0pKTtcblx0ICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuXHQgICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG5cdCAgICAgICAgICAgIHJldHVybiBQO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cblx0ICAgICAgICAvLyBlbmNvZGVfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcblx0ICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuXHQgICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmLCBEU1Q6IGRlZi5lbmNvZGVEU1QsIC4uLm9wdGlvbnMgfSk7XG5cdCAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpLmNsZWFyQ29mYWN0b3IoKTtcblx0ICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuXHQgICAgICAgICAgICByZXR1cm4gUDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIC8vIFNhbWUgYXMgZW5jb2RlVG9DdXJ2ZSwgYnV0IHdpdGhvdXQgaGFzaFxuXHQgICAgICAgIG1hcFRvQ3VydmUoc2NhbGFycykge1xuXHQgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmU6IGV4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcblx0ICAgICAgICAgICAgZm9yIChjb25zdCBpIG9mIHNjYWxhcnMpXG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdiaWdpbnQnKVxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZTogZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cycpO1xuXHQgICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHNjYWxhcnMpKS5jbGVhckNvZmFjdG9yKCk7XG5cdCAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcblx0ICAgICAgICAgICAgcmV0dXJuIFA7XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cdH1cblx0XG5cdHJldHVybiBoYXNoVG9DdXJ2ZTtcbn1cblxudmFyIG1vbnRnb21lcnkgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkTW9udGdvbWVyeTtcblxuZnVuY3Rpb24gcmVxdWlyZU1vbnRnb21lcnkgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRNb250Z29tZXJ5KSByZXR1cm4gbW9udGdvbWVyeTtcblx0aGFzUmVxdWlyZWRNb250Z29tZXJ5ID0gMTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vbnRnb21lcnksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRtb250Z29tZXJ5Lm1vbnRnb21lcnkgPSBtb250Z29tZXJ5JDE7XG5cdC8qKlxuXHQgKiBNb250Z29tZXJ5IGN1cnZlIG1ldGhvZHMuIEl0J3Mgbm90IHJlYWxseSB3aG9sZSBtb250Z29tZXJ5IGN1cnZlLFxuXHQgKiBqdXN0IGJ1bmNoIG9mIHZlcnkgc3BlY2lmaWMgbWV0aG9kcyBmb3IgWDI1NTE5IC8gWDQ0OCBmcm9tXG5cdCAqIFtSRkMgNzc0OF0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzc3NDgpXG5cdCAqIEBtb2R1bGVcblx0ICovXG5cdC8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cblx0Y29uc3QgbW9kdWxhcl9qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlTW9kdWxhcigpO1xuXHRjb25zdCB1dGlsc19qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMkMSgpO1xuXHRjb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5cdGNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcblx0ZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG5cdCAgICAoMCwgdXRpbHNfanNfMS52YWxpZGF0ZU9iamVjdCkoY3VydmUsIHtcblx0ICAgICAgICBhOiAnYmlnaW50Jyxcblx0ICAgIH0sIHtcblx0ICAgICAgICBtb250Z29tZXJ5Qml0czogJ2lzU2FmZUludGVnZXInLFxuXHQgICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG5cdCAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6ICdmdW5jdGlvbicsXG5cdCAgICAgICAgZG9tYWluOiAnZnVuY3Rpb24nLFxuXHQgICAgICAgIHBvd1BtaW51czI6ICdmdW5jdGlvbicsXG5cdCAgICAgICAgR3U6ICdiaWdpbnQnLFxuXHQgICAgfSk7XG5cdCAgICAvLyBTZXQgZGVmYXVsdHNcblx0ICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4uY3VydmUgfSk7XG5cdH1cblx0Ly8gVXNlcyBvbmx5IG9uZSBjb29yZGluYXRlIGluc3RlYWQgb2YgdHdvXG5cdGZ1bmN0aW9uIG1vbnRnb21lcnkkMShjdXJ2ZURlZikge1xuXHQgICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuXHQgICAgY29uc3QgeyBQIH0gPSBDVVJWRTtcblx0ICAgIGNvbnN0IG1vZFAgPSAobikgPT4gKDAsIG1vZHVsYXJfanNfMS5tb2QpKG4sIFApO1xuXHQgICAgY29uc3QgbW9udGdvbWVyeUJpdHMgPSBDVVJWRS5tb250Z29tZXJ5Qml0cztcblx0ICAgIGNvbnN0IG1vbnRnb21lcnlCeXRlcyA9IE1hdGguY2VpbChtb250Z29tZXJ5Qml0cyAvIDgpO1xuXHQgICAgY29uc3QgZmllbGRMZW4gPSBDVVJWRS5uQnl0ZUxlbmd0aDtcblx0ICAgIGNvbnN0IGFkanVzdFNjYWxhckJ5dGVzID0gQ1VSVkUuYWRqdXN0U2NhbGFyQnl0ZXMgfHwgKChieXRlcykgPT4gYnl0ZXMpO1xuXHQgICAgY29uc3QgcG93UG1pbnVzMiA9IENVUlZFLnBvd1BtaW51czIgfHwgKCh4KSA9PiAoMCwgbW9kdWxhcl9qc18xLnBvdykoeCwgUCAtIEJpZ0ludCgyKSwgUCkpO1xuXHQgICAgLy8gY3N3YXAgZnJvbSBSRkM3NzQ4LiBCdXQgaXQgaXMgbm90IGZyb20gUkZDNzc0OCFcblx0ICAgIC8qXG5cdCAgICAgIGNzd2FwKHN3YXAsIHhfMiwgeF8zKTpcblx0ICAgICAgICAgICBkdW1teSA9IG1hc2soc3dhcCkgQU5EICh4XzIgWE9SIHhfMylcblx0ICAgICAgICAgICB4XzIgPSB4XzIgWE9SIGR1bW15XG5cdCAgICAgICAgICAgeF8zID0geF8zIFhPUiBkdW1teVxuXHQgICAgICAgICAgIFJldHVybiAoeF8yLCB4XzMpXG5cdCAgICBXaGVyZSBtYXNrKHN3YXApIGlzIHRoZSBhbGwtMSBvciBhbGwtMCB3b3JkIG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB4XzJcblx0ICAgICBhbmQgeF8zLCBjb21wdXRlZCwgZS5nLiwgYXMgbWFzayhzd2FwKSA9IDAgLSBzd2FwLlxuXHQgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGNzd2FwKHN3YXAsIHhfMiwgeF8zKSB7XG5cdCAgICAgICAgY29uc3QgZHVtbXkgPSBtb2RQKHN3YXAgKiAoeF8yIC0geF8zKSk7XG5cdCAgICAgICAgeF8yID0gbW9kUCh4XzIgLSBkdW1teSk7XG5cdCAgICAgICAgeF8zID0gbW9kUCh4XzMgKyBkdW1teSk7XG5cdCAgICAgICAgcmV0dXJuIFt4XzIsIHhfM107XG5cdCAgICB9XG5cdCAgICAvLyB4MjU1MTkgZnJvbSA0XG5cdCAgICAvLyBUaGUgY29uc3RhbnQgYTI0IGlzICg0ODY2NjIgLSAyKSAvIDQgPSAxMjE2NjUgZm9yIGN1cnZlMjU1MTkvWDI1NTE5XG5cdCAgICBjb25zdCBhMjQgPSAoQ1VSVkUuYSAtIEJpZ0ludCgyKSkgLyBCaWdJbnQoNCk7XG5cdCAgICAvKipcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gcG9pbnRVIHUgY29vcmRpbmF0ZSAoeCkgb24gTW9udGdvbWVyeSBDdXJ2ZSAyNTUxOVxuXHQgICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuXHQgICAgICogQHJldHVybnMgbmV3IFBvaW50IG9uIE1vbnRnb21lcnkgY3VydmVcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gbW9udGdvbWVyeUxhZGRlcih1LCBzY2FsYXIpIHtcblx0ICAgICAgICAoMCwgdXRpbHNfanNfMS5hSW5SYW5nZSkoJ3UnLCB1LCBfMG4sIFApO1xuXHQgICAgICAgICgwLCB1dGlsc19qc18xLmFJblJhbmdlKSgnc2NhbGFyJywgc2NhbGFyLCBfMG4sIFApO1xuXHQgICAgICAgIC8vIFNlY3Rpb24gNTogSW1wbGVtZW50YXRpb25zIE1VU1QgYWNjZXB0IG5vbi1jYW5vbmljYWwgdmFsdWVzIGFuZCBwcm9jZXNzIHRoZW0gYXNcblx0ICAgICAgICAvLyBpZiB0aGV5IGhhZCBiZWVuIHJlZHVjZWQgbW9kdWxvIHRoZSBmaWVsZCBwcmltZS5cblx0ICAgICAgICBjb25zdCBrID0gc2NhbGFyO1xuXHQgICAgICAgIGNvbnN0IHhfMSA9IHU7XG5cdCAgICAgICAgbGV0IHhfMiA9IF8xbjtcblx0ICAgICAgICBsZXQgel8yID0gXzBuO1xuXHQgICAgICAgIGxldCB4XzMgPSB1O1xuXHQgICAgICAgIGxldCB6XzMgPSBfMW47XG5cdCAgICAgICAgbGV0IHN3YXAgPSBfMG47XG5cdCAgICAgICAgbGV0IHN3O1xuXHQgICAgICAgIGZvciAobGV0IHQgPSBCaWdJbnQobW9udGdvbWVyeUJpdHMgLSAxKTsgdCA+PSBfMG47IHQtLSkge1xuXHQgICAgICAgICAgICBjb25zdCBrX3QgPSAoayA+PiB0KSAmIF8xbjtcblx0ICAgICAgICAgICAgc3dhcCBePSBrX3Q7XG5cdCAgICAgICAgICAgIHN3ID0gY3N3YXAoc3dhcCwgeF8yLCB4XzMpO1xuXHQgICAgICAgICAgICB4XzIgPSBzd1swXTtcblx0ICAgICAgICAgICAgeF8zID0gc3dbMV07XG5cdCAgICAgICAgICAgIHN3ID0gY3N3YXAoc3dhcCwgel8yLCB6XzMpO1xuXHQgICAgICAgICAgICB6XzIgPSBzd1swXTtcblx0ICAgICAgICAgICAgel8zID0gc3dbMV07XG5cdCAgICAgICAgICAgIHN3YXAgPSBrX3Q7XG5cdCAgICAgICAgICAgIGNvbnN0IEEgPSB4XzIgKyB6XzI7XG5cdCAgICAgICAgICAgIGNvbnN0IEFBID0gbW9kUChBICogQSk7XG5cdCAgICAgICAgICAgIGNvbnN0IEIgPSB4XzIgLSB6XzI7XG5cdCAgICAgICAgICAgIGNvbnN0IEJCID0gbW9kUChCICogQik7XG5cdCAgICAgICAgICAgIGNvbnN0IEUgPSBBQSAtIEJCO1xuXHQgICAgICAgICAgICBjb25zdCBDID0geF8zICsgel8zO1xuXHQgICAgICAgICAgICBjb25zdCBEID0geF8zIC0gel8zO1xuXHQgICAgICAgICAgICBjb25zdCBEQSA9IG1vZFAoRCAqIEEpO1xuXHQgICAgICAgICAgICBjb25zdCBDQiA9IG1vZFAoQyAqIEIpO1xuXHQgICAgICAgICAgICBjb25zdCBkYWNiID0gREEgKyBDQjtcblx0ICAgICAgICAgICAgY29uc3QgZGFfY2IgPSBEQSAtIENCO1xuXHQgICAgICAgICAgICB4XzMgPSBtb2RQKGRhY2IgKiBkYWNiKTtcblx0ICAgICAgICAgICAgel8zID0gbW9kUCh4XzEgKiBtb2RQKGRhX2NiICogZGFfY2IpKTtcblx0ICAgICAgICAgICAgeF8yID0gbW9kUChBQSAqIEJCKTtcblx0ICAgICAgICAgICAgel8yID0gbW9kUChFICogKEFBICsgbW9kUChhMjQgKiBFKSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyAoeF8yLCB4XzMpID0gY3N3YXAoc3dhcCwgeF8yLCB4XzMpXG5cdCAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB4XzIsIHhfMyk7XG5cdCAgICAgICAgeF8yID0gc3dbMF07XG5cdCAgICAgICAgeF8zID0gc3dbMV07XG5cdCAgICAgICAgLy8gKHpfMiwgel8zKSA9IGNzd2FwKHN3YXAsIHpfMiwgel8zKVxuXHQgICAgICAgIHN3ID0gY3N3YXAoc3dhcCwgel8yLCB6XzMpO1xuXHQgICAgICAgIHpfMiA9IHN3WzBdO1xuXHQgICAgICAgIHpfMyA9IHN3WzFdO1xuXHQgICAgICAgIC8vIHpfMl4ocCAtIDIpXG5cdCAgICAgICAgY29uc3QgejIgPSBwb3dQbWludXMyKHpfMik7XG5cdCAgICAgICAgLy8gUmV0dXJuIHhfMiAqICh6XzJeKHAgLSAyKSlcblx0ICAgICAgICByZXR1cm4gbW9kUCh4XzIgKiB6Mik7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBlbmNvZGVVQ29vcmRpbmF0ZSh1KSB7XG5cdCAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNMRSkobW9kUCh1KSwgbW9udGdvbWVyeUJ5dGVzKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGRlY29kZVVDb29yZGluYXRlKHVFbmMpIHtcblx0ICAgICAgICAvLyBTZWN0aW9uIDU6IFdoZW4gcmVjZWl2aW5nIHN1Y2ggYW4gYXJyYXksIGltcGxlbWVudGF0aW9ucyBvZiBYMjU1MTlcblx0ICAgICAgICAvLyBNVVNUIG1hc2sgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGluIHRoZSBmaW5hbCBieXRlLlxuXHQgICAgICAgIGNvbnN0IHUgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3UgY29vcmRpbmF0ZScsIHVFbmMsIG1vbnRnb21lcnlCeXRlcyk7XG5cdCAgICAgICAgaWYgKGZpZWxkTGVuID09PSAzMilcblx0ICAgICAgICAgICAgdVszMV0gJj0gMTI3OyAvLyAwYjAxMTFfMTExMVxuXHQgICAgICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyTEUpKHUpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZGVjb2RlU2NhbGFyKG4pIHtcblx0ICAgICAgICBjb25zdCBieXRlcyA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnc2NhbGFyJywgbik7XG5cdCAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuXHQgICAgICAgIGlmIChsZW4gIT09IG1vbnRnb21lcnlCeXRlcyAmJiBsZW4gIT09IGZpZWxkTGVuKSB7XG5cdCAgICAgICAgICAgIGxldCB2YWxpZCA9ICcnICsgbW9udGdvbWVyeUJ5dGVzICsgJyBvciAnICsgZmllbGRMZW47XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXIsIGV4cGVjdGVkICcgKyB2YWxpZCArICcgYnl0ZXMsIGdvdCAnICsgbGVuKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkoYWRqdXN0U2NhbGFyQnl0ZXMoYnl0ZXMpKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHNjYWxhck11bHQoc2NhbGFyLCB1KSB7XG5cdCAgICAgICAgY29uc3QgcG9pbnRVID0gZGVjb2RlVUNvb3JkaW5hdGUodSk7XG5cdCAgICAgICAgY29uc3QgX3NjYWxhciA9IGRlY29kZVNjYWxhcihzY2FsYXIpO1xuXHQgICAgICAgIGNvbnN0IHB1ID0gbW9udGdvbWVyeUxhZGRlcihwb2ludFUsIF9zY2FsYXIpO1xuXHQgICAgICAgIC8vIFRoZSByZXN1bHQgd2FzIG5vdCBjb250cmlidXRvcnlcblx0ICAgICAgICAvLyBodHRwczovL2NyLnlwLnRvL2VjZGguaHRtbCN2YWxpZGF0ZVxuXHQgICAgICAgIGlmIChwdSA9PT0gXzBuKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBvciBwdWJsaWMga2V5IHJlY2VpdmVkJyk7XG5cdCAgICAgICAgcmV0dXJuIGVuY29kZVVDb29yZGluYXRlKHB1KTtcblx0ICAgIH1cblx0ICAgIC8vIENvbXB1dGVzIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlLiBCeSBkb2luZyBzY2FsYXIgbXVsdGlwbGljYXRpb24gb2YgYmFzZSBwb2ludC5cblx0ICAgIGNvbnN0IEd1Qnl0ZXMgPSBlbmNvZGVVQ29vcmRpbmF0ZShDVVJWRS5HdSk7XG5cdCAgICBmdW5jdGlvbiBzY2FsYXJNdWx0QmFzZShzY2FsYXIpIHtcblx0ICAgICAgICByZXR1cm4gc2NhbGFyTXVsdChzY2FsYXIsIEd1Qnl0ZXMpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICBzY2FsYXJNdWx0LFxuXHQgICAgICAgIHNjYWxhck11bHRCYXNlLFxuXHQgICAgICAgIGdldFNoYXJlZFNlY3JldDogKHByaXZhdGVLZXksIHB1YmxpY0tleSkgPT4gc2NhbGFyTXVsdChwcml2YXRlS2V5LCBwdWJsaWNLZXkpLFxuXHQgICAgICAgIGdldFB1YmxpY0tleTogKHByaXZhdGVLZXkpID0+IHNjYWxhck11bHRCYXNlKHByaXZhdGVLZXkpLFxuXHQgICAgICAgIHV0aWxzOiB7IHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IENVUlZFLnJhbmRvbUJ5dGVzKENVUlZFLm5CeXRlTGVuZ3RoKSB9LFxuXHQgICAgICAgIEd1Qnl0ZXM6IEd1Qnl0ZXMsXG5cdCAgICB9O1xuXHR9XG5cdFxuXHRyZXR1cm4gbW9udGdvbWVyeTtcbn1cblxudmFyIGhhc1JlcXVpcmVkRWQyNTUxOTtcblxuZnVuY3Rpb24gcmVxdWlyZUVkMjU1MTkgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRFZDI1NTE5KSByZXR1cm4gZWQyNTUxOTtcblx0aGFzUmVxdWlyZWRFZDI1NTE5ID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRcdGV4cG9ydHMuaGFzaF90b19yaXN0cmV0dG8yNTUgPSBleHBvcnRzLmhhc2hUb1Jpc3RyZXR0bzI1NSA9IGV4cG9ydHMuUmlzdHJldHRvUG9pbnQgPSBleHBvcnRzLmVuY29kZVRvQ3VydmUgPSBleHBvcnRzLmhhc2hUb0N1cnZlID0gZXhwb3J0cy5lZHdhcmRzVG9Nb250Z29tZXJ5ID0gZXhwb3J0cy54MjU1MTkgPSBleHBvcnRzLmVkMjU1MTlwaCA9IGV4cG9ydHMuZWQyNTUxOWN0eCA9IGV4cG9ydHMuZWQyNTUxOSA9IGV4cG9ydHMuRUQyNTUxOV9UT1JTSU9OX1NVQkdST1VQID0gdm9pZCAwO1xuXHRcdGV4cG9ydHMuZWR3YXJkc1RvTW9udGdvbWVyeVB1YiA9IGVkd2FyZHNUb01vbnRnb21lcnlQdWI7XG5cdFx0ZXhwb3J0cy5lZHdhcmRzVG9Nb250Z29tZXJ5UHJpdiA9IGVkd2FyZHNUb01vbnRnb21lcnlQcml2O1xuXHRcdC8qKlxuXHRcdCAqIGVkMjU1MTkgVHdpc3RlZCBFZHdhcmRzIGN1cnZlIHdpdGggZm9sbG93aW5nIGFkZG9uczpcblx0XHQgKiAtIFgyNTUxOSBFQ0RIXG5cdFx0ICogLSBSaXN0cmV0dG8gY29mYWN0b3IgZWxpbWluYXRpb25cblx0XHQgKiAtIEVsbGlnYXRvciBoYXNoLXRvLWdyb3VwIC8gcG9pbnQgaW5kaXN0aW5ndWlzaGFiaWxpdHlcblx0XHQgKiBAbW9kdWxlXG5cdFx0ICovXG5cdFx0LyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuXHRcdGNvbnN0IHNoYTUxMl8xID0gLypAX19QVVJFX18qLyByZXF1aXJlU2hhNTEyKCk7XG5cdFx0Y29uc3QgdXRpbHNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZVV0aWxzJDIoKTtcblx0XHRjb25zdCBjdXJ2ZV9qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlQ3VydmUoKTtcblx0XHRjb25zdCBlZHdhcmRzX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVFZHdhcmRzKCk7XG5cdFx0Y29uc3QgaGFzaF90b19jdXJ2ZV9qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlSGFzaFRvQ3VydmUoKTtcblx0XHRjb25zdCBtb2R1bGFyX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVNb2R1bGFyKCk7XG5cdFx0Y29uc3QgbW9udGdvbWVyeV9qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlTW9udGdvbWVyeSgpO1xuXHRcdGNvbnN0IHV0aWxzX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVVdGlscyQxKCk7XG5cdFx0Y29uc3QgRUQyNTUxOV9QID0gQmlnSW50KCc1Nzg5NjA0NDYxODY1ODA5NzcxMTc4NTQ5MjUwNDM0Mzk1MzkyNjYzNDk5MjMzMjgyMDI4MjAxOTcyODc5MjAwMzk1NjU2NDgxOTk0OScpO1xuXHRcdC8vIOKImigtMSkgYWthIOKImihhKSBha2EgMl4oKHAtMSkvNClcblx0XHRjb25zdCBFRDI1NTE5X1NRUlRfTTEgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcxOTY4MTE2MTM3NjcwNzUwNTk1NjgwNzA3OTMwNDk4ODU0MjAxNTQ0NjA2NjUxNTkyMzg5MDE2Mjc0NDAyMTA3MzEyMzgyOTc4NDc1MicpO1xuXHRcdC8vIHByZXR0aWVyLWlnbm9yZVxuXHRcdGNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcblx0XHQvLyBwcmV0dGllci1pZ25vcmVcblx0XHRjb25zdCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcblx0XHRmdW5jdGlvbiBlZDI1NTE5X3Bvd18yXzI1Ml8zKHgpIHtcblx0XHQgICAgLy8gcHJldHRpZXItaWdub3JlXG5cdFx0ICAgIGNvbnN0IF8xMG4gPSBCaWdJbnQoMTApLCBfMjBuID0gQmlnSW50KDIwKSwgXzQwbiA9IEJpZ0ludCg0MCksIF84MG4gPSBCaWdJbnQoODApO1xuXHRcdCAgICBjb25zdCBQID0gRUQyNTUxOV9QO1xuXHRcdCAgICBjb25zdCB4MiA9ICh4ICogeCkgJSBQO1xuXHRcdCAgICBjb25zdCBiMiA9ICh4MiAqIHgpICUgUDsgLy8geF4zLCAxMVxuXHRcdCAgICBjb25zdCBiNCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIyLCBfMm4sIFApICogYjIpICUgUDsgLy8geF4xNSwgMTExMVxuXHRcdCAgICBjb25zdCBiNSA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI0LCBfMW4sIFApICogeCkgJSBQOyAvLyB4XjMxXG5cdFx0ICAgIGNvbnN0IGIxMCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI1LCBfNW4sIFApICogYjUpICUgUDtcblx0XHQgICAgY29uc3QgYjIwID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjEwLCBfMTBuLCBQKSAqIGIxMCkgJSBQO1xuXHRcdCAgICBjb25zdCBiNDAgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMjAsIF8yMG4sIFApICogYjIwKSAlIFA7XG5cdFx0ICAgIGNvbnN0IGI4MCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI0MCwgXzQwbiwgUCkgKiBiNDApICUgUDtcblx0XHQgICAgY29uc3QgYjE2MCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI4MCwgXzgwbiwgUCkgKiBiODApICUgUDtcblx0XHQgICAgY29uc3QgYjI0MCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIxNjAsIF84MG4sIFApICogYjgwKSAlIFA7XG5cdFx0ICAgIGNvbnN0IGIyNTAgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMjQwLCBfMTBuLCBQKSAqIGIxMCkgJSBQO1xuXHRcdCAgICBjb25zdCBwb3dfcF81XzggPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMjUwLCBfMm4sIFApICogeCkgJSBQO1xuXHRcdCAgICAvLyBeIFRvIHBvdyB0byAocCszKS84LCBtdWx0aXBseSBpdCBieSB4LlxuXHRcdCAgICByZXR1cm4geyBwb3dfcF81XzgsIGIyIH07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGFkanVzdFNjYWxhckJ5dGVzKGJ5dGVzKSB7XG5cdFx0ICAgIC8vIFNlY3Rpb24gNTogRm9yIFgyNTUxOSwgaW4gb3JkZXIgdG8gZGVjb2RlIDMyIHJhbmRvbSBieXRlcyBhcyBhbiBpbnRlZ2VyIHNjYWxhcixcblx0XHQgICAgLy8gc2V0IHRoZSB0aHJlZSBsZWFzdCBzaWduaWZpY2FudCBiaXRzIG9mIHRoZSBmaXJzdCBieXRlXG5cdFx0ICAgIGJ5dGVzWzBdICY9IDI0ODsgLy8gMGIxMTExXzEwMDBcblx0XHQgICAgLy8gYW5kIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCB0byB6ZXJvLFxuXHRcdCAgICBieXRlc1szMV0gJj0gMTI3OyAvLyAwYjAxMTFfMTExMVxuXHRcdCAgICAvLyBzZXQgdGhlIHNlY29uZCBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCBieXRlIHRvIDFcblx0XHQgICAgYnl0ZXNbMzFdIHw9IDY0OyAvLyAwYjAxMDBfMDAwMFxuXHRcdCAgICByZXR1cm4gYnl0ZXM7XG5cdFx0fVxuXHRcdC8vIHNxcnQodS92KVxuXHRcdGZ1bmN0aW9uIHV2UmF0aW8odSwgdikge1xuXHRcdCAgICBjb25zdCBQID0gRUQyNTUxOV9QO1xuXHRcdCAgICBjb25zdCB2MyA9ICgwLCBtb2R1bGFyX2pzXzEubW9kKSh2ICogdiAqIHYsIFApOyAvLyB2wrNcblx0XHQgICAgY29uc3QgdjcgPSAoMCwgbW9kdWxhcl9qc18xLm1vZCkodjMgKiB2MyAqIHYsIFApOyAvLyB24oG3XG5cdFx0ICAgIC8vIChwKzMpLzggYW5kIChwLTUpLzhcblx0XHQgICAgY29uc3QgcG93ID0gZWQyNTUxOV9wb3dfMl8yNTJfMyh1ICogdjcpLnBvd19wXzVfODtcblx0XHQgICAgbGV0IHggPSAoMCwgbW9kdWxhcl9qc18xLm1vZCkodSAqIHYzICogcG93LCBQKTsgLy8gKHV2wrMpKHV24oG3KV4ocC01KS84XG5cdFx0ICAgIGNvbnN0IHZ4MiA9ICgwLCBtb2R1bGFyX2pzXzEubW9kKSh2ICogeCAqIHgsIFApOyAvLyB2eMKyXG5cdFx0ICAgIGNvbnN0IHJvb3QxID0geDsgLy8gRmlyc3Qgcm9vdCBjYW5kaWRhdGVcblx0XHQgICAgY29uc3Qgcm9vdDIgPSAoMCwgbW9kdWxhcl9qc18xLm1vZCkoeCAqIEVEMjU1MTlfU1FSVF9NMSwgUCk7IC8vIFNlY29uZCByb290IGNhbmRpZGF0ZVxuXHRcdCAgICBjb25zdCB1c2VSb290MSA9IHZ4MiA9PT0gdTsgLy8gSWYgdnjCsiA9IHUgKG1vZCBwKSwgeCBpcyBhIHNxdWFyZSByb290XG5cdFx0ICAgIGNvbnN0IHVzZVJvb3QyID0gdngyID09PSAoMCwgbW9kdWxhcl9qc18xLm1vZCkoLXUsIFApOyAvLyBJZiB2eMKyID0gLXUsIHNldCB4IDwtLSB4ICogMl4oKHAtMSkvNClcblx0XHQgICAgY29uc3Qgbm9Sb290ID0gdngyID09PSAoMCwgbW9kdWxhcl9qc18xLm1vZCkoLXUgKiBFRDI1NTE5X1NRUlRfTTEsIFApOyAvLyBUaGVyZSBpcyBubyB2YWxpZCByb290LCB2eMKyID0gLXXiiJooLTEpXG5cdFx0ICAgIGlmICh1c2VSb290MSlcblx0XHQgICAgICAgIHggPSByb290MTtcblx0XHQgICAgaWYgKHVzZVJvb3QyIHx8IG5vUm9vdClcblx0XHQgICAgICAgIHggPSByb290MjsgLy8gV2UgcmV0dXJuIHJvb3QyIGFueXdheSwgZm9yIGNvbnN0LXRpbWVcblx0XHQgICAgaWYgKCgwLCBtb2R1bGFyX2pzXzEuaXNOZWdhdGl2ZUxFKSh4LCBQKSlcblx0XHQgICAgICAgIHggPSAoMCwgbW9kdWxhcl9qc18xLm1vZCkoLXgsIFApO1xuXHRcdCAgICByZXR1cm4geyBpc1ZhbGlkOiB1c2VSb290MSB8fCB1c2VSb290MiwgdmFsdWU6IHggfTtcblx0XHR9XG5cdFx0Ly8gSnVzdCBpbiBjYXNlXG5cdFx0ZXhwb3J0cy5FRDI1NTE5X1RPUlNJT05fU1VCR1JPVVAgPSBbXG5cdFx0ICAgICcwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcblx0XHQgICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzN2EnLFxuXHRcdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MCcsXG5cdFx0ICAgICcyNmU4OTU4ZmMyYjIyN2IwNDVjM2Y0ODlmMmVmOThmMGQ1ZGZhYzA1ZDNjNjMzMzliMTM4MDI4ODZkNTNmYzA1Jyxcblx0XHQgICAgJ2VjZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmN2YnLFxuXHRcdCAgICAnMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmM4NScsXG5cdFx0ICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcblx0XHQgICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzZmEnLFxuXHRcdF07XG5cdFx0Y29uc3QgRnAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICgwLCBtb2R1bGFyX2pzXzEuRmllbGQpKEVEMjU1MTlfUCwgdW5kZWZpbmVkLCB0cnVlKSkoKTtcblx0XHRjb25zdCBlZDI1NTE5RGVmYXVsdHMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG5cdFx0ICAgIC8vIFBhcmFtOiBhXG5cdFx0ICAgIGE6IEJpZ0ludCgtMSksIC8vIEZwLmNyZWF0ZSgtMSkgaXMgcHJvcGVyOyBvdXIgd2F5IHN0aWxsIHdvcmtzIGFuZCBpcyBmYXN0ZXJcblx0XHQgICAgLy8gZCBpcyBlcXVhbCB0byAtMTIxNjY1LzEyMTY2NiBvdmVyIGZpbml0ZSBmaWVsZC5cblx0XHQgICAgLy8gTmVnYXRpdmUgbnVtYmVyIGlzIFAgLSBudW1iZXIsIGFuZCBkaXZpc2lvbiBpcyBpbnZlcnQobnVtYmVyLCBQKVxuXHRcdCAgICBkOiBCaWdJbnQoJzM3MDk1NzA1OTM0NjY5NDM5MzQzMTM4MDgzNTA4NzU0NTY1MTg5NTQyMTEzODc5ODQzMjE5MDE2Mzg4Nzg1NTMzMDg1OTQwMjgzNTU1JyksXG5cdFx0ICAgIC8vIEZpbml0ZSBmaWVsZCDwnZS9cCBvdmVyIHdoaWNoIHdlJ2xsIGRvIGNhbGN1bGF0aW9uczsgMm4qKjI1NW4gLSAxOW5cblx0XHQgICAgRnAsXG5cdFx0ICAgIC8vIFN1Ymdyb3VwIG9yZGVyOiBob3cgbWFueSBwb2ludHMgY3VydmUgaGFzXG5cdFx0ICAgIC8vIDJuKioyNTJuICsgMjc3NDIzMTc3NzczNzIzNTM1MzU4NTE5Mzc3OTA4ODM2NDg0OTNuO1xuXHRcdCAgICBuOiBCaWdJbnQoJzcyMzcwMDU1NzczMzIyNjIyMTM5NzMxODY1NjMwNDI5OTQyNDA4NTcxMTYzNTkzNzk5MDc2MDYwMDE5NTA5MzgyODU0NTQyNTA5ODknKSxcblx0XHQgICAgLy8gQ29mYWN0b3Jcblx0XHQgICAgaDogXzhuLFxuXHRcdCAgICAvLyBCYXNlIHBvaW50ICh4LCB5KSBha2EgZ2VuZXJhdG9yIHBvaW50XG5cdFx0ICAgIEd4OiBCaWdJbnQoJzE1MTEyMjIxMzQ5NTM1NDAwNzcyNTAxMTUxNDA5NTg4NTMxNTExNDU0MDEyNjkzMDQxODU3MjA2MDQ2MTEzMjgzOTQ5ODQ3NzYyMjAyJyksXG5cdFx0ICAgIEd5OiBCaWdJbnQoJzQ2MzE2ODM1Njk0OTI2NDc4MTY5NDI4Mzk0MDAzNDc1MTYzMTQxMzA3OTkzODY2MjU2MjI1NjE1NzgzMDMzNjAzMTY1MjUxODU1OTYwJyksXG5cdFx0ICAgIGhhc2g6IHNoYTUxMl8xLnNoYTUxMixcblx0XHQgICAgcmFuZG9tQnl0ZXM6IHV0aWxzXzEucmFuZG9tQnl0ZXMsXG5cdFx0ICAgIGFkanVzdFNjYWxhckJ5dGVzLFxuXHRcdCAgICAvLyBkb20yXG5cdFx0ICAgIC8vIFJhdGlvIG9mIHUgdG8gdi4gQWxsb3dzIHVzIHRvIGNvbWJpbmUgaW52ZXJzaW9uIGFuZCBzcXVhcmUgcm9vdC4gVXNlcyBhbGdvIGZyb20gUkZDODAzMiA1LjEuMy5cblx0XHQgICAgLy8gQ29uc3RhbnQtdGltZSwgdS/iiJp2XG5cdFx0ICAgIHV2UmF0aW8sXG5cdFx0fSkpKCk7XG5cdFx0LyoqXG5cdFx0ICogZWQyNTUxOSBjdXJ2ZSB3aXRoIEVkRFNBIHNpZ25hdHVyZXMuXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBpbXBvcnQgeyBlZDI1NTE5IH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5Jztcblx0XHQgKiBjb25zdCBwcml2ID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG5cdFx0ICogY29uc3QgcHViID0gZWQyNTUxOS5nZXRQdWJsaWNLZXkocHJpdik7XG5cdFx0ICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuXHRcdCAqIGNvbnN0IHNpZyA9IGVkMjU1MTkuc2lnbihtc2csIHByaXYpO1xuXHRcdCAqIGVkMjU1MTkudmVyaWZ5KHNpZywgbXNnLCBwdWIpOyAvLyBEZWZhdWx0IG1vZGU6IGZvbGxvd3MgWklQMjE1XG5cdFx0ICogZWQyNTUxOS52ZXJpZnkoc2lnLCBtc2csIHB1YiwgeyB6aXAyMTU6IGZhbHNlIH0pOyAvLyBSRkM4MDMyIC8gRklQUyAxODYtNVxuXHRcdCAqL1xuXHRcdGV4cG9ydHMuZWQyNTUxOSA9ICgoKSA9PiAoMCwgZWR3YXJkc19qc18xLnR3aXN0ZWRFZHdhcmRzKShlZDI1NTE5RGVmYXVsdHMpKSgpO1xuXHRcdGZ1bmN0aW9uIGVkMjU1MTlfZG9tYWluKGRhdGEsIGN0eCwgcGhmbGFnKSB7XG5cdFx0ICAgIGlmIChjdHgubGVuZ3RoID4gMjU1KVxuXHRcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0IGlzIHRvbyBiaWcnKTtcblx0XHQgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKSgoMCwgdXRpbHNfMS51dGY4VG9CeXRlcykoJ1NpZ0VkMjU1MTkgbm8gRWQyNTUxOSBjb2xsaXNpb25zJyksIG5ldyBVaW50OEFycmF5KFtwaGZsYWcgPyAxIDogMCwgY3R4Lmxlbmd0aF0pLCBjdHgsIGRhdGEpO1xuXHRcdH1cblx0XHRleHBvcnRzLmVkMjU1MTljdHggPSAoKCkgPT4gKDAsIGVkd2FyZHNfanNfMS50d2lzdGVkRWR3YXJkcykoe1xuXHRcdCAgICAuLi5lZDI1NTE5RGVmYXVsdHMsXG5cdFx0ICAgIGRvbWFpbjogZWQyNTUxOV9kb21haW4sXG5cdFx0fSkpKCk7XG5cdFx0ZXhwb3J0cy5lZDI1NTE5cGggPSAoKCkgPT4gKDAsIGVkd2FyZHNfanNfMS50d2lzdGVkRWR3YXJkcykoT2JqZWN0LmFzc2lnbih7fSwgZWQyNTUxOURlZmF1bHRzLCB7XG5cdFx0ICAgIGRvbWFpbjogZWQyNTUxOV9kb21haW4sXG5cdFx0ICAgIHByZWhhc2g6IHNoYTUxMl8xLnNoYTUxMixcblx0XHR9KSkpKCk7XG5cdFx0LyoqXG5cdFx0ICogRUNESCB1c2luZyBjdXJ2ZTI1NTE5IGFrYSB4MjU1MTkuXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBpbXBvcnQgeyB4MjU1MTkgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTknO1xuXHRcdCAqIGNvbnN0IHByaXYgPSAnYTU0NmUzNmJmMDUyN2M5ZDNiMTYxNTRiODI0NjVlZGQ2MjE0NGMwYWMxZmM1YTE4NTA2YTIyNDRiYTQ0OWFjNCc7XG5cdFx0ICogY29uc3QgcHViID0gJ2U2ZGI2ODY3NTgzMDMwZGIzNTk0YzFhNDI0YjE1ZjdjNzI2NjI0ZWMyNmIzMzUzYjEwYTkwM2E2ZDBhYjFjNGMnO1xuXHRcdCAqIHgyNTUxOS5nZXRTaGFyZWRTZWNyZXQocHJpdiwgcHViKSA9PT0geDI1NTE5LnNjYWxhck11bHQocHJpdiwgcHViKTsgLy8gYWxpYXNlc1xuXHRcdCAqIHgyNTUxOS5nZXRQdWJsaWNLZXkocHJpdikgPT09IHgyNTUxOS5zY2FsYXJNdWx0QmFzZShwcml2KTtcblx0XHQgKiB4MjU1MTkuZ2V0UHVibGljS2V5KHgyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpO1xuXHRcdCAqL1xuXHRcdGV4cG9ydHMueDI1NTE5ID0gKCgpID0+ICgwLCBtb250Z29tZXJ5X2pzXzEubW9udGdvbWVyeSkoe1xuXHRcdCAgICBQOiBFRDI1NTE5X1AsXG5cdFx0ICAgIGE6IEJpZ0ludCg0ODY2NjIpLFxuXHRcdCAgICBtb250Z29tZXJ5Qml0czogMjU1LCAvLyBuIGlzIDI1MyBiaXRzXG5cdFx0ICAgIG5CeXRlTGVuZ3RoOiAzMixcblx0XHQgICAgR3U6IEJpZ0ludCg5KSxcblx0XHQgICAgcG93UG1pbnVzMjogKHgpID0+IHtcblx0XHQgICAgICAgIGNvbnN0IFAgPSBFRDI1NTE5X1A7XG5cdFx0ICAgICAgICAvLyB4XihwLTIpIGFrYSB4XigyXjI1NS0yMSlcblx0XHQgICAgICAgIGNvbnN0IHsgcG93X3BfNV84LCBiMiB9ID0gZWQyNTUxOV9wb3dfMl8yNTJfMyh4KTtcblx0XHQgICAgICAgIHJldHVybiAoMCwgbW9kdWxhcl9qc18xLm1vZCkoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShwb3dfcF81XzgsIF8zbiwgUCkgKiBiMiwgUCk7XG5cdFx0ICAgIH0sXG5cdFx0ICAgIGFkanVzdFNjYWxhckJ5dGVzLFxuXHRcdCAgICByYW5kb21CeXRlczogdXRpbHNfMS5yYW5kb21CeXRlcyxcblx0XHR9KSkoKTtcblx0XHQvKipcblx0XHQgKiBDb252ZXJ0cyBlZDI1NTE5IHB1YmxpYyBrZXkgdG8geDI1NTE5IHB1YmxpYyBrZXkuIFVzZXMgZm9ybXVsYTpcblx0XHQgKiAqIGAodSwgdikgPSAoKDEreSkvKDEteSksIHNxcnQoLTQ4NjY2NCkqdS94KWBcblx0XHQgKiAqIGAoeCwgeSkgPSAoc3FydCgtNDg2NjY0KSp1L3YsICh1LTEpLyh1KzEpKWBcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgY29uc3Qgc29tZW9uZXNQdWIgPSBlZDI1NTE5LmdldFB1YmxpY0tleShlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKSk7XG5cdFx0ICogICBjb25zdCBhUHJpdiA9IHgyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG5cdFx0ICogICB4MjU1MTkuZ2V0U2hhcmVkU2VjcmV0KGFQcml2LCBlZHdhcmRzVG9Nb250Z29tZXJ5UHViKHNvbWVvbmVzUHViKSlcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBlZHdhcmRzVG9Nb250Z29tZXJ5UHViKGVkd2FyZHNQdWIpIHtcblx0XHQgICAgY29uc3QgeyB5IH0gPSBleHBvcnRzLmVkMjU1MTkuRXh0ZW5kZWRQb2ludC5mcm9tSGV4KGVkd2FyZHNQdWIpO1xuXHRcdCAgICBjb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5cdFx0ICAgIHJldHVybiBGcC50b0J5dGVzKEZwLmNyZWF0ZSgoXzFuICsgeSkgKiBGcC5pbnYoXzFuIC0geSkpKTtcblx0XHR9XG5cdFx0ZXhwb3J0cy5lZHdhcmRzVG9Nb250Z29tZXJ5ID0gZWR3YXJkc1RvTW9udGdvbWVyeVB1YjsgLy8gZGVwcmVjYXRlZFxuXHRcdC8qKlxuXHRcdCAqIENvbnZlcnRzIGVkMjU1MTkgc2VjcmV0IGtleSB0byB4MjU1MTkgc2VjcmV0IGtleS5cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgY29uc3Qgc29tZW9uZXNQdWIgPSB4MjU1MTkuZ2V0UHVibGljS2V5KHgyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpO1xuXHRcdCAqICAgY29uc3QgYVByaXYgPSBlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcblx0XHQgKiAgIHgyNTUxOS5nZXRTaGFyZWRTZWNyZXQoZWR3YXJkc1RvTW9udGdvbWVyeVByaXYoYVByaXYpLCBzb21lb25lc1B1Yilcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdihlZHdhcmRzUHJpdikge1xuXHRcdCAgICBjb25zdCBoYXNoZWQgPSBlZDI1NTE5RGVmYXVsdHMuaGFzaChlZHdhcmRzUHJpdi5zdWJhcnJheSgwLCAzMikpO1xuXHRcdCAgICByZXR1cm4gZWQyNTUxOURlZmF1bHRzLmFkanVzdFNjYWxhckJ5dGVzKGhhc2hlZCkuc3ViYXJyYXkoMCwgMzIpO1xuXHRcdH1cblx0XHQvLyBIYXNoIFRvIEN1cnZlIEVsbGlnYXRvcjIgTWFwIChOT1RFOiBkaWZmZXJlbnQgZnJvbSByaXN0cmV0dG8yNTUgZWxsaWdhdG9yKVxuXHRcdC8vIE5PVEU6IHZlcnkgaW1wb3J0YW50IHBhcnQgaXMgdXNhZ2Ugb2YgRnBTcXJ0RXZlbiBmb3IgRUxMMl9DMV9FRFdBUkRTLCBzaW5jZVxuXHRcdC8vIFNhZ2VNYXRoIHJldHVybnMgZGlmZmVyZW50IHJvb3QgZmlyc3QgYW5kIGV2ZXJ5dGhpbmcgZmFsbHMgYXBhcnRcblx0XHRjb25zdCBFTEwyX0MxID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoRnAuT1JERVIgKyBfM24pIC8gXzhuKSgpOyAvLyAxLiBjMSA9IChxICsgMykgLyA4ICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG5cdFx0Y29uc3QgRUxMMl9DMiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gRnAucG93KF8ybiwgRUxMMl9DMSkpKCk7IC8vIDIuIGMyID0gMl5jMVxuXHRcdGNvbnN0IEVMTDJfQzMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZwLnNxcnQoRnAubmVnKEZwLk9ORSkpKSgpOyAvLyAzLiBjMyA9IHNxcnQoLTEpXG5cdFx0Ly8gcHJldHRpZXItaWdub3JlXG5cdFx0ZnVuY3Rpb24gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KSB7XG5cdFx0ICAgIGNvbnN0IEVMTDJfQzQgPSAoRnAuT1JERVIgLSBfNW4pIC8gXzhuOyAvLyA0LiBjNCA9IChxIC0gNSkgLyA4ICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG5cdFx0ICAgIGNvbnN0IEVMTDJfSiA9IEJpZ0ludCg0ODY2NjIpO1xuXHRcdCAgICBsZXQgdHYxID0gRnAuc3FyKHUpOyAvLyAgMS4gIHR2MSA9IHVeMlxuXHRcdCAgICB0djEgPSBGcC5tdWwodHYxLCBfMm4pOyAvLyAgMi4gIHR2MSA9IDIgKiB0djFcblx0XHQgICAgbGV0IHhkID0gRnAuYWRkKHR2MSwgRnAuT05FKTsgLy8gIDMuICAgeGQgPSB0djEgKyAxICAgICAgICAgIyBOb256ZXJvOiAtMSBpcyBzcXVhcmUgKG1vZCBwKSwgdHYxIGlzIG5vdFxuXHRcdCAgICBsZXQgeDFuID0gRnAubmVnKEVMTDJfSik7IC8vICA0LiAgeDFuID0gLUogICAgICAgICAgICAgICMgeDEgPSB4MW4gLyB4ZCA9IC1KIC8gKDEgKyAyICogdV4yKVxuXHRcdCAgICBsZXQgdHYyID0gRnAuc3FyKHhkKTsgLy8gIDUuICB0djIgPSB4ZF4yXG5cdFx0ICAgIGxldCBneGQgPSBGcC5tdWwodHYyLCB4ZCk7IC8vICA2LiAgZ3hkID0gdHYyICogeGQgICAgICAgICMgZ3hkID0geGReM1xuXHRcdCAgICBsZXQgZ3gxID0gRnAubXVsKHR2MSwgRUxMMl9KKTsgLy8gIDcuICBneDEgPSBKICogdHYxICAgICAgICAgIyB4MW4gKyBKICogeGRcblx0XHQgICAgZ3gxID0gRnAubXVsKGd4MSwgeDFuKTsgLy8gIDguICBneDEgPSBneDEgKiB4MW4gICAgICAgIyB4MW5eMiArIEogKiB4MW4gKiB4ZFxuXHRcdCAgICBneDEgPSBGcC5hZGQoZ3gxLCB0djIpOyAvLyAgOS4gIGd4MSA9IGd4MSArIHR2MiAgICAgICAjIHgxbl4yICsgSiAqIHgxbiAqIHhkICsgeGReMlxuXHRcdCAgICBneDEgPSBGcC5tdWwoZ3gxLCB4MW4pOyAvLyAgMTAuIGd4MSA9IGd4MSAqIHgxbiAgICAgICAjIHgxbl4zICsgSiAqIHgxbl4yICogeGQgKyB4MW4gKiB4ZF4yXG5cdFx0ICAgIGxldCB0djMgPSBGcC5zcXIoZ3hkKTsgLy8gIDExLiB0djMgPSBneGReMlxuXHRcdCAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gIDEyLiB0djIgPSB0djNeMiAgICAgICAgICAgIyBneGReNFxuXHRcdCAgICB0djMgPSBGcC5tdWwodHYzLCBneGQpOyAvLyAgMTMuIHR2MyA9IHR2MyAqIGd4ZCAgICAgICAjIGd4ZF4zXG5cdFx0ICAgIHR2MyA9IEZwLm11bCh0djMsIGd4MSk7IC8vICAxNC4gdHYzID0gdHYzICogZ3gxICAgICAgICMgZ3gxICogZ3hkXjNcblx0XHQgICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gIDE1LiB0djIgPSB0djIgKiB0djMgICAgICAgIyBneDEgKiBneGReN1xuXHRcdCAgICBsZXQgeTExID0gRnAucG93KHR2MiwgRUxMMl9DNCk7IC8vICAxNi4geTExID0gdHYyXmM0ICAgICAgICAjIChneDEgKiBneGReNyleKChwIC0gNSkgLyA4KVxuXHRcdCAgICB5MTEgPSBGcC5tdWwoeTExLCB0djMpOyAvLyAgMTcuIHkxMSA9IHkxMSAqIHR2MyAgICAgICAjIGd4MSpneGReMyooZ3gxKmd4ZF43KV4oKHAtNSkvOClcblx0XHQgICAgbGV0IHkxMiA9IEZwLm11bCh5MTEsIEVMTDJfQzMpOyAvLyAgMTguIHkxMiA9IHkxMSAqIGMzXG5cdFx0ICAgIHR2MiA9IEZwLnNxcih5MTEpOyAvLyAgMTkuIHR2MiA9IHkxMV4yXG5cdFx0ICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAyMC4gdHYyID0gdHYyICogZ3hkXG5cdFx0ICAgIGxldCBlMSA9IEZwLmVxbCh0djIsIGd4MSk7IC8vICAyMS4gIGUxID0gdHYyID09IGd4MVxuXHRcdCAgICBsZXQgeTEgPSBGcC5jbW92KHkxMiwgeTExLCBlMSk7IC8vICAyMi4gIHkxID0gQ01PVih5MTIsIHkxMSwgZTEpICAjIElmIGcoeDEpIGlzIHNxdWFyZSwgdGhpcyBpcyBpdHMgc3FydFxuXHRcdCAgICBsZXQgeDJuID0gRnAubXVsKHgxbiwgdHYxKTsgLy8gIDIzLiB4Mm4gPSB4MW4gKiB0djEgICAgICAgIyB4MiA9IHgybiAvIHhkID0gMiAqIHVeMiAqIHgxbiAvIHhkXG5cdFx0ICAgIGxldCB5MjEgPSBGcC5tdWwoeTExLCB1KTsgLy8gIDI0LiB5MjEgPSB5MTEgKiB1XG5cdFx0ICAgIHkyMSA9IEZwLm11bCh5MjEsIEVMTDJfQzIpOyAvLyAgMjUuIHkyMSA9IHkyMSAqIGMyXG5cdFx0ICAgIGxldCB5MjIgPSBGcC5tdWwoeTIxLCBFTEwyX0MzKTsgLy8gIDI2LiB5MjIgPSB5MjEgKiBjM1xuXHRcdCAgICBsZXQgZ3gyID0gRnAubXVsKGd4MSwgdHYxKTsgLy8gIDI3LiBneDIgPSBneDEgKiB0djEgICAgICAgIyBnKHgyKSA9IGd4MiAvIGd4ZCA9IDIgKiB1XjIgKiBnKHgxKVxuXHRcdCAgICB0djIgPSBGcC5zcXIoeTIxKTsgLy8gIDI4LiB0djIgPSB5MjFeMlxuXHRcdCAgICB0djIgPSBGcC5tdWwodHYyLCBneGQpOyAvLyAgMjkuIHR2MiA9IHR2MiAqIGd4ZFxuXHRcdCAgICBsZXQgZTIgPSBGcC5lcWwodHYyLCBneDIpOyAvLyAgMzAuICBlMiA9IHR2MiA9PSBneDJcblx0XHQgICAgbGV0IHkyID0gRnAuY21vdih5MjIsIHkyMSwgZTIpOyAvLyAgMzEuICB5MiA9IENNT1YoeTIyLCB5MjEsIGUyKSAgIyBJZiBnKHgyKSBpcyBzcXVhcmUsIHRoaXMgaXMgaXRzIHNxcnRcblx0XHQgICAgdHYyID0gRnAuc3FyKHkxKTsgLy8gIDMyLiB0djIgPSB5MV4yXG5cdFx0ICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAzMy4gdHYyID0gdHYyICogZ3hkXG5cdFx0ICAgIGxldCBlMyA9IEZwLmVxbCh0djIsIGd4MSk7IC8vICAzNC4gIGUzID0gdHYyID09IGd4MVxuXHRcdCAgICBsZXQgeG4gPSBGcC5jbW92KHgybiwgeDFuLCBlMyk7IC8vICAzNS4gIHhuID0gQ01PVih4Mm4sIHgxbiwgZTMpICAjIElmIGUzLCB4ID0geDEsIGVsc2UgeCA9IHgyXG5cdFx0ICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGUzKTsgLy8gIDM2LiAgIHkgPSBDTU9WKHkyLCB5MSwgZTMpICAgICMgSWYgZTMsIHkgPSB5MSwgZWxzZSB5ID0geTJcblx0XHQgICAgbGV0IGU0ID0gRnAuaXNPZGQoeSk7IC8vICAzNy4gIGU0ID0gc2duMCh5KSA9PSAxICAgICAgICAjIEZpeCBzaWduIG9mIHlcblx0XHQgICAgeSA9IEZwLmNtb3YoeSwgRnAubmVnKHkpLCBlMyAhPT0gZTQpOyAvLyAgMzguICAgeSA9IENNT1YoeSwgLXksIGUzIFhPUiBlNClcblx0XHQgICAgcmV0dXJuIHsgeE1uOiB4biwgeE1kOiB4ZCwgeU1uOiB5LCB5TWQ6IF8xbiB9OyAvLyAgMzkuIHJldHVybiAoeG4sIHhkLCB5LCAxKVxuXHRcdH1cblx0XHRjb25zdCBFTEwyX0MxX0VEV0FSRFMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICgwLCBtb2R1bGFyX2pzXzEuRnBTcXJ0RXZlbikoRnAsIEZwLm5lZyhCaWdJbnQoNDg2NjY0KSkpKSgpOyAvLyBzZ24wKGMxKSBNVVNUIGVxdWFsIDBcblx0XHRmdW5jdGlvbiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkodSkge1xuXHRcdCAgICBjb25zdCB7IHhNbiwgeE1kLCB5TW4sIHlNZCB9ID0gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KTsgLy8gIDEuICAoeE1uLCB4TWQsIHlNbiwgeU1kKSA9XG5cdFx0ICAgIC8vIG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2N1cnZlMjU1MTkodSlcblx0XHQgICAgbGV0IHhuID0gRnAubXVsKHhNbiwgeU1kKTsgLy8gIDIuICB4biA9IHhNbiAqIHlNZFxuXHRcdCAgICB4biA9IEZwLm11bCh4biwgRUxMMl9DMV9FRFdBUkRTKTsgLy8gIDMuICB4biA9IHhuICogYzFcblx0XHQgICAgbGV0IHhkID0gRnAubXVsKHhNZCwgeU1uKTsgLy8gIDQuICB4ZCA9IHhNZCAqIHlNbiAgICAjIHhuIC8geGQgPSBjMSAqIHhNIC8geU1cblx0XHQgICAgbGV0IHluID0gRnAuc3ViKHhNbiwgeE1kKTsgLy8gIDUuICB5biA9IHhNbiAtIHhNZFxuXHRcdCAgICBsZXQgeWQgPSBGcC5hZGQoeE1uLCB4TWQpOyAvLyAgNi4gIHlkID0geE1uICsgeE1kICAgICMgKG4gLyBkIC0gMSkgLyAobiAvIGQgKyAxKSA9IChuIC0gZCkgLyAobiArIGQpXG5cdFx0ICAgIGxldCB0djEgPSBGcC5tdWwoeGQsIHlkKTsgLy8gIDcuIHR2MSA9IHhkICogeWRcblx0XHQgICAgbGV0IGUgPSBGcC5lcWwodHYxLCBGcC5aRVJPKTsgLy8gIDguICAgZSA9IHR2MSA9PSAwXG5cdFx0ICAgIHhuID0gRnAuY21vdih4biwgRnAuWkVSTywgZSk7IC8vICA5LiAgeG4gPSBDTU9WKHhuLCAwLCBlKVxuXHRcdCAgICB4ZCA9IEZwLmNtb3YoeGQsIEZwLk9ORSwgZSk7IC8vICAxMC4geGQgPSBDTU9WKHhkLCAxLCBlKVxuXHRcdCAgICB5biA9IEZwLmNtb3YoeW4sIEZwLk9ORSwgZSk7IC8vICAxMS4geW4gPSBDTU9WKHluLCAxLCBlKVxuXHRcdCAgICB5ZCA9IEZwLmNtb3YoeWQsIEZwLk9ORSwgZSk7IC8vICAxMi4geWQgPSBDTU9WKHlkLCAxLCBlKVxuXHRcdCAgICBjb25zdCBpbnYgPSBGcC5pbnZlcnRCYXRjaChbeGQsIHlkXSk7IC8vIGJhdGNoIGRpdmlzaW9uXG5cdFx0ICAgIHJldHVybiB7IHg6IEZwLm11bCh4biwgaW52WzBdKSwgeTogRnAubXVsKHluLCBpbnZbMV0pIH07IC8vICAxMy4gcmV0dXJuICh4biwgeGQsIHluLCB5ZClcblx0XHR9XG5cdFx0Y29uc3QgaHRmID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgaGFzaF90b19jdXJ2ZV9qc18xLmNyZWF0ZUhhc2hlcikoZXhwb3J0cy5lZDI1NTE5LkV4dGVuZGVkUG9pbnQsIChzY2FsYXJzKSA9PiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkoc2NhbGFyc1swXSksIHtcblx0XHQgICAgRFNUOiAnZWR3YXJkczI1NTE5X1hNRDpTSEEtNTEyX0VMTDJfUk9fJyxcblx0XHQgICAgZW5jb2RlRFNUOiAnZWR3YXJkczI1NTE5X1hNRDpTSEEtNTEyX0VMTDJfTlVfJyxcblx0XHQgICAgcDogRnAuT1JERVIsXG5cdFx0ICAgIG06IDEsXG5cdFx0ICAgIGs6IDEyOCxcblx0XHQgICAgZXhwYW5kOiAneG1kJyxcblx0XHQgICAgaGFzaDogc2hhNTEyXzEuc2hhNTEyLFxuXHRcdH0pKSgpO1xuXHRcdGV4cG9ydHMuaGFzaFRvQ3VydmUgPSAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuXHRcdGV4cG9ydHMuZW5jb2RlVG9DdXJ2ZSA9ICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcblx0XHRmdW5jdGlvbiBhc3NlcnRSc3RQb2ludChvdGhlcikge1xuXHRcdCAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFJpc3RQb2ludCkpXG5cdFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jpc3RyZXR0b1BvaW50IGV4cGVjdGVkJyk7XG5cdFx0fVxuXHRcdC8vIOKImigtMSkgYWthIOKImihhKSBha2EgMl4oKHAtMSkvNClcblx0XHRjb25zdCBTUVJUX00xID0gRUQyNTUxOV9TUVJUX00xO1xuXHRcdC8vIOKImihhZCAtIDEpXG5cdFx0Y29uc3QgU1FSVF9BRF9NSU5VU19PTkUgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcyNTA2MzA2ODk1MzM4NDYyMzQ3NDExMTQxNDE1ODcwMjE1MjcwMTI0NDUzMTUwMjQ5MjY1NjQ2MDA3OTIxMDQ4MjYxMDQzMDc1MDIzNScpO1xuXHRcdC8vIDEgLyDiiJooYS1kKVxuXHRcdGNvbnN0IElOVlNRUlRfQV9NSU5VU19EID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnNTQ0NjkzMDcwMDg5MDkzMTY5MjA5OTU4MTM4Njg3NDUxNDE2MDUzOTM1OTcyOTI5Mjc0NTY5MjEyMDUzMTI4OTYzMTE3MjEwMTc1NzgnKTtcblx0XHQvLyAxLWTCslxuXHRcdGNvbnN0IE9ORV9NSU5VU19EX1NRID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnMTE1OTg0MzAyMTY2ODc3OTg3OTE5Mzc3NTUyMTg1NTU4NjY0NzkzNzM1Nzc1OTcxNTQxNzY1NDQzOTg3OTcyMDg3NjExMTgwNjgzOCcpO1xuXHRcdC8vIChkLTEpwrJcblx0XHRjb25zdCBEX01JTlVTX09ORV9TUSA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzQwNDQwODM0MzQ2MzA4NTM2ODU4MTAxMDQyNDY5MzIzMTkwODI2MjQ4Mzk5MTQ2MjM4NzA4MzUyMjQwMTMzMjIwODY1MTM3MjY1OTUyJyk7XG5cdFx0Ly8gQ2FsY3VsYXRlcyAxL+KImihudW1iZXIpXG5cdFx0Y29uc3QgaW52ZXJ0U3FydCA9IChudW1iZXIpID0+IHV2UmF0aW8oXzFuLCBudW1iZXIpO1xuXHRcdGNvbnN0IE1BWF8yNTVCID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJyk7XG5cdFx0Y29uc3QgYnl0ZXMyNTVUb051bWJlckxFID0gKGJ5dGVzKSA9PiBleHBvcnRzLmVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlKCgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkoYnl0ZXMpICYgTUFYXzI1NUIpO1xuXHRcdC8vIENvbXB1dGVzIEVsbGlnYXRvciBtYXAgZm9yIFJpc3RyZXR0b1xuXHRcdC8vIGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2VsbGlnYXRvci5odG1sXG5cdFx0ZnVuY3Rpb24gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMCkge1xuXHRcdCAgICBjb25zdCB7IGQgfSA9IGV4cG9ydHMuZWQyNTUxOS5DVVJWRTtcblx0XHQgICAgY29uc3QgUCA9IGV4cG9ydHMuZWQyNTUxOS5DVVJWRS5GcC5PUkRFUjtcblx0XHQgICAgY29uc3QgbW9kID0gZXhwb3J0cy5lZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZTtcblx0XHQgICAgY29uc3QgciA9IG1vZChTUVJUX00xICogcjAgKiByMCk7IC8vIDFcblx0XHQgICAgY29uc3QgTnMgPSBtb2QoKHIgKyBfMW4pICogT05FX01JTlVTX0RfU1EpOyAvLyAyXG5cdFx0ICAgIGxldCBjID0gQmlnSW50KC0xKTsgLy8gM1xuXHRcdCAgICBjb25zdCBEID0gbW9kKChjIC0gZCAqIHIpICogbW9kKHIgKyBkKSk7IC8vIDRcblx0XHQgICAgbGV0IHsgaXNWYWxpZDogTnNfRF9pc19zcSwgdmFsdWU6IHMgfSA9IHV2UmF0aW8oTnMsIEQpOyAvLyA1XG5cdFx0ICAgIGxldCBzXyA9IG1vZChzICogcjApOyAvLyA2XG5cdFx0ICAgIGlmICghKDAsIG1vZHVsYXJfanNfMS5pc05lZ2F0aXZlTEUpKHNfLCBQKSlcblx0XHQgICAgICAgIHNfID0gbW9kKC1zXyk7XG5cdFx0ICAgIGlmICghTnNfRF9pc19zcSlcblx0XHQgICAgICAgIHMgPSBzXzsgLy8gN1xuXHRcdCAgICBpZiAoIU5zX0RfaXNfc3EpXG5cdFx0ICAgICAgICBjID0gcjsgLy8gOFxuXHRcdCAgICBjb25zdCBOdCA9IG1vZChjICogKHIgLSBfMW4pICogRF9NSU5VU19PTkVfU1EgLSBEKTsgLy8gOVxuXHRcdCAgICBjb25zdCBzMiA9IHMgKiBzO1xuXHRcdCAgICBjb25zdCBXMCA9IG1vZCgocyArIHMpICogRCk7IC8vIDEwXG5cdFx0ICAgIGNvbnN0IFcxID0gbW9kKE50ICogU1FSVF9BRF9NSU5VU19PTkUpOyAvLyAxMVxuXHRcdCAgICBjb25zdCBXMiA9IG1vZChfMW4gLSBzMik7IC8vIDEyXG5cdFx0ICAgIGNvbnN0IFczID0gbW9kKF8xbiArIHMyKTsgLy8gMTNcblx0XHQgICAgcmV0dXJuIG5ldyBleHBvcnRzLmVkMjU1MTkuRXh0ZW5kZWRQb2ludChtb2QoVzAgKiBXMyksIG1vZChXMiAqIFcxKSwgbW9kKFcxICogVzMpLCBtb2QoVzAgKiBXMikpO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBFYWNoIGVkMjU1MTkvRXh0ZW5kZWRQb2ludCBoYXMgOCBkaWZmZXJlbnQgZXF1aXZhbGVudCBwb2ludHMuIFRoaXMgY2FuIGJlXG5cdFx0ICogYSBzb3VyY2Ugb2YgYnVncyBmb3IgcHJvdG9jb2xzIGxpa2UgcmluZyBzaWduYXR1cmVzLiBSaXN0cmV0dG8gd2FzIGNyZWF0ZWQgdG8gc29sdmUgdGhpcy5cblx0XHQgKiBSaXN0cmV0dG8gcG9pbnQgb3BlcmF0ZXMgaW4gWDpZOlo6VCBleHRlbmRlZCBjb29yZGluYXRlcyBsaWtlIEV4dGVuZGVkUG9pbnQsXG5cdFx0ICogYnV0IGl0IHNob3VsZCB3b3JrIGluIGl0cyBvd24gbmFtZXNwYWNlOiBkbyBub3QgY29tYmluZSB0aG9zZSB0d28uXG5cdFx0ICogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctcmlzdHJldHRvMjU1LWRlY2FmNDQ4XG5cdFx0ICovXG5cdFx0Y2xhc3MgUmlzdFBvaW50IHtcblx0XHQgICAgLy8gUHJpdmF0ZSBwcm9wZXJ0eSB0byBkaXNjb3VyYWdlIGNvbWJpbmluZyBFeHRlbmRlZFBvaW50ICsgUmlzdHJldHRvUG9pbnRcblx0XHQgICAgLy8gQWx3YXlzIHVzZSBSaXN0cmV0dG8gZW5jb2RpbmcvZGVjb2RpbmcgaW5zdGVhZC5cblx0XHQgICAgY29uc3RydWN0b3IoZXApIHtcblx0XHQgICAgICAgIHRoaXMuZXAgPSBlcDtcblx0XHQgICAgfVxuXHRcdCAgICBzdGF0aWMgZnJvbUFmZmluZShhcCkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQoZXhwb3J0cy5lZDI1NTE5LkV4dGVuZGVkUG9pbnQuZnJvbUFmZmluZShhcCkpO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBUYWtlcyB1bmlmb3JtIG91dHB1dCBvZiA2NC1ieXRlIGhhc2ggZnVuY3Rpb24gbGlrZSBzaGE1MTIgYW5kIGNvbnZlcnRzIGl0IHRvIGBSaXN0cmV0dG9Qb2ludGAuXG5cdFx0ICAgICAqIFRoZSBoYXNoLXRvLWdyb3VwIG9wZXJhdGlvbiBhcHBsaWVzIEVsbGlnYXRvciB0d2ljZSBhbmQgYWRkcyB0aGUgcmVzdWx0cy5cblx0XHQgICAgICogKipOb3RlOioqIHRoaXMgaXMgb25lLXdheSBtYXAsIHRoZXJlIGlzIG5vIGNvbnZlcnNpb24gZnJvbSBwb2ludCB0byBoYXNoLlxuXHRcdCAgICAgKiBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9lbGxpZ2F0b3IuaHRtbFxuXHRcdCAgICAgKiBAcGFyYW0gaGV4IDY0LWJ5dGUgb3V0cHV0IG9mIGEgaGFzaCBmdW5jdGlvblxuXHRcdCAgICAgKi9cblx0XHQgICAgc3RhdGljIGhhc2hUb0N1cnZlKGhleCkge1xuXHRcdCAgICAgICAgaGV4ID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdyaXN0cmV0dG9IYXNoJywgaGV4LCA2NCk7XG5cdFx0ICAgICAgICBjb25zdCByMSA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXguc2xpY2UoMCwgMzIpKTtcblx0XHQgICAgICAgIGNvbnN0IFIxID0gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMSk7XG5cdFx0ICAgICAgICBjb25zdCByMiA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXguc2xpY2UoMzIsIDY0KSk7XG5cdFx0ICAgICAgICBjb25zdCBSMiA9IGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjIpO1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQoUjEuYWRkKFIyKSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIENvbnZlcnRzIHJpc3RyZXR0by1lbmNvZGVkIHN0cmluZyB0byByaXN0cmV0dG8gcG9pbnQuXG5cdFx0ICAgICAqIGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2RlY29kaW5nLmh0bWxcblx0XHQgICAgICogQHBhcmFtIGhleCBSaXN0cmV0dG8tZW5jb2RlZCAzMiBieXRlcy4gTm90IGV2ZXJ5IDMyLWJ5dGUgc3RyaW5nIGlzIHZhbGlkIHJpc3RyZXR0byBlbmNvZGluZ1xuXHRcdCAgICAgKi9cblx0XHQgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG5cdFx0ICAgICAgICBoZXggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3Jpc3RyZXR0b0hleCcsIGhleCwgMzIpO1xuXHRcdCAgICAgICAgY29uc3QgeyBhLCBkIH0gPSBleHBvcnRzLmVkMjU1MTkuQ1VSVkU7XG5cdFx0ICAgICAgICBjb25zdCBQID0gZXhwb3J0cy5lZDI1NTE5LkNVUlZFLkZwLk9SREVSO1xuXHRcdCAgICAgICAgY29uc3QgbW9kID0gZXhwb3J0cy5lZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZTtcblx0XHQgICAgICAgIGNvbnN0IGVtc2cgPSAnUmlzdHJldHRvUG9pbnQuZnJvbUhleDogdGhlIGhleCBpcyBub3QgdmFsaWQgZW5jb2Rpbmcgb2YgUmlzdHJldHRvUG9pbnQnO1xuXHRcdCAgICAgICAgY29uc3QgcyA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXgpO1xuXHRcdCAgICAgICAgLy8gMS4gQ2hlY2sgdGhhdCBzX2J5dGVzIGlzIHRoZSBjYW5vbmljYWwgZW5jb2Rpbmcgb2YgYSBmaWVsZCBlbGVtZW50LCBvciBlbHNlIGFib3J0LlxuXHRcdCAgICAgICAgLy8gMy4gQ2hlY2sgdGhhdCBzIGlzIG5vbi1uZWdhdGl2ZSwgb3IgZWxzZSBhYm9ydFxuXHRcdCAgICAgICAgaWYgKCEoMCwgdXRpbHNfanNfMS5lcXVhbEJ5dGVzKSgoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzTEUpKHMsIDMyKSwgaGV4KSB8fCAoMCwgbW9kdWxhcl9qc18xLmlzTmVnYXRpdmVMRSkocywgUCkpXG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVtc2cpO1xuXHRcdCAgICAgICAgY29uc3QgczIgPSBtb2QocyAqIHMpO1xuXHRcdCAgICAgICAgY29uc3QgdTEgPSBtb2QoXzFuICsgYSAqIHMyKTsgLy8gNCAoYSBpcyAtMSlcblx0XHQgICAgICAgIGNvbnN0IHUyID0gbW9kKF8xbiAtIGEgKiBzMik7IC8vIDVcblx0XHQgICAgICAgIGNvbnN0IHUxXzIgPSBtb2QodTEgKiB1MSk7XG5cdFx0ICAgICAgICBjb25zdCB1Ml8yID0gbW9kKHUyICogdTIpO1xuXHRcdCAgICAgICAgY29uc3QgdiA9IG1vZChhICogZCAqIHUxXzIgLSB1Ml8yKTsgLy8gNlxuXHRcdCAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZTogSSB9ID0gaW52ZXJ0U3FydChtb2QodiAqIHUyXzIpKTsgLy8gN1xuXHRcdCAgICAgICAgY29uc3QgRHggPSBtb2QoSSAqIHUyKTsgLy8gOFxuXHRcdCAgICAgICAgY29uc3QgRHkgPSBtb2QoSSAqIER4ICogdik7IC8vIDlcblx0XHQgICAgICAgIGxldCB4ID0gbW9kKChzICsgcykgKiBEeCk7IC8vIDEwXG5cdFx0ICAgICAgICBpZiAoKDAsIG1vZHVsYXJfanNfMS5pc05lZ2F0aXZlTEUpKHgsIFApKVxuXHRcdCAgICAgICAgICAgIHggPSBtb2QoLXgpOyAvLyAxMFxuXHRcdCAgICAgICAgY29uc3QgeSA9IG1vZCh1MSAqIER5KTsgLy8gMTFcblx0XHQgICAgICAgIGNvbnN0IHQgPSBtb2QoeCAqIHkpOyAvLyAxMlxuXHRcdCAgICAgICAgaWYgKCFpc1ZhbGlkIHx8ICgwLCBtb2R1bGFyX2pzXzEuaXNOZWdhdGl2ZUxFKSh0LCBQKSB8fCB5ID09PSBfMG4pXG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVtc2cpO1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQobmV3IGV4cG9ydHMuZWQyNTUxOS5FeHRlbmRlZFBvaW50KHgsIHksIF8xbiwgdCkpO1xuXHRcdCAgICB9XG5cdFx0ICAgIHN0YXRpYyBtc20ocG9pbnRzLCBzY2FsYXJzKSB7XG5cdFx0ICAgICAgICBjb25zdCBGbiA9ICgwLCBtb2R1bGFyX2pzXzEuRmllbGQpKGV4cG9ydHMuZWQyNTUxOS5DVVJWRS5uLCBleHBvcnRzLmVkMjU1MTkuQ1VSVkUubkJpdExlbmd0aCk7XG5cdFx0ICAgICAgICByZXR1cm4gKDAsIGN1cnZlX2pzXzEucGlwcGVuZ2VyKShSaXN0UG9pbnQsIEZuLCBwb2ludHMsIHNjYWxhcnMpO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBFbmNvZGVzIHJpc3RyZXR0byBwb2ludCB0byBVaW50OEFycmF5LlxuXHRcdCAgICAgKiBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9lbmNvZGluZy5odG1sXG5cdFx0ICAgICAqL1xuXHRcdCAgICB0b1Jhd0J5dGVzKCkge1xuXHRcdCAgICAgICAgbGV0IHsgZXg6IHgsIGV5OiB5LCBlejogeiwgZXQ6IHQgfSA9IHRoaXMuZXA7XG5cdFx0ICAgICAgICBjb25zdCBQID0gZXhwb3J0cy5lZDI1NTE5LkNVUlZFLkZwLk9SREVSO1xuXHRcdCAgICAgICAgY29uc3QgbW9kID0gZXhwb3J0cy5lZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZTtcblx0XHQgICAgICAgIGNvbnN0IHUxID0gbW9kKG1vZCh6ICsgeSkgKiBtb2QoeiAtIHkpKTsgLy8gMVxuXHRcdCAgICAgICAgY29uc3QgdTIgPSBtb2QoeCAqIHkpOyAvLyAyXG5cdFx0ICAgICAgICAvLyBTcXVhcmUgcm9vdCBhbHdheXMgZXhpc3RzXG5cdFx0ICAgICAgICBjb25zdCB1MnNxID0gbW9kKHUyICogdTIpO1xuXHRcdCAgICAgICAgY29uc3QgeyB2YWx1ZTogaW52c3FydCB9ID0gaW52ZXJ0U3FydChtb2QodTEgKiB1MnNxKSk7IC8vIDNcblx0XHQgICAgICAgIGNvbnN0IEQxID0gbW9kKGludnNxcnQgKiB1MSk7IC8vIDRcblx0XHQgICAgICAgIGNvbnN0IEQyID0gbW9kKGludnNxcnQgKiB1Mik7IC8vIDVcblx0XHQgICAgICAgIGNvbnN0IHpJbnYgPSBtb2QoRDEgKiBEMiAqIHQpOyAvLyA2XG5cdFx0ICAgICAgICBsZXQgRDsgLy8gN1xuXHRcdCAgICAgICAgaWYgKCgwLCBtb2R1bGFyX2pzXzEuaXNOZWdhdGl2ZUxFKSh0ICogekludiwgUCkpIHtcblx0XHQgICAgICAgICAgICBsZXQgX3ggPSBtb2QoeSAqIFNRUlRfTTEpO1xuXHRcdCAgICAgICAgICAgIGxldCBfeSA9IG1vZCh4ICogU1FSVF9NMSk7XG5cdFx0ICAgICAgICAgICAgeCA9IF94O1xuXHRcdCAgICAgICAgICAgIHkgPSBfeTtcblx0XHQgICAgICAgICAgICBEID0gbW9kKEQxICogSU5WU1FSVF9BX01JTlVTX0QpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgRCA9IEQyOyAvLyA4XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoKDAsIG1vZHVsYXJfanNfMS5pc05lZ2F0aXZlTEUpKHggKiB6SW52LCBQKSlcblx0XHQgICAgICAgICAgICB5ID0gbW9kKC15KTsgLy8gOVxuXHRcdCAgICAgICAgbGV0IHMgPSBtb2QoKHogLSB5KSAqIEQpOyAvLyAxMCAoY2hlY2sgZm9vdGVyJ3Mgbm90ZSwgbm8gc3FydCgtYSkpXG5cdFx0ICAgICAgICBpZiAoKDAsIG1vZHVsYXJfanNfMS5pc05lZ2F0aXZlTEUpKHMsIFApKVxuXHRcdCAgICAgICAgICAgIHMgPSBtb2QoLXMpO1xuXHRcdCAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNMRSkocywgMzIpOyAvLyAxMVxuXHRcdCAgICB9XG5cdFx0ICAgIHRvSGV4KCkge1xuXHRcdCAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmJ5dGVzVG9IZXgpKHRoaXMudG9SYXdCeXRlcygpKTtcblx0XHQgICAgfVxuXHRcdCAgICB0b1N0cmluZygpIHtcblx0XHQgICAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cblx0XHQgICAgZXF1YWxzKG90aGVyKSB7XG5cdFx0ICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG5cdFx0ICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxIH0gPSB0aGlzLmVwO1xuXHRcdCAgICAgICAgY29uc3QgeyBleDogWDIsIGV5OiBZMiB9ID0gb3RoZXIuZXA7XG5cdFx0ICAgICAgICBjb25zdCBtb2QgPSBleHBvcnRzLmVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuXHRcdCAgICAgICAgLy8gKHgxICogeTIgPT0geTEgKiB4MikgfCAoeTEgKiB5MiA9PSB4MSAqIHgyKVxuXHRcdCAgICAgICAgY29uc3Qgb25lID0gbW9kKFgxICogWTIpID09PSBtb2QoWTEgKiBYMik7XG5cdFx0ICAgICAgICBjb25zdCB0d28gPSBtb2QoWTEgKiBZMikgPT09IG1vZChYMSAqIFgyKTtcblx0XHQgICAgICAgIHJldHVybiBvbmUgfHwgdHdvO1xuXHRcdCAgICB9XG5cdFx0ICAgIGFkZChvdGhlcikge1xuXHRcdCAgICAgICAgYXNzZXJ0UnN0UG9pbnQob3RoZXIpO1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5hZGQob3RoZXIuZXApKTtcblx0XHQgICAgfVxuXHRcdCAgICBzdWJ0cmFjdChvdGhlcikge1xuXHRcdCAgICAgICAgYXNzZXJ0UnN0UG9pbnQob3RoZXIpO1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5zdWJ0cmFjdChvdGhlci5lcCkpO1xuXHRcdCAgICB9XG5cdFx0ICAgIG11bHRpcGx5KHNjYWxhcikge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5tdWx0aXBseShzY2FsYXIpKTtcblx0XHQgICAgfVxuXHRcdCAgICBtdWx0aXBseVVuc2FmZShzY2FsYXIpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAubXVsdGlwbHlVbnNhZmUoc2NhbGFyKSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZG91YmxlKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5kb3VibGUoKSk7XG5cdFx0ICAgIH1cblx0XHQgICAgbmVnYXRlKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5uZWdhdGUoKSk7XG5cdFx0ICAgIH1cblx0XHR9XG5cdFx0ZXhwb3J0cy5SaXN0cmV0dG9Qb2ludCA9ICgoKSA9PiB7XG5cdFx0ICAgIGlmICghUmlzdFBvaW50LkJBU0UpXG5cdFx0ICAgICAgICBSaXN0UG9pbnQuQkFTRSA9IG5ldyBSaXN0UG9pbnQoZXhwb3J0cy5lZDI1NTE5LkV4dGVuZGVkUG9pbnQuQkFTRSk7XG5cdFx0ICAgIGlmICghUmlzdFBvaW50LlpFUk8pXG5cdFx0ICAgICAgICBSaXN0UG9pbnQuWkVSTyA9IG5ldyBSaXN0UG9pbnQoZXhwb3J0cy5lZDI1NTE5LkV4dGVuZGVkUG9pbnQuWkVSTyk7XG5cdFx0ICAgIHJldHVybiBSaXN0UG9pbnQ7XG5cdFx0fSkoKTtcblx0XHQvLyBIYXNoaW5nIHRvIHJpc3RyZXR0bzI1NS4gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjYXBwZW5kaXgtQlxuXHRcdGNvbnN0IGhhc2hUb1Jpc3RyZXR0bzI1NSA9IChtc2csIG9wdGlvbnMpID0+IHtcblx0XHQgICAgY29uc3QgZCA9IG9wdGlvbnMuRFNUO1xuXHRcdCAgICBjb25zdCBEU1QgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAoMCwgdXRpbHNfMS51dGY4VG9CeXRlcykoZCkgOiBkO1xuXHRcdCAgICBjb25zdCB1bmlmb3JtX2J5dGVzID0gKDAsIGhhc2hfdG9fY3VydmVfanNfMS5leHBhbmRfbWVzc2FnZV94bWQpKG1zZywgRFNULCA2NCwgc2hhNTEyXzEuc2hhNTEyKTtcblx0XHQgICAgY29uc3QgUCA9IFJpc3RQb2ludC5oYXNoVG9DdXJ2ZSh1bmlmb3JtX2J5dGVzKTtcblx0XHQgICAgcmV0dXJuIFA7XG5cdFx0fTtcblx0XHRleHBvcnRzLmhhc2hUb1Jpc3RyZXR0bzI1NSA9IGhhc2hUb1Jpc3RyZXR0bzI1NTtcblx0XHRleHBvcnRzLmhhc2hfdG9fcmlzdHJldHRvMjU1ID0gZXhwb3J0cy5oYXNoVG9SaXN0cmV0dG8yNTU7IC8vIGxlZ2FjeVxuXHRcdFxuXHR9IChlZDI1NTE5KSk7XG5cdHJldHVybiBlZDI1NTE5O1xufVxuXG52YXIgc2VjcDI1NmsxID0ge307XG5cbnZhciBzaGEyNTYgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkU2hhMjU2O1xuXG5mdW5jdGlvbiByZXF1aXJlU2hhMjU2ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkU2hhMjU2KSByZXR1cm4gc2hhMjU2O1xuXHRoYXNSZXF1aXJlZFNoYTI1NiA9IDE7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaGEyNTYsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRzaGEyNTYuc2hhMjI0ID0gc2hhMjU2LnNoYTI1NiA9IHNoYTI1Ni5TSEEyNTYgPSB2b2lkIDA7XG5cdC8qKlxuXHQgKiBTSEEyLTI1NiBhLmsuYS4gc2hhMjU2LiBJbiBKUywgaXQgaXMgdGhlIGZhc3Rlc3QgaGFzaCwgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG5cdCAqXG5cdCAqIFRvIGJyZWFrIHNoYTI1NiB1c2luZyBiaXJ0aGRheSBhdHRhY2ssIGF0dGFja2VycyBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMuXG5cdCAqIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNzAgaGFzaGVzL3NlYyAoMl45NSBoYXNoZXMveWVhcikgYXMgcGVyIDIwMjUuXG5cdCAqXG5cdCAqIENoZWNrIG91dCBbRklQUyAxODAtNF0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZikuXG5cdCAqIEBtb2R1bGVcblx0ICovXG5cdGNvbnN0IF9tZF9qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlX21kKCk7XG5cdGNvbnN0IHV0aWxzX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVVdGlscyQyKCk7XG5cdC8qKiBSb3VuZCBjb25zdGFudHM6IGZpcnN0IDMyIGJpdHMgb2YgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSkuICovXG5cdC8vIHByZXR0aWVyLWlnbm9yZVxuXHRjb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuXHQgICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcblx0ICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG5cdCAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuXHQgICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2Nyxcblx0ICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG5cdCAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuXHQgICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcblx0ICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcblx0XSk7XG5cdC8qKiBJbml0aWFsIHN0YXRlOiBmaXJzdCAzMiBiaXRzIG9mIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkuICovXG5cdC8vIHByZXR0aWVyLWlnbm9yZVxuXHRjb25zdCBTSEEyNTZfSVYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcblx0ICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcblx0XSk7XG5cdC8qKlxuXHQgKiBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnMuXG5cdCAqIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuXHQgKi9cblx0Y29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcblx0Y2xhc3MgU0hBMjU2IGV4dGVuZHMgX21kX2pzXzEuSGFzaE1EIHtcblx0ICAgIGNvbnN0cnVjdG9yKCkge1xuXHQgICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuXHQgICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcblx0ICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG5cdCAgICAgICAgdGhpcy5BID0gU0hBMjU2X0lWWzBdIHwgMDtcblx0ICAgICAgICB0aGlzLkIgPSBTSEEyNTZfSVZbMV0gfCAwO1xuXHQgICAgICAgIHRoaXMuQyA9IFNIQTI1Nl9JVlsyXSB8IDA7XG5cdCAgICAgICAgdGhpcy5EID0gU0hBMjU2X0lWWzNdIHwgMDtcblx0ICAgICAgICB0aGlzLkUgPSBTSEEyNTZfSVZbNF0gfCAwO1xuXHQgICAgICAgIHRoaXMuRiA9IFNIQTI1Nl9JVls1XSB8IDA7XG5cdCAgICAgICAgdGhpcy5HID0gU0hBMjU2X0lWWzZdIHwgMDtcblx0ICAgICAgICB0aGlzLkggPSBTSEEyNTZfSVZbN10gfCAwO1xuXHQgICAgfVxuXHQgICAgZ2V0KCkge1xuXHQgICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcblx0ICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuXHQgICAgfVxuXHQgICAgLy8gcHJldHRpZXItaWdub3JlXG5cdCAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuXHQgICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuXHQgICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuXHQgICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuXHQgICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuXHQgICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuXHQgICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuXHQgICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuXHQgICAgICAgIHRoaXMuSCA9IEggfCAwO1xuXHQgICAgfVxuXHQgICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcblx0ICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuXHQgICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuXHQgICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcblx0ICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG5cdCAgICAgICAgICAgIGNvbnN0IHMwID0gKDAsIHV0aWxzX2pzXzEucm90cikoVzE1LCA3KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG5cdCAgICAgICAgICAgIGNvbnN0IHMxID0gKDAsIHV0aWxzX2pzXzEucm90cikoVzIsIDE3KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcblx0ICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcblx0ICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuXHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICBjb25zdCBzaWdtYTEgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCA2KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDExKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDI1KTtcblx0ICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArICgwLCBfbWRfanNfMS5DaGkpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuXHQgICAgICAgICAgICBjb25zdCBzaWdtYTAgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAyKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDEzKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDIyKTtcblx0ICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgKDAsIF9tZF9qc18xLk1haikoQSwgQiwgQykpIHwgMDtcblx0ICAgICAgICAgICAgSCA9IEc7XG5cdCAgICAgICAgICAgIEcgPSBGO1xuXHQgICAgICAgICAgICBGID0gRTtcblx0ICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcblx0ICAgICAgICAgICAgRCA9IEM7XG5cdCAgICAgICAgICAgIEMgPSBCO1xuXHQgICAgICAgICAgICBCID0gQTtcblx0ICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG5cdCAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG5cdCAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG5cdCAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG5cdCAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG5cdCAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG5cdCAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG5cdCAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG5cdCAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG5cdCAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG5cdCAgICB9XG5cdCAgICByb3VuZENsZWFuKCkge1xuXHQgICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG5cdCAgICB9XG5cdCAgICBkZXN0cm95KCkge1xuXHQgICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuXHQgICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG5cdCAgICB9XG5cdH1cblx0c2hhMjU2LlNIQTI1NiA9IFNIQTI1Njtcblx0LyoqXG5cdCAqIENvbnN0YW50cyB0YWtlbiBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGYuXG5cdCAqL1xuXHRjbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuXHQgICAgY29uc3RydWN0b3IoKSB7XG5cdCAgICAgICAgc3VwZXIoKTtcblx0ICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcblx0ICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcblx0ICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcblx0ICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcblx0ICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcblx0ICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcblx0ICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcblx0ICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcblx0ICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuXHQgICAgfVxuXHR9XG5cdC8qKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uICovXG5cdHNoYTI1Ni5zaGEyNTYgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5cdC8qKiBTSEEyLTIyNCBoYXNoIGZ1bmN0aW9uICovXG5cdHNoYTI1Ni5zaGEyMjQgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEyMjQoKSk7XG5cdFxuXHRyZXR1cm4gc2hhMjU2O1xufVxuXG52YXIgX3Nob3J0d191dGlscyA9IHt9O1xuXG52YXIgaG1hYyA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRIbWFjO1xuXG5mdW5jdGlvbiByZXF1aXJlSG1hYyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEhtYWMpIHJldHVybiBobWFjO1xuXHRoYXNSZXF1aXJlZEhtYWMgPSAxO1xuXHQoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0ZXhwb3J0cy5obWFjID0gZXhwb3J0cy5ITUFDID0gdm9pZCAwO1xuXHRcdC8qKlxuXHRcdCAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuXHRcdCAqIEBtb2R1bGVcblx0XHQgKi9cblx0XHRjb25zdCBfYXNzZXJ0X2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVfYXNzZXJ0KCk7XG5cdFx0Y29uc3QgdXRpbHNfanNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZVV0aWxzJDIoKTtcblx0XHRjbGFzcyBITUFDIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcblx0XHQgICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuXHRcdCAgICAgICAgc3VwZXIoKTtcblx0XHQgICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblx0XHQgICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cdFx0ICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmFoYXNoKShoYXNoKTtcblx0XHQgICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKF9rZXkpO1xuXHRcdCAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG5cdFx0ICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG5cdFx0ICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcblx0XHQgICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG5cdFx0ICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG5cdFx0ICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG5cdFx0ICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG5cdFx0ICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuXHRcdCAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG5cdFx0ICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG5cdFx0ICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuXHRcdCAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuXHRcdCAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG5cdFx0ICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1Jcblx0XHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuXHRcdCAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1Yztcblx0XHQgICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG5cdFx0ICAgICAgICBwYWQuZmlsbCgwKTtcblx0XHQgICAgfVxuXHRcdCAgICB1cGRhdGUoYnVmKSB7XG5cdFx0ICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmFleGlzdHMpKHRoaXMpO1xuXHRcdCAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcblx0XHQgICAgICAgIHJldHVybiB0aGlzO1xuXHRcdCAgICB9XG5cdFx0ICAgIGRpZ2VzdEludG8ob3V0KSB7XG5cdFx0ICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmFleGlzdHMpKHRoaXMpO1xuXHRcdCAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuXHRcdCAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG5cdFx0ICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcblx0XHQgICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG5cdFx0ICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcblx0XHQgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGRpZ2VzdCgpIHtcblx0XHQgICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcblx0XHQgICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuXHRcdCAgICAgICAgcmV0dXJuIG91dDtcblx0XHQgICAgfVxuXHRcdCAgICBfY2xvbmVJbnRvKHRvKSB7XG5cdFx0ICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cblx0XHQgICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuXHRcdCAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG5cdFx0ICAgICAgICB0byA9IHRvO1xuXHRcdCAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcblx0XHQgICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcblx0XHQgICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG5cdFx0ICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG5cdFx0ICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuXHRcdCAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcblx0XHQgICAgICAgIHJldHVybiB0bztcblx0XHQgICAgfVxuXHRcdCAgICBkZXN0cm95KCkge1xuXHRcdCAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG5cdFx0ICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcblx0XHQgICAgfVxuXHRcdH1cblx0XHRleHBvcnRzLkhNQUMgPSBITUFDO1xuXHRcdC8qKlxuXHRcdCAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuXHRcdCAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG5cdFx0ICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG5cdFx0ICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIGltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuXHRcdCAqIGltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG5cdFx0ICogY29uc3QgbWFjMSA9IGhtYWMoc2hhMjU2LCAna2V5JywgJ21lc3NhZ2UnKTtcblx0XHQgKi9cblx0XHRjb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5cdFx0ZXhwb3J0cy5obWFjID0gaG1hYztcblx0XHRleHBvcnRzLmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcblx0XHRcblx0fSAoaG1hYykpO1xuXHRyZXR1cm4gaG1hYztcbn1cblxudmFyIHdlaWVyc3RyYXNzID0ge307XG5cbnZhciBoYXNSZXF1aXJlZFdlaWVyc3RyYXNzO1xuXG5mdW5jdGlvbiByZXF1aXJlV2VpZXJzdHJhc3MgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRXZWllcnN0cmFzcykgcmV0dXJuIHdlaWVyc3RyYXNzO1xuXHRoYXNSZXF1aXJlZFdlaWVyc3RyYXNzID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRcdGV4cG9ydHMuREVSID0gZXhwb3J0cy5ERVJFcnIgPSB2b2lkIDA7XG5cdFx0ZXhwb3J0cy53ZWllcnN0cmFzc1BvaW50cyA9IHdlaWVyc3RyYXNzUG9pbnRzO1xuXHRcdGV4cG9ydHMud2VpZXJzdHJhc3MgPSB3ZWllcnN0cmFzcztcblx0XHRleHBvcnRzLlNXVUZwU3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW87XG5cdFx0ZXhwb3J0cy5tYXBUb0N1cnZlU2ltcGxlU1dVID0gbWFwVG9DdXJ2ZVNpbXBsZVNXVTtcblx0XHQvKipcblx0XHQgKiBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZSBtZXRob2RzLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiLlxuXHRcdCAqXG5cdFx0ICogIyMjIERlc2lnbiByYXRpb25hbGUgZm9yIHR5cGVzXG5cdFx0ICpcblx0XHQgKiAqIEludGVyYWN0aW9uIGJldHdlZW4gY2xhc3NlcyBmcm9tIGRpZmZlcmVudCBjdXJ2ZXMgc2hvdWxkIGZhaWw6XG5cdFx0ICogICBgazI1Ni5Qb2ludC5CQVNFLmFkZChwMjU2LlBvaW50LkJBU0UpYFxuXHRcdCAqICogRm9yIHRoaXMgcHVycG9zZSB3ZSB3YW50IHRvIHVzZSBgaW5zdGFuY2VvZmAgb3BlcmF0b3IsIHdoaWNoIGlzIGZhc3QgYW5kIHdvcmtzIGR1cmluZyBydW50aW1lXG5cdFx0ICogKiBEaWZmZXJlbnQgY2FsbHMgb2YgYGN1cnZlKClgIHdvdWxkIHJldHVybiBkaWZmZXJlbnQgY2xhc3NlcyAtXG5cdFx0ICogICBgY3VydmUocGFyYW1zKSAhPT0gY3VydmUocGFyYW1zKWA6IGlmIHNvbWVib2R5IGRlY2lkZWQgdG8gbW9ua2V5LXBhdGNoIHRoZWlyIGN1cnZlLFxuXHRcdCAqICAgaXQgd29uJ3QgYWZmZWN0IG90aGVyc1xuXHRcdCAqXG5cdFx0ICogVHlwZVNjcmlwdCBjYW4ndCBpbmZlciB0eXBlcyBmb3IgY2xhc3NlcyBjcmVhdGVkIGluc2lkZSBhIGZ1bmN0aW9uLiBDbGFzc2VzIGlzIG9uZSBpbnN0YW5jZVxuXHRcdCAqIG9mIG5vbWluYXRpdmUgdHlwZXMgaW4gVHlwZVNjcmlwdCBhbmQgaW50ZXJmYWNlcyBvbmx5IGNoZWNrIGZvciBzaGFwZSwgc28gaXQncyBoYXJkIHRvIGNyZWF0ZVxuXHRcdCAqIHVuaXF1ZSB0eXBlIGZvciBldmVyeSBmdW5jdGlvbiBjYWxsLlxuXHRcdCAqXG5cdFx0ICogV2UgY2FuIHVzZSBnZW5lcmljIHR5cGVzIHZpYSBzb21lIHBhcmFtLCBsaWtlIGN1cnZlIG9wdHMsIGJ1dCB0aGF0IHdvdWxkOlxuXHRcdCAqICAgICAxLiBFbmFibGUgaW50ZXJhY3Rpb24gYmV0d2VlbiBgY3VydmUocGFyYW1zKWAgYW5kIGBjdXJ2ZShwYXJhbXMpYCAoY3VydmVzIG9mIHNhbWUgcGFyYW1zKVxuXHRcdCAqICAgICB3aGljaCBpcyBoYXJkIHRvIGRlYnVnLlxuXHRcdCAqICAgICAyLiBQYXJhbXMgY2FuIGJlIGdlbmVyaWMgYW5kIHdlIGNhbid0IGVuZm9yY2UgdGhlbSB0byBiZSBjb25zdGFudCB2YWx1ZTpcblx0XHQgKiAgICAgaWYgc29tZWJvZHkgY3JlYXRlcyBjdXJ2ZSBmcm9tIG5vbi1jb25zdGFudCBwYXJhbXMsXG5cdFx0ICogICAgIGl0IHdvdWxkIGJlIGFsbG93ZWQgdG8gaW50ZXJhY3Qgd2l0aCBvdGhlciBjdXJ2ZXMgd2l0aCBub24tY29uc3RhbnQgcGFyYW1zXG5cdFx0ICpcblx0XHQgKiBAdG9kbyBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9yZWxlYXNlLW5vdGVzL3R5cGVzY3JpcHQtMi03Lmh0bWwjdW5pcXVlLXN5bWJvbFxuXHRcdCAqIEBtb2R1bGVcblx0XHQgKi9cblx0XHQvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5cdFx0Y29uc3QgY3VydmVfanNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUN1cnZlKCk7XG5cdFx0Y29uc3QgbW9kdWxhcl9qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlTW9kdWxhcigpO1xuXHRcdGNvbnN0IHV0ID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMkMSgpO1xuXHRcdGNvbnN0IHV0aWxzX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVVdGlscyQxKCk7XG5cdFx0ZnVuY3Rpb24gdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpIHtcblx0XHQgICAgaWYgKG9wdHMubG93UyAhPT0gdW5kZWZpbmVkKVxuXHRcdCAgICAgICAgKDAsIHV0aWxzX2pzXzEuYWJvb2wpKCdsb3dTJywgb3B0cy5sb3dTKTtcblx0XHQgICAgaWYgKG9wdHMucHJlaGFzaCAhPT0gdW5kZWZpbmVkKVxuXHRcdCAgICAgICAgKDAsIHV0aWxzX2pzXzEuYWJvb2wpKCdwcmVoYXNoJywgb3B0cy5wcmVoYXNoKTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcblx0XHQgICAgY29uc3Qgb3B0cyA9ICgwLCBjdXJ2ZV9qc18xLnZhbGlkYXRlQmFzaWMpKGN1cnZlKTtcblx0XHQgICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuXHRcdCAgICAgICAgYTogJ2ZpZWxkJyxcblx0XHQgICAgICAgIGI6ICdmaWVsZCcsXG5cdFx0ICAgIH0sIHtcblx0XHQgICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5Jyxcblx0XHQgICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG5cdFx0ICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuXHRcdCAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcblx0XHQgICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxuXHRcdCAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuXHRcdCAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcblx0XHQgICAgfSk7XG5cdFx0ICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG5cdFx0ICAgIGlmIChlbmRvKSB7XG5cdFx0ICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBlbmRvbW9ycGhpc20sIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcblx0XHQgICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuXHRcdCAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVuZG9tb3JwaGlzbSwgZXhwZWN0ZWQgYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG5cdFx0fVxuXHRcdGNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG5cdFx0Y2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuXHRcdCAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcblx0XHQgICAgICAgIHN1cGVyKG0pO1xuXHRcdCAgICB9XG5cdFx0fVxuXHRcdGV4cG9ydHMuREVSRXJyID0gREVSRXJyO1xuXHRcdC8qKlxuXHRcdCAqIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXMuIEFTTiBpcyB2ZXJ5IGNvbXBsZXggJiBmcmFnaWxlLiBGb3JtYXQ6XG5cdFx0ICpcblx0XHQgKiAgICAgWzB4MzAgKFNFUVVFTkNFKSwgYnl0ZWxlbmd0aCwgMHgwMiAoSU5URUdFUiksIGludExlbmd0aCwgUiwgMHgwMiAoSU5URUdFUiksIGludExlbmd0aCwgU11cblx0XHQgKlxuXHRcdCAqIERvY3M6IGh0dHBzOi8vbGV0c2VuY3J5cHQub3JnL2RvY3MvYS13YXJtLXdlbGNvbWUtdG8tYXNuMS1hbmQtZGVyLywgaHR0cHM6Ly9sdWNhLm50b3Aub3JnL1RlYWNoaW5nL0FwcHVudGkvYXNuMS5odG1sXG5cdFx0ICovXG5cdFx0ZXhwb3J0cy5ERVIgPSB7XG5cdFx0ICAgIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuXHRcdCAgICBFcnI6IERFUkVycixcblx0XHQgICAgLy8gQmFzaWMgYnVpbGRpbmcgYmxvY2sgaXMgVExWIChUYWctTGVuZ3RoLVZhbHVlKVxuXHRcdCAgICBfdGx2OiB7XG5cdFx0ICAgICAgICBlbmNvZGU6ICh0YWcsIGRhdGEpID0+IHtcblx0XHQgICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gZXhwb3J0cy5ERVI7XG5cdFx0ICAgICAgICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KVxuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG5cdFx0ICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICYgMSlcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHVucGFkZGVkIGRhdGEnKTtcblx0XHQgICAgICAgICAgICBjb25zdCBkYXRhTGVuID0gZGF0YS5sZW5ndGggLyAyO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGxlbiA9IHV0Lm51bWJlclRvSGV4VW5wYWRkZWQoZGF0YUxlbik7XG5cdFx0ICAgICAgICAgICAgaWYgKChsZW4ubGVuZ3RoIC8gMikgJiAxMjgpXG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiBsb25nIGZvcm0gbGVuZ3RoIHRvbyBiaWcnKTtcblx0XHQgICAgICAgICAgICAvLyBsZW5ndGggb2YgbGVuZ3RoIHdpdGggbG9uZyBmb3JtIGZsYWdcblx0XHQgICAgICAgICAgICBjb25zdCBsZW5MZW4gPSBkYXRhTGVuID4gMTI3ID8gdXQubnVtYmVyVG9IZXhVbnBhZGRlZCgobGVuLmxlbmd0aCAvIDIpIHwgMTI4KSA6ICcnO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHQgPSB1dC5udW1iZXJUb0hleFVucGFkZGVkKHRhZyk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHQgKyBsZW5MZW4gKyBsZW4gKyBkYXRhO1xuXHRcdCAgICAgICAgfSxcblx0XHQgICAgICAgIC8vIHYgLSB2YWx1ZSwgbCAtIGxlZnQgYnl0ZXMgKHVucGFyc2VkKVxuXHRcdCAgICAgICAgZGVjb2RlKHRhZywgZGF0YSkge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBleHBvcnRzLkRFUjtcblx0XHQgICAgICAgICAgICBsZXQgcG9zID0gMDtcblx0XHQgICAgICAgICAgICBpZiAodGFnIDwgMCB8fCB0YWcgPiAyNTYpXG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcblx0XHQgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbcG9zKytdICE9PSB0YWcpXG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiB3cm9uZyB0bHYnKTtcblx0XHQgICAgICAgICAgICBjb25zdCBmaXJzdCA9IGRhdGFbcG9zKytdO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGlzTG9uZyA9ICEhKGZpcnN0ICYgMTI4KTsgLy8gRmlyc3QgYml0IG9mIGZpcnN0IGxlbmd0aCBieXRlIGlzIGZsYWcgZm9yIHNob3J0L2xvbmcgZm9ybVxuXHRcdCAgICAgICAgICAgIGxldCBsZW5ndGggPSAwO1xuXHRcdCAgICAgICAgICAgIGlmICghaXNMb25nKVxuXHRcdCAgICAgICAgICAgICAgICBsZW5ndGggPSBmaXJzdDtcblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgLy8gTG9uZyBmb3JtOiBbbG9uZ0ZsYWcoMWJpdCksIGxlbmd0aExlbmd0aCg3Yml0KSwgbGVuZ3RoIChCRSldXG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGZpcnN0ICYgMTI3O1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoIWxlbkxlbilcblx0XHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBpbmRlZmluaXRlIGxlbmd0aCBub3Qgc3VwcG9ydGVkJyk7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChsZW5MZW4gPiA0KVxuXHRcdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IGJ5dGUgbGVuZ3RoIGlzIHRvbyBiaWcnKTsgLy8gdGhpcyB3aWxsIG92ZXJmbG93IHUzMiBpbiBqc1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGhCeXRlcyA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5MZW4pO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXMubGVuZ3RoICE9PSBsZW5MZW4pXG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogbGVuZ3RoIGJ5dGVzIG5vdCBjb21wbGV0ZScpO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXNbMF0gPT09IDApXG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogemVybyBsZWZ0bW9zdCBieXRlJyk7XG5cdFx0ICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiBsZW5ndGhCeXRlcylcblx0XHQgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggPDwgOCkgfCBiO1xuXHRcdCAgICAgICAgICAgICAgICBwb3MgKz0gbGVuTGVuO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAobGVuZ3RoIDwgMTI4KVxuXHRcdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IG5vdCBtaW5pbWFsIGVuY29kaW5nJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHYgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbGVuZ3RoKTtcblx0XHQgICAgICAgICAgICBpZiAodi5sZW5ndGggIT09IGxlbmd0aClcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHZhbHVlIGxlbmd0aCcpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiB7IHYsIGw6IGRhdGEuc3ViYXJyYXkocG9zICsgbGVuZ3RoKSB9O1xuXHRcdCAgICAgICAgfSxcblx0XHQgICAgfSxcblx0XHQgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG5cdFx0ICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG5cdFx0ICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcblx0XHQgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuXHRcdCAgICBfaW50OiB7XG5cdFx0ICAgICAgICBlbmNvZGUobnVtKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IGV4cG9ydHMuREVSO1xuXHRcdCAgICAgICAgICAgIGlmIChudW0gPCBfMG4pXG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnRlZ2VyOiBuZWdhdGl2ZSBpbnRlZ2VycyBhcmUgbm90IGFsbG93ZWQnKTtcblx0XHQgICAgICAgICAgICBsZXQgaGV4ID0gdXQubnVtYmVyVG9IZXhVbnBhZGRlZChudW0pO1xuXHRcdCAgICAgICAgICAgIC8vIFBhZCB3aXRoIHplcm8gYnl0ZSBpZiBuZWdhdGl2ZSBmbGFnIGlzIHByZXNlbnRcblx0XHQgICAgICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KGhleFswXSwgMTYpICYgMGIxMDAwKVxuXHRcdCAgICAgICAgICAgICAgICBoZXggPSAnMDAnICsgaGV4O1xuXHRcdCAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoICYgMSlcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3VuZXhwZWN0ZWQgREVSIHBhcnNpbmcgYXNzZXJ0aW9uOiB1bnBhZGRlZCBoZXgnKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gaGV4O1xuXHRcdCAgICAgICAgfSxcblx0XHQgICAgICAgIGRlY29kZShkYXRhKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IGV4cG9ydHMuREVSO1xuXHRcdCAgICAgICAgICAgIGlmIChkYXRhWzBdICYgMTI4KVxuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmUnKTtcblx0XHQgICAgICAgICAgICBpZiAoZGF0YVswXSA9PT0gMHgwMCAmJiAhKGRhdGFbMV0gJiAxMjgpKVxuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGIybihkYXRhKTtcblx0XHQgICAgICAgIH0sXG5cdFx0ICAgIH0sXG5cdFx0ICAgIHRvU2lnKGhleCkge1xuXHRcdCAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuXHRcdCAgICAgICAgY29uc3QgeyBFcnI6IEUsIF9pbnQ6IGludCwgX3RsdjogdGx2IH0gPSBleHBvcnRzLkRFUjtcblx0XHQgICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuXHRcdCAgICAgICAgdXQuYWJ5dGVzKGRhdGEpO1xuXHRcdCAgICAgICAgY29uc3QgeyB2OiBzZXFCeXRlcywgbDogc2VxTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MzAsIGRhdGEpO1xuXHRcdCAgICAgICAgaWYgKHNlcUxlZnRCeXRlcy5sZW5ndGgpXG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcblx0XHQgICAgICAgIGNvbnN0IHsgdjogckJ5dGVzLCBsOiByTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHNlcUJ5dGVzKTtcblx0XHQgICAgICAgIGNvbnN0IHsgdjogc0J5dGVzLCBsOiBzTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHJMZWZ0Qnl0ZXMpO1xuXHRcdCAgICAgICAgaWYgKHNMZWZ0Qnl0ZXMubGVuZ3RoKVxuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG5cdFx0ICAgICAgICByZXR1cm4geyByOiBpbnQuZGVjb2RlKHJCeXRlcyksIHM6IGludC5kZWNvZGUoc0J5dGVzKSB9O1xuXHRcdCAgICB9LFxuXHRcdCAgICBoZXhGcm9tU2lnKHNpZykge1xuXHRcdCAgICAgICAgY29uc3QgeyBfdGx2OiB0bHYsIF9pbnQ6IGludCB9ID0gZXhwb3J0cy5ERVI7XG5cdFx0ICAgICAgICBjb25zdCBycyA9IHRsdi5lbmNvZGUoMHgwMiwgaW50LmVuY29kZShzaWcucikpO1xuXHRcdCAgICAgICAgY29uc3Qgc3MgPSB0bHYuZW5jb2RlKDB4MDIsIGludC5lbmNvZGUoc2lnLnMpKTtcblx0XHQgICAgICAgIGNvbnN0IHNlcSA9IHJzICsgc3M7XG5cdFx0ICAgICAgICByZXR1cm4gdGx2LmVuY29kZSgweDMwLCBzZXEpO1xuXHRcdCAgICB9LFxuXHRcdH07XG5cdFx0Ly8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG5cdFx0Ly8gcHJldHRpZXItaWdub3JlXG5cdFx0Y29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5cdFx0ZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuXHRcdCAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuXHRcdCAgICBjb25zdCB7IEZwIH0gPSBDVVJWRTsgLy8gQWxsIGN1cnZlcyBoYXMgc2FtZSBmaWVsZCAvIGdyb3VwIGxlbmd0aCBhcyBmb3Igbm93LCBidXQgdGhleSBjYW4gZGlmZmVyXG5cdFx0ICAgIGNvbnN0IEZuID0gKDAsIG1vZHVsYXJfanNfMS5GaWVsZCkoQ1VSVkUubiwgQ1VSVkUubkJpdExlbmd0aCk7XG5cdFx0ICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG5cdFx0ICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuXHRcdCAgICAgICAgKChieXRlcykgPT4ge1xuXHRcdCAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcblx0XHQgICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG5cdFx0ICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcblx0XHQgICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcblx0XHQgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICAvKipcblx0XHQgICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG5cdFx0ICAgICAqIEByZXR1cm5zIHnCslxuXHRcdCAgICAgKi9cblx0XHQgICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG5cdFx0ICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuXHRcdCAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG5cdFx0ICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuXHRcdCAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuXHRcdCAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuXHRcdCAgICAvLyBgYXNzZXJ0VmFsaWRpdHkoKWAgd29uJ3Qgd29yazogYGlzVG9yc2lvbkZyZWUoKWAgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGluIGJsczEyLTM4MS5cblx0XHQgICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG5cdFx0ICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcblx0XHQgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGdlbmVyYXRvciBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuXHRcdCAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG5cdFx0ICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcblx0XHQgICAgICAgIHJldHVybiB1dC5pblJhbmdlKG51bSwgXzFuLCBDVVJWRS5uKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cblx0XHQgICAgLy8gU3VwcG9ydHMgb3B0aW9ucyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgYW5kIHdyYXBQcml2YXRlS2V5LlxuXHRcdCAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuXHRcdCAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbjogTiB9ID0gQ1VSVkU7XG5cdFx0ICAgICAgICBpZiAobGVuZ3RocyAmJiB0eXBlb2Yga2V5ICE9PSAnYmlnaW50Jykge1xuXHRcdCAgICAgICAgICAgIGlmICh1dC5pc0J5dGVzKGtleSkpXG5cdFx0ICAgICAgICAgICAgICAgIGtleSA9IHV0LmJ5dGVzVG9IZXgoa2V5KTtcblx0XHQgICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG5cdFx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBrZXknKTtcblx0XHQgICAgICAgICAgICBrZXkgPSBrZXkucGFkU3RhcnQobkJ5dGVMZW5ndGggKiAyLCAnMCcpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgbGV0IG51bTtcblx0XHQgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgbnVtID1cblx0XHQgICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcblx0XHQgICAgICAgICAgICAgICAgICAgID8ga2V5XG5cdFx0ICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRSgoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByaXZhdGUga2V5LCBleHBlY3RlZCBoZXggb3IgJyArIG5CeXRlTGVuZ3RoICsgJyBieXRlcywgZ290ICcgKyB0eXBlb2Yga2V5KTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcblx0XHQgICAgICAgICAgICBudW0gPSAoMCwgbW9kdWxhcl9qc18xLm1vZCkobnVtLCBOKTsgLy8gZGlzYWJsZWQgYnkgZGVmYXVsdCwgZW5hYmxlZCBmb3IgQkxTXG5cdFx0ICAgICAgICB1dC5hSW5SYW5nZSgncHJpdmF0ZSBrZXknLCBudW0sIF8xbiwgTik7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuXHRcdCAgICAgICAgcmV0dXJuIG51bTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBhc3NlcnRQcmpQb2ludChvdGhlcikge1xuXHRcdCAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBNZW1vaXplZCB0b0FmZmluZSAvIHZhbGlkaXR5IGNoZWNrLiBUaGV5IGFyZSBoZWF2eS4gUG9pbnRzIGFyZSBpbW11dGFibGUuXG5cdFx0ICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cblx0XHQgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG5cdFx0ICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcblx0XHQgICAgY29uc3QgdG9BZmZpbmVNZW1vID0gKDAsIHV0aWxzX2pzXzEubWVtb2l6ZWQpKChwLCBpeikgPT4ge1xuXHRcdCAgICAgICAgY29uc3QgeyBweDogeCwgcHk6IHksIHB6OiB6IH0gPSBwO1xuXHRcdCAgICAgICAgLy8gRmFzdC1wYXRoIGZvciBub3JtYWxpemVkIHBvaW50c1xuXHRcdCAgICAgICAgaWYgKEZwLmVxbCh6LCBGcC5PTkUpKVxuXHRcdCAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcblx0XHQgICAgICAgIGNvbnN0IGlzMCA9IHAuaXMwKCk7XG5cdFx0ICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcblx0XHQgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG5cdFx0ICAgICAgICBpZiAoaXogPT0gbnVsbClcblx0XHQgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcblx0XHQgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcblx0XHQgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcblx0XHQgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcblx0XHQgICAgICAgIGlmIChpczApXG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuXHRcdCAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG5cdFx0ICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcblx0XHQgICAgfSk7XG5cdFx0ICAgIC8vIE5PVEU6IG9uIGV4Y2VwdGlvbiB0aGlzIHdpbGwgY3Jhc2ggJ2NhY2hlZCcgYW5kIG5vIHZhbHVlIHdpbGwgYmUgc2V0LlxuXHRcdCAgICAvLyBPdGhlcndpc2UgdHJ1ZSB3aWxsIGJlIHJldHVyblxuXHRcdCAgICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSAoMCwgdXRpbHNfanNfMS5tZW1vaXplZCkoKHApID0+IHtcblx0XHQgICAgICAgIGlmIChwLmlzMCgpKSB7XG5cdFx0ICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cblx0XHQgICAgICAgICAgICAvLyBJbiBCTFMsIFpFUk8gY2FuIGJlIHNlcmlhbGl6ZWQsIHNvIHdlIGFsbG93IGl0LlxuXHRcdCAgICAgICAgICAgIC8vICgwLCAwLCAwKSBpcyBpbnZhbGlkIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8uXG5cdFx0ICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHAucHkpKVxuXHRcdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcblx0XHQgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcC50b0FmZmluZSgpO1xuXHRcdCAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcblx0XHQgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuXHRcdCAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG5cdFx0ICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuXHRcdCAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG5cdFx0ICAgICAgICBpZiAoIXAuaXNUb3JzaW9uRnJlZSgpKVxuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcblx0XHQgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICB9KTtcblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcblx0XHQgICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG5cdFx0ICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cblx0XHQgICAgICovXG5cdFx0ICAgIGNsYXNzIFBvaW50IHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcblx0XHQgICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG5cdFx0ICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuXHRcdCAgICAgICAgICAgIHRoaXMucHogPSBwejtcblx0XHQgICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuXHRcdCAgICAgICAgICAgIGlmIChweSA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB5KSlcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG5cdFx0ICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcblx0XHQgICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLy8gRG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIG9uLWN1cnZlLlxuXHRcdCAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuXHRcdCAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcblx0XHQgICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcblx0XHQgICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcblx0XHQgICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuXHRcdCAgICAgICAgICAgIC8vIGZyb21BZmZpbmUoeDowLCB5OjApIHdvdWxkIHByb2R1Y2UgKHg6MCwgeTowLCB6OjEpLCBidXQgd2UgbmVlZCAoeDowLCB5OjEsIHo6MClcblx0XHQgICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZ2V0IHgoKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZ2V0IHkoKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxuXHRcdCAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcblx0XHQgICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxuXHRcdCAgICAgICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5weikpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuXHRcdCAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcblx0XHQgICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdwb2ludEhleCcsIGhleCkpKTtcblx0XHQgICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFA7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuXHRcdCAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gUG9pbnQuQkFTRS5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIE11bHRpc2NhbGFyIE11bHRpcGxpY2F0aW9uXG5cdFx0ICAgICAgICBzdGF0aWMgbXNtKHBvaW50cywgc2NhbGFycykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiAoMCwgY3VydmVfanNfMS5waXBwZW5nZXIpKFBvaW50LCBGbiwgcG9pbnRzLCBzY2FsYXJzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG5cdFx0ICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG5cdFx0ICAgICAgICAgICAgd25hZi5zZXRXaW5kb3dTaXplKHRoaXMsIHdpbmRvd1NpemUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cblx0XHQgICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuXHRcdCAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGhhc0V2ZW5ZKCkge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuXHRcdCAgICAgICAgICAgIGlmIChGcC5pc09kZClcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuICFGcC5pc09kZCh5KTtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGVxdWFscyhvdGhlcikge1xuXHRcdCAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcblx0XHQgICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG5cdFx0ICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcblx0XHQgICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFUxICYmIFUyO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBGbGlwcyBwb2ludCB0byBvbmUgY29ycmVzcG9uZGluZyB0byAoeCwgLXkpIGluIEFmZmluZSBjb29yZGluYXRlcy5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgbmVnYXRlKCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5weCwgRnAubmVnKHRoaXMucHkpLCB0aGlzLnB6KTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuXHRcdCAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuXHRcdCAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuXHRcdCAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cblx0XHQgICAgICAgIGRvdWJsZSgpIHtcblx0XHQgICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG5cdFx0ICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuXHRcdCAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcblx0XHQgICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG5cdFx0ICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMSk7XG5cdFx0ICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG5cdFx0ICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG5cdFx0ICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIHQzKTsgLy8gc3RlcCA1XG5cdFx0ICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcblx0XHQgICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuXHRcdCAgICAgICAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcblx0XHQgICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuXHRcdCAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcblx0XHQgICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWTMpO1xuXHRcdCAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG5cdFx0ICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcblx0XHQgICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuXHRcdCAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcblx0XHQgICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG5cdFx0ICAgICAgICAgICAgdDMgPSBGcC5zdWIodDAsIHQyKTtcblx0XHQgICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG5cdFx0ICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcblx0XHQgICAgICAgICAgICBaMyA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDIwXG5cdFx0ICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcblx0XHQgICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuXHRcdCAgICAgICAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XG5cdFx0ICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcblx0XHQgICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG5cdFx0ICAgICAgICAgICAgdDIgPSBGcC5hZGQodDIsIHQyKTtcblx0XHQgICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuXHRcdCAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG5cdFx0ICAgICAgICAgICAgWjMgPSBGcC5tdWwodDIsIHQxKTtcblx0XHQgICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG5cdFx0ICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG5cdFx0ICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG5cdFx0ICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG5cdFx0ICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cblx0XHQgICAgICAgIGFkZChvdGhlcikge1xuXHRcdCAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcblx0XHQgICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG5cdFx0ICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcblx0XHQgICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG5cdFx0ICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG5cdFx0ICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoQ1VSVkUuYiwgXzNuKTtcblx0XHQgICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG5cdFx0ICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG5cdFx0ICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XG5cdFx0ICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG5cdFx0ICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuXHRcdCAgICAgICAgICAgIHQzID0gRnAubXVsKHQzLCB0NCk7XG5cdFx0ICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcblx0XHQgICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuXHRcdCAgICAgICAgICAgIHQ0ID0gRnAuYWRkKFgxLCBaMSk7XG5cdFx0ICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcblx0XHQgICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuXHRcdCAgICAgICAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XG5cdFx0ICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcblx0XHQgICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuXHRcdCAgICAgICAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7IC8vIHN0ZXAgMTVcblx0XHQgICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuXHRcdCAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG5cdFx0ICAgICAgICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcblx0XHQgICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG5cdFx0ICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuXHRcdCAgICAgICAgICAgIFozID0gRnAuYWRkKFgzLCBaMyk7XG5cdFx0ICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcblx0XHQgICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuXHRcdCAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBaMyk7XG5cdFx0ICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuXHRcdCAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG5cdFx0ICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuXHRcdCAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG5cdFx0ICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcblx0XHQgICAgICAgICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpOyAvLyBzdGVwIDMwXG5cdFx0ICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuXHRcdCAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG5cdFx0ICAgICAgICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcblx0XHQgICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuXHRcdCAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcblx0XHQgICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuXHRcdCAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG5cdFx0ICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcblx0XHQgICAgICAgICAgICBaMyA9IEZwLm11bCh0NSwgWjMpO1xuXHRcdCAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcblx0XHQgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaXMwKCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHdOQUYobikge1xuXHRcdCAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgbiwgUG9pbnQubm9ybWFsaXplWik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cblx0XHQgICAgICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG5cdFx0ICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBtdWx0aXBseVVuc2FmZShzYykge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHsgZW5kbywgbjogTiB9ID0gQ1VSVkU7XG5cdFx0ICAgICAgICAgICAgdXQuYUluUmFuZ2UoJ3NjYWxhcicsIHNjLCBfMG4sIE4pO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuXHRcdCAgICAgICAgICAgIGlmIChzYyA9PT0gXzBuKVxuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gSTtcblx0XHQgICAgICAgICAgICBpZiAodGhpcy5pczAoKSB8fCBzYyA9PT0gXzFuKVxuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0XHQgICAgICAgICAgICAvLyBDYXNlIGE6IG5vIGVuZG9tb3JwaGlzbS4gQ2FzZSBiOiBoYXMgcHJlY29tcHV0ZXMuXG5cdFx0ICAgICAgICAgICAgaWYgKCFlbmRvIHx8IHduYWYuaGFzUHJlY29tcHV0ZXModGhpcykpXG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWRVbnNhZmUodGhpcywgc2MsIFBvaW50Lm5vcm1hbGl6ZVopO1xuXHRcdCAgICAgICAgICAgIC8vIENhc2UgYzogZW5kb21vcnBoaXNtXG5cdFx0ICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIoc2MpO1xuXHRcdCAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuXHRcdCAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuXHRcdCAgICAgICAgICAgIGxldCBkID0gdGhpcztcblx0XHQgICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuXHRcdCAgICAgICAgICAgICAgICAgICAgazFwID0gazFwLmFkZChkKTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuXHRcdCAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcblx0XHQgICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG5cdFx0ICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG5cdFx0ICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChrMW5lZylcblx0XHQgICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuXHRcdCAgICAgICAgICAgIGlmIChrMm5lZylcblx0XHQgICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuXHRcdCAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cblx0XHQgICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3Rlcixcblx0XHQgICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cblx0XHQgICAgICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG5cdFx0ICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG5cdFx0ICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG5cdFx0ICAgICAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgeyBlbmRvLCBuOiBOIH0gPSBDVVJWRTtcblx0XHQgICAgICAgICAgICB1dC5hSW5SYW5nZSgnc2NhbGFyJywgc2NhbGFyLCBfMW4sIE4pO1xuXHRcdCAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuXHRcdCAgICAgICAgICAgIGlmIChlbmRvKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIoc2NhbGFyKTtcblx0XHQgICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG5cdFx0ICAgICAgICAgICAgICAgIGxldCB7IHA6IGsycCwgZjogZjJwIH0gPSB0aGlzLndOQUYoazIpO1xuXHRcdCAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcblx0XHQgICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG5cdFx0ICAgICAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG5cdFx0ICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuXHRcdCAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYoc2NhbGFyKTtcblx0XHQgICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuXHRcdCAgICAgICAgICAgICAgICBmYWtlID0gZjtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuXHRcdCAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG5cdFx0ICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuXHRcdCAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuXHRcdCAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcblx0XHQgICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG5cdFx0ICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuXHRcdCAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuXHRcdCAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG5cdFx0ICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG5cdFx0ICAgICAgICB0b0FmZmluZShpeikge1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0b0FmZmluZU1lbW8odGhpcywgaXopO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcblx0XHQgICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBpc1RvcnNpb25GcmVlIH0gPSBDVVJWRTtcblx0XHQgICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuXHRcdCAgICAgICAgICAgIGlmIChpc1RvcnNpb25GcmVlKVxuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG5cdFx0ICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcblx0XHQgICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3Rvcilcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG5cdFx0ICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuYWJvb2wpKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuXHRcdCAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gdG9CeXRlcyhQb2ludCwgdGhpcywgaXNDb21wcmVzc2VkKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcblx0XHQgICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5hYm9vbCkoJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuXHRcdCAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG5cdFx0ICAgIGNvbnN0IF9iaXRzID0gQ1VSVkUubkJpdExlbmd0aDtcblx0XHQgICAgY29uc3Qgd25hZiA9ICgwLCBjdXJ2ZV9qc18xLndOQUYpKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG5cdFx0ICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuXHRcdCAgICByZXR1cm4ge1xuXHRcdCAgICAgICAgQ1VSVkUsXG5cdFx0ICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuXHRcdCAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcblx0XHQgICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG5cdFx0ICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG5cdFx0ICAgIH07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuXHRcdCAgICBjb25zdCBvcHRzID0gKDAsIGN1cnZlX2pzXzEudmFsaWRhdGVCYXNpYykoY3VydmUpO1xuXHRcdCAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG5cdFx0ICAgICAgICBoYXNoOiAnaGFzaCcsXG5cdFx0ICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuXHRcdCAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG5cdFx0ICAgIH0sIHtcblx0XHQgICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuXHRcdCAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcblx0XHQgICAgICAgIGxvd1M6ICdib29sZWFuJyxcblx0XHQgICAgfSk7XG5cdFx0ICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgbG93UzogdHJ1ZSwgLi4ub3B0cyB9KTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBzaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBhbmQgRUNEU0Egc2lnbmF0dXJlIG1ldGhvZHMgZm9yIGl0LlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogaW1wb3J0IHsgRmllbGQgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuXHRcdCAqIC8vIEJlZm9yZSB0aGF0LCBkZWZpbmUgQmlnSW50LXM6IGEsIGIsIHAsIG4sIEd4LCBHeVxuXHRcdCAqIGNvbnN0IGN1cnZlID0gd2VpZXJzdHJhc3MoeyBhLCBiLCBGcDogRmllbGQocCksIG4sIEd4LCBHeSwgaDogMW4gfSlcblx0XHQgKi9cblx0XHRmdW5jdGlvbiB3ZWllcnN0cmFzcyhjdXJ2ZURlZikge1xuXHRcdCAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG5cdFx0ICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcblx0XHQgICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcblx0XHQgICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcblx0XHQgICAgZnVuY3Rpb24gbW9kTihhKSB7XG5cdFx0ICAgICAgICByZXR1cm4gKDAsIG1vZHVsYXJfanNfMS5tb2QpKGEsIENVUlZFX09SREVSKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBpbnZOKGEpIHtcblx0XHQgICAgICAgIHJldHVybiAoMCwgbW9kdWxhcl9qc18xLmludmVydCkoYSwgQ1VSVkVfT1JERVIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuXHRcdCAgICAgICAgLi4uQ1VSVkUsXG5cdFx0ICAgICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcblx0XHQgICAgICAgICAgICBjb25zdCBjYXQgPSB1dC5jb25jYXRCeXRlcztcblx0XHQgICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5hYm9vbCkoJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG5cdFx0ICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDB4MDIgOiAweDAzXSksIHgpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9LFxuXHRcdCAgICAgICAgZnJvbUJ5dGVzKGJ5dGVzKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcblx0XHQgICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG5cdFx0ICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcblx0XHQgICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IHggPSB1dC5ieXRlc1RvTnVtYmVyQkUodGFpbCk7XG5cdFx0ICAgICAgICAgICAgICAgIGlmICghdXQuaW5SYW5nZSh4LCBfMW4sIEZwLk9SREVSKSlcblx0XHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG5cdFx0ICAgICAgICAgICAgICAgIGxldCB5O1xuXHRcdCAgICAgICAgICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0gecKyIF4gKHArMSkvNFxuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGNhdGNoIChzcXJ0RXJyb3IpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IHNxcnRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gJzogJyArIHNxcnRFcnJvci5tZXNzYWdlIDogJyc7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScgKyBzdWZmaXgpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGlzWU9kZCA9ICh5ICYgXzFuKSA9PT0gXzFuO1xuXHRcdCAgICAgICAgICAgICAgICAvLyBFQ0RTQVxuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoaXNIZWFkT2RkICE9PSBpc1lPZGQpXG5cdFx0ICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWQgPT09IDB4MDQpIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGNsID0gY29tcHJlc3NlZExlbjtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgdWwgPSB1bmNvbXByZXNzZWRMZW47XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBQb2ludCwgZXhwZWN0ZWQgbGVuZ3RoIG9mICcgKyBjbCArICcsIG9yIHVuY29tcHJlc3NlZCAnICsgdWwgKyAnLCBnb3QgJyArIGxlbik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfSxcblx0XHQgICAgfSk7XG5cdFx0ICAgIGNvbnN0IG51bVRvTkJ5dGVTdHIgPSAobnVtKSA9PiB1dC5ieXRlc1RvSGV4KHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKSk7XG5cdFx0ICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG5cdFx0ICAgICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcblx0XHQgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBtb2ROKC1zKSA6IHM7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG5cdFx0ICAgIGNvbnN0IHNsY051bSA9IChiLCBmcm9tLCB0bykgPT4gdXQuYnl0ZXNUb051bWJlckJFKGIuc2xpY2UoZnJvbSwgdG8pKTtcblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBTaWduYXR1cmUge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcblx0XHQgICAgICAgICAgICB0aGlzLnIgPSByO1xuXHRcdCAgICAgICAgICAgIHRoaXMucyA9IHM7XG5cdFx0ICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuXHRcdCAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG5cdFx0ICAgICAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuXHRcdCAgICAgICAgICAgIGhleCA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLy8gREVSIGVuY29kZWQgRUNEU0Egc2lnbmF0dXJlXG5cdFx0ICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG5cdFx0ICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcblx0XHQgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IGV4cG9ydHMuREVSLnRvU2lnKCgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnREVSJywgaGV4KSk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcblx0XHQgICAgICAgICAgICB1dC5hSW5SYW5nZSgncicsIHRoaXMuciwgXzFuLCBDVVJWRV9PUkRFUik7IC8vIHIgaW4gWzEuLk5dXG5cdFx0ICAgICAgICAgICAgdXQuYUluUmFuZ2UoJ3MnLCB0aGlzLnMsIF8xbiwgQ1VSVkVfT1JERVIpOyAvLyBzIGluIFsxLi5OXVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKCgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuXHRcdCAgICAgICAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpXG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuXHRcdCAgICAgICAgICAgIGlmIChyYWRqID49IEZwLk9SREVSKVxuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG5cdFx0ICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG9OQnl0ZVN0cihyYWRqKSk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG5cdFx0ICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcblx0XHQgICAgICAgICAgICBjb25zdCB1MiA9IG1vZE4ocyAqIGlyKTsgLy8gc3JeLTFcblx0XHQgICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcblx0XHQgICAgICAgICAgICBpZiAoIVEpXG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTsgLy8gdW5zYWZlIGlzIGZpbmU6IG5vIHByaXYgZGF0YSBsZWFrZWRcblx0XHQgICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFE7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG5cdFx0ICAgICAgICBoYXNIaWdoUygpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBub3JtYWxpemVTKCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kTigtdGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLy8gREVSLWVuY29kZWRcblx0XHQgICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHRvREVSSGV4KCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkRFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xuXHRcdCAgICAgICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBjb25zdCB1dGlscyA9IHtcblx0XHQgICAgICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcblx0XHQgICAgICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9LFxuXHRcdCAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcblx0XHQgICAgICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gKDAsIG1vZHVsYXJfanNfMS5nZXRNaW5IYXNoTGVuZ3RoKShDVVJWRS5uKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gKDAsIG1vZHVsYXJfanNfMS5tYXBIYXNoVG9GaWVsZCkoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG5cdFx0ICAgICAgICB9LFxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cblx0XHQgICAgICAgICAqIEFsbG93cyB0byBtYXNzaXZlbHkgc3BlZWQtdXAgYHBvaW50Lm11bHRpcGx5KHNjYWxhcilgLlxuXHRcdCAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG5cdFx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHRcdCAgICAgICAgICogY29uc3QgZmFzdCA9IHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoc29tZW9uZXNQdWJLZXkpKTtcblx0XHQgICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuXHRcdCAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuXHRcdCAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuXHRcdCAgICAgICAgfSxcblx0XHQgICAgfTtcblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuXHRcdCAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuXHRcdCAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuXHRcdCAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG5cdFx0ICAgICAqL1xuXHRcdCAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcblx0XHQgICAgfVxuXHRcdCAgICAvKipcblx0XHQgICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG5cdFx0ICAgICAqL1xuXHRcdCAgICBmdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xuXHRcdCAgICAgICAgY29uc3QgYXJyID0gdXQuaXNCeXRlcyhpdGVtKTtcblx0XHQgICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcblx0XHQgICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcblx0XHQgICAgICAgIGlmIChhcnIpXG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcblx0XHQgICAgICAgIGlmIChzdHIpXG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gMiAqIGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSAyICogdW5jb21wcmVzc2VkTGVuO1xuXHRcdCAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcblx0XHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgfVxuXHRcdCAgICAvKipcblx0XHQgICAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuXHRcdCAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuXHRcdCAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG5cdFx0ICAgICAqIERvZXMgTk9UIGhhc2ggdGhlIHJlc3VsdC5cblx0XHQgICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG5cdFx0ICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG5cdFx0ICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG5cdFx0ICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG5cdFx0ICAgICAqL1xuXHRcdCAgICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUEsIHB1YmxpY0IsIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcblx0XHQgICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcblx0XHQgICAgICAgIGlmICghaXNQcm9iUHViKHB1YmxpY0IpKVxuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcblx0XHQgICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcblx0XHQgICAgICAgIHJldHVybiBiLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cblx0XHQgICAgLy8gRklQUyAxODYtNCA0LjYgc3VnZ2VzdHMgdGhlIGxlZnRtb3N0IG1pbihuQml0TGVuLCBvdXRMZW4pIGJpdHMsIHdoaWNoIG1hdGNoZXMgYml0czJpbnQuXG5cdFx0ICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cblx0XHQgICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcblx0XHQgICAgY29uc3QgYml0czJpbnQgPSBDVVJWRS5iaXRzMmludCB8fFxuXHRcdCAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG5cdFx0ICAgICAgICAgICAgLy8gT3VyIGN1c3RvbSBjaGVjayBcImp1c3QgaW4gY2FzZVwiXG5cdFx0ICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IDgxOTIpXG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgaXMgdG9vIGxhcmdlJyk7XG5cdFx0ICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG5cdFx0ICAgICAgICAgICAgLy8gZm9yIHNvbWUgY2FzZXMsIHNpbmNlIGJ5dGVzLmxlbmd0aCAqIDggaXMgbm90IGFjdHVhbCBiaXRMZW5ndGguXG5cdFx0ICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuXHRcdCAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuXHRcdCAgICAgICAgICAgIHJldHVybiBkZWx0YSA+IDAgPyBudW0gPj4gQmlnSW50KGRlbHRhKSA6IG51bTtcblx0XHQgICAgICAgIH07XG5cdFx0ICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG5cdFx0ICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcblx0XHQgICAgICAgIH07XG5cdFx0ICAgIC8vIE5PVEU6IHBhZHMgb3V0cHV0IHdpdGggemVybyBhcyBwZXIgc3BlY1xuXHRcdCAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIENvbnZlcnRzIHRvIGJ5dGVzLiBDaGVja3MgaWYgbnVtIGluIGBbMC4uT1JERVJfTUFTSy0xXWAgZS5nLjogYFswLi4yXjI1Ni0xXWAuXG5cdFx0ICAgICAqL1xuXHRcdCAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuXHRcdCAgICAgICAgdXQuYUluUmFuZ2UoJ251bSA8IDJeJyArIENVUlZFLm5CaXRMZW5ndGgsIG51bSwgXzBuLCBPUkRFUl9NQVNLKTtcblx0XHQgICAgICAgIC8vIHdvcmtzIHdpdGggb3JkZXIsIGNhbiBoYXZlIGRpZmZlcmVudCBzaXplIHRoYW4gbnVtVG9GaWVsZCFcblx0XHQgICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMlxuXHRcdCAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cblx0XHQgICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG5cdFx0ICAgIC8vIE5PVEU6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1zZ0hhc2ggaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLFxuXHRcdCAgICAvLyB0aGlzIHdpbGwgYmUgaW52YWxpZCBhdCBsZWFzdCBmb3IgUDUyMS4gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2XG5cdFx0ICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG5cdFx0ICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG5cdFx0ICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcblx0XHQgICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG5cdFx0ICAgICAgICBpZiAobG93UyA9PSBudWxsKVxuXHRcdCAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcblx0XHQgICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcblx0XHQgICAgICAgIHZhbGlkYXRlU2lnVmVyT3B0cyhvcHRzKTtcblx0XHQgICAgICAgIGlmIChwcmVoYXNoKVxuXHRcdCAgICAgICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3ByZWhhc2hlZCBtc2dIYXNoJywgaGFzaChtc2dIYXNoKSk7XG5cdFx0ICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcblx0XHQgICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuXHRcdCAgICAgICAgLy8gY29uc3QgYml0czJvY3RldHMgPSAoYml0cykgPT4gaW50Mm9jdGV0cyhiaXRzMmludF9tb2ROKGJpdHMpKVxuXHRcdCAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuXHRcdCAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuXHRcdCAgICAgICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgaW50Mm9jdGV0cyhoMWludCldO1xuXHRcdCAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuXHRcdCAgICAgICAgaWYgKGVudCAhPSBudWxsICYmIGVudCAhPT0gZmFsc2UpIHtcblx0XHQgICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcblx0XHQgICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuXHRcdCAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3Qgc2VlZCA9IHV0LmNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG5cdFx0ICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuXHRcdCAgICAgICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cblx0XHQgICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xuXHRcdCAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuXHRcdCAgICAgICAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG5cdFx0ICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG5cdFx0ICAgICAgICAgICAgY29uc3QgaWsgPSBpbnZOKGspOyAvLyBrXi0xIG1vZCBuXG5cdFx0ICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG5cdFx0ICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuXHRcdCAgICAgICAgICAgIGlmIChyID09PSBfMG4pXG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG5cdFx0ICAgICAgICAgICAgLy8gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzczMzcvNjUwOS4gV2UndmUgZGVjaWRlZCBhZ2FpbnN0IGl0OlxuXHRcdCAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuXHRcdCAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcblx0XHQgICAgICAgICAgICBpZiAocyA9PT0gXzBuKVxuXHRcdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuXHRcdCAgICAgICAgICAgIGxldCBub3JtUyA9IHM7XG5cdFx0ICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcblx0XHQgICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcblx0XHQgICAgfVxuXHRcdCAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcblx0XHQgICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHByaXZhdGUga2V5LlxuXHRcdCAgICAgKiBgYGBcblx0XHQgICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuXHRcdCAgICAgKiAgICh4LCB5KSA9IEcgw5cga1xuXHRcdCAgICAgKiAgIHIgPSB4IG1vZCBuXG5cdFx0ICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cblx0XHQgICAgICogYGBgXG5cdFx0ICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cblx0XHQgICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcblx0XHQgICAgICogQHBhcmFtIG9wdHMgbG93UyBmb3Igbm9uLW1hbGxlYWJsZSBzaWdzLiBleHRyYUVudHJvcHkgZm9yIG1peGluZyByYW5kb21uZXNzIGludG8gay4gcHJlaGFzaCB3aWxsIGhhc2ggZmlyc3QgYXJnLlxuXHRcdCAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxuXHRcdCAgICAgKi9cblx0XHQgICAgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcblx0XHQgICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG5cdFx0ICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG5cdFx0ICAgICAgICBjb25zdCBkcmJnID0gdXQuY3JlYXRlSG1hY0RyYmcoQy5oYXNoLm91dHB1dExlbiwgQy5uQnl0ZUxlbmd0aCwgQy5obWFjKTtcblx0XHQgICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cblx0XHQgICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcblx0XHQgICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuXHRcdCAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcblx0XHQgICAgICogc3BlY2lmeSBvcHRpb24gYHtsb3dTOiBmYWxzZX1gLiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcblx0XHQgICAgICpcblx0XHQgICAgICogYGBgXG5cdFx0ICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuXHRcdCAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cblx0XHQgICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG5cdFx0ICAgICAqICAgUiA9IFUx4ouFRyAtIFUy4ouFUFxuXHRcdCAgICAgKiAgIG1vZChSLngsIG4pID09IHJcblx0XHQgICAgICogYGBgXG5cdFx0ICAgICAqL1xuXHRcdCAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xuXHRcdCAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG5cdFx0ICAgICAgICBtc2dIYXNoID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdtc2dIYXNoJywgbXNnSGFzaCk7XG5cdFx0ICAgICAgICBwdWJsaWNLZXkgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG5cdFx0ICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2gsIGZvcm1hdCB9ID0gb3B0cztcblx0XHQgICAgICAgIC8vIFZlcmlmeSBvcHRzLCBkZWR1Y2Ugc2lnbmF0dXJlIGZvcm1hdFxuXHRcdCAgICAgICAgdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpO1xuXHRcdCAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG5cdFx0ICAgICAgICBpZiAoZm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgZm9ybWF0ICE9PSAnY29tcGFjdCcgJiYgZm9ybWF0ICE9PSAnZGVyJylcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zvcm1hdCBtdXN0IGJlIGNvbXBhY3Qgb3IgZGVyJyk7XG5cdFx0ICAgICAgICBjb25zdCBpc0hleCA9IHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgdXQuaXNCeXRlcyhzZyk7XG5cdFx0ICAgICAgICBjb25zdCBpc09iaiA9ICFpc0hleCAmJlxuXHRcdCAgICAgICAgICAgICFmb3JtYXQgJiZcblx0XHQgICAgICAgICAgICB0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmXG5cdFx0ICAgICAgICAgICAgc2cgIT09IG51bGwgJiZcblx0XHQgICAgICAgICAgICB0eXBlb2Ygc2cuciA9PT0gJ2JpZ2ludCcgJiZcblx0XHQgICAgICAgICAgICB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCc7XG5cdFx0ICAgICAgICBpZiAoIWlzSGV4ICYmICFpc09iailcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmF0dXJlLCBleHBlY3RlZCBVaW50OEFycmF5LCBoZXggc3RyaW5nIG9yIFNpZ25hdHVyZSBpbnN0YW5jZScpO1xuXHRcdCAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBsZXQgUDtcblx0XHQgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgaWYgKGlzT2JqKVxuXHRcdCAgICAgICAgICAgICAgICBfc2lnID0gbmV3IFNpZ25hdHVyZShzZy5yLCBzZy5zKTtcblx0XHQgICAgICAgICAgICBpZiAoaXNIZXgpIHtcblx0XHQgICAgICAgICAgICAgICAgLy8gU2lnbmF0dXJlIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheXM6IGNvbXBhY3QgKDIqbkJ5dGVMZW5ndGgpICYgREVSICh2YXJpYWJsZS1sZW5ndGgpLlxuXHRcdCAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuXHRcdCAgICAgICAgICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdCAhPT0gJ2NvbXBhY3QnKVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIGV4cG9ydHMuREVSLkVycikpXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgaWYgKCFfc2lnICYmIGZvcm1hdCAhPT0gJ2RlcicpXG5cdFx0ICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghX3NpZylcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgaWYgKHByZWhhc2gpXG5cdFx0ICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG5cdFx0ICAgICAgICBjb25zdCB7IHIsIHMgfSA9IF9zaWc7XG5cdFx0ICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuXHRcdCAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG5cdFx0ICAgICAgICBjb25zdCB1MSA9IG1vZE4oaCAqIGlzKTsgLy8gdTEgPSBoc14tMSBtb2QgblxuXHRcdCAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cblx0XHQgICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcblx0XHQgICAgICAgIGlmICghUilcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuXHRcdCAgICAgICAgcmV0dXJuIHYgPT09IHI7XG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIHtcblx0XHQgICAgICAgIENVUlZFLFxuXHRcdCAgICAgICAgZ2V0UHVibGljS2V5LFxuXHRcdCAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuXHRcdCAgICAgICAgc2lnbixcblx0XHQgICAgICAgIHZlcmlmeSxcblx0XHQgICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG5cdFx0ICAgICAgICBTaWduYXR1cmUsXG5cdFx0ICAgICAgICB1dGlscyxcblx0XHQgICAgfTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG5cdFx0ICogVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSB3YXkgdG8gbWVyZ2UgdGhpcyB3aXRoIHV2UmF0aW8gaW4gRWR3YXJkczsgbW92ZSB0byBtb2R1bGFyLlxuXHRcdCAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG5cdFx0ICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuXHRcdCAqIEBwYXJhbSBGcFxuXHRcdCAqIEBwYXJhbSBaXG5cdFx0ICogQHJldHVybnNcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBTV1VGcFNxcnRSYXRpbyhGcCwgWikge1xuXHRcdCAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG5cdFx0ICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcblx0XHQgICAgbGV0IGwgPSBfMG47XG5cdFx0ICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuXHRcdCAgICAgICAgbCArPSBfMW47XG5cdFx0ICAgIGNvbnN0IGMxID0gbDsgLy8gMS4gYzEsIHRoZSBsYXJnZXN0IGludGVnZXIgc3VjaCB0aGF0IDJeYzEgZGl2aWRlcyBxIC0gMS5cblx0XHQgICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuXHRcdCAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcblx0XHQgICAgY29uc3QgXzJuX3Bvd19jMV8xID0gXzJuIDw8IChjMSAtIF8xbiAtIF8xbik7XG5cdFx0ICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG5cdFx0ICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuXHRcdCAgICBjb25zdCBjMyA9IChjMiAtIF8xbikgLyBfMm47IC8vIDMuIGMzID0gKGMyIC0gMSkgLyAyICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcblx0XHQgICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG5cdFx0ICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuXHRcdCAgICBjb25zdCBjNiA9IEZwLnBvdyhaLCBjMik7IC8vIDYuIGM2ID0gWl5jMlxuXHRcdCAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG5cdFx0ICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuXHRcdCAgICAgICAgbGV0IHR2MSA9IGM2OyAvLyAxLiB0djEgPSBjNlxuXHRcdCAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcblx0XHQgICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcblx0XHQgICAgICAgIHR2MyA9IEZwLm11bCh0djMsIHYpOyAvLyA0LiB0djMgPSB0djMgKiB2XG5cdFx0ICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcblx0XHQgICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG5cdFx0ICAgICAgICB0djUgPSBGcC5tdWwodHY1LCB0djIpOyAvLyA3LiB0djUgPSB0djUgKiB0djJcblx0XHQgICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG5cdFx0ICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuXHRcdCAgICAgICAgbGV0IHR2NCA9IEZwLm11bCh0djMsIHR2Mik7IC8vIDEwLiB0djQgPSB0djMgKiB0djJcblx0XHQgICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuXHRcdCAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG5cdFx0ICAgICAgICB0djIgPSBGcC5tdWwodHYzLCBjNyk7IC8vIDEzLiB0djIgPSB0djMgKiBjN1xuXHRcdCAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuXHRcdCAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuXHRcdCAgICAgICAgdHY0ID0gRnAuY21vdih0djUsIHR2NCwgaXNRUik7IC8vIDE2LiB0djQgPSBDTU9WKHR2NSwgdHY0LCBpc1FSKVxuXHRcdCAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuXHRcdCAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcblx0XHQgICAgICAgICAgICBsZXQgdHY1ID0gaSAtIF8ybjsgLy8gMTguICAgIHR2NSA9IGkgLSAyXG5cdFx0ICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcblx0XHQgICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG5cdFx0ICAgICAgICAgICAgY29uc3QgZTEgPSBGcC5lcWwodHZ2NSwgRnAuT05FKTsgLy8gMjEuICAgIGUxID0gdHY1ID09IDFcblx0XHQgICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG5cdFx0ICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuXHRcdCAgICAgICAgICAgIHR2djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAyNC4gICAgdHY1ID0gdHY0ICogdHYxXG5cdFx0ICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG5cdFx0ICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuXHRcdCAgICB9O1xuXHRcdCAgICBpZiAoRnAuT1JERVIgJSBfNG4gPT09IF8zbikge1xuXHRcdCAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuXHRcdCAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuXHRcdCAgICAgICAgY29uc3QgYzIgPSBGcC5zcXJ0KEZwLm5lZyhaKSk7IC8vIDIuIGMyID0gc3FydCgtWilcblx0XHQgICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG5cdFx0ICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG5cdFx0ICAgICAgICAgICAgY29uc3QgdHYyID0gRnAubXVsKHUsIHYpOyAvLyAyLiB0djIgPSB1ICogdlxuXHRcdCAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuXHRcdCAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcblx0XHQgICAgICAgICAgICB5MSA9IEZwLm11bCh5MSwgdHYyKTsgLy8gNS4geTEgPSB5MSAqIHR2MlxuXHRcdCAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuXHRcdCAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuXHRcdCAgICAgICAgICAgIGNvbnN0IGlzUVIgPSBGcC5lcWwodHYzLCB1KTsgLy8gOS4gaXNRUiA9IHR2MyA9PSB1XG5cdFx0ICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcblx0XHQgICAgLy8gaWYgKEZwLk9SREVSICUgXzhuID09PSBfNW4pIC8vIHNxcnRfcmF0aW9fNW1vZDhcblx0XHQgICAgcmV0dXJuIHNxcnRSYXRpbztcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2Rcblx0XHQgKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwgb3B0cykge1xuXHRcdCAgICAoMCwgbW9kdWxhcl9qc18xLnZhbGlkYXRlRmllbGQpKEZwKTtcblx0XHQgICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuXHRcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcblx0XHQgICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIG9wdHMuWik7XG5cdFx0ICAgIGlmICghRnAuaXNPZGQpXG5cdFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcblx0XHQgICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cblx0XHQgICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cblx0XHQgICAgcmV0dXJuICh1KSA9PiB7XG5cdFx0ICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcblx0XHQgICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuXHRcdCAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG5cdFx0ICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBvcHRzLlopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxuXHRcdCAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuXHRcdCAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuXHRcdCAgICAgICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcblx0XHQgICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG5cdFx0ICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuXHRcdCAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcblx0XHQgICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcblx0XHQgICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcblx0XHQgICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG5cdFx0ICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG5cdFx0ICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG5cdFx0ICAgICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG5cdFx0ICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuXHRcdCAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuXHRcdCAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcblx0XHQgICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2Nilcblx0XHQgICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuXHRcdCAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcblx0XHQgICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcblx0XHQgICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG5cdFx0ICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuXHRcdCAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcblx0XHQgICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcblx0XHQgICAgICAgIHJldHVybiB7IHgsIHkgfTtcblx0XHQgICAgfTtcblx0XHR9XG5cdFx0XG5cdH0gKHdlaWVyc3RyYXNzKSk7XG5cdHJldHVybiB3ZWllcnN0cmFzcztcbn1cblxudmFyIGhhc1JlcXVpcmVkX3Nob3J0d191dGlscztcblxuZnVuY3Rpb24gcmVxdWlyZV9zaG9ydHdfdXRpbHMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfc2hvcnR3X3V0aWxzKSByZXR1cm4gX3Nob3J0d191dGlscztcblx0aGFzUmVxdWlyZWRfc2hvcnR3X3V0aWxzID0gMTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KF9zaG9ydHdfdXRpbHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRfc2hvcnR3X3V0aWxzLmdldEhhc2ggPSBnZXRIYXNoO1xuXHRfc2hvcnR3X3V0aWxzLmNyZWF0ZUN1cnZlID0gY3JlYXRlQ3VydmU7XG5cdC8qKlxuXHQgKiBVdGlsaXRpZXMgZm9yIHNob3J0IHdlaWVyc3RyYXNzIGN1cnZlcywgY29tYmluZWQgd2l0aCBub2JsZS1oYXNoZXMuXG5cdCAqIEBtb2R1bGVcblx0ICovXG5cdC8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cblx0Y29uc3QgaG1hY18xID0gLypAX19QVVJFX18qLyByZXF1aXJlSG1hYygpO1xuXHRjb25zdCB1dGlsc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMkMigpO1xuXHRjb25zdCB3ZWllcnN0cmFzc19qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlV2VpZXJzdHJhc3MoKTtcblx0LyoqIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXMgKi9cblx0ZnVuY3Rpb24gZ2V0SGFzaChoYXNoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGhhc2gsXG5cdCAgICAgICAgaG1hYzogKGtleSwgLi4ubXNncykgPT4gKDAsIGhtYWNfMS5obWFjKShoYXNoLCBrZXksICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKSguLi5tc2dzKSksXG5cdCAgICAgICAgcmFuZG9tQnl0ZXM6IHV0aWxzXzEucmFuZG9tQnl0ZXMsXG5cdCAgICB9O1xuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG5cdCAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gKDAsIHdlaWVyc3RyYXNzX2pzXzEud2VpZXJzdHJhc3MpKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG5cdCAgICByZXR1cm4geyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9O1xuXHR9XG5cdFxuXHRyZXR1cm4gX3Nob3J0d191dGlscztcbn1cblxudmFyIGhhc1JlcXVpcmVkU2VjcDI1NmsxO1xuXG5mdW5jdGlvbiByZXF1aXJlU2VjcDI1NmsxICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkU2VjcDI1NmsxKSByZXR1cm4gc2VjcDI1NmsxO1xuXHRoYXNSZXF1aXJlZFNlY3AyNTZrMSA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0XHRleHBvcnRzLmVuY29kZVRvQ3VydmUgPSBleHBvcnRzLmhhc2hUb0N1cnZlID0gZXhwb3J0cy5zY2hub3JyID0gZXhwb3J0cy5zZWNwMjU2azEgPSB2b2lkIDA7XG5cdFx0LyoqXG5cdFx0ICogTklTVCBzZWNwMjU2azEuIFNlZSBbcGRmXShodHRwczovL3d3dy5zZWNnLm9yZy9zZWMyLXYyLnBkZikuXG5cdFx0ICpcblx0XHQgKiBTZWVtcyB0byBiZSByaWdpZCAobm90IGJhY2tkb29yZWQpXG5cdFx0ICogW2FzIHBlciBkaXNjdXNzaW9uXShodHRwczovL2JpdGNvaW50YWxrLm9yZy9pbmRleC5waHA/dG9waWM9Mjg5Nzk1Lm1zZzMxODM5NzUjbXNnMzE4Mzk3NSkuXG5cdFx0ICpcblx0XHQgKiBzZWNwMjU2azEgYmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5IGNvbXB1dGFibGUgZW5kb21vcnBoaXNtLlxuXHRcdCAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuXHRcdCAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cblx0XHQgKiBbU2VlIGV4cGxhbmF0aW9uXShodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsbWlsbHIvZWI2NzA4MDY3OTNlODRkZjYyOGE3YzQzNGE4NzMwNjYpLlxuXHRcdCAqIEBtb2R1bGVcblx0XHQgKi9cblx0XHQvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5cdFx0Y29uc3Qgc2hhMjU2XzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVTaGEyNTYoKTtcblx0XHRjb25zdCB1dGlsc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMkMigpO1xuXHRcdGNvbnN0IF9zaG9ydHdfdXRpbHNfanNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZV9zaG9ydHdfdXRpbHMoKTtcblx0XHRjb25zdCBoYXNoX3RvX2N1cnZlX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVIYXNoVG9DdXJ2ZSgpO1xuXHRcdGNvbnN0IG1vZHVsYXJfanNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZU1vZHVsYXIoKTtcblx0XHRjb25zdCB1dGlsc19qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMkMSgpO1xuXHRcdGNvbnN0IHdlaWVyc3RyYXNzX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVXZWllcnN0cmFzcygpO1xuXHRcdGNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuXHRcdGNvbnN0IHNlY3AyNTZrMU4gPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpO1xuXHRcdGNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcblx0XHRjb25zdCBfMm4gPSBCaWdJbnQoMik7XG5cdFx0Y29uc3QgZGl2TmVhcmVzdCA9IChhLCBiKSA9PiAoYSArIGIgLyBfMm4pIC8gYjtcblx0XHQvKipcblx0XHQgKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuXHRcdCAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzcXJ0TW9kKHkpIHtcblx0XHQgICAgY29uc3QgUCA9IHNlY3AyNTZrMVA7XG5cdFx0ICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuXHRcdCAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuXHRcdCAgICAvLyBwcmV0dGllci1pZ25vcmVcblx0XHQgICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcblx0XHQgICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcblx0XHQgICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHkpICUgUDsgLy8geF43XG5cdFx0ICAgIGNvbnN0IGI2ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuXHRcdCAgICBjb25zdCBiOSA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI2LCBfM24sIFApICogYjMpICUgUDtcblx0XHQgICAgY29uc3QgYjExID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjksIF8ybiwgUCkgKiBiMikgJSBQO1xuXHRcdCAgICBjb25zdCBiMjIgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG5cdFx0ICAgIGNvbnN0IGI0NCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcblx0XHQgICAgY29uc3QgYjg4ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjQ0LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuXHRcdCAgICBjb25zdCBiMTc2ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuXHRcdCAgICBjb25zdCBiMjIwID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcblx0XHQgICAgY29uc3QgYjIyMyA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIyMjAsIF8zbiwgUCkgKiBiMykgJSBQO1xuXHRcdCAgICBjb25zdCB0MSA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG5cdFx0ICAgIGNvbnN0IHQyID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikodDEsIF82biwgUCkgKiBiMikgJSBQO1xuXHRcdCAgICBjb25zdCByb290ID0gKDAsIG1vZHVsYXJfanNfMS5wb3cyKSh0MiwgXzJuLCBQKTtcblx0XHQgICAgaWYgKCFGcGsxLmVxbChGcGsxLnNxcihyb290KSwgeSkpXG5cdFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG5cdFx0ICAgIHJldHVybiByb290O1xuXHRcdH1cblx0XHRjb25zdCBGcGsxID0gKDAsIG1vZHVsYXJfanNfMS5GaWVsZCkoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcblx0XHQvKipcblx0XHQgKiBzZWNwMjU2azEgc2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgYW5kIEVDRFNBIHNpZ25hdHVyZXMgb3ZlciBpdC5cblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuXHRcdCAqXG5cdFx0ICogY29uc3QgcHJpdiA9IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG5cdFx0ICogY29uc3QgcHViID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleShwcml2KTtcblx0XHQgKiBjb25zdCBtc2cgPSBuZXcgVWludDhBcnJheSgzMikuZmlsbCgxKTsgLy8gbWVzc2FnZSBoYXNoIChub3QgbWVzc2FnZSkgaW4gZWNkc2Fcblx0XHQgKiBjb25zdCBzaWcgPSBzZWNwMjU2azEuc2lnbihtc2csIHByaXYpOyAvLyBge3ByZWhhc2g6IHRydWV9YCBvcHRpb24gaXMgYXZhaWxhYmxlXG5cdFx0ICogY29uc3QgaXNWYWxpZCA9IHNlY3AyNTZrMS52ZXJpZnkoc2lnLCBtc2csIHB1YikgPT09IHRydWU7XG5cdFx0ICovXG5cdFx0ZXhwb3J0cy5zZWNwMjU2azEgPSAoMCwgX3Nob3J0d191dGlsc19qc18xLmNyZWF0ZUN1cnZlKSh7XG5cdFx0ICAgIGE6IEJpZ0ludCgwKSwgLy8gZXF1YXRpb24gcGFyYW1zOiBhLCBiXG5cdFx0ICAgIGI6IEJpZ0ludCg3KSxcblx0XHQgICAgRnA6IEZwazEsIC8vIEZpZWxkJ3MgcHJpbWU6IDJuKioyNTZuIC0gMm4qKjMybiAtIDJuKio5biAtIDJuKio4biAtIDJuKio3biAtIDJuKio2biAtIDJuKio0biAtIDFuXG5cdFx0ICAgIG46IHNlY3AyNTZrMU4sIC8vIEN1cnZlIG9yZGVyLCB0b3RhbCBjb3VudCBvZiB2YWxpZCBwb2ludHMgaW4gdGhlIGZpZWxkXG5cdFx0ICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcblx0XHQgICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcblx0XHQgICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcblx0XHQgICAgaDogQmlnSW50KDEpLCAvLyBDb2ZhY3RvclxuXHRcdCAgICBsb3dTOiB0cnVlLCAvLyBBbGxvdyBvbmx5IGxvdy1TIHNpZ25hdHVyZXMgYnkgZGVmYXVsdCBpbiBzaWduKCkgYW5kIHZlcmlmeSgpXG5cdFx0ICAgIGVuZG86IHtcblx0XHQgICAgICAgIC8vIEVuZG9tb3JwaGlzbSwgc2VlIGFib3ZlXG5cdFx0ICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuXHRcdCAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgbiA9IHNlY3AyNTZrMU47XG5cdFx0ICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcblx0XHQgICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcblx0XHQgICAgICAgICAgICBjb25zdCBhMiA9IEJpZ0ludCgnMHgxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnKTtcblx0XHQgICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcblx0XHQgICAgICAgICAgICBjb25zdCBjMSA9IGRpdk5lYXJlc3QoYjIgKiBrLCBuKTtcblx0XHQgICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG5cdFx0ICAgICAgICAgICAgbGV0IGsxID0gKDAsIG1vZHVsYXJfanNfMS5tb2QpKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG5cdFx0ICAgICAgICAgICAgbGV0IGsyID0gKDAsIG1vZHVsYXJfanNfMS5tb2QpKC1jMSAqIGIxIC0gYzIgKiBiMiwgbik7XG5cdFx0ICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcblx0XHQgICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuXHRcdCAgICAgICAgICAgIGlmIChrMW5lZylcblx0XHQgICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG5cdFx0ICAgICAgICAgICAgaWYgKGsybmVnKVxuXHRcdCAgICAgICAgICAgICAgICBrMiA9IG4gLSBrMjtcblx0XHQgICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG5cdFx0ICAgICAgICB9LFxuXHRcdCAgICB9LFxuXHRcdH0sIHNoYTI1Nl8xLnNoYTI1Nik7XG5cdFx0Ly8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraVxuXHRcdGNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcblx0XHQvKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5cdFx0Y29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcblx0XHRmdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcblx0XHQgICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuXHRcdCAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICBjb25zdCB0YWdIID0gKDAsIHNoYTI1Nl8xLnNoYTI1NikoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuXHRcdCAgICAgICAgdGFnUCA9ICgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSh0YWdILCB0YWdIKTtcblx0XHQgICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiAoMCwgc2hhMjU2XzEuc2hhMjU2KSgoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykodGFnUCwgLi4ubWVzc2FnZXMpKTtcblx0XHR9XG5cdFx0Ly8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5cdFx0Y29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuXHRcdGNvbnN0IG51bVRvMzJiID0gKG4pID0+ICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNCRSkobiwgMzIpO1xuXHRcdGNvbnN0IG1vZFAgPSAoeCkgPT4gKDAsIG1vZHVsYXJfanNfMS5tb2QpKHgsIHNlY3AyNTZrMVApO1xuXHRcdGNvbnN0IG1vZE4gPSAoeCkgPT4gKDAsIG1vZHVsYXJfanNfMS5tb2QpKHgsIHNlY3AyNTZrMU4pO1xuXHRcdGNvbnN0IFBvaW50ID0gZXhwb3J0cy5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuXHRcdGNvbnN0IEdtdWxBZGQgPSAoUSwgYSwgYikgPT4gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKTtcblx0XHQvLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcblx0XHRmdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcblx0XHQgICAgbGV0IGRfID0gZXhwb3J0cy5zZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcblx0XHQgICAgbGV0IHAgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShkXyk7IC8vIFAgPSBkJ+KLhUc7IDAgPCBkJyA8IG4gY2hlY2sgaXMgZG9uZSBpbnNpZGVcblx0XHQgICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG5cdFx0ICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cblx0XHQgKiBAcmV0dXJucyB2YWxpZCBwb2ludCBjaGVja2VkIGZvciBiZWluZyBvbi1jdXJ2ZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGxpZnRfeCh4KSB7XG5cdFx0ICAgICgwLCB1dGlsc19qc18xLmFJblJhbmdlKSgneCcsIHgsIF8xbiwgc2VjcDI1NmsxUCk7IC8vIEZhaWwgaWYgeCDiiaUgcC5cblx0XHQgICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcblx0XHQgICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuXHRcdCAgICBsZXQgeSA9IHNxcnRNb2QoYyk7IC8vIExldCB5ID0gY14ocCsxKS80IG1vZCBwLlxuXHRcdCAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuXHRcdCAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcblx0XHQgICAgY29uc3QgcCA9IG5ldyBQb2ludCh4LCB5LCBfMW4pOyAvLyB5KFApID0geSBpZiB5IG1vZCAyID0gMCBvciB5KFApID0gcC15IG90aGVyd2lzZS5cblx0XHQgICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuXHRcdCAgICByZXR1cm4gcDtcblx0XHR9XG5cdFx0Y29uc3QgbnVtID0gdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkU7XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG5cdFx0ICAgIHJldHVybiBtb2ROKG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG5cdFx0ICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxuXHRcdH1cblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuXHRcdCAqIGF1eFJhbmQgaXMgb3B0aW9uYWwgYW5kIGlzIG5vdCB0aGUgc29sZSBzb3VyY2Ugb2YgayBnZW5lcmF0aW9uOiBiYWQgQ1NQUk5HIHdvbid0IGJlIGRhbmdlcm91cy5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gKDAsIHV0aWxzXzEucmFuZG9tQnl0ZXMpKDMyKSkge1xuXHRcdCAgICBjb25zdCBtID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdtZXNzYWdlJywgbWVzc2FnZSk7XG5cdFx0ICAgIGNvbnN0IHsgYnl0ZXM6IHB4LCBzY2FsYXI6IGQgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSk7IC8vIGNoZWNrcyBmb3IgaXNXaXRoaW5DdXJ2ZU9yZGVyXG5cdFx0ICAgIGNvbnN0IGEgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcblx0XHQgICAgY29uc3QgdCA9IG51bVRvMzJiKGQgXiBudW0odGFnZ2VkSGFzaCgnQklQMDM0MC9hdXgnLCBhKSkpOyAvLyBMZXQgdCBiZSB0aGUgYnl0ZS13aXNlIHhvciBvZiBieXRlcyhkKSBhbmQgaGFzaC9hdXgoYSlcblx0XHQgICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG5cdFx0ICAgIGNvbnN0IGtfID0gbW9kTihudW0ocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cblx0XHQgICAgaWYgKGtfID09PSBfMG4pXG5cdFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG5cdFx0ICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cblx0XHQgICAgY29uc3QgZSA9IGNoYWxsZW5nZShyeCwgcHgsIG0pOyAvLyBMZXQgZSA9IGludChoYXNoL2NoYWxsZW5nZShieXRlcyhSKSB8fCBieXRlcyhQKSB8fCBtKSkgbW9kIG4uXG5cdFx0ICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cblx0XHQgICAgc2lnLnNldChyeCwgMCk7XG5cdFx0ICAgIHNpZy5zZXQobnVtVG8zMmIobW9kTihrICsgZSAqIGQpKSwgMzIpO1xuXHRcdCAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuXHRcdCAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG5cdFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ246IEludmFsaWQgc2lnbmF0dXJlIHByb2R1Y2VkJyk7XG5cdFx0ICAgIHJldHVybiBzaWc7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuXHRcdCAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuXHRcdCAgICBjb25zdCBzaWcgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSwgNjQpO1xuXHRcdCAgICBjb25zdCBtID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdtZXNzYWdlJywgbWVzc2FnZSk7XG5cdFx0ICAgIGNvbnN0IHB1YiA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG5cdFx0ICAgIHRyeSB7XG5cdFx0ICAgICAgICBjb25zdCBQID0gbGlmdF94KG51bShwdWIpKTsgLy8gUCA9IGxpZnRfeChpbnQocGspKTsgZmFpbCBpZiB0aGF0IGZhaWxzXG5cdFx0ICAgICAgICBjb25zdCByID0gbnVtKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG5cdFx0ICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmluUmFuZ2UpKHIsIF8xbiwgc2VjcDI1NmsxUCkpXG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgY29uc3QgcyA9IG51bShzaWcuc3ViYXJyYXkoMzIsIDY0KSk7IC8vIExldCBzID0gaW50KHNpZ1szMjo2NF0pOyBmYWlsIGlmIHMg4omlIG4uXG5cdFx0ICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmluUmFuZ2UpKHMsIF8xbiwgc2VjcDI1NmsxTikpXG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG5cdFx0ICAgICAgICBjb25zdCBSID0gR211bEFkZChQLCBzLCBtb2ROKC1lKSk7IC8vIFIgPSBz4ouFRyAtIGXii4VQXG5cdFx0ICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIC1lUCA9PSAobi1lKVBcblx0XHQgICAgICAgIHJldHVybiB0cnVlOyAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIOKJoCByLlxuXHRcdCAgICB9XG5cdFx0ICAgIGNhdGNoIChlcnJvcikge1xuXHRcdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICB9XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFNjaG5vcnIgc2lnbmF0dXJlcyBvdmVyIHNlY3AyNTZrMS5cblx0XHQgKiBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcblx0XHQgKiBjb25zdCBwcml2ID0gc2Nobm9yci51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG5cdFx0ICogY29uc3QgcHViID0gc2Nobm9yci5nZXRQdWJsaWNLZXkocHJpdik7XG5cdFx0ICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuXHRcdCAqIGNvbnN0IHNpZyA9IHNjaG5vcnIuc2lnbihtc2csIHByaXYpO1xuXHRcdCAqIGNvbnN0IGlzVmFsaWQgPSBzY2hub3JyLnZlcmlmeShzaWcsIG1zZywgcHViKTtcblx0XHQgKi9cblx0XHRleHBvcnRzLnNjaG5vcnIgPSAoKCkgPT4gKHtcblx0XHQgICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuXHRcdCAgICBzaWduOiBzY2hub3JyU2lnbixcblx0XHQgICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuXHRcdCAgICB1dGlsczoge1xuXHRcdCAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogZXhwb3J0cy5zZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcblx0XHQgICAgICAgIGxpZnRfeCxcblx0XHQgICAgICAgIHBvaW50VG9CeXRlcyxcblx0XHQgICAgICAgIG51bWJlclRvQnl0ZXNCRTogdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzQkUsXG5cdFx0ICAgICAgICBieXRlc1RvTnVtYmVyQkU6IHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFLFxuXHRcdCAgICAgICAgdGFnZ2VkSGFzaCxcblx0XHQgICAgICAgIG1vZDogbW9kdWxhcl9qc18xLm1vZCxcblx0XHQgICAgfSxcblx0XHR9KSkoKTtcblx0XHRjb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICgwLCBoYXNoX3RvX2N1cnZlX2pzXzEuaXNvZ2VueU1hcCkoRnBrMSwgW1xuXHRcdCAgICAvLyB4TnVtXG5cdFx0ICAgIFtcblx0XHQgICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4YzcnLFxuXHRcdCAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcblx0XHQgICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuXHRcdCAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYTg4YycsXG5cdFx0ICAgIF0sXG5cdFx0ICAgIC8vIHhEZW5cblx0XHQgICAgW1xuXHRcdCAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG5cdFx0ICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0Jyxcblx0XHQgICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcblx0XHQgICAgXSxcblx0XHQgICAgLy8geU51bVxuXHRcdCAgICBbXG5cdFx0ICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcblx0XHQgICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuXHRcdCAgICAgICAgJzB4MjlhNjE5NDY5MWY5MWE3MzcxNTIwOWVmNjUxMmU1NzY3MjI4MzBhMjAxYmUyMDE4YTc2NWU4NWE5ZWNlZTkzMScsXG5cdFx0ICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0Jyxcblx0XHQgICAgXSxcblx0XHQgICAgLy8geURlblxuXHRcdCAgICBbXG5cdFx0ICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcblx0XHQgICAgICAgICcweDdhMDY1MzRiYjhiZGI0OWZkNWU5ZTY2MzI3MjJjMjk4OTQ2N2MxYmZjOGU4ZDk3OGRmYjQyNWQyNjg1YzI1NzMnLFxuXHRcdCAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG5cdFx0ICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG5cdFx0ICAgIF0sXG5cdFx0XS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5cdFx0Y29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgd2VpZXJzdHJhc3NfanNfMS5tYXBUb0N1cnZlU2ltcGxlU1dVKShGcGsxLCB7XG5cdFx0ICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG5cdFx0ICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuXHRcdCAgICBaOiBGcGsxLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcblx0XHR9KSkoKTtcblx0XHRjb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICgwLCBoYXNoX3RvX2N1cnZlX2pzXzEuY3JlYXRlSGFzaGVyKShleHBvcnRzLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG5cdFx0ICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwazEuY3JlYXRlKHNjYWxhcnNbMF0pKTtcblx0XHQgICAgcmV0dXJuIGlzb01hcCh4LCB5KTtcblx0XHR9LCB7XG5cdFx0ICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG5cdFx0ICAgIGVuY29kZURTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX05VXycsXG5cdFx0ICAgIHA6IEZwazEuT1JERVIsXG5cdFx0ICAgIG06IDEsXG5cdFx0ICAgIGs6IDEyOCxcblx0XHQgICAgZXhwYW5kOiAneG1kJyxcblx0XHQgICAgaGFzaDogc2hhMjU2XzEuc2hhMjU2LFxuXHRcdH0pKSgpO1xuXHRcdC8qKiBzZWNwMjU2azEgaGFzaC10by1jdXJ2ZSBmcm9tIFtSRkMgOTM4MF0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODApLiAqL1xuXHRcdGV4cG9ydHMuaGFzaFRvQ3VydmUgPSAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuXHRcdC8qKiBzZWNwMjU2azEgZW5jb2RlLXRvLWN1cnZlIGZyb20gW1JGQyA5MzgwXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCkuICovXG5cdFx0ZXhwb3J0cy5lbmNvZGVUb0N1cnZlID0gKCgpID0+IGh0Zi5lbmNvZGVUb0N1cnZlKSgpO1xuXHRcdFxuXHR9IChzZWNwMjU2azEpKTtcblx0cmV0dXJuIHNlY3AyNTZrMTtcbn1cblxudmFyIGhleCA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRIZXg7XG5cbmZ1bmN0aW9uIHJlcXVpcmVIZXggKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRIZXgpIHJldHVybiBoZXg7XG5cdGhhc1JlcXVpcmVkSGV4ID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRcdGV4cG9ydHMuZGVjb2RlSGV4ID0gZXhwb3J0cy5yZW1vdmUweCA9IHZvaWQgMDtcblx0XHR2YXIgdXRpbHNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZVV0aWxzJDMoKTtcblx0XHR2YXIgcmVtb3ZlMHggPSBmdW5jdGlvbiAoaGV4KSB7XG5cdFx0ICAgIHJldHVybiBoZXguc3RhcnRzV2l0aChcIjB4XCIpIHx8IGhleC5zdGFydHNXaXRoKFwiMFhcIikgPyBoZXguc2xpY2UoMikgOiBoZXg7XG5cdFx0fTtcblx0XHRleHBvcnRzLnJlbW92ZTB4ID0gcmVtb3ZlMHg7XG5cdFx0dmFyIGRlY29kZUhleCA9IGZ1bmN0aW9uIChoZXgpIHsgcmV0dXJuICgwLCB1dGlsc18xLmhleFRvQnl0ZXMpKCgwLCBleHBvcnRzLnJlbW92ZTB4KShoZXgpKTsgfTtcblx0XHRleHBvcnRzLmRlY29kZUhleCA9IGRlY29kZUhleDsgXG5cdH0gKGhleCkpO1xuXHRyZXR1cm4gaGV4O1xufVxuXG52YXIgaGFzUmVxdWlyZWRFbGxpcHRpYztcblxuZnVuY3Rpb24gcmVxdWlyZUVsbGlwdGljICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkRWxsaXB0aWMpIHJldHVybiBlbGxpcHRpYztcblx0aGFzUmVxdWlyZWRFbGxpcHRpYyA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0XHRleHBvcnRzLmhleFRvUHVibGljS2V5ID0gZXhwb3J0cy5jb252ZXJ0UHVibGljS2V5Rm9ybWF0ID0gZXhwb3J0cy5nZXRTaGFyZWRQb2ludCA9IGV4cG9ydHMuZ2V0UHVibGljS2V5ID0gZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZUtleSA9IGV4cG9ydHMuZ2V0VmFsaWRTZWNyZXQgPSB2b2lkIDA7XG5cdFx0dmFyIHdlYmNyeXB0b18xID0gLypAX19QVVJFX18qLyByZXF1aXJlV2ViY3J5cHRvKCk7XG5cdFx0dmFyIGVkMjU1MTlfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUVkMjU1MTkoKTtcblx0XHR2YXIgc2VjcDI1NmsxXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVTZWNwMjU2azEoKTtcblx0XHR2YXIgY29uZmlnXzEgPSByZXF1aXJlQ29uZmlnKCk7XG5cdFx0dmFyIGNvbnN0c18xID0gcmVxdWlyZUNvbnN0cygpO1xuXHRcdHZhciBoZXhfMSA9IHJlcXVpcmVIZXgoKTtcblx0XHR2YXIgZ2V0VmFsaWRTZWNyZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIHZhciBrZXk7XG5cdFx0ICAgIGRvIHtcblx0XHQgICAgICAgIGtleSA9ICgwLCB3ZWJjcnlwdG9fMS5yYW5kb21CeXRlcykoY29uc3RzXzEuU0VDUkVUX0tFWV9MRU5HVEgpO1xuXHRcdCAgICB9IHdoaWxlICghKDAsIGV4cG9ydHMuaXNWYWxpZFByaXZhdGVLZXkpKGtleSkpO1xuXHRcdCAgICByZXR1cm4ga2V5O1xuXHRcdH07XG5cdFx0ZXhwb3J0cy5nZXRWYWxpZFNlY3JldCA9IGdldFZhbGlkU2VjcmV0O1xuXHRcdHZhciBpc1ZhbGlkUHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChzZWNyZXQpIHtcblx0XHQgICAgLy8gb24gc2VjcDI1NmsxOiBvbmx5IGtleSDiiIggKDAsIGdyb3VwIG9yZGVyKSBpcyB2YWxpZFxuXHRcdCAgICAvLyBvbiBjdXJ2ZTI1NTE5OiBhbnkgMzItYnl0ZSBrZXkgaXMgdmFsaWRcblx0XHQgICAgcmV0dXJuIF9leGVjKCgwLCBjb25maWdfMS5lbGxpcHRpY0N1cnZlKSgpLCBmdW5jdGlvbiAoY3VydmUpIHsgcmV0dXJuIGN1cnZlLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KHNlY3JldCk7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0pO1xuXHRcdH07XG5cdFx0ZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZUtleSA9IGlzVmFsaWRQcml2YXRlS2V5O1xuXHRcdHZhciBnZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAoc2VjcmV0KSB7XG5cdFx0ICAgIHJldHVybiBfZXhlYygoMCwgY29uZmlnXzEuZWxsaXB0aWNDdXJ2ZSkoKSwgZnVuY3Rpb24gKGN1cnZlKSB7IHJldHVybiBjdXJ2ZS5nZXRQdWJsaWNLZXkoc2VjcmV0KTsgfSwgZnVuY3Rpb24gKGN1cnZlKSB7IHJldHVybiBjdXJ2ZS5nZXRQdWJsaWNLZXkoc2VjcmV0KTsgfSwgZnVuY3Rpb24gKGN1cnZlKSB7IHJldHVybiBjdXJ2ZS5nZXRQdWJsaWNLZXkoc2VjcmV0KTsgfSk7XG5cdFx0fTtcblx0XHRleHBvcnRzLmdldFB1YmxpY0tleSA9IGdldFB1YmxpY0tleTtcblx0XHR2YXIgZ2V0U2hhcmVkUG9pbnQgPSBmdW5jdGlvbiAoc2ssIHBrLCBjb21wcmVzc2VkKSB7XG5cdFx0ICAgIHJldHVybiBfZXhlYygoMCwgY29uZmlnXzEuZWxsaXB0aWNDdXJ2ZSkoKSwgZnVuY3Rpb24gKGN1cnZlKSB7IHJldHVybiBjdXJ2ZS5nZXRTaGFyZWRTZWNyZXQoc2ssIHBrLCBjb21wcmVzc2VkKTsgfSwgZnVuY3Rpb24gKGN1cnZlKSB7IHJldHVybiBjdXJ2ZS5nZXRTaGFyZWRTZWNyZXQoc2ssIHBrKTsgfSwgZnVuY3Rpb24gKGN1cnZlKSB7IHJldHVybiBnZXRTaGFyZWRQb2ludE9uRWQyNTUxOShjdXJ2ZSwgc2ssIHBrKTsgfSk7XG5cdFx0fTtcblx0XHRleHBvcnRzLmdldFNoYXJlZFBvaW50ID0gZ2V0U2hhcmVkUG9pbnQ7XG5cdFx0dmFyIGNvbnZlcnRQdWJsaWNLZXlGb3JtYXQgPSBmdW5jdGlvbiAocGssIGNvbXByZXNzZWQpIHtcblx0XHQgICAgLy8gb25seSBmb3Igc2VjcDI1NmsxXG5cdFx0ICAgIHJldHVybiBfZXhlYygoMCwgY29uZmlnXzEuZWxsaXB0aWNDdXJ2ZSkoKSwgZnVuY3Rpb24gKGN1cnZlKSB7IHJldHVybiBjdXJ2ZS5nZXRTaGFyZWRTZWNyZXQoQmlnSW50KDEpLCBwaywgY29tcHJlc3NlZCk7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBrOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBwazsgfSk7XG5cdFx0fTtcblx0XHRleHBvcnRzLmNvbnZlcnRQdWJsaWNLZXlGb3JtYXQgPSBjb252ZXJ0UHVibGljS2V5Rm9ybWF0O1xuXHRcdHZhciBoZXhUb1B1YmxpY0tleSA9IGZ1bmN0aW9uIChoZXgpIHtcblx0XHQgICAgdmFyIGRlY29kZWQgPSAoMCwgaGV4XzEuZGVjb2RlSGV4KShoZXgpO1xuXHRcdCAgICByZXR1cm4gX2V4ZWMoKDAsIGNvbmZpZ18xLmVsbGlwdGljQ3VydmUpKCksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBhdEV0aFB1YmxpY0tleShkZWNvZGVkKTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlZDsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlZDsgfSk7XG5cdFx0fTtcblx0XHRleHBvcnRzLmhleFRvUHVibGljS2V5ID0gaGV4VG9QdWJsaWNLZXk7XG5cdFx0ZnVuY3Rpb24gX2V4ZWMoY3VydmUsIHNlY3AyNTZrMUNhbGxiYWNrLCB4MjU1MTlDYWxsYmFjaywgZWQyNTUxOUNhbGxiYWNrKSB7XG5cdFx0ICAgIGlmIChjdXJ2ZSA9PT0gXCJzZWNwMjU2azFcIikge1xuXHRcdCAgICAgICAgcmV0dXJuIHNlY3AyNTZrMUNhbGxiYWNrKHNlY3AyNTZrMV8xLnNlY3AyNTZrMSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZWxzZSBpZiAoY3VydmUgPT09IFwieDI1NTE5XCIpIHtcblx0XHQgICAgICAgIHJldHVybiB4MjU1MTlDYWxsYmFjayhlZDI1NTE5XzEueDI1NTE5KTtcblx0XHQgICAgfVxuXHRcdCAgICBlbHNlIGlmIChjdXJ2ZSA9PT0gXCJlZDI1NTE5XCIpIHtcblx0XHQgICAgICAgIHJldHVybiBlZDI1NTE5Q2FsbGJhY2soZWQyNTUxOV8xLmVkMjU1MTkpO1xuXHRcdCAgICB9IC8qIHY4IGlnbm9yZSBuZXh0IDIgKi9cblx0XHQgICAgZWxzZSB7XG5cdFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG5cdFx0ICAgIH1cblx0XHR9XG5cdFx0dmFyIGNvbXBhdEV0aFB1YmxpY0tleSA9IGZ1bmN0aW9uIChwaykge1xuXHRcdCAgICBpZiAocGsubGVuZ3RoID09PSBjb25zdHNfMS5FVEhfUFVCTElDX0tFWV9TSVpFKSB7XG5cdFx0ICAgICAgICB2YXIgZml4ZWQgPSBuZXcgVWludDhBcnJheSgxICsgcGsubGVuZ3RoKTtcblx0XHQgICAgICAgIGZpeGVkLnNldChbMHgwNF0pO1xuXHRcdCAgICAgICAgZml4ZWQuc2V0KHBrLCAxKTtcblx0XHQgICAgICAgIHJldHVybiBmaXhlZDtcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gcGs7XG5cdFx0fTtcblx0XHR2YXIgZ2V0U2hhcmVkUG9pbnRPbkVkMjU1MTkgPSBmdW5jdGlvbiAoY3VydmUsIHNrLCBwaykge1xuXHRcdCAgICAvLyBOb3RlOiBzY2FsYXIgaXMgaGFzaGVkIGZyb20gc2tcblx0XHQgICAgdmFyIHNjYWxhciA9IGN1cnZlLnV0aWxzLmdldEV4dGVuZGVkUHVibGljS2V5KHNrKS5zY2FsYXI7XG5cdFx0ICAgIHZhciBwb2ludCA9IGN1cnZlLkV4dGVuZGVkUG9pbnQuZnJvbUhleChwaykubXVsdGlwbHkoc2NhbGFyKTtcblx0XHQgICAgcmV0dXJuIHBvaW50LnRvUmF3Qnl0ZXMoKTtcblx0XHR9OyBcblx0fSAoZWxsaXB0aWMpKTtcblx0cmV0dXJuIGVsbGlwdGljO1xufVxuXG52YXIgaGFzaCA9IHt9O1xuXG52YXIgaGtkZiA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRIa2RmO1xuXG5mdW5jdGlvbiByZXF1aXJlSGtkZiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEhrZGYpIHJldHVybiBoa2RmO1xuXHRoYXNSZXF1aXJlZEhrZGYgPSAxO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoaGtkZiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGhrZGYuaGtkZiA9IHZvaWQgMDtcblx0aGtkZi5leHRyYWN0ID0gZXh0cmFjdDtcblx0aGtkZi5leHBhbmQgPSBleHBhbmQ7XG5cdC8qKlxuXHQgKiBIS0RGIChSRkMgNTg2OSk6IGV4dHJhY3QgKyBleHBhbmQgaW4gb25lIHN0ZXAuXG5cdCAqIFNlZSBodHRwczovL3NvYXRvay5ibG9nLzIwMjEvMTEvMTcvdW5kZXJzdGFuZGluZy1oa2RmLy5cblx0ICogQG1vZHVsZVxuXHQgKi9cblx0Y29uc3QgX2Fzc2VydF9qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlX2Fzc2VydCgpO1xuXHRjb25zdCBobWFjX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVIbWFjKCk7XG5cdGNvbnN0IHV0aWxzX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVVdGlscyQyKCk7XG5cdC8qKlxuXHQgKiBIS0RGLWV4dHJhY3QgZnJvbSBzcGVjLiBMZXNzIGltcG9ydGFudCBwYXJ0LiBgSEtERi1FeHRyYWN0KElLTSwgc2FsdCkgLT4gUFJLYFxuXHQgKiBBcmd1bWVudHMgcG9zaXRpb24gZGlmZmVycyBmcm9tIHNwZWMgKElLTSBpcyBmaXJzdCBvbmUsIHNpbmNlIGl0IGlzIG5vdCBvcHRpb25hbClcblx0ICogQHBhcmFtIGhhc2ggLSBoYXNoIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCAoZS5nLiBzaGEyNTYpXG5cdCAqIEBwYXJhbSBpa20gLSBpbnB1dCBrZXlpbmcgbWF0ZXJpYWwsIHRoZSBpbml0aWFsIGtleVxuXHQgKiBAcGFyYW0gc2FsdCAtIG9wdGlvbmFsIHNhbHQgdmFsdWUgKGEgbm9uLXNlY3JldCByYW5kb20gdmFsdWUpXG5cdCAqL1xuXHRmdW5jdGlvbiBleHRyYWN0KGhhc2gsIGlrbSwgc2FsdCkge1xuXHQgICAgKDAsIF9hc3NlcnRfanNfMS5haGFzaCkoaGFzaCk7XG5cdCAgICAvLyBOT1RFOiBzb21lIGxpYnJhcmllcyB0cmVhdCB6ZXJvLWxlbmd0aCBhcnJheSBhcyAnbm90IHByb3ZpZGVkJztcblx0ICAgIC8vIHdlIGRvbid0LCBzaW5jZSB3ZSBoYXZlIHVuZGVmaW5lZCBhcyAnbm90IHByb3ZpZGVkJ1xuXHQgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1J1c3RDcnlwdG8vS0RGcy9pc3N1ZXMvMTVcblx0ICAgIGlmIChzYWx0ID09PSB1bmRlZmluZWQpXG5cdCAgICAgICAgc2FsdCA9IG5ldyBVaW50OEFycmF5KGhhc2gub3V0cHV0TGVuKTtcblx0ICAgIHJldHVybiAoMCwgaG1hY19qc18xLmhtYWMpKGhhc2gsICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKHNhbHQpLCAoMCwgdXRpbHNfanNfMS50b0J5dGVzKShpa20pKTtcblx0fVxuXHRjb25zdCBIS0RGX0NPVU5URVIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoWzBdKTtcblx0Y29uc3QgRU1QVFlfQlVGRkVSID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50OEFycmF5KCk7XG5cdC8qKlxuXHQgKiBIS0RGLWV4cGFuZCBmcm9tIHRoZSBzcGVjLiBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydC4gYEhLREYtRXhwYW5kKFBSSywgaW5mbywgTCkgLT4gT0tNYFxuXHQgKiBAcGFyYW0gaGFzaCAtIGhhc2ggZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIChlLmcuIHNoYTI1Nilcblx0ICogQHBhcmFtIHByayAtIGEgcHNldWRvcmFuZG9tIGtleSBvZiBhdCBsZWFzdCBIYXNoTGVuIG9jdGV0cyAodXN1YWxseSwgdGhlIG91dHB1dCBmcm9tIHRoZSBleHRyYWN0IHN0ZXApXG5cdCAqIEBwYXJhbSBpbmZvIC0gb3B0aW9uYWwgY29udGV4dCBhbmQgYXBwbGljYXRpb24gc3BlY2lmaWMgaW5mb3JtYXRpb24gKGNhbiBiZSBhIHplcm8tbGVuZ3RoIHN0cmluZylcblx0ICogQHBhcmFtIGxlbmd0aCAtIGxlbmd0aCBvZiBvdXRwdXQga2V5aW5nIG1hdGVyaWFsIGluIGJ5dGVzXG5cdCAqL1xuXHRmdW5jdGlvbiBleHBhbmQoaGFzaCwgcHJrLCBpbmZvLCBsZW5ndGggPSAzMikge1xuXHQgICAgKDAsIF9hc3NlcnRfanNfMS5haGFzaCkoaGFzaCk7XG5cdCAgICAoMCwgX2Fzc2VydF9qc18xLmFudW1iZXIpKGxlbmd0aCk7XG5cdCAgICBpZiAobGVuZ3RoID4gMjU1ICogaGFzaC5vdXRwdXRMZW4pXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggc2hvdWxkIGJlIDw9IDI1NSpIYXNoTGVuJyk7XG5cdCAgICBjb25zdCBibG9ja3MgPSBNYXRoLmNlaWwobGVuZ3RoIC8gaGFzaC5vdXRwdXRMZW4pO1xuXHQgICAgaWYgKGluZm8gPT09IHVuZGVmaW5lZClcblx0ICAgICAgICBpbmZvID0gRU1QVFlfQlVGRkVSO1xuXHQgICAgLy8gZmlyc3QgTChlbmd0aCkgb2N0ZXRzIG9mIFRcblx0ICAgIGNvbnN0IG9rbSA9IG5ldyBVaW50OEFycmF5KGJsb2NrcyAqIGhhc2gub3V0cHV0TGVuKTtcblx0ICAgIC8vIFJlLXVzZSBITUFDIGluc3RhbmNlIGJldHdlZW4gYmxvY2tzXG5cdCAgICBjb25zdCBITUFDID0gaG1hY19qc18xLmhtYWMuY3JlYXRlKGhhc2gsIHByayk7XG5cdCAgICBjb25zdCBITUFDVG1wID0gSE1BQy5fY2xvbmVJbnRvKCk7XG5cdCAgICBjb25zdCBUID0gbmV3IFVpbnQ4QXJyYXkoSE1BQy5vdXRwdXRMZW4pO1xuXHQgICAgZm9yIChsZXQgY291bnRlciA9IDA7IGNvdW50ZXIgPCBibG9ja3M7IGNvdW50ZXIrKykge1xuXHQgICAgICAgIEhLREZfQ09VTlRFUlswXSA9IGNvdW50ZXIgKyAxO1xuXHQgICAgICAgIC8vIFQoMCkgPSBlbXB0eSBzdHJpbmcgKHplcm8gbGVuZ3RoKVxuXHQgICAgICAgIC8vIFQoTikgPSBITUFDLUhhc2goUFJLLCBUKE4tMSkgfCBpbmZvIHwgTilcblx0ICAgICAgICBITUFDVG1wLnVwZGF0ZShjb3VudGVyID09PSAwID8gRU1QVFlfQlVGRkVSIDogVClcblx0ICAgICAgICAgICAgLnVwZGF0ZShpbmZvKVxuXHQgICAgICAgICAgICAudXBkYXRlKEhLREZfQ09VTlRFUilcblx0ICAgICAgICAgICAgLmRpZ2VzdEludG8oVCk7XG5cdCAgICAgICAgb2ttLnNldChULCBoYXNoLm91dHB1dExlbiAqIGNvdW50ZXIpO1xuXHQgICAgICAgIEhNQUMuX2Nsb25lSW50byhITUFDVG1wKTtcblx0ICAgIH1cblx0ICAgIEhNQUMuZGVzdHJveSgpO1xuXHQgICAgSE1BQ1RtcC5kZXN0cm95KCk7XG5cdCAgICBULmZpbGwoMCk7XG5cdCAgICBIS0RGX0NPVU5URVIuZmlsbCgwKTtcblx0ICAgIHJldHVybiBva20uc2xpY2UoMCwgbGVuZ3RoKTtcblx0fVxuXHQvKipcblx0ICogSEtERiAoUkZDIDU4NjkpOiBkZXJpdmUga2V5cyBmcm9tIGFuIGluaXRpYWwgaW5wdXQuXG5cdCAqIENvbWJpbmVzIGhrZGZfZXh0cmFjdCArIGhrZGZfZXhwYW5kIGluIG9uZSBzdGVwXG5cdCAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgKGUuZy4gc2hhMjU2KVxuXHQgKiBAcGFyYW0gaWttIC0gaW5wdXQga2V5aW5nIG1hdGVyaWFsLCB0aGUgaW5pdGlhbCBrZXlcblx0ICogQHBhcmFtIHNhbHQgLSBvcHRpb25hbCBzYWx0IHZhbHVlIChhIG5vbi1zZWNyZXQgcmFuZG9tIHZhbHVlKVxuXHQgKiBAcGFyYW0gaW5mbyAtIG9wdGlvbmFsIGNvbnRleHQgYW5kIGFwcGxpY2F0aW9uIHNwZWNpZmljIGluZm9ybWF0aW9uIChjYW4gYmUgYSB6ZXJvLWxlbmd0aCBzdHJpbmcpXG5cdCAqIEBwYXJhbSBsZW5ndGggLSBsZW5ndGggb2Ygb3V0cHV0IGtleWluZyBtYXRlcmlhbCBpbiBieXRlc1xuXHQgKiBAZXhhbXBsZVxuXHQgKiBpbXBvcnQgeyBoa2RmIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9oa2RmJztcblx0ICogaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyJztcblx0ICogaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcblx0ICogY29uc3QgaW5wdXRLZXkgPSByYW5kb21CeXRlcygzMik7XG5cdCAqIGNvbnN0IHNhbHQgPSByYW5kb21CeXRlcygzMik7XG5cdCAqIGNvbnN0IGluZm8gPSAnYXBwbGljYXRpb24ta2V5Jztcblx0ICogY29uc3QgaGsxID0gaGtkZihzaGEyNTYsIGlucHV0S2V5LCBzYWx0LCBpbmZvLCAzMik7XG5cdCAqL1xuXHRjb25zdCBoa2RmJDEgPSAoaGFzaCwgaWttLCBzYWx0LCBpbmZvLCBsZW5ndGgpID0+IGV4cGFuZChoYXNoLCBleHRyYWN0KGhhc2gsIGlrbSwgc2FsdCksIGluZm8sIGxlbmd0aCk7XG5cdGhrZGYuaGtkZiA9IGhrZGYkMTtcblx0XG5cdHJldHVybiBoa2RmO1xufVxuXG52YXIgaGFzUmVxdWlyZWRIYXNoO1xuXG5mdW5jdGlvbiByZXF1aXJlSGFzaCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEhhc2gpIHJldHVybiBoYXNoO1xuXHRoYXNSZXF1aXJlZEhhc2ggPSAxO1xuXHQoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0ZXhwb3J0cy5nZXRTaGFyZWRLZXkgPSBleHBvcnRzLmRlcml2ZUtleSA9IHZvaWQgMDtcblx0XHR2YXIgdXRpbHNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZVV0aWxzJDMoKTtcblx0XHR2YXIgaGtkZl8xID0gLypAX19QVVJFX18qLyByZXF1aXJlSGtkZigpO1xuXHRcdHZhciBzaGEyNTZfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZVNoYTI1NigpO1xuXHRcdHZhciBkZXJpdmVLZXkgPSBmdW5jdGlvbiAobWFzdGVyLCBzYWx0LCBpbmZvKSB7XG5cdFx0ICAgIC8vIDMyIGJ5dGVzIHNoYXJlZCBzZWNyZXQgZm9yIGFlczI1NiBhbmQgeGNoYWNoYTIwIGRlcml2ZWQgZnJvbSBIS0RGLVNIQTI1NlxuXHRcdCAgICByZXR1cm4gKDAsIGhrZGZfMS5oa2RmKShzaGEyNTZfMS5zaGEyNTYsIG1hc3Rlciwgc2FsdCwgaW5mbywgMzIpO1xuXHRcdH07XG5cdFx0ZXhwb3J0cy5kZXJpdmVLZXkgPSBkZXJpdmVLZXk7XG5cdFx0dmFyIGdldFNoYXJlZEtleSA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgdmFyIHBhcnRzID0gW107XG5cdFx0ICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdFx0ICAgICAgICBwYXJ0c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiAoMCwgZXhwb3J0cy5kZXJpdmVLZXkpKHV0aWxzXzEuY29uY2F0Qnl0ZXMuYXBwbHkodm9pZCAwLCBwYXJ0cykpO1xuXHRcdH07XG5cdFx0ZXhwb3J0cy5nZXRTaGFyZWRLZXkgPSBnZXRTaGFyZWRLZXk7IFxuXHR9IChoYXNoKSk7XG5cdHJldHVybiBoYXNoO1xufVxuXG52YXIgc3ltbWV0cmljID0ge307XG5cbnZhciBub2JsZSQxID0ge307XG5cbnZhciBhZXMgPSB7fTtcblxudmFyIF9wb2x5dmFsID0ge307XG5cbnZhciBoYXNSZXF1aXJlZF9wb2x5dmFsO1xuXG5mdW5jdGlvbiByZXF1aXJlX3BvbHl2YWwgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfcG9seXZhbCkgcmV0dXJuIF9wb2x5dmFsO1xuXHRoYXNSZXF1aXJlZF9wb2x5dmFsID0gMTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KF9wb2x5dmFsLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0X3BvbHl2YWwucG9seXZhbCA9IF9wb2x5dmFsLmdoYXNoID0gdm9pZCAwO1xuXHRfcG9seXZhbC5fdG9HSEFTSEtleSA9IF90b0dIQVNIS2V5O1xuXHQvKipcblx0ICogR0hhc2ggZnJvbSBBRVMtR0NNIGFuZCBpdHMgbGl0dGxlLWVuZGlhbiBcIm1pcnJvciBpbWFnZVwiIFBvbHl2YWwgZnJvbSBBRVMtU0lWLlxuXHQgKlxuXHQgKiBJbXBsZW1lbnRlZCBpbiB0ZXJtcyBvZiBHSGFzaCB3aXRoIGNvbnZlcnNpb24gZnVuY3Rpb24gZm9yIGtleXNcblx0ICogR0NNIEdIQVNIIGZyb21cblx0ICogW05JU1QgU1A4MDAtMzhkXShodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvTGVnYWN5L1NQL25pc3RzcGVjaWFscHVibGljYXRpb244MDAtMzhkLnBkZiksXG5cdCAqIFNJViBmcm9tXG5cdCAqIFtSRkMgODQ1Ml0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM4NDUyKS5cblx0ICpcblx0ICogR0hBU0ggICBtb2R1bG86IHheMTI4ICsgeF43ICAgKyB4XjIgICArIHggICAgICsgMVxuXHQgKiBQT0xZVkFMIG1vZHVsbzogeF4xMjggKyB4XjEyNyArIHheMTI2ICsgeF4xMjEgKyAxXG5cdCAqXG5cdCAqIEBtb2R1bGVcblx0ICovXG5cdGNvbnN0IF9hc3NlcnRfanNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZV9hc3NlcnQkMSgpO1xuXHRjb25zdCB1dGlsc19qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMkMygpO1xuXHRjb25zdCBCTE9DS19TSVpFID0gMTY7XG5cdC8vIFRPRE86IHJld3JpdGVcblx0Ly8gdGVtcG9yYXJ5IHBhZGRpbmcgYnVmZmVyXG5cdGNvbnN0IFpFUk9TMTYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXHRjb25zdCBaRVJPUzMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShaRVJPUzE2KTtcblx0Y29uc3QgUE9MWSA9IDB4ZTE7IC8vIHYgPSAyKnYgJSBQT0xZXG5cdC8vIHYgPSAyKnYgJSBQT0xZXG5cdC8vIE5PVEU6IGJlY2F1c2UgeCArIHggPSAwIChhZGQvc3ViIGlzIHNhbWUpLCBtdWwyKHgpICE9IHgreFxuXHQvLyBXZSBjYW4gbXVsdGlwbHkgYW55IG51bWJlciB1c2luZyBtb250Z29tZXJ5IGxhZGRlciBhbmQgdGhpcyBmdW5jdGlvbiAod29ya3MgYXMgZG91YmxlLCBhZGQgaXMgc2ltcGxlIHhvcilcblx0Y29uc3QgbXVsMiA9IChzMCwgczEsIHMyLCBzMykgPT4ge1xuXHQgICAgY29uc3QgaGlCaXQgPSBzMyAmIDE7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIHMzOiAoczIgPDwgMzEpIHwgKHMzID4+PiAxKSxcblx0ICAgICAgICBzMjogKHMxIDw8IDMxKSB8IChzMiA+Pj4gMSksXG5cdCAgICAgICAgczE6IChzMCA8PCAzMSkgfCAoczEgPj4+IDEpLFxuXHQgICAgICAgIHMwOiAoczAgPj4+IDEpIF4gKChQT0xZIDw8IDI0KSAmIC0oaGlCaXQgJiAxKSksIC8vIHJlZHVjZSAlIHBvbHlcblx0ICAgIH07XG5cdH07XG5cdGNvbnN0IHN3YXBMRSA9IChuKSA9PiAoKChuID4+PiAwKSAmIDB4ZmYpIDw8IDI0KSB8XG5cdCAgICAoKChuID4+PiA4KSAmIDB4ZmYpIDw8IDE2KSB8XG5cdCAgICAoKChuID4+PiAxNikgJiAweGZmKSA8PCA4KSB8XG5cdCAgICAoKG4gPj4+IDI0KSAmIDB4ZmYpIHxcblx0ICAgIDA7XG5cdC8qKlxuXHQgKiBgbXVsWF9QT0xZVkFMKEJ5dGVSZXZlcnNlKEgpKWAgZnJvbSBzcGVjXG5cdCAqIEBwYXJhbSBrIG11dGF0ZWQgaW4gcGxhY2Vcblx0ICovXG5cdGZ1bmN0aW9uIF90b0dIQVNIS2V5KGspIHtcblx0ICAgIGsucmV2ZXJzZSgpO1xuXHQgICAgY29uc3QgaGlCaXQgPSBrWzE1XSAmIDE7XG5cdCAgICAvLyBrID4+PSAxXG5cdCAgICBsZXQgY2FycnkgPSAwO1xuXHQgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgY29uc3QgdCA9IGtbaV07XG5cdCAgICAgICAga1tpXSA9ICh0ID4+PiAxKSB8IGNhcnJ5O1xuXHQgICAgICAgIGNhcnJ5ID0gKHQgJiAxKSA8PCA3O1xuXHQgICAgfVxuXHQgICAga1swXSBePSAtaGlCaXQgJiAweGUxOyAvLyBpZiAoaGlCaXQpIG4gXj0gMHhlMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDtcblx0ICAgIHJldHVybiBrO1xuXHR9XG5cdGNvbnN0IGVzdGltYXRlV2luZG93ID0gKGJ5dGVzKSA9PiB7XG5cdCAgICBpZiAoYnl0ZXMgPiA2NCAqIDEwMjQpXG5cdCAgICAgICAgcmV0dXJuIDg7XG5cdCAgICBpZiAoYnl0ZXMgPiAxMDI0KVxuXHQgICAgICAgIHJldHVybiA0O1xuXHQgICAgcmV0dXJuIDI7XG5cdH07XG5cdGNsYXNzIEdIQVNIIHtcblx0ICAgIC8vIFdlIHNlbGVjdCBiaXRzIHBlciB3aW5kb3cgYWRhcHRpdmVseSBiYXNlZCBvbiBleHBlY3RlZExlbmd0aFxuXHQgICAgY29uc3RydWN0b3Ioa2V5LCBleHBlY3RlZExlbmd0aCkge1xuXHQgICAgICAgIHRoaXMuYmxvY2tMZW4gPSBCTE9DS19TSVpFO1xuXHQgICAgICAgIHRoaXMub3V0cHV0TGVuID0gQkxPQ0tfU0laRTtcblx0ICAgICAgICB0aGlzLnMwID0gMDtcblx0ICAgICAgICB0aGlzLnMxID0gMDtcblx0ICAgICAgICB0aGlzLnMyID0gMDtcblx0ICAgICAgICB0aGlzLnMzID0gMDtcblx0ICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cdCAgICAgICAga2V5ID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoa2V5KTtcblx0ICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmFieXRlcykoa2V5LCAxNik7XG5cdCAgICAgICAgY29uc3Qga1ZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShrZXkpO1xuXHQgICAgICAgIGxldCBrMCA9IGtWaWV3LmdldFVpbnQzMigwLCBmYWxzZSk7XG5cdCAgICAgICAgbGV0IGsxID0ga1ZpZXcuZ2V0VWludDMyKDQsIGZhbHNlKTtcblx0ICAgICAgICBsZXQgazIgPSBrVmlldy5nZXRVaW50MzIoOCwgZmFsc2UpO1xuXHQgICAgICAgIGxldCBrMyA9IGtWaWV3LmdldFVpbnQzMigxMiwgZmFsc2UpO1xuXHQgICAgICAgIC8vIGdlbmVyYXRlIHRhYmxlIG9mIGRvdWJsZWQga2V5cyAoaGFsZiBvZiBtb250Z29tZXJ5IGxhZGRlcilcblx0ICAgICAgICBjb25zdCBkb3VibGVzID0gW107XG5cdCAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuXHQgICAgICAgICAgICBkb3VibGVzLnB1c2goeyBzMDogc3dhcExFKGswKSwgczE6IHN3YXBMRShrMSksIHMyOiBzd2FwTEUoazIpLCBzMzogc3dhcExFKGszKSB9KTtcblx0ICAgICAgICAgICAgKHsgczA6IGswLCBzMTogazEsIHMyOiBrMiwgczM6IGszIH0gPSBtdWwyKGswLCBrMSwgazIsIGszKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvbnN0IFcgPSBlc3RpbWF0ZVdpbmRvdyhleHBlY3RlZExlbmd0aCB8fCAxMDI0KTtcblx0ICAgICAgICBpZiAoIVsxLCAyLCA0LCA4XS5pbmNsdWRlcyhXKSlcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnaGFzaDogaW52YWxpZCB3aW5kb3cgc2l6ZSwgZXhwZWN0ZWQgMiwgNCBvciA4Jyk7XG5cdCAgICAgICAgdGhpcy5XID0gVztcblx0ICAgICAgICBjb25zdCBiaXRzID0gMTI4OyAvLyBhbHdheXMgMTI4IGJpdHM7XG5cdCAgICAgICAgY29uc3Qgd2luZG93cyA9IGJpdHMgLyBXO1xuXHQgICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAodGhpcy53aW5kb3dTaXplID0gMiAqKiBXKTtcblx0ICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuXHQgICAgICAgIC8vIENyZWF0ZSBwcmVjb21wdXRlIHRhYmxlIGZvciB3aW5kb3cgb2YgVyBiaXRzXG5cdCAgICAgICAgZm9yIChsZXQgdyA9IDA7IHcgPCB3aW5kb3dzOyB3KyspIHtcblx0ICAgICAgICAgICAgLy8gdHJ1dGggdGFibGU6IDAwLCAwMSwgMTAsIDExXG5cdCAgICAgICAgICAgIGZvciAobGV0IGJ5dGUgPSAwOyBieXRlIDwgd2luZG93U2l6ZTsgYnl0ZSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcblx0ICAgICAgICAgICAgICAgIGxldCBzMCA9IDAsIHMxID0gMCwgczIgPSAwLCBzMyA9IDA7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IFc7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IChieXRlID4+PiAoVyAtIGogLSAxKSkgJiAxO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghYml0KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHMwOiBkMCwgczE6IGQxLCBzMjogZDIsIHMzOiBkMyB9ID0gZG91Ymxlc1tXICogdyArIGpdO1xuXHQgICAgICAgICAgICAgICAgICAgIChzMCBePSBkMCksIChzMSBePSBkMSksIChzMiBePSBkMiksIChzMyBePSBkMyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHsgczAsIHMxLCBzMiwgczMgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy50ID0gaXRlbXM7XG5cdCAgICB9XG5cdCAgICBfdXBkYXRlQmxvY2soczAsIHMxLCBzMiwgczMpIHtcblx0ICAgICAgICAoczAgXj0gdGhpcy5zMCksIChzMSBePSB0aGlzLnMxKSwgKHMyIF49IHRoaXMuczIpLCAoczMgXj0gdGhpcy5zMyk7XG5cdCAgICAgICAgY29uc3QgeyBXLCB0LCB3aW5kb3dTaXplIH0gPSB0aGlzO1xuXHQgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuXHQgICAgICAgIGxldCBvMCA9IDAsIG8xID0gMCwgbzIgPSAwLCBvMyA9IDA7XG5cdCAgICAgICAgY29uc3QgbWFzayA9ICgxIDw8IFcpIC0gMTsgLy8gMioqVyB3aWxsIGtpbGwgcGVyZm9ybWFuY2UuXG5cdCAgICAgICAgbGV0IHcgPSAwO1xuXHQgICAgICAgIGZvciAoY29uc3QgbnVtIG9mIFtzMCwgczEsIHMyLCBzM10pIHtcblx0ICAgICAgICAgICAgZm9yIChsZXQgYnl0ZVBvcyA9IDA7IGJ5dGVQb3MgPCA0OyBieXRlUG9zKyspIHtcblx0ICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGUgPSAobnVtID4+PiAoOCAqIGJ5dGVQb3MpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGxldCBiaXRQb3MgPSA4IC8gVyAtIDE7IGJpdFBvcyA+PSAwOyBiaXRQb3MtLSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IChieXRlID4+PiAoVyAqIGJpdFBvcykpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHMwOiBlMCwgczE6IGUxLCBzMjogZTIsIHMzOiBlMyB9ID0gdFt3ICogd2luZG93U2l6ZSArIGJpdF07XG5cdCAgICAgICAgICAgICAgICAgICAgKG8wIF49IGUwKSwgKG8xIF49IGUxKSwgKG8yIF49IGUyKSwgKG8zIF49IGUzKTtcblx0ICAgICAgICAgICAgICAgICAgICB3ICs9IDE7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5zMCA9IG8wO1xuXHQgICAgICAgIHRoaXMuczEgPSBvMTtcblx0ICAgICAgICB0aGlzLnMyID0gbzI7XG5cdCAgICAgICAgdGhpcy5zMyA9IG8zO1xuXHQgICAgfVxuXHQgICAgdXBkYXRlKGRhdGEpIHtcblx0ICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG5cdCAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hZXhpc3RzKSh0aGlzKTtcblx0ICAgICAgICBjb25zdCBiMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGRhdGEpO1xuXHQgICAgICAgIGNvbnN0IGJsb2NrcyA9IE1hdGguZmxvb3IoZGF0YS5sZW5ndGggLyBCTE9DS19TSVpFKTtcblx0ICAgICAgICBjb25zdCBsZWZ0ID0gZGF0YS5sZW5ndGggJSBCTE9DS19TSVpFO1xuXHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fdXBkYXRlQmxvY2soYjMyW2kgKiA0ICsgMF0sIGIzMltpICogNCArIDFdLCBiMzJbaSAqIDQgKyAyXSwgYjMyW2kgKiA0ICsgM10pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobGVmdCkge1xuXHQgICAgICAgICAgICBaRVJPUzE2LnNldChkYXRhLnN1YmFycmF5KGJsb2NrcyAqIEJMT0NLX1NJWkUpKTtcblx0ICAgICAgICAgICAgdGhpcy5fdXBkYXRlQmxvY2soWkVST1MzMlswXSwgWkVST1MzMlsxXSwgWkVST1MzMlsyXSwgWkVST1MzMlszXSk7XG5cdCAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmNsZWFuKShaRVJPUzMyKTsgLy8gY2xlYW4gdG1wIGJ1ZmZlclxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICAgIGRlc3Ryb3koKSB7XG5cdCAgICAgICAgY29uc3QgeyB0IH0gPSB0aGlzO1xuXHQgICAgICAgIC8vIGNsZWFuIHByZWNvbXB1dGUgdGFibGVcblx0ICAgICAgICBmb3IgKGNvbnN0IGVsbSBvZiB0KSB7XG5cdCAgICAgICAgICAgIChlbG0uczAgPSAwKSwgKGVsbS5zMSA9IDApLCAoZWxtLnMyID0gMCksIChlbG0uczMgPSAwKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBkaWdlc3RJbnRvKG91dCkge1xuXHQgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWV4aXN0cykodGhpcyk7XG5cdCAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hb3V0cHV0KShvdXQsIHRoaXMpO1xuXHQgICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuXHQgICAgICAgIGNvbnN0IHsgczAsIHMxLCBzMiwgczMgfSA9IHRoaXM7XG5cdCAgICAgICAgY29uc3QgbzMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShvdXQpO1xuXHQgICAgICAgIG8zMlswXSA9IHMwO1xuXHQgICAgICAgIG8zMlsxXSA9IHMxO1xuXHQgICAgICAgIG8zMlsyXSA9IHMyO1xuXHQgICAgICAgIG8zMlszXSA9IHMzO1xuXHQgICAgICAgIHJldHVybiBvdXQ7XG5cdCAgICB9XG5cdCAgICBkaWdlc3QoKSB7XG5cdCAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoQkxPQ0tfU0laRSk7XG5cdCAgICAgICAgdGhpcy5kaWdlc3RJbnRvKHJlcyk7XG5cdCAgICAgICAgdGhpcy5kZXN0cm95KCk7XG5cdCAgICAgICAgcmV0dXJuIHJlcztcblx0ICAgIH1cblx0fVxuXHRjbGFzcyBQb2x5dmFsIGV4dGVuZHMgR0hBU0gge1xuXHQgICAgY29uc3RydWN0b3Ioa2V5LCBleHBlY3RlZExlbmd0aCkge1xuXHQgICAgICAgIGtleSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGtleSk7XG5cdCAgICAgICAgY29uc3QgZ2hLZXkgPSBfdG9HSEFTSEtleSgoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKGtleSkpO1xuXHQgICAgICAgIHN1cGVyKGdoS2V5LCBleHBlY3RlZExlbmd0aCk7XG5cdCAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKGdoS2V5KTtcblx0ICAgIH1cblx0ICAgIHVwZGF0ZShkYXRhKSB7XG5cdCAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuXHQgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWV4aXN0cykodGhpcyk7XG5cdCAgICAgICAgY29uc3QgYjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShkYXRhKTtcblx0ICAgICAgICBjb25zdCBsZWZ0ID0gZGF0YS5sZW5ndGggJSBCTE9DS19TSVpFO1xuXHQgICAgICAgIGNvbnN0IGJsb2NrcyA9IE1hdGguZmxvb3IoZGF0YS5sZW5ndGggLyBCTE9DS19TSVpFKTtcblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrczsgaSsrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJsb2NrKHN3YXBMRShiMzJbaSAqIDQgKyAzXSksIHN3YXBMRShiMzJbaSAqIDQgKyAyXSksIHN3YXBMRShiMzJbaSAqIDQgKyAxXSksIHN3YXBMRShiMzJbaSAqIDQgKyAwXSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobGVmdCkge1xuXHQgICAgICAgICAgICBaRVJPUzE2LnNldChkYXRhLnN1YmFycmF5KGJsb2NrcyAqIEJMT0NLX1NJWkUpKTtcblx0ICAgICAgICAgICAgdGhpcy5fdXBkYXRlQmxvY2soc3dhcExFKFpFUk9TMzJbM10pLCBzd2FwTEUoWkVST1MzMlsyXSksIHN3YXBMRShaRVJPUzMyWzFdKSwgc3dhcExFKFpFUk9TMzJbMF0pKTtcblx0ICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKFpFUk9TMzIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICAgIGRpZ2VzdEludG8ob3V0KSB7XG5cdCAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hZXhpc3RzKSh0aGlzKTtcblx0ICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmFvdXRwdXQpKG91dCwgdGhpcyk7XG5cdCAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG5cdCAgICAgICAgLy8gdG1wIHVnbHkgaGFja1xuXHQgICAgICAgIGNvbnN0IHsgczAsIHMxLCBzMiwgczMgfSA9IHRoaXM7XG5cdCAgICAgICAgY29uc3QgbzMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShvdXQpO1xuXHQgICAgICAgIG8zMlswXSA9IHMwO1xuXHQgICAgICAgIG8zMlsxXSA9IHMxO1xuXHQgICAgICAgIG8zMlsyXSA9IHMyO1xuXHQgICAgICAgIG8zMlszXSA9IHMzO1xuXHQgICAgICAgIHJldHVybiBvdXQucmV2ZXJzZSgpO1xuXHQgICAgfVxuXHR9XG5cdGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhLZXkoaGFzaENvbnMpIHtcblx0ICAgIGNvbnN0IGhhc2hDID0gKG1zZywga2V5KSA9PiBoYXNoQ29ucyhrZXksIG1zZy5sZW5ndGgpLnVwZGF0ZSgoMCwgdXRpbHNfanNfMS50b0J5dGVzKShtc2cpKS5kaWdlc3QoKTtcblx0ICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKG5ldyBVaW50OEFycmF5KDE2KSwgMCk7XG5cdCAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuXHQgICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG5cdCAgICBoYXNoQy5jcmVhdGUgPSAoa2V5LCBleHBlY3RlZExlbmd0aCkgPT4gaGFzaENvbnMoa2V5LCBleHBlY3RlZExlbmd0aCk7XG5cdCAgICByZXR1cm4gaGFzaEM7XG5cdH1cblx0LyoqIEdIYXNoIE1BQyBmb3IgQUVTLUdDTS4gKi9cblx0X3BvbHl2YWwuZ2hhc2ggPSB3cmFwQ29uc3RydWN0b3JXaXRoS2V5KChrZXksIGV4cGVjdGVkTGVuZ3RoKSA9PiBuZXcgR0hBU0goa2V5LCBleHBlY3RlZExlbmd0aCkpO1xuXHQvKiogUG9seXZhbCBNQUMgZm9yIEFFUy1TSVYuICovXG5cdF9wb2x5dmFsLnBvbHl2YWwgPSB3cmFwQ29uc3RydWN0b3JXaXRoS2V5KChrZXksIGV4cGVjdGVkTGVuZ3RoKSA9PiBuZXcgUG9seXZhbChrZXksIGV4cGVjdGVkTGVuZ3RoKSk7XG5cdFxuXHRyZXR1cm4gX3BvbHl2YWw7XG59XG5cbnZhciBoYXNSZXF1aXJlZEFlcztcblxuZnVuY3Rpb24gcmVxdWlyZUFlcyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEFlcykgcmV0dXJuIGFlcztcblx0aGFzUmVxdWlyZWRBZXMgPSAxO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYWVzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0YWVzLnVuc2FmZSA9IGFlcy5hZXNrd3AgPSBhZXMuYWVza3cgPSBhZXMuc2l2ID0gYWVzLmdjbSA9IGFlcy5jZmIgPSBhZXMuY2JjID0gYWVzLmVjYiA9IGFlcy5jdHIgPSB2b2lkIDA7XG5cdC8qKlxuXHQgKiBbQUVTXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BZHZhbmNlZF9FbmNyeXB0aW9uX1N0YW5kYXJkKVxuXHQgKiBhLmsuYS4gQWR2YW5jZWQgRW5jcnlwdGlvbiBTdGFuZGFyZFxuXHQgKiBpcyBhIHZhcmlhbnQgb2YgUmlqbmRhZWwgYmxvY2sgY2lwaGVyLCBzdGFuZGFyZGl6ZWQgYnkgTklTVCBpbiAyMDAxLlxuXHQgKiBXZSBwcm92aWRlIHRoZSBmYXN0ZXN0IGF2YWlsYWJsZSBwdXJlIEpTIGltcGxlbWVudGF0aW9uLlxuXHQgKlxuXHQgKiBEYXRhIGlzIHNwbGl0IGludG8gMTI4LWJpdCBibG9ja3MuIEVuY3J5cHRlZCBpbiAxMC8xMi8xNCByb3VuZHMgKDEyOC8xOTIvMjU2IGJpdHMpLiBJbiBldmVyeSByb3VuZDpcblx0ICogMS4gKipTLWJveCoqLCB0YWJsZSBzdWJzdGl0dXRpb25cblx0ICogMi4gKipTaGlmdCByb3dzKiosIGN5Y2xpYyBzaGlmdCBsZWZ0IG9mIGFsbCByb3dzIG9mIGRhdGEgYXJyYXlcblx0ICogMy4gKipNaXggY29sdW1ucyoqLCBtdWx0aXBseWluZyBldmVyeSBjb2x1bW4gYnkgZml4ZWQgcG9seW5vbWlhbFxuXHQgKiA0LiAqKkFkZCByb3VuZCBrZXkqKiwgcm91bmRfa2V5IHhvciBpLXRoIGNvbHVtbiBvZiBhcnJheVxuXHQgKlxuXHQgKiBDaGVjayBvdXQgW0ZJUFMtMTk3XShodHRwczovL2NzcmMubmlzdC5nb3YvZmlsZXMvcHVicy9maXBzLzE5Ny9maW5hbC9kb2NzL2ZpcHMtMTk3LnBkZilcblx0ICogYW5kIFtvcmlnaW5hbCBwcm9wb3NhbF0oaHR0cHM6Ly9jc3JjLm5pc3QuZ292L2NzcmMvbWVkaWEvcHJvamVjdHMvY3J5cHRvZ3JhcGhpYy1zdGFuZGFyZHMtYW5kLWd1aWRlbGluZXMvZG9jdW1lbnRzL2Flcy1kZXZlbG9wbWVudC9yaWpuZGFlbC1hbW1lbmRlZC5wZGYpXG5cdCAqIEBtb2R1bGVcblx0ICovXG5cdGNvbnN0IF9hc3NlcnRfanNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZV9hc3NlcnQkMSgpO1xuXHRjb25zdCBfcG9seXZhbF9qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlX3BvbHl2YWwoKTtcblx0Y29uc3QgdXRpbHNfanNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZVV0aWxzJDMoKTtcblx0Y29uc3QgQkxPQ0tfU0laRSA9IDE2O1xuXHRjb25zdCBCTE9DS19TSVpFMzIgPSA0O1xuXHRjb25zdCBFTVBUWV9CTE9DSyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDhBcnJheShCTE9DS19TSVpFKTtcblx0Y29uc3QgUE9MWSA9IDB4MTFiOyAvLyAxICsgeCArIHgqKjMgKyB4Kio0ICsgeCoqOFxuXHQvLyBUT0RPOiByZW1vdmUgbXVsdGlwbGljYXRpb24sIGJpbmFyeSBvcHMgb25seVxuXHRmdW5jdGlvbiBtdWwyKG4pIHtcblx0ICAgIHJldHVybiAobiA8PCAxKSBeIChQT0xZICYgLShuID4+IDcpKTtcblx0fVxuXHRmdW5jdGlvbiBtdWwoYSwgYikge1xuXHQgICAgbGV0IHJlcyA9IDA7XG5cdCAgICBmb3IgKDsgYiA+IDA7IGIgPj49IDEpIHtcblx0ICAgICAgICAvLyBNb250Z29tZXJ5IGxhZGRlclxuXHQgICAgICAgIHJlcyBePSBhICYgLShiICYgMSk7IC8vIGlmIChiJjEpIHJlcyBePWEgKGJ1dCBjb25zdC10aW1lKS5cblx0ICAgICAgICBhID0gbXVsMihhKTsgLy8gYSA9IDIqYVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlcztcblx0fVxuXHQvLyBBRVMgUy1ib3ggaXMgZ2VuZXJhdGVkIHVzaW5nIGZpbml0ZSBmaWVsZCBpbnZlcnNpb24sXG5cdC8vIGFuIGFmZmluZSB0cmFuc2Zvcm0sIGFuZCB4b3Igb2YgYSBjb25zdGFudCAweDYzLlxuXHRjb25zdCBzYm94ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG5cdCAgICBjb25zdCB0ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcblx0ICAgIGZvciAobGV0IGkgPSAwLCB4ID0gMTsgaSA8IDI1NjsgaSsrLCB4IF49IG11bDIoeCkpXG5cdCAgICAgICAgdFtpXSA9IHg7XG5cdCAgICBjb25zdCBib3ggPSBuZXcgVWludDhBcnJheSgyNTYpO1xuXHQgICAgYm94WzBdID0gMHg2MzsgLy8gZmlyc3QgZWxtXG5cdCAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NTsgaSsrKSB7XG5cdCAgICAgICAgbGV0IHggPSB0WzI1NSAtIGldO1xuXHQgICAgICAgIHggfD0geCA8PCA4O1xuXHQgICAgICAgIGJveFt0W2ldXSA9ICh4IF4gKHggPj4gNCkgXiAoeCA+PiA1KSBeICh4ID4+IDYpIF4gKHggPj4gNykgXiAweDYzKSAmIDB4ZmY7XG5cdCAgICB9XG5cdCAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikodCk7XG5cdCAgICByZXR1cm4gYm94O1xuXHR9KSgpO1xuXHQvLyBJbnZlcnRlZCBTLWJveFxuXHRjb25zdCBpbnZTYm94ID0gLyogQF9fUFVSRV9fICovIHNib3gubWFwKChfLCBqKSA9PiBzYm94LmluZGV4T2YoaikpO1xuXHQvLyBSb3RhdGUgdTMyIGJ5IDhcblx0Y29uc3Qgcm90cjMyXzggPSAobikgPT4gKG4gPDwgMjQpIHwgKG4gPj4+IDgpO1xuXHRjb25zdCByb3RsMzJfOCA9IChuKSA9PiAobiA8PCA4KSB8IChuID4+PiAyNCk7XG5cdC8vIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzIgKExFPC0+QkUpXG5cdGNvbnN0IGJ5dGVTd2FwID0gKHdvcmQpID0+ICgod29yZCA8PCAyNCkgJiAweGZmMDAwMDAwKSB8XG5cdCAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuXHQgICAgKCh3b3JkID4+PiA4KSAmIDB4ZmYwMCkgfFxuXHQgICAgKCh3b3JkID4+PiAyNCkgJiAweGZmKTtcblx0Ly8gVC10YWJsZSBpcyBvcHRpbWl6YXRpb24gc3VnZ2VzdGVkIGluIDUuMiBvZiBvcmlnaW5hbCBwcm9wb3NhbCAobWlzc2VkIGZyb20gRklQUy0xOTcpLiBDaGFuZ2VzOlxuXHQvLyAtIExFIGluc3RlYWQgb2YgQkVcblx0Ly8gLSBiaWdnZXIgdGFibGVzOiBUMCBhbmQgVDEgYXJlIG1lcmdlZCBpbnRvIFQwMSB0YWJsZSBhbmQgVDIgJiBUMyBpbnRvIFQyMztcblx0Ly8gICBzbyBpbmRleCBpcyB1MTYsIGluc3RlYWQgb2YgdTguIFRoaXMgc3BlZWRzIHVwIHRoaW5ncywgdW5leHBlY3RlZGx5XG5cdGZ1bmN0aW9uIGdlblR0YWJsZShzYm94LCBmbikge1xuXHQgICAgaWYgKHNib3gubGVuZ3RoICE9PSAyNTYpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBzYm94IGxlbmd0aCcpO1xuXHQgICAgY29uc3QgVDAgPSBuZXcgVWludDMyQXJyYXkoMjU2KS5tYXAoKF8sIGopID0+IGZuKHNib3hbal0pKTtcblx0ICAgIGNvbnN0IFQxID0gVDAubWFwKHJvdGwzMl84KTtcblx0ICAgIGNvbnN0IFQyID0gVDEubWFwKHJvdGwzMl84KTtcblx0ICAgIGNvbnN0IFQzID0gVDIubWFwKHJvdGwzMl84KTtcblx0ICAgIGNvbnN0IFQwMSA9IG5ldyBVaW50MzJBcnJheSgyNTYgKiAyNTYpO1xuXHQgICAgY29uc3QgVDIzID0gbmV3IFVpbnQzMkFycmF5KDI1NiAqIDI1Nik7XG5cdCAgICBjb25zdCBzYm94MiA9IG5ldyBVaW50MTZBcnJheSgyNTYgKiAyNTYpO1xuXHQgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjU2OyBqKyspIHtcblx0ICAgICAgICAgICAgY29uc3QgaWR4ID0gaSAqIDI1NiArIGo7XG5cdCAgICAgICAgICAgIFQwMVtpZHhdID0gVDBbaV0gXiBUMVtqXTtcblx0ICAgICAgICAgICAgVDIzW2lkeF0gPSBUMltpXSBeIFQzW2pdO1xuXHQgICAgICAgICAgICBzYm94MltpZHhdID0gKHNib3hbaV0gPDwgOCkgfCBzYm94W2pdO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB7IHNib3gsIHNib3gyLCBUMCwgVDEsIFQyLCBUMywgVDAxLCBUMjMgfTtcblx0fVxuXHRjb25zdCB0YWJsZUVuY29kaW5nID0gLyogQF9fUFVSRV9fICovIGdlblR0YWJsZShzYm94LCAocykgPT4gKG11bChzLCAzKSA8PCAyNCkgfCAocyA8PCAxNikgfCAocyA8PCA4KSB8IG11bChzLCAyKSk7XG5cdGNvbnN0IHRhYmxlRGVjb2RpbmcgPSAvKiBAX19QVVJFX18gKi8gZ2VuVHRhYmxlKGludlNib3gsIChzKSA9PiAobXVsKHMsIDExKSA8PCAyNCkgfCAobXVsKHMsIDEzKSA8PCAxNikgfCAobXVsKHMsIDkpIDw8IDgpIHwgbXVsKHMsIDE0KSk7XG5cdGNvbnN0IHhQb3dlcnMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcblx0ICAgIGNvbnN0IHAgPSBuZXcgVWludDhBcnJheSgxNik7XG5cdCAgICBmb3IgKGxldCBpID0gMCwgeCA9IDE7IGkgPCAxNjsgaSsrLCB4ID0gbXVsMih4KSlcblx0ICAgICAgICBwW2ldID0geDtcblx0ICAgIHJldHVybiBwO1xuXHR9KSgpO1xuXHQvKiogS2V5IGV4cGFuc2lvbiB1c2VkIGluIENUUi4gKi9cblx0ZnVuY3Rpb24gZXhwYW5kS2V5TEUoa2V5KSB7XG5cdCAgICAoMCwgX2Fzc2VydF9qc18xLmFieXRlcykoa2V5KTtcblx0ICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG5cdCAgICBpZiAoIVsxNiwgMjQsIDMyXS5pbmNsdWRlcyhsZW4pKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignYWVzOiBpbnZhbGlkIGtleSBzaXplLCBzaG91bGQgYmUgMTYsIDI0IG9yIDMyLCBnb3QgJyArIGxlbik7XG5cdCAgICBjb25zdCB7IHNib3gyIH0gPSB0YWJsZUVuY29kaW5nO1xuXHQgICAgY29uc3QgdG9DbGVhbiA9IFtdO1xuXHQgICAgaWYgKCEoMCwgdXRpbHNfanNfMS5pc0FsaWduZWQzMikoa2V5KSlcblx0ICAgICAgICB0b0NsZWFuLnB1c2goKGtleSA9ICgwLCB1dGlsc19qc18xLmNvcHlCeXRlcykoa2V5KSkpO1xuXHQgICAgY29uc3QgazMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShrZXkpO1xuXHQgICAgY29uc3QgTmsgPSBrMzIubGVuZ3RoO1xuXHQgICAgY29uc3Qgc3ViQnl0ZSA9IChuKSA9PiBhcHBseVNib3goc2JveDIsIG4sIG4sIG4sIG4pO1xuXHQgICAgY29uc3QgeGsgPSBuZXcgVWludDMyQXJyYXkobGVuICsgMjgpOyAvLyBleHBhbmRlZCBrZXlcblx0ICAgIHhrLnNldChrMzIpO1xuXHQgICAgLy8gNC4zLjEgS2V5IGV4cGFuc2lvblxuXHQgICAgZm9yIChsZXQgaSA9IE5rOyBpIDwgeGsubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBsZXQgdCA9IHhrW2kgLSAxXTtcblx0ICAgICAgICBpZiAoaSAlIE5rID09PSAwKVxuXHQgICAgICAgICAgICB0ID0gc3ViQnl0ZShyb3RyMzJfOCh0KSkgXiB4UG93ZXJzW2kgLyBOayAtIDFdO1xuXHQgICAgICAgIGVsc2UgaWYgKE5rID4gNiAmJiBpICUgTmsgPT09IDQpXG5cdCAgICAgICAgICAgIHQgPSBzdWJCeXRlKHQpO1xuXHQgICAgICAgIHhrW2ldID0geGtbaSAtIE5rXSBeIHQ7XG5cdCAgICB9XG5cdCAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoLi4udG9DbGVhbik7XG5cdCAgICByZXR1cm4geGs7XG5cdH1cblx0ZnVuY3Rpb24gZXhwYW5kS2V5RGVjTEUoa2V5KSB7XG5cdCAgICBjb25zdCBlbmNLZXkgPSBleHBhbmRLZXlMRShrZXkpO1xuXHQgICAgY29uc3QgeGsgPSBlbmNLZXkuc2xpY2UoKTtcblx0ICAgIGNvbnN0IE5rID0gZW5jS2V5Lmxlbmd0aDtcblx0ICAgIGNvbnN0IHsgc2JveDIgfSA9IHRhYmxlRW5jb2Rpbmc7XG5cdCAgICBjb25zdCB7IFQwLCBUMSwgVDIsIFQzIH0gPSB0YWJsZURlY29kaW5nO1xuXHQgICAgLy8gSW52ZXJzZSBrZXkgYnkgY2h1bmtzIG9mIDQgKHJvdW5kcylcblx0ICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTms7IGkgKz0gNCkge1xuXHQgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKVxuXHQgICAgICAgICAgICB4a1tpICsgal0gPSBlbmNLZXlbTmsgLSBpIC0gNCArIGpdO1xuXHQgICAgfVxuXHQgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKGVuY0tleSk7XG5cdCAgICAvLyBhcHBseSBJbnZNaXhDb2x1bW4gZXhjZXB0IGZpcnN0ICYgbGFzdCByb3VuZFxuXHQgICAgZm9yIChsZXQgaSA9IDQ7IGkgPCBOayAtIDQ7IGkrKykge1xuXHQgICAgICAgIGNvbnN0IHggPSB4a1tpXTtcblx0ICAgICAgICBjb25zdCB3ID0gYXBwbHlTYm94KHNib3gyLCB4LCB4LCB4LCB4KTtcblx0ICAgICAgICB4a1tpXSA9IFQwW3cgJiAweGZmXSBeIFQxWyh3ID4+PiA4KSAmIDB4ZmZdIF4gVDJbKHcgPj4+IDE2KSAmIDB4ZmZdIF4gVDNbdyA+Pj4gMjRdO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHhrO1xuXHR9XG5cdC8vIEFwcGx5IHRhYmxlc1xuXHRmdW5jdGlvbiBhcHBseTAxMjMoVDAxLCBUMjMsIHMwLCBzMSwgczIsIHMzKSB7XG5cdCAgICByZXR1cm4gKFQwMVsoKHMwIDw8IDgpICYgMHhmZjAwKSB8ICgoczEgPj4+IDgpICYgMHhmZildIF5cblx0ICAgICAgICBUMjNbKChzMiA+Pj4gOCkgJiAweGZmMDApIHwgKChzMyA+Pj4gMjQpICYgMHhmZildKTtcblx0fVxuXHRmdW5jdGlvbiBhcHBseVNib3goc2JveDIsIHMwLCBzMSwgczIsIHMzKSB7XG5cdCAgICByZXR1cm4gKHNib3gyWyhzMCAmIDB4ZmYpIHwgKHMxICYgMHhmZjAwKV0gfFxuXHQgICAgICAgIChzYm94MlsoKHMyID4+PiAxNikgJiAweGZmKSB8ICgoczMgPj4+IDE2KSAmIDB4ZmYwMCldIDw8IDE2KSk7XG5cdH1cblx0ZnVuY3Rpb24gZW5jcnlwdCh4aywgczAsIHMxLCBzMiwgczMpIHtcblx0ICAgIGNvbnN0IHsgc2JveDIsIFQwMSwgVDIzIH0gPSB0YWJsZUVuY29kaW5nO1xuXHQgICAgbGV0IGsgPSAwO1xuXHQgICAgKHMwIF49IHhrW2srK10pLCAoczEgXj0geGtbaysrXSksIChzMiBePSB4a1trKytdKSwgKHMzIF49IHhrW2srK10pO1xuXHQgICAgY29uc3Qgcm91bmRzID0geGsubGVuZ3RoIC8gNCAtIDI7XG5cdCAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kczsgaSsrKSB7XG5cdCAgICAgICAgY29uc3QgdDAgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMCwgczEsIHMyLCBzMyk7XG5cdCAgICAgICAgY29uc3QgdDEgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMSwgczIsIHMzLCBzMCk7XG5cdCAgICAgICAgY29uc3QgdDIgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMiwgczMsIHMwLCBzMSk7XG5cdCAgICAgICAgY29uc3QgdDMgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMywgczAsIHMxLCBzMik7XG5cdCAgICAgICAgKHMwID0gdDApLCAoczEgPSB0MSksIChzMiA9IHQyKSwgKHMzID0gdDMpO1xuXHQgICAgfVxuXHQgICAgLy8gbGFzdCByb3VuZCAod2l0aG91dCBtaXhjb2x1bW5zLCBzbyB1c2luZyBTQk9YMiB0YWJsZSlcblx0ICAgIGNvbnN0IHQwID0geGtbaysrXSBeIGFwcGx5U2JveChzYm94MiwgczAsIHMxLCBzMiwgczMpO1xuXHQgICAgY29uc3QgdDEgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMSwgczIsIHMzLCBzMCk7XG5cdCAgICBjb25zdCB0MiA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMyLCBzMywgczAsIHMxKTtcblx0ICAgIGNvbnN0IHQzID0geGtbaysrXSBeIGFwcGx5U2JveChzYm94MiwgczMsIHMwLCBzMSwgczIpO1xuXHQgICAgcmV0dXJuIHsgczA6IHQwLCBzMTogdDEsIHMyOiB0MiwgczM6IHQzIH07XG5cdH1cblx0Ly8gQ2FuJ3QgYmUgbWVyZ2VkIHdpdGggZW5jcnlwdDogYXJnIHBvc2l0aW9ucyBmb3IgYXBwbHkwMTIzIC8gYXBwbHlTYm94IGFyZSBkaWZmZXJlbnRcblx0ZnVuY3Rpb24gZGVjcnlwdCh4aywgczAsIHMxLCBzMiwgczMpIHtcblx0ICAgIGNvbnN0IHsgc2JveDIsIFQwMSwgVDIzIH0gPSB0YWJsZURlY29kaW5nO1xuXHQgICAgbGV0IGsgPSAwO1xuXHQgICAgKHMwIF49IHhrW2srK10pLCAoczEgXj0geGtbaysrXSksIChzMiBePSB4a1trKytdKSwgKHMzIF49IHhrW2srK10pO1xuXHQgICAgY29uc3Qgcm91bmRzID0geGsubGVuZ3RoIC8gNCAtIDI7XG5cdCAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kczsgaSsrKSB7XG5cdCAgICAgICAgY29uc3QgdDAgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMCwgczMsIHMyLCBzMSk7XG5cdCAgICAgICAgY29uc3QgdDEgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMSwgczAsIHMzLCBzMik7XG5cdCAgICAgICAgY29uc3QgdDIgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMiwgczEsIHMwLCBzMyk7XG5cdCAgICAgICAgY29uc3QgdDMgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMywgczIsIHMxLCBzMCk7XG5cdCAgICAgICAgKHMwID0gdDApLCAoczEgPSB0MSksIChzMiA9IHQyKSwgKHMzID0gdDMpO1xuXHQgICAgfVxuXHQgICAgLy8gTGFzdCByb3VuZFxuXHQgICAgY29uc3QgdDAgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMCwgczMsIHMyLCBzMSk7XG5cdCAgICBjb25zdCB0MSA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMxLCBzMCwgczMsIHMyKTtcblx0ICAgIGNvbnN0IHQyID0geGtbaysrXSBeIGFwcGx5U2JveChzYm94MiwgczIsIHMxLCBzMCwgczMpO1xuXHQgICAgY29uc3QgdDMgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMywgczIsIHMxLCBzMCk7XG5cdCAgICByZXR1cm4geyBzMDogdDAsIHMxOiB0MSwgczI6IHQyLCBzMzogdDMgfTtcblx0fVxuXHQvLyBUT0RPOiBpbnZlc3RpZ2F0ZSBtZXJnaW5nIHdpdGggY3RyMzJcblx0ZnVuY3Rpb24gY3RyQ291bnRlcih4aywgbm9uY2UsIHNyYywgZHN0KSB7XG5cdCAgICAoMCwgX2Fzc2VydF9qc18xLmFieXRlcykobm9uY2UsIEJMT0NLX1NJWkUpO1xuXHQgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKHNyYyk7XG5cdCAgICBjb25zdCBzcmNMZW4gPSBzcmMubGVuZ3RoO1xuXHQgICAgZHN0ID0gKDAsIHV0aWxzX2pzXzEuZ2V0T3V0cHV0KShzcmNMZW4sIGRzdCk7XG5cdCAgICAoMCwgdXRpbHNfanNfMS5jb21wbGV4T3ZlcmxhcEJ5dGVzKShzcmMsIGRzdCk7XG5cdCAgICBjb25zdCBjdHIgPSBub25jZTtcblx0ICAgIGNvbnN0IGMzMiA9ICgwLCB1dGlsc19qc18xLnUzMikoY3RyKTtcblx0ICAgIC8vIEZpbGwgYmxvY2sgKGVtcHR5LCBjdHI9MClcblx0ICAgIGxldCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBjMzJbMF0sIGMzMlsxXSwgYzMyWzJdLCBjMzJbM10pO1xuXHQgICAgY29uc3Qgc3JjMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHNyYyk7XG5cdCAgICBjb25zdCBkc3QzMiA9ICgwLCB1dGlsc19qc18xLnUzMikoZHN0KTtcblx0ICAgIC8vIHByb2Nlc3MgYmxvY2tzXG5cdCAgICBmb3IgKGxldCBpID0gMDsgaSArIDQgPD0gc3JjMzIubGVuZ3RoOyBpICs9IDQpIHtcblx0ICAgICAgICBkc3QzMltpICsgMF0gPSBzcmMzMltpICsgMF0gXiBzMDtcblx0ICAgICAgICBkc3QzMltpICsgMV0gPSBzcmMzMltpICsgMV0gXiBzMTtcblx0ICAgICAgICBkc3QzMltpICsgMl0gPSBzcmMzMltpICsgMl0gXiBzMjtcblx0ICAgICAgICBkc3QzMltpICsgM10gPSBzcmMzMltpICsgM10gXiBzMztcblx0ICAgICAgICAvLyBGdWxsIDEyOCBiaXQgY291bnRlciB3aXRoIHdyYXAgYXJvdW5kXG5cdCAgICAgICAgbGV0IGNhcnJ5ID0gMTtcblx0ICAgICAgICBmb3IgKGxldCBpID0gY3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgICAgIGNhcnJ5ID0gKGNhcnJ5ICsgKGN0cltpXSAmIDB4ZmYpKSB8IDA7XG5cdCAgICAgICAgICAgIGN0cltpXSA9IGNhcnJ5ICYgMHhmZjtcblx0ICAgICAgICAgICAgY2FycnkgPj4+PSA4O1xuXHQgICAgICAgIH1cblx0ICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgYzMyWzBdLCBjMzJbMV0sIGMzMlsyXSwgYzMyWzNdKSk7XG5cdCAgICB9XG5cdCAgICAvLyBsZWZ0b3ZlcnMgKGxlc3MgdGhhbiBibG9jaylcblx0ICAgIC8vIEl0J3MgcG9zc2libGUgdG8gaGFuZGxlID4gdTMyIGZhc3QsIGJ1dCBpcyBpdCB3b3J0aCBpdD9cblx0ICAgIGNvbnN0IHN0YXJ0ID0gQkxPQ0tfU0laRSAqIE1hdGguZmxvb3Ioc3JjMzIubGVuZ3RoIC8gQkxPQ0tfU0laRTMyKTtcblx0ICAgIGlmIChzdGFydCA8IHNyY0xlbikge1xuXHQgICAgICAgIGNvbnN0IGIzMiA9IG5ldyBVaW50MzJBcnJheShbczAsIHMxLCBzMiwgczNdKTtcblx0ICAgICAgICBjb25zdCBidWYgPSAoMCwgdXRpbHNfanNfMS51OCkoYjMyKTtcblx0ICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQsIHBvcyA9IDA7IGkgPCBzcmNMZW47IGkrKywgcG9zKyspXG5cdCAgICAgICAgICAgIGRzdFtpXSA9IHNyY1tpXSBeIGJ1Zltwb3NdO1xuXHQgICAgICAgICgwLCB1dGlsc19qc18xLmNsZWFuKShiMzIpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGRzdDtcblx0fVxuXHQvLyBBRVMgQ1RSIHdpdGggb3ZlcmZsb3dpbmcgMzIgYml0IGNvdW50ZXJcblx0Ly8gSXQncyBwb3NzaWJsZSB0byBkbyAzMmxlIHNpZ25pZmljYW50bHkgc2ltcGxlciAoYW5kIHByb2JhYmx5IGZhc3RlcikgYnkgdXNpbmcgdTMyLlxuXHQvLyBCdXQsIHdlIG5lZWQgYm90aCwgYW5kIHBlcmYgYm90dGxlbmVjayBpcyBpbiBnaGFzaCBhbnl3YXkuXG5cdGZ1bmN0aW9uIGN0cjMyKHhrLCBpc0xFLCBub25jZSwgc3JjLCBkc3QpIHtcblx0ICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJ5dGVzKShub25jZSwgQkxPQ0tfU0laRSk7XG5cdCAgICAoMCwgX2Fzc2VydF9qc18xLmFieXRlcykoc3JjKTtcblx0ICAgIGRzdCA9ICgwLCB1dGlsc19qc18xLmdldE91dHB1dCkoc3JjLmxlbmd0aCwgZHN0KTtcblx0ICAgIGNvbnN0IGN0ciA9IG5vbmNlOyAvLyB3cml0ZSBuZXcgdmFsdWUgdG8gbm9uY2UsIHNvIGl0IGNhbiBiZSByZS11c2VkXG5cdCAgICBjb25zdCBjMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGN0cik7XG5cdCAgICBjb25zdCB2aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykoY3RyKTtcblx0ICAgIGNvbnN0IHNyYzMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShzcmMpO1xuXHQgICAgY29uc3QgZHN0MzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGRzdCk7XG5cdCAgICBjb25zdCBjdHJQb3MgPSBpc0xFID8gMCA6IDEyO1xuXHQgICAgY29uc3Qgc3JjTGVuID0gc3JjLmxlbmd0aDtcblx0ICAgIC8vIEZpbGwgYmxvY2sgKGVtcHR5LCBjdHI9MClcblx0ICAgIGxldCBjdHJOdW0gPSB2aWV3LmdldFVpbnQzMihjdHJQb3MsIGlzTEUpOyAvLyByZWFkIGN1cnJlbnQgY291bnRlciB2YWx1ZVxuXHQgICAgbGV0IHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIGMzMlswXSwgYzMyWzFdLCBjMzJbMl0sIGMzMlszXSk7XG5cdCAgICAvLyBwcm9jZXNzIGJsb2Nrc1xuXHQgICAgZm9yIChsZXQgaSA9IDA7IGkgKyA0IDw9IHNyYzMyLmxlbmd0aDsgaSArPSA0KSB7XG5cdCAgICAgICAgZHN0MzJbaSArIDBdID0gc3JjMzJbaSArIDBdIF4gczA7XG5cdCAgICAgICAgZHN0MzJbaSArIDFdID0gc3JjMzJbaSArIDFdIF4gczE7XG5cdCAgICAgICAgZHN0MzJbaSArIDJdID0gc3JjMzJbaSArIDJdIF4gczI7XG5cdCAgICAgICAgZHN0MzJbaSArIDNdID0gc3JjMzJbaSArIDNdIF4gczM7XG5cdCAgICAgICAgY3RyTnVtID0gKGN0ck51bSArIDEpID4+PiAwOyAvLyB1MzIgd3JhcFxuXHQgICAgICAgIHZpZXcuc2V0VWludDMyKGN0clBvcywgY3RyTnVtLCBpc0xFKTtcblx0ICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgYzMyWzBdLCBjMzJbMV0sIGMzMlsyXSwgYzMyWzNdKSk7XG5cdCAgICB9XG5cdCAgICAvLyBsZWZ0b3ZlcnMgKGxlc3MgdGhhbiBhIGJsb2NrKVxuXHQgICAgY29uc3Qgc3RhcnQgPSBCTE9DS19TSVpFICogTWF0aC5mbG9vcihzcmMzMi5sZW5ndGggLyBCTE9DS19TSVpFMzIpO1xuXHQgICAgaWYgKHN0YXJ0IDwgc3JjTGVuKSB7XG5cdCAgICAgICAgY29uc3QgYjMyID0gbmV3IFVpbnQzMkFycmF5KFtzMCwgczEsIHMyLCBzM10pO1xuXHQgICAgICAgIGNvbnN0IGJ1ZiA9ICgwLCB1dGlsc19qc18xLnU4KShiMzIpO1xuXHQgICAgICAgIGZvciAobGV0IGkgPSBzdGFydCwgcG9zID0gMDsgaSA8IHNyY0xlbjsgaSsrLCBwb3MrKylcblx0ICAgICAgICAgICAgZHN0W2ldID0gc3JjW2ldIF4gYnVmW3Bvc107XG5cdCAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKGIzMik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZHN0O1xuXHR9XG5cdC8qKlxuXHQgKiBDVFI6IGNvdW50ZXIgbW9kZS4gQ3JlYXRlcyBzdHJlYW0gY2lwaGVyLlxuXHQgKiBSZXF1aXJlcyBnb29kIElWLiBQYXJhbGxlbGl6YWJsZS4gT0ssIGJ1dCBubyBNQUMuXG5cdCAqL1xuXHRhZXMuY3RyID0gKDAsIHV0aWxzX2pzXzEud3JhcENpcGhlcikoeyBibG9ja1NpemU6IDE2LCBub25jZUxlbmd0aDogMTYgfSwgZnVuY3Rpb24gYWVzY3RyKGtleSwgbm9uY2UpIHtcblx0ICAgIGZ1bmN0aW9uIHByb2Nlc3NDdHIoYnVmLCBkc3QpIHtcblx0ICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmFieXRlcykoYnVmKTtcblx0ICAgICAgICBpZiAoZHN0ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKGRzdCk7XG5cdCAgICAgICAgICAgIGlmICghKDAsIHV0aWxzX2pzXzEuaXNBbGlnbmVkMzIpKGRzdCkpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWxpZ25lZCBkZXN0aW5hdGlvbicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG5cdCAgICAgICAgY29uc3QgbiA9ICgwLCB1dGlsc19qc18xLmNvcHlCeXRlcykobm9uY2UpOyAvLyBhbGlnbiArIGF2b2lkIGNoYW5naW5nXG5cdCAgICAgICAgY29uc3QgdG9DbGVhbiA9IFt4aywgbl07XG5cdCAgICAgICAgaWYgKCEoMCwgdXRpbHNfanNfMS5pc0FsaWduZWQzMikoYnVmKSlcblx0ICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChidWYgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKGJ1ZikpKTtcblx0ICAgICAgICBjb25zdCBvdXQgPSBjdHJDb3VudGVyKHhrLCBuLCBidWYsIGRzdCk7XG5cdCAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKC4uLnRvQ2xlYW4pO1xuXHQgICAgICAgIHJldHVybiBvdXQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGVuY3J5cHQ6IChwbGFpbnRleHQsIGRzdCkgPT4gcHJvY2Vzc0N0cihwbGFpbnRleHQsIGRzdCksXG5cdCAgICAgICAgZGVjcnlwdDogKGNpcGhlcnRleHQsIGRzdCkgPT4gcHJvY2Vzc0N0cihjaXBoZXJ0ZXh0LCBkc3QpLFxuXHQgICAgfTtcblx0fSk7XG5cdGZ1bmN0aW9uIHZhbGlkYXRlQmxvY2tEZWNyeXB0KGRhdGEpIHtcblx0ICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJ5dGVzKShkYXRhKTtcblx0ICAgIGlmIChkYXRhLmxlbmd0aCAlIEJMT0NLX1NJWkUgIT09IDApIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Flcy0oY2JjL2VjYikuZGVjcnlwdCBjaXBoZXJ0ZXh0IHNob3VsZCBjb25zaXN0IG9mIGJsb2NrcyB3aXRoIHNpemUgJyArIEJMT0NLX1NJWkUpO1xuXHQgICAgfVxuXHR9XG5cdGZ1bmN0aW9uIHZhbGlkYXRlQmxvY2tFbmNyeXB0KHBsYWludGV4dCwgcGNrczUsIGRzdCkge1xuXHQgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKHBsYWludGV4dCk7XG5cdCAgICBsZXQgb3V0TGVuID0gcGxhaW50ZXh0Lmxlbmd0aDtcblx0ICAgIGNvbnN0IHJlbWFpbmluZyA9IG91dExlbiAlIEJMT0NLX1NJWkU7XG5cdCAgICBpZiAoIXBja3M1ICYmIHJlbWFpbmluZyAhPT0gMClcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FlYy8oY2JjLWVjYik6IHVucGFkZGVkIHBsYWludGV4dCB3aXRoIGRpc2FibGVkIHBhZGRpbmcnKTtcblx0ICAgIGlmICghKDAsIHV0aWxzX2pzXzEuaXNBbGlnbmVkMzIpKHBsYWludGV4dCkpXG5cdCAgICAgICAgcGxhaW50ZXh0ID0gKDAsIHV0aWxzX2pzXzEuY29weUJ5dGVzKShwbGFpbnRleHQpO1xuXHQgICAgY29uc3QgYiA9ICgwLCB1dGlsc19qc18xLnUzMikocGxhaW50ZXh0KTtcblx0ICAgIGlmIChwY2tzNSkge1xuXHQgICAgICAgIGxldCBsZWZ0ID0gQkxPQ0tfU0laRSAtIHJlbWFpbmluZztcblx0ICAgICAgICBpZiAoIWxlZnQpXG5cdCAgICAgICAgICAgIGxlZnQgPSBCTE9DS19TSVpFOyAvLyBpZiBubyBieXRlcyBsZWZ0LCBjcmVhdGUgZW1wdHkgcGFkZGluZyBibG9ja1xuXHQgICAgICAgIG91dExlbiA9IG91dExlbiArIGxlZnQ7XG5cdCAgICB9XG5cdCAgICBkc3QgPSAoMCwgdXRpbHNfanNfMS5nZXRPdXRwdXQpKG91dExlbiwgZHN0KTtcblx0ICAgICgwLCB1dGlsc19qc18xLmNvbXBsZXhPdmVybGFwQnl0ZXMpKHBsYWludGV4dCwgZHN0KTtcblx0ICAgIGNvbnN0IG8gPSAoMCwgdXRpbHNfanNfMS51MzIpKGRzdCk7XG5cdCAgICByZXR1cm4geyBiLCBvLCBvdXQ6IGRzdCB9O1xuXHR9XG5cdGZ1bmN0aW9uIHZhbGlkYXRlUENLUyhkYXRhLCBwY2tzNSkge1xuXHQgICAgaWYgKCFwY2tzNSlcblx0ICAgICAgICByZXR1cm4gZGF0YTtcblx0ICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuXHQgICAgaWYgKCFsZW4pXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZXMvcGNrczU6IGVtcHR5IGNpcGhlcnRleHQgbm90IGFsbG93ZWQnKTtcblx0ICAgIGNvbnN0IGxhc3RCeXRlID0gZGF0YVtsZW4gLSAxXTtcblx0ICAgIGlmIChsYXN0Qnl0ZSA8PSAwIHx8IGxhc3RCeXRlID4gMTYpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZXMvcGNrczU6IHdyb25nIHBhZGRpbmcnKTtcblx0ICAgIGNvbnN0IG91dCA9IGRhdGEuc3ViYXJyYXkoMCwgLWxhc3RCeXRlKTtcblx0ICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdEJ5dGU7IGkrKylcblx0ICAgICAgICBpZiAoZGF0YVtsZW4gLSBpIC0gMV0gIT09IGxhc3RCeXRlKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Flcy9wY2tzNTogd3JvbmcgcGFkZGluZycpO1xuXHQgICAgcmV0dXJuIG91dDtcblx0fVxuXHRmdW5jdGlvbiBwYWRQQ0tTKGxlZnQpIHtcblx0ICAgIGNvbnN0IHRtcCA9IG5ldyBVaW50OEFycmF5KDE2KTtcblx0ICAgIGNvbnN0IHRtcDMyID0gKDAsIHV0aWxzX2pzXzEudTMyKSh0bXApO1xuXHQgICAgdG1wLnNldChsZWZ0KTtcblx0ICAgIGNvbnN0IHBhZGRpbmdCeXRlID0gQkxPQ0tfU0laRSAtIGxlZnQubGVuZ3RoO1xuXHQgICAgZm9yIChsZXQgaSA9IEJMT0NLX1NJWkUgLSBwYWRkaW5nQnl0ZTsgaSA8IEJMT0NLX1NJWkU7IGkrKylcblx0ICAgICAgICB0bXBbaV0gPSBwYWRkaW5nQnl0ZTtcblx0ICAgIHJldHVybiB0bXAzMjtcblx0fVxuXHQvKipcblx0ICogRUNCOiBFbGVjdHJvbmljIENvZGVCb29rLiBTaW1wbGUgZGV0ZXJtaW5pc3RpYyByZXBsYWNlbWVudC5cblx0ICogRGFuZ2Vyb3VzOiBhbHdheXMgbWFwIHggdG8geS4gU2VlIFtBRVMgUGVuZ3Vpbl0oaHR0cHM6Ly93b3Jkcy5maWxpcHBvLmlvL3RoZS1lY2ItcGVuZ3Vpbi8pLlxuXHQgKi9cblx0YWVzLmVjYiA9ICgwLCB1dGlsc19qc18xLndyYXBDaXBoZXIpKHsgYmxvY2tTaXplOiAxNiB9LCBmdW5jdGlvbiBhZXNlY2Ioa2V5LCBvcHRzID0ge30pIHtcblx0ICAgIGNvbnN0IHBja3M1ID0gIW9wdHMuZGlzYWJsZVBhZGRpbmc7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGVuY3J5cHQocGxhaW50ZXh0LCBkc3QpIHtcblx0ICAgICAgICAgICAgY29uc3QgeyBiLCBvLCBvdXQ6IF9vdXQgfSA9IHZhbGlkYXRlQmxvY2tFbmNyeXB0KHBsYWludGV4dCwgcGNrczUsIGRzdCk7XG5cdCAgICAgICAgICAgIGNvbnN0IHhrID0gZXhwYW5kS2V5TEUoa2V5KTtcblx0ICAgICAgICAgICAgbGV0IGkgPSAwO1xuXHQgICAgICAgICAgICBmb3IgKDsgaSArIDQgPD0gYi5sZW5ndGg7KSB7XG5cdCAgICAgICAgICAgICAgICBjb25zdCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBiW2kgKyAwXSwgYltpICsgMV0sIGJbaSArIDJdLCBiW2kgKyAzXSk7XG5cdCAgICAgICAgICAgICAgICAob1tpKytdID0gczApLCAob1tpKytdID0gczEpLCAob1tpKytdID0gczIpLCAob1tpKytdID0gczMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChwY2tzNSkge1xuXHQgICAgICAgICAgICAgICAgY29uc3QgdG1wMzIgPSBwYWRQQ0tTKHBsYWludGV4dC5zdWJhcnJheShpICogNCkpO1xuXHQgICAgICAgICAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgdG1wMzJbMF0sIHRtcDMyWzFdLCB0bXAzMlsyXSwgdG1wMzJbM10pO1xuXHQgICAgICAgICAgICAgICAgKG9baSsrXSA9IHMwKSwgKG9baSsrXSA9IHMxKSwgKG9baSsrXSA9IHMyKSwgKG9baSsrXSA9IHMzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoeGspO1xuXHQgICAgICAgICAgICByZXR1cm4gX291dDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGRlY3J5cHQoY2lwaGVydGV4dCwgZHN0KSB7XG5cdCAgICAgICAgICAgIHZhbGlkYXRlQmxvY2tEZWNyeXB0KGNpcGhlcnRleHQpO1xuXHQgICAgICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleURlY0xFKGtleSk7XG5cdCAgICAgICAgICAgIGRzdCA9ICgwLCB1dGlsc19qc18xLmdldE91dHB1dCkoY2lwaGVydGV4dC5sZW5ndGgsIGRzdCk7XG5cdCAgICAgICAgICAgIGNvbnN0IHRvQ2xlYW4gPSBbeGtdO1xuXHQgICAgICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmlzQWxpZ25lZDMyKShjaXBoZXJ0ZXh0KSlcblx0ICAgICAgICAgICAgICAgIHRvQ2xlYW4ucHVzaCgoY2lwaGVydGV4dCA9ICgwLCB1dGlsc19qc18xLmNvcHlCeXRlcykoY2lwaGVydGV4dCkpKTtcblx0ICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuY29tcGxleE92ZXJsYXBCeXRlcykoY2lwaGVydGV4dCwgZHN0KTtcblx0ICAgICAgICAgICAgY29uc3QgYiA9ICgwLCB1dGlsc19qc18xLnUzMikoY2lwaGVydGV4dCk7XG5cdCAgICAgICAgICAgIGNvbnN0IG8gPSAoMCwgdXRpbHNfanNfMS51MzIpKGRzdCk7XG5cdCAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpICsgNCA8PSBiLmxlbmd0aDspIHtcblx0ICAgICAgICAgICAgICAgIGNvbnN0IHsgczAsIHMxLCBzMiwgczMgfSA9IGRlY3J5cHQoeGssIGJbaSArIDBdLCBiW2kgKyAxXSwgYltpICsgMl0sIGJbaSArIDNdKTtcblx0ICAgICAgICAgICAgICAgIChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKC4uLnRvQ2xlYW4pO1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVQQ0tTKGRzdCwgcGNrczUpO1xuXHQgICAgICAgIH0sXG5cdCAgICB9O1xuXHR9KTtcblx0LyoqXG5cdCAqIENCQzogQ2lwaGVyLUJsb2NrLUNoYWluaW5nLiBLZXkgaXMgcHJldmlvdXMgcm91bmTigJlzIGJsb2NrLlxuXHQgKiBGcmFnaWxlOiBuZWVkcyBwcm9wZXIgcGFkZGluZy4gVW5hdXRoZW50aWNhdGVkOiBuZWVkcyBNQUMuXG5cdCAqL1xuXHRhZXMuY2JjID0gKDAsIHV0aWxzX2pzXzEud3JhcENpcGhlcikoeyBibG9ja1NpemU6IDE2LCBub25jZUxlbmd0aDogMTYgfSwgZnVuY3Rpb24gYWVzY2JjKGtleSwgaXYsIG9wdHMgPSB7fSkge1xuXHQgICAgY29uc3QgcGNrczUgPSAhb3B0cy5kaXNhYmxlUGFkZGluZztcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgZW5jcnlwdChwbGFpbnRleHQsIGRzdCkge1xuXHQgICAgICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG5cdCAgICAgICAgICAgIGNvbnN0IHsgYiwgbywgb3V0OiBfb3V0IH0gPSB2YWxpZGF0ZUJsb2NrRW5jcnlwdChwbGFpbnRleHQsIHBja3M1LCBkc3QpO1xuXHQgICAgICAgICAgICBsZXQgX2l2ID0gaXY7XG5cdCAgICAgICAgICAgIGNvbnN0IHRvQ2xlYW4gPSBbeGtdO1xuXHQgICAgICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmlzQWxpZ25lZDMyKShfaXYpKVxuXHQgICAgICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChfaXYgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKF9pdikpKTtcblx0ICAgICAgICAgICAgY29uc3QgbjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShfaXYpO1xuXHQgICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcblx0ICAgICAgICAgICAgbGV0IHMwID0gbjMyWzBdLCBzMSA9IG4zMlsxXSwgczIgPSBuMzJbMl0sIHMzID0gbjMyWzNdO1xuXHQgICAgICAgICAgICBsZXQgaSA9IDA7XG5cdCAgICAgICAgICAgIGZvciAoOyBpICsgNCA8PSBiLmxlbmd0aDspIHtcblx0ICAgICAgICAgICAgICAgIChzMCBePSBiW2kgKyAwXSksIChzMSBePSBiW2kgKyAxXSksIChzMiBePSBiW2kgKyAyXSksIChzMyBePSBiW2kgKyAzXSk7XG5cdCAgICAgICAgICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgczAsIHMxLCBzMiwgczMpKTtcblx0ICAgICAgICAgICAgICAgIChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHBja3M1KSB7XG5cdCAgICAgICAgICAgICAgICBjb25zdCB0bXAzMiA9IHBhZFBDS1MocGxhaW50ZXh0LnN1YmFycmF5KGkgKiA0KSk7XG5cdCAgICAgICAgICAgICAgICAoczAgXj0gdG1wMzJbMF0pLCAoczEgXj0gdG1wMzJbMV0pLCAoczIgXj0gdG1wMzJbMl0pLCAoczMgXj0gdG1wMzJbM10pO1xuXHQgICAgICAgICAgICAgICAgKHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIHMwLCBzMSwgczIsIHMzKSk7XG5cdCAgICAgICAgICAgICAgICAob1tpKytdID0gczApLCAob1tpKytdID0gczEpLCAob1tpKytdID0gczIpLCAob1tpKytdID0gczMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmNsZWFuKSguLi50b0NsZWFuKTtcblx0ICAgICAgICAgICAgcmV0dXJuIF9vdXQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBkZWNyeXB0KGNpcGhlcnRleHQsIGRzdCkge1xuXHQgICAgICAgICAgICB2YWxpZGF0ZUJsb2NrRGVjcnlwdChjaXBoZXJ0ZXh0KTtcblx0ICAgICAgICAgICAgY29uc3QgeGsgPSBleHBhbmRLZXlEZWNMRShrZXkpO1xuXHQgICAgICAgICAgICBsZXQgX2l2ID0gaXY7XG5cdCAgICAgICAgICAgIGNvbnN0IHRvQ2xlYW4gPSBbeGtdO1xuXHQgICAgICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmlzQWxpZ25lZDMyKShfaXYpKVxuXHQgICAgICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChfaXYgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKF9pdikpKTtcblx0ICAgICAgICAgICAgY29uc3QgbjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShfaXYpO1xuXHQgICAgICAgICAgICBkc3QgPSAoMCwgdXRpbHNfanNfMS5nZXRPdXRwdXQpKGNpcGhlcnRleHQubGVuZ3RoLCBkc3QpO1xuXHQgICAgICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmlzQWxpZ25lZDMyKShjaXBoZXJ0ZXh0KSlcblx0ICAgICAgICAgICAgICAgIHRvQ2xlYW4ucHVzaCgoY2lwaGVydGV4dCA9ICgwLCB1dGlsc19qc18xLmNvcHlCeXRlcykoY2lwaGVydGV4dCkpKTtcblx0ICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuY29tcGxleE92ZXJsYXBCeXRlcykoY2lwaGVydGV4dCwgZHN0KTtcblx0ICAgICAgICAgICAgY29uc3QgYiA9ICgwLCB1dGlsc19qc18xLnUzMikoY2lwaGVydGV4dCk7XG5cdCAgICAgICAgICAgIGNvbnN0IG8gPSAoMCwgdXRpbHNfanNfMS51MzIpKGRzdCk7XG5cdCAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuXHQgICAgICAgICAgICBsZXQgczAgPSBuMzJbMF0sIHMxID0gbjMyWzFdLCBzMiA9IG4zMlsyXSwgczMgPSBuMzJbM107XG5cdCAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpICsgNCA8PSBiLmxlbmd0aDspIHtcblx0ICAgICAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuXHQgICAgICAgICAgICAgICAgY29uc3QgcHMwID0gczAsIHBzMSA9IHMxLCBwczIgPSBzMiwgcHMzID0gczM7XG5cdCAgICAgICAgICAgICAgICAoczAgPSBiW2kgKyAwXSksIChzMSA9IGJbaSArIDFdKSwgKHMyID0gYltpICsgMl0pLCAoczMgPSBiW2kgKyAzXSk7XG5cdCAgICAgICAgICAgICAgICBjb25zdCB7IHMwOiBvMCwgczE6IG8xLCBzMjogbzIsIHMzOiBvMyB9ID0gZGVjcnlwdCh4aywgczAsIHMxLCBzMiwgczMpO1xuXHQgICAgICAgICAgICAgICAgKG9baSsrXSA9IG8wIF4gcHMwKSwgKG9baSsrXSA9IG8xIF4gcHMxKSwgKG9baSsrXSA9IG8yIF4gcHMyKSwgKG9baSsrXSA9IG8zIF4gcHMzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoLi4udG9DbGVhbik7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVBDS1MoZHN0LCBwY2tzNSk7XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cdH0pO1xuXHQvKipcblx0ICogQ0ZCOiBDaXBoZXIgRmVlZGJhY2sgTW9kZS4gVGhlIGlucHV0IGZvciB0aGUgYmxvY2sgY2lwaGVyIGlzIHRoZSBwcmV2aW91cyBjaXBoZXIgb3V0cHV0LlxuXHQgKiBVbmF1dGhlbnRpY2F0ZWQ6IG5lZWRzIE1BQy5cblx0ICovXG5cdGFlcy5jZmIgPSAoMCwgdXRpbHNfanNfMS53cmFwQ2lwaGVyKSh7IGJsb2NrU2l6ZTogMTYsIG5vbmNlTGVuZ3RoOiAxNiB9LCBmdW5jdGlvbiBhZXNjZmIoa2V5LCBpdikge1xuXHQgICAgZnVuY3Rpb24gcHJvY2Vzc0NmYihzcmMsIGlzRW5jcnlwdCwgZHN0KSB7XG5cdCAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKHNyYyk7XG5cdCAgICAgICAgY29uc3Qgc3JjTGVuID0gc3JjLmxlbmd0aDtcblx0ICAgICAgICBkc3QgPSAoMCwgdXRpbHNfanNfMS5nZXRPdXRwdXQpKHNyY0xlbiwgZHN0KTtcblx0ICAgICAgICBpZiAoKDAsIHV0aWxzX2pzXzEub3ZlcmxhcEJ5dGVzKShzcmMsIGRzdCkpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3ZlcmxhcHBpbmcgc3JjIGFuZCBkc3Qgbm90IHN1cHBvcnRlZC4nKTtcblx0ICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG5cdCAgICAgICAgbGV0IF9pdiA9IGl2O1xuXHQgICAgICAgIGNvbnN0IHRvQ2xlYW4gPSBbeGtdO1xuXHQgICAgICAgIGlmICghKDAsIHV0aWxzX2pzXzEuaXNBbGlnbmVkMzIpKF9pdikpXG5cdCAgICAgICAgICAgIHRvQ2xlYW4ucHVzaCgoX2l2ID0gKDAsIHV0aWxzX2pzXzEuY29weUJ5dGVzKShfaXYpKSk7XG5cdCAgICAgICAgaWYgKCEoMCwgdXRpbHNfanNfMS5pc0FsaWduZWQzMikoc3JjKSlcblx0ICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChzcmMgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKHNyYykpKTtcblx0ICAgICAgICBjb25zdCBzcmMzMiA9ICgwLCB1dGlsc19qc18xLnUzMikoc3JjKTtcblx0ICAgICAgICBjb25zdCBkc3QzMiA9ICgwLCB1dGlsc19qc18xLnUzMikoZHN0KTtcblx0ICAgICAgICBjb25zdCBuZXh0MzIgPSBpc0VuY3J5cHQgPyBkc3QzMiA6IHNyYzMyO1xuXHQgICAgICAgIGNvbnN0IG4zMiA9ICgwLCB1dGlsc19qc18xLnUzMikoX2l2KTtcblx0ICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcblx0ICAgICAgICBsZXQgczAgPSBuMzJbMF0sIHMxID0gbjMyWzFdLCBzMiA9IG4zMlsyXSwgczMgPSBuMzJbM107XG5cdCAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgKyA0IDw9IHNyYzMyLmxlbmd0aDspIHtcblx0ICAgICAgICAgICAgY29uc3QgeyBzMDogZTAsIHMxOiBlMSwgczI6IGUyLCBzMzogZTMgfSA9IGVuY3J5cHQoeGssIHMwLCBzMSwgczIsIHMzKTtcblx0ICAgICAgICAgICAgZHN0MzJbaSArIDBdID0gc3JjMzJbaSArIDBdIF4gZTA7XG5cdCAgICAgICAgICAgIGRzdDMyW2kgKyAxXSA9IHNyYzMyW2kgKyAxXSBeIGUxO1xuXHQgICAgICAgICAgICBkc3QzMltpICsgMl0gPSBzcmMzMltpICsgMl0gXiBlMjtcblx0ICAgICAgICAgICAgZHN0MzJbaSArIDNdID0gc3JjMzJbaSArIDNdIF4gZTM7XG5cdCAgICAgICAgICAgIChzMCA9IG5leHQzMltpKytdKSwgKHMxID0gbmV4dDMyW2krK10pLCAoczIgPSBuZXh0MzJbaSsrXSksIChzMyA9IG5leHQzMltpKytdKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gbGVmdG92ZXJzIChsZXNzIHRoYW4gYmxvY2spXG5cdCAgICAgICAgY29uc3Qgc3RhcnQgPSBCTE9DS19TSVpFICogTWF0aC5mbG9vcihzcmMzMi5sZW5ndGggLyBCTE9DS19TSVpFMzIpO1xuXHQgICAgICAgIGlmIChzdGFydCA8IHNyY0xlbikge1xuXHQgICAgICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgczAsIHMxLCBzMiwgczMpKTtcblx0ICAgICAgICAgICAgY29uc3QgYnVmID0gKDAsIHV0aWxzX2pzXzEudTgpKG5ldyBVaW50MzJBcnJheShbczAsIHMxLCBzMiwgczNdKSk7XG5cdCAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydCwgcG9zID0gMDsgaSA8IHNyY0xlbjsgaSsrLCBwb3MrKylcblx0ICAgICAgICAgICAgICAgIGRzdFtpXSA9IHNyY1tpXSBeIGJ1Zltwb3NdO1xuXHQgICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoYnVmKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKC4uLnRvQ2xlYW4pO1xuXHQgICAgICAgIHJldHVybiBkc3Q7XG5cdCAgICB9XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGVuY3J5cHQ6IChwbGFpbnRleHQsIGRzdCkgPT4gcHJvY2Vzc0NmYihwbGFpbnRleHQsIHRydWUsIGRzdCksXG5cdCAgICAgICAgZGVjcnlwdDogKGNpcGhlcnRleHQsIGRzdCkgPT4gcHJvY2Vzc0NmYihjaXBoZXJ0ZXh0LCBmYWxzZSwgZHN0KSxcblx0ICAgIH07XG5cdH0pO1xuXHQvLyBUT0RPOiBtZXJnZSB3aXRoIGNoYWNoYSwgaG93ZXZlciBnY20gaGFzIGJpdExlbiB3aGlsZSBjaGFjaGEgaGFzIGJ5dGVMZW5cblx0ZnVuY3Rpb24gY29tcHV0ZVRhZyhmbiwgaXNMRSwga2V5LCBkYXRhLCBBQUQpIHtcblx0ICAgIGNvbnN0IGFhZExlbmd0aCA9IEFBRCA9PSBudWxsID8gMCA6IEFBRC5sZW5ndGg7XG5cdCAgICBjb25zdCBoID0gZm4uY3JlYXRlKGtleSwgZGF0YS5sZW5ndGggKyBhYWRMZW5ndGgpO1xuXHQgICAgaWYgKEFBRClcblx0ICAgICAgICBoLnVwZGF0ZShBQUQpO1xuXHQgICAgaC51cGRhdGUoZGF0YSk7XG5cdCAgICBjb25zdCBudW0gPSBuZXcgVWludDhBcnJheSgxNik7XG5cdCAgICBjb25zdCB2aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykobnVtKTtcblx0ICAgIGlmIChBQUQpXG5cdCAgICAgICAgKDAsIHV0aWxzX2pzXzEuc2V0QmlnVWludDY0KSh2aWV3LCAwLCBCaWdJbnQoYWFkTGVuZ3RoICogOCksIGlzTEUpO1xuXHQgICAgKDAsIHV0aWxzX2pzXzEuc2V0QmlnVWludDY0KSh2aWV3LCA4LCBCaWdJbnQoZGF0YS5sZW5ndGggKiA4KSwgaXNMRSk7XG5cdCAgICBoLnVwZGF0ZShudW0pO1xuXHQgICAgY29uc3QgcmVzID0gaC5kaWdlc3QoKTtcblx0ICAgICgwLCB1dGlsc19qc18xLmNsZWFuKShudW0pO1xuXHQgICAgcmV0dXJuIHJlcztcblx0fVxuXHQvKipcblx0ICogR0NNOiBHYWxvaXMvQ291bnRlciBNb2RlLlxuXHQgKiBNb2Rlcm4sIHBhcmFsbGVsIHZlcnNpb24gb2YgQ1RSLCB3aXRoIE1BQy5cblx0ICogQmUgY2FyZWZ1bDogTUFDcyBjYW4gYmUgZm9yZ2VkLlxuXHQgKiBVbnNhZmUgdG8gdXNlIHJhbmRvbSBub25jZXMgdW5kZXIgdGhlIHNhbWUga2V5LCBkdWUgdG8gY29sbGlzaW9uIGNoYW5jZS5cblx0ICogQXMgZm9yIG5vbmNlIHNpemUsIHByZWZlciAxMi1ieXRlLCBpbnN0ZWFkIG9mIDgtYnl0ZS5cblx0ICovXG5cdGFlcy5nY20gPSAoMCwgdXRpbHNfanNfMS53cmFwQ2lwaGVyKSh7IGJsb2NrU2l6ZTogMTYsIG5vbmNlTGVuZ3RoOiAxMiwgdGFnTGVuZ3RoOiAxNiwgdmFyU2l6ZU5vbmNlOiB0cnVlIH0sIGZ1bmN0aW9uIGFlc2djbShrZXksIG5vbmNlLCBBQUQpIHtcblx0ICAgIC8vIE5JU1QgODAwLTM4ZCBkb2Vzbid0IGVuZm9yY2UgbWluaW11bSBub25jZSBsZW5ndGguXG5cdCAgICAvLyBXZSBlbmZvcmNlIDggYnl0ZXMgZm9yIGNvbXBhdCB3aXRoIG9wZW5zc2wuXG5cdCAgICAvLyAxMiBieXRlcyBhcmUgcmVjb21tZW5kZWQuIE1vcmUgdGhhbiAxMiBieXRlcyB3b3VsZCBiZSBjb252ZXJ0ZWQgaW50byAxMi5cblx0ICAgIGlmIChub25jZS5sZW5ndGggPCA4KVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignYWVzL2djbTogaW52YWxpZCBub25jZSBsZW5ndGgnKTtcblx0ICAgIGNvbnN0IHRhZ0xlbmd0aCA9IDE2O1xuXHQgICAgZnVuY3Rpb24gX2NvbXB1dGVUYWcoYXV0aEtleSwgdGFnTWFzaywgZGF0YSkge1xuXHQgICAgICAgIGNvbnN0IHRhZyA9IGNvbXB1dGVUYWcoX3BvbHl2YWxfanNfMS5naGFzaCwgZmFsc2UsIGF1dGhLZXksIGRhdGEsIEFBRCk7XG5cdCAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWdNYXNrLmxlbmd0aDsgaSsrKVxuXHQgICAgICAgICAgICB0YWdbaV0gXj0gdGFnTWFza1tpXTtcblx0ICAgICAgICByZXR1cm4gdGFnO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZGVyaXZlS2V5cygpIHtcblx0ICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG5cdCAgICAgICAgY29uc3QgYXV0aEtleSA9IEVNUFRZX0JMT0NLLnNsaWNlKCk7XG5cdCAgICAgICAgY29uc3QgY291bnRlciA9IEVNUFRZX0JMT0NLLnNsaWNlKCk7XG5cdCAgICAgICAgY3RyMzIoeGssIGZhbHNlLCBjb3VudGVyLCBjb3VudGVyLCBhdXRoS2V5KTtcblx0ICAgICAgICAvLyBOSVNUIDgwMC0zOGQsIHBhZ2UgMTU6IGRpZmZlcmVudCBiZWhhdmlvciBmb3IgOTYtYml0IGFuZCBub24tOTYtYml0IG5vbmNlc1xuXHQgICAgICAgIGlmIChub25jZS5sZW5ndGggPT09IDEyKSB7XG5cdCAgICAgICAgICAgIGNvdW50ZXIuc2V0KG5vbmNlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGNvbnN0IG5vbmNlTGVuID0gRU1QVFlfQkxPQ0suc2xpY2UoKTtcblx0ICAgICAgICAgICAgY29uc3QgdmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKG5vbmNlTGVuKTtcblx0ICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuc2V0QmlnVWludDY0KSh2aWV3LCA4LCBCaWdJbnQobm9uY2UubGVuZ3RoICogOCksIGZhbHNlKTtcblx0ICAgICAgICAgICAgLy8gZ2hhc2gobm9uY2UgfHwgdTY0YmUoMCkgfHwgdTY0YmUobm9uY2VMZW4qOCkpXG5cdCAgICAgICAgICAgIGNvbnN0IGcgPSBfcG9seXZhbF9qc18xLmdoYXNoLmNyZWF0ZShhdXRoS2V5KS51cGRhdGUobm9uY2UpLnVwZGF0ZShub25jZUxlbik7XG5cdCAgICAgICAgICAgIGcuZGlnZXN0SW50byhjb3VudGVyKTsgLy8gZGlnZXN0SW50byBkb2Vzbid0IHRyaWdnZXIgJy5kZXN0cm95J1xuXHQgICAgICAgICAgICBnLmRlc3Ryb3koKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY29uc3QgdGFnTWFzayA9IGN0cjMyKHhrLCBmYWxzZSwgY291bnRlciwgRU1QVFlfQkxPQ0spO1xuXHQgICAgICAgIHJldHVybiB7IHhrLCBhdXRoS2V5LCBjb3VudGVyLCB0YWdNYXNrIH07XG5cdCAgICB9XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG5cdCAgICAgICAgICAgIGNvbnN0IHsgeGssIGF1dGhLZXksIGNvdW50ZXIsIHRhZ01hc2sgfSA9IGRlcml2ZUtleXMoKTtcblx0ICAgICAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCArIHRhZ0xlbmd0aCk7XG5cdCAgICAgICAgICAgIGNvbnN0IHRvQ2xlYW4gPSBbeGssIGF1dGhLZXksIGNvdW50ZXIsIHRhZ01hc2tdO1xuXHQgICAgICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmlzQWxpZ25lZDMyKShwbGFpbnRleHQpKVxuXHQgICAgICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChwbGFpbnRleHQgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKHBsYWludGV4dCkpKTtcblx0ICAgICAgICAgICAgY3RyMzIoeGssIGZhbHNlLCBjb3VudGVyLCBwbGFpbnRleHQsIG91dC5zdWJhcnJheSgwLCBwbGFpbnRleHQubGVuZ3RoKSk7XG5cdCAgICAgICAgICAgIGNvbnN0IHRhZyA9IF9jb21wdXRlVGFnKGF1dGhLZXksIHRhZ01hc2ssIG91dC5zdWJhcnJheSgwLCBvdXQubGVuZ3RoIC0gdGFnTGVuZ3RoKSk7XG5cdCAgICAgICAgICAgIHRvQ2xlYW4ucHVzaCh0YWcpO1xuXHQgICAgICAgICAgICBvdXQuc2V0KHRhZywgcGxhaW50ZXh0Lmxlbmd0aCk7XG5cdCAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmNsZWFuKSguLi50b0NsZWFuKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG91dDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuXHQgICAgICAgICAgICBjb25zdCB7IHhrLCBhdXRoS2V5LCBjb3VudGVyLCB0YWdNYXNrIH0gPSBkZXJpdmVLZXlzKCk7XG5cdCAgICAgICAgICAgIGNvbnN0IHRvQ2xlYW4gPSBbeGssIGF1dGhLZXksIHRhZ01hc2ssIGNvdW50ZXJdO1xuXHQgICAgICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmlzQWxpZ25lZDMyKShjaXBoZXJ0ZXh0KSlcblx0ICAgICAgICAgICAgICAgIHRvQ2xlYW4ucHVzaCgoY2lwaGVydGV4dCA9ICgwLCB1dGlsc19qc18xLmNvcHlCeXRlcykoY2lwaGVydGV4dCkpKTtcblx0ICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgLXRhZ0xlbmd0aCk7XG5cdCAgICAgICAgICAgIGNvbnN0IHBhc3NlZFRhZyA9IGNpcGhlcnRleHQuc3ViYXJyYXkoLXRhZ0xlbmd0aCk7XG5cdCAgICAgICAgICAgIGNvbnN0IHRhZyA9IF9jb21wdXRlVGFnKGF1dGhLZXksIHRhZ01hc2ssIGRhdGEpO1xuXHQgICAgICAgICAgICB0b0NsZWFuLnB1c2godGFnKTtcblx0ICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfanNfMS5lcXVhbEJ5dGVzKSh0YWcsIHBhc3NlZFRhZykpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Flcy9nY206IGludmFsaWQgZ2hhc2ggdGFnJyk7XG5cdCAgICAgICAgICAgIGNvbnN0IG91dCA9IGN0cjMyKHhrLCBmYWxzZSwgY291bnRlciwgZGF0YSk7XG5cdCAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmNsZWFuKSguLi50b0NsZWFuKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG91dDtcblx0ICAgICAgICB9LFxuXHQgICAgfTtcblx0fSk7XG5cdGNvbnN0IGxpbWl0ID0gKG5hbWUsIG1pbiwgbWF4KSA9PiAodmFsdWUpID0+IHtcblx0ICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpIHx8IG1pbiA+IHZhbHVlIHx8IHZhbHVlID4gbWF4KSB7XG5cdCAgICAgICAgY29uc3QgbWlubWF4ID0gJ1snICsgbWluICsgJy4uJyArIG1heCArICddJztcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJycgKyBuYW1lICsgJzogZXhwZWN0ZWQgdmFsdWUgaW4gcmFuZ2UgJyArIG1pbm1heCArICcsIGdvdCAnICsgdmFsdWUpO1xuXHQgICAgfVxuXHR9O1xuXHQvKipcblx0ICogQUVTLUdDTS1TSVY6IGNsYXNzaWMgQUVTLUdDTSB3aXRoIG5vbmNlLW1pc3VzZSByZXNpc3RhbmNlLlxuXHQgKiBHdWFyYW50ZWVzIHRoYXQsIHdoZW4gYSBub25jZSBpcyByZXBlYXRlZCwgdGhlIG9ubHkgc2VjdXJpdHkgbG9zcyBpcyB0aGF0IGlkZW50aWNhbFxuXHQgKiBwbGFpbnRleHRzIHdpbGwgcHJvZHVjZSBpZGVudGljYWwgY2lwaGVydGV4dHMuXG5cdCAqIFJGQyA4NDUyLCBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzg0NTJcblx0ICovXG5cdGFlcy5zaXYgPSAoMCwgdXRpbHNfanNfMS53cmFwQ2lwaGVyKSh7IGJsb2NrU2l6ZTogMTYsIG5vbmNlTGVuZ3RoOiAxMiwgdGFnTGVuZ3RoOiAxNiwgdmFyU2l6ZU5vbmNlOiB0cnVlIH0sIGZ1bmN0aW9uIGFlc3NpdihrZXksIG5vbmNlLCBBQUQpIHtcblx0ICAgIGNvbnN0IHRhZ0xlbmd0aCA9IDE2O1xuXHQgICAgLy8gRnJvbSBSRkMgODQ1MjogU2VjdGlvbiA2XG5cdCAgICBjb25zdCBBQURfTElNSVQgPSBsaW1pdCgnQUFEJywgMCwgMiAqKiAzNik7XG5cdCAgICBjb25zdCBQTEFJTl9MSU1JVCA9IGxpbWl0KCdwbGFpbnRleHQnLCAwLCAyICoqIDM2KTtcblx0ICAgIGNvbnN0IE5PTkNFX0xJTUlUID0gbGltaXQoJ25vbmNlJywgMTIsIDEyKTtcblx0ICAgIGNvbnN0IENJUEhFUl9MSU1JVCA9IGxpbWl0KCdjaXBoZXJ0ZXh0JywgMTYsIDIgKiogMzYgKyAxNik7XG5cdCAgICAoMCwgX2Fzc2VydF9qc18xLmFieXRlcykoa2V5LCAxNiwgMjQsIDMyKTtcblx0ICAgIE5PTkNFX0xJTUlUKG5vbmNlLmxlbmd0aCk7XG5cdCAgICBpZiAoQUFEICE9PSB1bmRlZmluZWQpXG5cdCAgICAgICAgQUFEX0xJTUlUKEFBRC5sZW5ndGgpO1xuXHQgICAgZnVuY3Rpb24gZGVyaXZlS2V5cygpIHtcblx0ICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG5cdCAgICAgICAgY29uc3QgZW5jS2V5ID0gbmV3IFVpbnQ4QXJyYXkoa2V5Lmxlbmd0aCk7XG5cdCAgICAgICAgY29uc3QgYXV0aEtleSA9IG5ldyBVaW50OEFycmF5KDE2KTtcblx0ICAgICAgICBjb25zdCB0b0NsZWFuID0gW3hrLCBlbmNLZXldO1xuXHQgICAgICAgIGxldCBfbm9uY2UgPSBub25jZTtcblx0ICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmlzQWxpZ25lZDMyKShfbm9uY2UpKVxuXHQgICAgICAgICAgICB0b0NsZWFuLnB1c2goKF9ub25jZSA9ICgwLCB1dGlsc19qc18xLmNvcHlCeXRlcykoX25vbmNlKSkpO1xuXHQgICAgICAgIGNvbnN0IG4zMiA9ICgwLCB1dGlsc19qc18xLnUzMikoX25vbmNlKTtcblx0ICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcblx0ICAgICAgICBsZXQgczAgPSAwLCBzMSA9IG4zMlswXSwgczIgPSBuMzJbMV0sIHMzID0gbjMyWzJdO1xuXHQgICAgICAgIGxldCBjb3VudGVyID0gMDtcblx0ICAgICAgICBmb3IgKGNvbnN0IGRlcml2ZWRLZXkgb2YgW2F1dGhLZXksIGVuY0tleV0ubWFwKHV0aWxzX2pzXzEudTMyKSkge1xuXHQgICAgICAgICAgICBjb25zdCBkMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGRlcml2ZWRLZXkpO1xuXHQgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGQzMi5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgLy8gYWVzKHUzMmxlKDApIHx8IG5vbmNlKVs6OF0gfHwgYWVzKHUzMmxlKDEpIHx8IG5vbmNlKVs6OF0gLi4uXG5cdCAgICAgICAgICAgICAgICBjb25zdCB7IHMwOiBvMCwgczE6IG8xIH0gPSBlbmNyeXB0KHhrLCBzMCwgczEsIHMyLCBzMyk7XG5cdCAgICAgICAgICAgICAgICBkMzJbaSArIDBdID0gbzA7XG5cdCAgICAgICAgICAgICAgICBkMzJbaSArIDFdID0gbzE7XG5cdCAgICAgICAgICAgICAgICBzMCA9ICsrY291bnRlcjsgLy8gaW5jcmVtZW50IGNvdW50ZXIgaW5zaWRlIHN0YXRlXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgY29uc3QgcmVzID0geyBhdXRoS2V5LCBlbmNLZXk6IGV4cGFuZEtleUxFKGVuY0tleSkgfTtcblx0ICAgICAgICAvLyBDbGVhbnVwXG5cdCAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKC4uLnRvQ2xlYW4pO1xuXHQgICAgICAgIHJldHVybiByZXM7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBfY29tcHV0ZVRhZyhlbmNLZXksIGF1dGhLZXksIGRhdGEpIHtcblx0ICAgICAgICBjb25zdCB0YWcgPSBjb21wdXRlVGFnKF9wb2x5dmFsX2pzXzEucG9seXZhbCwgdHJ1ZSwgYXV0aEtleSwgZGF0YSwgQUFEKTtcblx0ICAgICAgICAvLyBDb21wdXRlIHRoZSBleHBlY3RlZCB0YWcgYnkgWE9SaW5nIFNfcyBhbmQgdGhlIG5vbmNlLCBjbGVhcmluZyB0aGVcblx0ICAgICAgICAvLyBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCBieXRlIGFuZCBlbmNyeXB0aW5nIHdpdGggdGhlXG5cdCAgICAgICAgLy8gbWVzc2FnZS1lbmNyeXB0aW9uIGtleS5cblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspXG5cdCAgICAgICAgICAgIHRhZ1tpXSBePSBub25jZVtpXTtcblx0ICAgICAgICB0YWdbMTVdICY9IDB4N2Y7IC8vIENsZWFyIHRoZSBoaWdoZXN0IGJpdFxuXHQgICAgICAgIC8vIGVuY3J5cHQgdGFnIGFzIGJsb2NrXG5cdCAgICAgICAgY29uc3QgdDMyID0gKDAsIHV0aWxzX2pzXzEudTMyKSh0YWcpO1xuXHQgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuXHQgICAgICAgIGxldCBzMCA9IHQzMlswXSwgczEgPSB0MzJbMV0sIHMyID0gdDMyWzJdLCBzMyA9IHQzMlszXTtcblx0ICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdChlbmNLZXksIHMwLCBzMSwgczIsIHMzKSk7XG5cdCAgICAgICAgKHQzMlswXSA9IHMwKSwgKHQzMlsxXSA9IHMxKSwgKHQzMlsyXSA9IHMyKSwgKHQzMlszXSA9IHMzKTtcblx0ICAgICAgICByZXR1cm4gdGFnO1xuXHQgICAgfVxuXHQgICAgLy8gYWN0dWFsIGRlY3J5cHQvZW5jcnlwdCBvZiBtZXNzYWdlLlxuXHQgICAgZnVuY3Rpb24gcHJvY2Vzc1NpdihlbmNLZXksIHRhZywgaW5wdXQpIHtcblx0ICAgICAgICBsZXQgYmxvY2sgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKHRhZyk7XG5cdCAgICAgICAgYmxvY2tbMTVdIHw9IDB4ODA7IC8vIEZvcmNlIGhpZ2hlc3QgYml0XG5cdCAgICAgICAgY29uc3QgcmVzID0gY3RyMzIoZW5jS2V5LCB0cnVlLCBibG9jaywgaW5wdXQpO1xuXHQgICAgICAgIC8vIENsZWFudXBcblx0ICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoYmxvY2spO1xuXHQgICAgICAgIHJldHVybiByZXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG5cdCAgICAgICAgICAgIFBMQUlOX0xJTUlUKHBsYWludGV4dC5sZW5ndGgpO1xuXHQgICAgICAgICAgICBjb25zdCB7IGVuY0tleSwgYXV0aEtleSB9ID0gZGVyaXZlS2V5cygpO1xuXHQgICAgICAgICAgICBjb25zdCB0YWcgPSBfY29tcHV0ZVRhZyhlbmNLZXksIGF1dGhLZXksIHBsYWludGV4dCk7XG5cdCAgICAgICAgICAgIGNvbnN0IHRvQ2xlYW4gPSBbZW5jS2V5LCBhdXRoS2V5LCB0YWddO1xuXHQgICAgICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmlzQWxpZ25lZDMyKShwbGFpbnRleHQpKVxuXHQgICAgICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChwbGFpbnRleHQgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKHBsYWludGV4dCkpKTtcblx0ICAgICAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCArIHRhZ0xlbmd0aCk7XG5cdCAgICAgICAgICAgIG91dC5zZXQodGFnLCBwbGFpbnRleHQubGVuZ3RoKTtcblx0ICAgICAgICAgICAgb3V0LnNldChwcm9jZXNzU2l2KGVuY0tleSwgdGFnLCBwbGFpbnRleHQpKTtcblx0ICAgICAgICAgICAgLy8gQ2xlYW51cFxuXHQgICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoLi4udG9DbGVhbik7XG5cdCAgICAgICAgICAgIHJldHVybiBvdXQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBkZWNyeXB0KGNpcGhlcnRleHQpIHtcblx0ICAgICAgICAgICAgQ0lQSEVSX0xJTUlUKGNpcGhlcnRleHQubGVuZ3RoKTtcblx0ICAgICAgICAgICAgY29uc3QgdGFnID0gY2lwaGVydGV4dC5zdWJhcnJheSgtdGFnTGVuZ3RoKTtcblx0ICAgICAgICAgICAgY29uc3QgeyBlbmNLZXksIGF1dGhLZXkgfSA9IGRlcml2ZUtleXMoKTtcblx0ICAgICAgICAgICAgY29uc3QgdG9DbGVhbiA9IFtlbmNLZXksIGF1dGhLZXldO1xuXHQgICAgICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmlzQWxpZ25lZDMyKShjaXBoZXJ0ZXh0KSlcblx0ICAgICAgICAgICAgICAgIHRvQ2xlYW4ucHVzaCgoY2lwaGVydGV4dCA9ICgwLCB1dGlsc19qc18xLmNvcHlCeXRlcykoY2lwaGVydGV4dCkpKTtcblx0ICAgICAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0gcHJvY2Vzc1NpdihlbmNLZXksIHRhZywgY2lwaGVydGV4dC5zdWJhcnJheSgwLCAtdGFnTGVuZ3RoKSk7XG5cdCAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVGFnID0gX2NvbXB1dGVUYWcoZW5jS2V5LCBhdXRoS2V5LCBwbGFpbnRleHQpO1xuXHQgICAgICAgICAgICB0b0NsZWFuLnB1c2goZXhwZWN0ZWRUYWcpO1xuXHQgICAgICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmVxdWFsQnl0ZXMpKHRhZywgZXhwZWN0ZWRUYWcpKSB7XG5cdCAgICAgICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoLi4udG9DbGVhbik7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9seXZhbCB0YWcnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBDbGVhbnVwXG5cdCAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmNsZWFuKSguLi50b0NsZWFuKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgICB9LFxuXHQgICAgfTtcblx0fSk7XG5cdGZ1bmN0aW9uIGlzQnl0ZXMzMihhKSB7XG5cdCAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQzMkFycmF5JykpO1xuXHR9XG5cdGZ1bmN0aW9uIGVuY3J5cHRCbG9jayh4aywgYmxvY2spIHtcblx0ICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJ5dGVzKShibG9jaywgMTYpO1xuXHQgICAgaWYgKCFpc0J5dGVzMzIoeGspKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignX2VuY3J5cHRCbG9jayBhY2NlcHRzIHJlc3VsdCBvZiBleHBhbmRLZXlMRScpO1xuXHQgICAgY29uc3QgYjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShibG9jayk7XG5cdCAgICBsZXQgeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgYjMyWzBdLCBiMzJbMV0sIGIzMlsyXSwgYjMyWzNdKTtcblx0ICAgIChiMzJbMF0gPSBzMCksIChiMzJbMV0gPSBzMSksIChiMzJbMl0gPSBzMiksIChiMzJbM10gPSBzMyk7XG5cdCAgICByZXR1cm4gYmxvY2s7XG5cdH1cblx0ZnVuY3Rpb24gZGVjcnlwdEJsb2NrKHhrLCBibG9jaykge1xuXHQgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKGJsb2NrLCAxNik7XG5cdCAgICBpZiAoIWlzQnl0ZXMzMih4aykpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfZGVjcnlwdEJsb2NrIGFjY2VwdHMgcmVzdWx0IG9mIGV4cGFuZEtleUxFJyk7XG5cdCAgICBjb25zdCBiMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGJsb2NrKTtcblx0ICAgIGxldCB7IHMwLCBzMSwgczIsIHMzIH0gPSBkZWNyeXB0KHhrLCBiMzJbMF0sIGIzMlsxXSwgYjMyWzJdLCBiMzJbM10pO1xuXHQgICAgKGIzMlswXSA9IHMwKSwgKGIzMlsxXSA9IHMxKSwgKGIzMlsyXSA9IHMyKSwgKGIzMlszXSA9IHMzKTtcblx0ICAgIHJldHVybiBibG9jaztcblx0fVxuXHQvKipcblx0ICogQUVTLVcgKGJhc2UgZm9yIEFFU0tXL0FFU0tXUCkuXG5cdCAqIFNwZWNzOiBbU1A4MDAtMzhGXShodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvU3BlY2lhbFB1YmxpY2F0aW9ucy9OSVNULlNQLjgwMC0zOEYucGRmKSxcblx0ICogW1JGQyAzMzk0XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9yZmMzMzk0LyksXG5cdCAqIFtSRkMgNTY0OV0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvcmZjNTY0OS8pLlxuXHQgKi9cblx0Y29uc3QgQUVTVyA9IHtcblx0ICAgIC8qXG5cdCAgICBIaWdoLWxldmVsIHBzZXVkb2NvZGU6XG5cdCAgICBgYGBcblx0ICAgIEE6IHU2NCA9IElWXG5cdCAgICBvdXQgPSBbXVxuXHQgICAgZm9yIChsZXQgaT0wLCBjdHIgPSAwOyBpPDY7IGkrKykge1xuXHQgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcyhwbGFpbnRleHQsIDgpKSB7XG5cdCAgICAgICAgQSBePSBzd2FwRW5kaWFuZXNzKGN0cisrKVxuXHQgICAgICAgIFtBLCByZXNdID0gY2h1bmtzKGVuY3J5cHQoQSB8fCBjaHVuayksIDgpO1xuXHQgICAgICAgIG91dCB8fD0gcmVzXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIG91dCA9IEEgfHwgb3V0XG5cdCAgICBgYGBcblx0ICAgIERlY3J5cHQgaXMgdGhlIHNhbWUsIGJ1dCByZXZlcnNlZC5cblx0ICAgICovXG5cdCAgICBlbmNyeXB0KGtlaywgb3V0KSB7XG5cdCAgICAgICAgLy8gU2l6ZSBpcyBsaW1pdGVkIHRvIDRHQiwgb3RoZXJ3aXNlIGN0ciB3aWxsIG92ZXJmbG93IGFuZCB3ZSdsbCBuZWVkIHRvIHN3aXRjaCB0byBiaWdpbnRzLlxuXHQgICAgICAgIC8vIElmIHlvdSBuZWVkIGl0IGxhcmdlciwgb3BlbiBhbiBpc3N1ZS5cblx0ICAgICAgICBpZiAob3V0Lmxlbmd0aCA+PSAyICoqIDMyKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BsYWludGV4dCBzaG91bGQgYmUgbGVzcyB0aGFuIDRnYicpO1xuXHQgICAgICAgIGNvbnN0IHhrID0gZXhwYW5kS2V5TEUoa2VrKTtcblx0ICAgICAgICBpZiAob3V0Lmxlbmd0aCA9PT0gMTYpXG5cdCAgICAgICAgICAgIGVuY3J5cHRCbG9jayh4aywgb3V0KTtcblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgY29uc3QgbzMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShvdXQpO1xuXHQgICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcblx0ICAgICAgICAgICAgbGV0IGEwID0gbzMyWzBdLCBhMSA9IG8zMlsxXTsgLy8gQVxuXHQgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgY3RyID0gMTsgaiA8IDY7IGorKykge1xuXHQgICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gMjsgcG9zIDwgbzMyLmxlbmd0aDsgcG9zICs9IDIsIGN0cisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgYTAsIGExLCBvMzJbcG9zXSwgbzMyW3BvcyArIDFdKTtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBID0gTVNCKDY0LCBCKSBeIHQgd2hlcmUgdCA9IChuKmopK2lcblx0ICAgICAgICAgICAgICAgICAgICAoYTAgPSBzMCksIChhMSA9IHMxIF4gYnl0ZVN3YXAoY3RyKSksIChvMzJbcG9zXSA9IHMyKSwgKG8zMltwb3MgKyAxXSA9IHMzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAobzMyWzBdID0gYTApLCAobzMyWzFdID0gYTEpOyAvLyBvdXQgPSBBIHx8IG91dFxuXHQgICAgICAgIH1cblx0ICAgICAgICB4ay5maWxsKDApO1xuXHQgICAgfSxcblx0ICAgIGRlY3J5cHQoa2VrLCBvdXQpIHtcblx0ICAgICAgICBpZiAob3V0Lmxlbmd0aCAtIDggPj0gMiAqKiAzMilcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaXBoZXJ0ZXh0IHNob3VsZCBiZSBsZXNzIHRoYW4gNGdiJyk7XG5cdCAgICAgICAgY29uc3QgeGsgPSBleHBhbmRLZXlEZWNMRShrZWspO1xuXHQgICAgICAgIGNvbnN0IGNodW5rcyA9IG91dC5sZW5ndGggLyA4IC0gMTsgLy8gZmlyc3QgY2h1bmsgaXMgSVZcblx0ICAgICAgICBpZiAoY2h1bmtzID09PSAxKVxuXHQgICAgICAgICAgICBkZWNyeXB0QmxvY2soeGssIG91dCk7XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGNvbnN0IG8zMiA9ICgwLCB1dGlsc19qc18xLnUzMikob3V0KTtcblx0ICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG5cdCAgICAgICAgICAgIGxldCBhMCA9IG8zMlswXSwgYTEgPSBvMzJbMV07IC8vIEFcblx0ICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGN0ciA9IGNodW5rcyAqIDY7IGogPCA2OyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IGNodW5rcyAqIDI7IHBvcyA+PSAxOyBwb3MgLT0gMiwgY3RyLS0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBhMSBePSBieXRlU3dhcChjdHIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgczAsIHMxLCBzMiwgczMgfSA9IGRlY3J5cHQoeGssIGEwLCBhMSwgbzMyW3Bvc10sIG8zMltwb3MgKyAxXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgKGEwID0gczApLCAoYTEgPSBzMSksIChvMzJbcG9zXSA9IHMyKSwgKG8zMltwb3MgKyAxXSA9IHMzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAobzMyWzBdID0gYTApLCAobzMyWzFdID0gYTEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB4ay5maWxsKDApO1xuXHQgICAgfSxcblx0fTtcblx0Y29uc3QgQUVTS1dfSVYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoOCkuZmlsbCgweGE2KTsgLy8gQTZBNkE2QTZBNkE2QTZBNlxuXHQvKipcblx0ICogQUVTLUtXIChrZXktd3JhcCkuIEluamVjdHMgc3RhdGljIElWIGludG8gcGxhaW50ZXh0LCBhZGRzIGNvdW50ZXIsIGVuY3J5cHRzIDYgdGltZXMuXG5cdCAqIFJlZHVjZXMgYmxvY2sgc2l6ZSBmcm9tIDE2IHRvIDggYnl0ZXMuXG5cdCAqIEZvciBwYWRkZWQgdmVyc2lvbiwgdXNlIGFlc2t3cC5cblx0ICogW1JGQyAzMzk0XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9yZmMzMzk0LyksXG5cdCAqIFtOSVNULlNQLjgwMC0zOEZdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9TcGVjaWFsUHVibGljYXRpb25zL05JU1QuU1AuODAwLTM4Ri5wZGYpLlxuXHQgKi9cblx0YWVzLmFlc2t3ID0gKDAsIHV0aWxzX2pzXzEud3JhcENpcGhlcikoeyBibG9ja1NpemU6IDggfSwgKGtlaykgPT4gKHtcblx0ICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG5cdCAgICAgICAgaWYgKCFwbGFpbnRleHQubGVuZ3RoIHx8IHBsYWludGV4dC5sZW5ndGggJSA4ICE9PSAwKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IGxlbmd0aCcpO1xuXHQgICAgICAgIGlmIChwbGFpbnRleHQubGVuZ3RoID09PSA4KVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzgtYnl0ZSBrZXlzIG5vdCBhbGxvd2VkIGluIEFFU0tXLCB1c2UgQUVTS1dQIGluc3RlYWQnKTtcblx0ICAgICAgICBjb25zdCBvdXQgPSAoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoQUVTS1dfSVYsIHBsYWludGV4dCk7XG5cdCAgICAgICAgQUVTVy5lbmNyeXB0KGtlaywgb3V0KTtcblx0ICAgICAgICByZXR1cm4gb3V0O1xuXHQgICAgfSxcblx0ICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuXHQgICAgICAgIC8vIGNpcGhlcnRleHQgbXVzdCBiZSBhdCBsZWFzdCAyNCBieXRlcyBhbmQgYSBtdWx0aXBsZSBvZiA4IGJ5dGVzXG5cdCAgICAgICAgLy8gMjQgYmVjYXVzZSBzaG91bGQgaGF2ZSBhdCBsZWFzdCB0d28gYmxvY2sgKDEgaXYgKyAyKS5cblx0ICAgICAgICAvLyBSZXBsYWNlIHdpdGggMTYgdG8gZW5hYmxlICc4LWJ5dGUga2V5cydcblx0ICAgICAgICBpZiAoY2lwaGVydGV4dC5sZW5ndGggJSA4ICE9PSAwIHx8IGNpcGhlcnRleHQubGVuZ3RoIDwgMyAqIDgpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjaXBoZXJ0ZXh0IGxlbmd0aCcpO1xuXHQgICAgICAgIGNvbnN0IG91dCA9ICgwLCB1dGlsc19qc18xLmNvcHlCeXRlcykoY2lwaGVydGV4dCk7XG5cdCAgICAgICAgQUVTVy5kZWNyeXB0KGtlaywgb3V0KTtcblx0ICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmVxdWFsQnl0ZXMpKG91dC5zdWJhcnJheSgwLCA4KSwgQUVTS1dfSVYpKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludGVncml0eSBjaGVjayBmYWlsZWQnKTtcblx0ICAgICAgICBvdXQuc3ViYXJyYXkoMCwgOCkuZmlsbCgwKTsgLy8gY2lwaGVydGV4dC5zdWJhcnJheSgwLCA4KSA9PT0gSVYsIGJ1dCB3ZSBjbGVhbiBpdCBhbnl3YXlcblx0ICAgICAgICByZXR1cm4gb3V0LnN1YmFycmF5KDgpO1xuXHQgICAgfSxcblx0fSkpO1xuXHQvKlxuXHRXZSBkb24ndCBzdXBwb3J0IDgtYnl0ZSBrZXlzLiBUaGUgcmFiYml0IGhvbGU6XG5cblx0LSBXeWNoZXByb29mIHNheXM6IFwiTklTVCBTUCA4MDAtMzhGIGRvZXMgbm90IGRlZmluZSB0aGUgd3JhcHBpbmcgb2YgOCBieXRlIGtleXMuXG5cdCAgUkZDIDMzOTQgU2VjdGlvbiAyICBvbiB0aGUgb3RoZXIgaGFuZCBzcGVjaWZpZXMgdGhhdCA4IGJ5dGUga2V5cyBhcmUgd3JhcHBlZFxuXHQgIGJ5IGRpcmVjdGx5IGVuY3J5cHRpbmcgb25lIGJsb2NrIHdpdGggQUVTLlwiXG5cdCAgICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9DMlNQL3d5Y2hlcHJvb2YvYmxvYi9tYXN0ZXIvZG9jL2tleV93cmFwLm1kXG5cdCAgICAtIFwiUkZDIDMzOTQgc3BlY2lmaWVzIGluIFNlY3Rpb24gMiwgdGhhdCB0aGUgaW5wdXQgZm9yIHRoZSBrZXkgd3JhcFxuXHQgICAgICBhbGdvcml0aG0gbXVzdCBiZSBhdCBsZWFzdCB0d28gYmxvY2tzIGFuZCBvdGhlcndpc2UgdGhlIGNvbnN0YW50XG5cdCAgICAgIGZpZWxkIGFuZCBrZXkgYXJlIHNpbXBseSBlbmNyeXB0ZWQgd2l0aCBFQ0IgYXMgYSBzaW5nbGUgYmxvY2tcIlxuXHQtIFdoYXQgUkZDIDMzOTQgYWN0dWFsbHkgc2F5cyAoaW4gU2VjdGlvbiAyKTpcblx0ICAgIC0gXCJCZWZvcmUgYmVpbmcgd3JhcHBlZCwgdGhlIGtleSBkYXRhIGlzIHBhcnNlZCBpbnRvIG4gYmxvY2tzIG9mIDY0IGJpdHMuXG5cdCAgICAgIFRoZSBvbmx5IHJlc3RyaWN0aW9uIHRoZSBrZXkgd3JhcCBhbGdvcml0aG0gcGxhY2VzIG9uIG4gaXMgdGhhdCBuIGJlXG5cdCAgICAgIGF0IGxlYXN0IHR3b1wiXG5cdCAgICAtIFwiRm9yIGtleSBkYXRhIHdpdGggbGVuZ3RoIGxlc3MgdGhhbiBvciBlcXVhbCB0byA2NCBiaXRzLCB0aGUgY29uc3RhbnRcblx0ICAgICAgZmllbGQgdXNlZCBpbiB0aGlzIHNwZWNpZmljYXRpb24gYW5kIHRoZSBrZXkgZGF0YSBmb3JtIGEgc2luZ2xlXG5cdCAgICAgIDEyOC1iaXQgY29kZWJvb2sgaW5wdXQgbWFraW5nIHRoaXMga2V5IHdyYXAgdW5uZWNlc3NhcnkuXCJcblx0LSBXaGljaCBtZWFucyBcImFzc2VydChuID49IDIpXCIgYW5kIFwidXNlIHNvbWV0aGluZyBlbHNlIGZvciA4IGJ5dGUga2V5c1wiXG5cdC0gTklTVCBTUDgwMC0zOEYgYWN0dWFsbHkgcHJvaGliaXRzIDgtYnl0ZSBpbiBcIjUuMy4xIE1hbmRhdG9yeSBMaW1pdHNcIi5cblx0ICBJdCBzdGF0ZXMgdGhhdCBwbGFpbnRleHQgZm9yIEtXIHNob3VsZCBiZSBcIjIgdG8gMl41NCAtMSBzZW1pYmxvY2tzXCIuXG5cdC0gU28sIHdoZXJlIGRvZXMgXCJkaXJlY3RseSBlbmNyeXB0IHNpbmdsZSBibG9jayB3aXRoIEFFU1wiIGNvbWUgZnJvbT9cblx0ICAgIC0gTm90IFJGQyAzMzk0LiBQc2V1ZG9jb2RlIG9mIGtleSB3cmFwIGluIDIuMiBleHBsaWNpdGx5IHVzZXNcblx0ICAgICAgbG9vcCBvZiA2IGZvciBhbnkgY29kZSBwYXRoXG5cdCAgICAtIFRoZXJlIGlzIGEgd2VpcmQgVzNDIHNwZWM6XG5cdCAgICAgIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAyL1JFQy14bWxlbmMtY29yZS0yMDAyMTIxMC9PdmVydmlldy5odG1sI2t3LWFlczEyOFxuXHQgICAgLSBUaGlzIHNwZWMgaXMgb3V0ZGF0ZWQsIGFzIGFkbWl0dGVkIGJ5IFd5Y2hlcHJvb2YgYXV0aG9yc1xuXHQgICAgLSBUaGVyZSBpcyBSRkMgNTY0OSBmb3IgcGFkZGVkIGtleSB3cmFwLCB3aGljaCBpcyBwYWRkaW5nIGNvbnN0cnVjdGlvbiBvblxuXHQgICAgICB0b3Agb2YgQUVTS1cuIEluICc0LjEuMicgaXQgc2F5czogXCJJZiB0aGUgcGFkZGVkIHBsYWludGV4dCBjb250YWlucyBleGFjdGx5XG5cdCAgICAgIGVpZ2h0IG9jdGV0cywgdGhlbiBwcmVwZW5kIHRoZSBBSVYgYXMgZGVmaW5lZCBpbiBTZWN0aW9uIDMgYWJvdmUgdG8gUFsxXSBhbmRcblx0ICAgICAgZW5jcnlwdCB0aGUgcmVzdWx0aW5nIDEyOC1iaXQgYmxvY2sgdXNpbmcgQUVTIGluIEVDQiBtb2RlIFtNb2Rlc10gd2l0aCBrZXlcblx0ICAgICAgSyAodGhlIEtFSykuICBJbiB0aGlzIGNhc2UsIHRoZSBvdXRwdXQgaXMgdHdvIDY0LWJpdCBibG9ja3MgQ1swXSBhbmQgQ1sxXTpcIlxuXHQgICAgLSBCcm93c2VyIHN1YnRsZSBjcnlwdG8gaXMgYWN0dWFsbHkgY3Jhc2hlcyBvbiB3cmFwcGluZyBrZXlzIGxlc3MgdGhhbiAxNiBieXRlczpcblx0ICAgICAgYEVycm9yOiBlcnJvcjoxQzgwMDBFNjpQcm92aWRlciByb3V0aW5lczo6aW52YWxpZCBpbnB1dCBsZW5ndGhdIHsgb3BlbnNzbEVycm9yU3RhY2s6IFsgJ2Vycm9yOjAzMDAwMEJEOmRpZ2l0YWwgZW52ZWxvcGUgcm91dGluZXM6OnVwZGF0ZSBlcnJvcicgXWBcblxuXHRJbiB0aGUgZW5kLCBzZWVtcyBsaWtlIGEgYnVnIGluIFd5Y2hlcHJvb2YuXG5cdFRoZSA4LWJ5dGUgY2hlY2sgY2FuIGJlIGVhc2lseSBkaXNhYmxlZCBpbnNpZGUgb2YgQUVTX1cuXG5cdCovXG5cdGNvbnN0IEFFU0tXUF9JViA9IDB4YTY1OTU5YTY7IC8vIHNpbmdsZSB1MzJsZSB2YWx1ZVxuXHQvKipcblx0ICogQUVTLUtXLCBidXQgd2l0aCBwYWRkaW5nIGFuZCBhbGxvd3MgcmFuZG9tIGtleXMuXG5cdCAqIFNlY29uZCB1MzIgb2YgSVYgaXMgdXNlZCBhcyBjb3VudGVyIGZvciBsZW5ndGguXG5cdCAqIFtSRkMgNTY0OV0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzU2NDkpXG5cdCAqL1xuXHRhZXMuYWVza3dwID0gKDAsIHV0aWxzX2pzXzEud3JhcENpcGhlcikoeyBibG9ja1NpemU6IDggfSwgKGtlaykgPT4gKHtcblx0ICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG5cdCAgICAgICAgaWYgKCFwbGFpbnRleHQubGVuZ3RoKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IGxlbmd0aCcpO1xuXHQgICAgICAgIGNvbnN0IHBhZGRlZCA9IE1hdGguY2VpbChwbGFpbnRleHQubGVuZ3RoIC8gOCkgKiA4O1xuXHQgICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KDggKyBwYWRkZWQpO1xuXHQgICAgICAgIG91dC5zZXQocGxhaW50ZXh0LCA4KTtcblx0ICAgICAgICBjb25zdCBvdXQzMiA9ICgwLCB1dGlsc19qc18xLnUzMikob3V0KTtcblx0ICAgICAgICBvdXQzMlswXSA9IEFFU0tXUF9JVjtcblx0ICAgICAgICBvdXQzMlsxXSA9IGJ5dGVTd2FwKHBsYWludGV4dC5sZW5ndGgpO1xuXHQgICAgICAgIEFFU1cuZW5jcnlwdChrZWssIG91dCk7XG5cdCAgICAgICAgcmV0dXJuIG91dDtcblx0ICAgIH0sXG5cdCAgICBkZWNyeXB0KGNpcGhlcnRleHQpIHtcblx0ICAgICAgICAvLyAxNiBiZWNhdXNlIHNob3VsZCBoYXZlIGF0IGxlYXN0IG9uZSBibG9ja1xuXHQgICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCA8IDE2KVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBsZW5ndGgnKTtcblx0ICAgICAgICBjb25zdCBvdXQgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKGNpcGhlcnRleHQpO1xuXHQgICAgICAgIGNvbnN0IG8zMiA9ICgwLCB1dGlsc19qc18xLnUzMikob3V0KTtcblx0ICAgICAgICBBRVNXLmRlY3J5cHQoa2VrLCBvdXQpO1xuXHQgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVTd2FwKG8zMlsxXSkgPj4+IDA7XG5cdCAgICAgICAgY29uc3QgcGFkZGVkID0gTWF0aC5jZWlsKGxlbiAvIDgpICogODtcblx0ICAgICAgICBpZiAobzMyWzBdICE9PSBBRVNLV1BfSVYgfHwgb3V0Lmxlbmd0aCAtIDggIT09IHBhZGRlZClcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnRlZ3JpdHkgY2hlY2sgZmFpbGVkJyk7XG5cdCAgICAgICAgZm9yIChsZXQgaSA9IGxlbjsgaSA8IHBhZGRlZDsgaSsrKVxuXHQgICAgICAgICAgICBpZiAob3V0WzggKyBpXSAhPT0gMClcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW50ZWdyaXR5IGNoZWNrIGZhaWxlZCcpO1xuXHQgICAgICAgIG91dC5zdWJhcnJheSgwLCA4KS5maWxsKDApOyAvLyBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIDgpID09PSBJViwgYnV0IHdlIGNsZWFuIGl0IGFueXdheVxuXHQgICAgICAgIHJldHVybiBvdXQuc3ViYXJyYXkoOCwgOCArIGxlbik7XG5cdCAgICB9LFxuXHR9KSk7XG5cdC8qKiBVbnNhZmUgbG93LWxldmVsIGludGVybmFsIG1ldGhvZHMuIE1heSBjaGFuZ2UgYXQgYW55IHRpbWUuICovXG5cdGFlcy51bnNhZmUgPSB7XG5cdCAgICBleHBhbmRLZXlMRSxcblx0ICAgIGV4cGFuZEtleURlY0xFLFxuXHQgICAgZW5jcnlwdCxcblx0ICAgIGRlY3J5cHQsXG5cdCAgICBlbmNyeXB0QmxvY2ssXG5cdCAgICBkZWNyeXB0QmxvY2ssXG5cdCAgICBjdHJDb3VudGVyLFxuXHQgICAgY3RyMzIsXG5cdH07XG5cdFxuXHRyZXR1cm4gYWVzO1xufVxuXG52YXIgaGFzUmVxdWlyZWROb2JsZSQxO1xuXG5mdW5jdGlvbiByZXF1aXJlTm9ibGUkMSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZE5vYmxlJDEpIHJldHVybiBub2JsZSQxO1xuXHRoYXNSZXF1aXJlZE5vYmxlJDEgPSAxO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ibGUkMSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdG5vYmxlJDEuYWVzMjU2Y2JjID0gbm9ibGUkMS5hZXMyNTZnY20gPSB2b2lkIDA7XG5cdHZhciBhZXNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUFlcygpO1xuXHR2YXIgYWVzMjU2Z2NtID0gZnVuY3Rpb24gKGtleSwgbm9uY2UsIEFBRCkge1xuXHQgICAgcmV0dXJuICgwLCBhZXNfMS5nY20pKGtleSwgbm9uY2UsIEFBRCk7XG5cdH07XG5cdG5vYmxlJDEuYWVzMjU2Z2NtID0gYWVzMjU2Z2NtO1xuXHR2YXIgYWVzMjU2Y2JjID0gZnVuY3Rpb24gKGtleSwgbm9uY2UsIEFBRCkge1xuXHQgICAgcmV0dXJuICgwLCBhZXNfMS5jYmMpKGtleSwgbm9uY2UpO1xuXHR9O1xuXHRub2JsZSQxLmFlczI1NmNiYyA9IGFlczI1NmNiYztcblx0cmV0dXJuIG5vYmxlJDE7XG59XG5cbnZhciBub2JsZSA9IHt9O1xuXG52YXIgY2hhY2hhID0ge307XG5cbnZhciBfYXJ4ID0ge307XG5cbnZhciBoYXNSZXF1aXJlZF9hcng7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfYXJ4ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2FyeCkgcmV0dXJuIF9hcng7XG5cdGhhc1JlcXVpcmVkX2FyeCA9IDE7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXJ4LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0X2FyeC5yb3RsID0gcm90bDtcblx0X2FyeC5jcmVhdGVDaXBoZXIgPSBjcmVhdGVDaXBoZXI7XG5cdC8qKlxuXHQgKiBCYXNpYyB1dGlscyBmb3IgQVJYIChhZGQtcm90YXRlLXhvcikgc2Fsc2EgYW5kIGNoYWNoYSBjaXBoZXJzLlxuXG5cdFJGQzg0MzkgcmVxdWlyZXMgbXVsdGktc3RlcCBjaXBoZXIgc3RyZWFtLCB3aGVyZVxuXHRhdXRoS2V5IHN0YXJ0cyB3aXRoIGNvdW50ZXI6IDAsIGFjdHVhbCBtc2cgd2l0aCBjb3VudGVyOiAxLlxuXG5cdEZvciB0aGlzLCB3ZSBuZWVkIGEgd2F5IHRvIHJlLXVzZSBub25jZSAvIGNvdW50ZXI6XG5cblx0ICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDhBcnJheSg0KTtcblx0ICAgIGNoYWNoYSguLi4sIGNvdW50ZXIsIC4uLik7IC8vIGNvdW50ZXIgaXMgbm93IDFcblx0ICAgIGNoYWNoYSguLi4sIGNvdW50ZXIsIC4uLik7IC8vIGNvdW50ZXIgaXMgbm93IDJcblxuXHRUaGlzIGlzIGNvbXBsaWNhdGVkOlxuXG5cdC0gMzItYml0IGNvdW50ZXJzIGFyZSBlbm91Z2gsIG5vIG5lZWQgZm9yIDY0LWJpdDogbWF4IEFycmF5QnVmZmVyIHNpemUgaW4gSlMgaXMgNEdCXG5cdC0gT3JpZ2luYWwgcGFwZXJzIGRvbid0IGFsbG93IG11dGF0aW5nIGNvdW50ZXJzXG5cdC0gQ291bnRlciBvdmVyZmxvdyBpcyB1bmRlZmluZWQgW14xXVxuXHQtIElkZWEgQTogYWxsb3cgcHJvdmlkaW5nIChub25jZSB8IGNvdW50ZXIpIGluc3RlYWQgb2YganVzdCBub25jZSwgcmUtdXNlIGl0XG5cdC0gQ2F2ZWF0OiBDYW5ub3QgYmUgcmUtdXNlZCB0aHJvdWdoIGFsbCBjYXNlczpcblx0LSAqIGNoYWNoYSBoYXMgKGNvdW50ZXIgfCBub25jZSlcblx0LSAqIHhjaGFjaGEgaGFzIChub25jZTE2IHwgY291bnRlciB8IG5vbmNlMTYpXG5cdC0gSWRlYSBCOiBzZXBhcmF0ZSBub25jZSAvIGNvdW50ZXIgYW5kIHByb3ZpZGUgc2VwYXJhdGUgQVBJIGZvciBjb3VudGVyIHJlLXVzZVxuXHQtIENhdmVhdDogdGhlcmUgYXJlIGRpZmZlcmVudCBjb3VudGVyIHNpemVzIGRlcGVuZGluZyBvbiBhbiBhbGdvcml0aG0uXG5cdC0gc2Fsc2EgJiBjaGFjaGEgYWxzbyBkaWZmZXIgaW4gc3RydWN0dXJlcyBvZiBrZXkgJiBzaWdtYTpcblx0ICBzYWxzYTIwOiAgICAgIHNbMF0gfCBrKDQpIHwgc1sxXSB8IG5vbmNlKDIpIHwgY3RyKDIpIHwgc1syXSB8IGsoNCkgfCBzWzNdXG5cdCAgY2hhY2hhOiAgICAgICBzKDQpIHwgayg4KSB8IGN0cigxKSB8IG5vbmNlKDMpXG5cdCAgY2hhY2hhMjBvcmlnOiBzKDQpIHwgayg4KSB8IGN0cigyKSB8IG5vbmNlKDIpXG5cdC0gSWRlYSBDOiBoZWxwZXIgbWV0aG9kIHN1Y2ggYXMgYHNldFNhbHNhU3RhdGUoa2V5LCBub25jZSwgc2lnbWEsIGRhdGEpYFxuXHQtIENhdmVhdDogd2UgY2FuJ3QgcmUtdXNlIGNvdW50ZXIgYXJyYXlcblxuXHR4Y2hhY2hhIFteMl0gdXNlcyB0aGUgc3Via2V5IGFuZCByZW1haW5pbmcgOCBieXRlIG5vbmNlIHdpdGggQ2hhQ2hhMjAgYXMgbm9ybWFsXG5cdChwcmVmaXhlZCBieSA0IE5VTCBieXRlcywgc2luY2UgW1JGQzg0MzldIHNwZWNpZmllcyBhIDEyLWJ5dGUgbm9uY2UpLlxuXG5cdFteMV06IGh0dHBzOi8vbWFpbGFyY2hpdmUuaWV0Zi5vcmcvYXJjaC9tc2cvY2ZyZy9nc09uVEp6Y2JnRzZPcUQ4U2MwR081YVJfdFUvXG5cdFteMl06IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXhjaGFjaGEjYXBwZW5kaXgtQS4yXG5cblx0ICogQG1vZHVsZVxuXHQgKi9cblx0Y29uc3QgX2Fzc2VydF9qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlX2Fzc2VydCQxKCk7XG5cdGNvbnN0IHV0aWxzX2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVVdGlscyQzKCk7XG5cdC8vIFdlIGNhbid0IG1ha2UgdG9wLWxldmVsIHZhciBkZXBlbmQgb24gdXRpbHMudXRmOFRvQnl0ZXNcblx0Ly8gYmVjYXVzZSBpdCdzIG5vdCBwcmVzZW50IGluIGFsbCBlbnZzLiBDcmVhdGluZyBhIHNpbWlsYXIgZm4gaGVyZVxuXHRjb25zdCBfdXRmOFRvQnl0ZXMgPSAoc3RyKSA9PiBVaW50OEFycmF5LmZyb20oc3RyLnNwbGl0KCcnKS5tYXAoKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuXHRjb25zdCBzaWdtYTE2ID0gX3V0ZjhUb0J5dGVzKCdleHBhbmQgMTYtYnl0ZSBrJyk7XG5cdGNvbnN0IHNpZ21hMzIgPSBfdXRmOFRvQnl0ZXMoJ2V4cGFuZCAzMi1ieXRlIGsnKTtcblx0Y29uc3Qgc2lnbWExNl8zMiA9ICgwLCB1dGlsc19qc18xLnUzMikoc2lnbWExNik7XG5cdGNvbnN0IHNpZ21hMzJfMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHNpZ21hMzIpO1xuXHRmdW5jdGlvbiByb3RsKGEsIGIpIHtcblx0ICAgIHJldHVybiAoYSA8PCBiKSB8IChhID4+PiAoMzIgLSBiKSk7XG5cdH1cblx0Ly8gSXMgYnl0ZSBhcnJheSBhbGlnbmVkIHRvIDQgYnl0ZSBvZmZzZXQgKHUzMik/XG5cdGZ1bmN0aW9uIGlzQWxpZ25lZDMyKGIpIHtcblx0ICAgIHJldHVybiBiLmJ5dGVPZmZzZXQgJSA0ID09PSAwO1xuXHR9XG5cdC8vIFNhbHNhIGFuZCBDaGFjaGEgYmxvY2sgbGVuZ3RoIGlzIGFsd2F5cyA1MTItYml0XG5cdGNvbnN0IEJMT0NLX0xFTiA9IDY0O1xuXHRjb25zdCBCTE9DS19MRU4zMiA9IDE2O1xuXHQvLyBuZXcgVWludDMyQXJyYXkoWzIqKjMyXSkgICAvLyA9PiBVaW50MzJBcnJheSgxKSBbIDAgXVxuXHQvLyBuZXcgVWludDMyQXJyYXkoWzIqKjMyLTFdKSAvLyA9PiBVaW50MzJBcnJheSgxKSBbIDQyOTQ5NjcyOTUgXVxuXHRjb25zdCBNQVhfQ09VTlRFUiA9IDIgKiogMzIgLSAxO1xuXHRjb25zdCBVMzJfRU1QVFkgPSBuZXcgVWludDMyQXJyYXkoKTtcblx0ZnVuY3Rpb24gcnVuQ2lwaGVyKGNvcmUsIHNpZ21hLCBrZXksIG5vbmNlLCBkYXRhLCBvdXRwdXQsIGNvdW50ZXIsIHJvdW5kcykge1xuXHQgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG5cdCAgICBjb25zdCBibG9jayA9IG5ldyBVaW50OEFycmF5KEJMT0NLX0xFTik7XG5cdCAgICBjb25zdCBiMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGJsb2NrKTtcblx0ICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGJ1ZmZlcnMgYWxpZ25lZCB0byA0IGJ5dGVzXG5cdCAgICBjb25zdCBpc0FsaWduZWQgPSBpc0FsaWduZWQzMihkYXRhKSAmJiBpc0FsaWduZWQzMihvdXRwdXQpO1xuXHQgICAgY29uc3QgZDMyID0gaXNBbGlnbmVkID8gKDAsIHV0aWxzX2pzXzEudTMyKShkYXRhKSA6IFUzMl9FTVBUWTtcblx0ICAgIGNvbnN0IG8zMiA9IGlzQWxpZ25lZCA/ICgwLCB1dGlsc19qc18xLnUzMikob3V0cHV0KSA6IFUzMl9FTVBUWTtcblx0ICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjsgY291bnRlcisrKSB7XG5cdCAgICAgICAgY29yZShzaWdtYSwga2V5LCBub25jZSwgYjMyLCBjb3VudGVyLCByb3VuZHMpO1xuXHQgICAgICAgIGlmIChjb3VudGVyID49IE1BWF9DT1VOVEVSKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyeDogY291bnRlciBvdmVyZmxvdycpO1xuXHQgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihCTE9DS19MRU4sIGxlbiAtIHBvcyk7XG5cdCAgICAgICAgLy8gYWxpZ25lZCB0byA0IGJ5dGVzXG5cdCAgICAgICAgaWYgKGlzQWxpZ25lZCAmJiB0YWtlID09PSBCTE9DS19MRU4pIHtcblx0ICAgICAgICAgICAgY29uc3QgcG9zMzIgPSBwb3MgLyA0O1xuXHQgICAgICAgICAgICBpZiAocG9zICUgNCAhPT0gMClcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJ4OiBpbnZhbGlkIGJsb2NrIHBvc2l0aW9uJyk7XG5cdCAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBwb3NqOyBqIDwgQkxPQ0tfTEVOMzI7IGorKykge1xuXHQgICAgICAgICAgICAgICAgcG9zaiA9IHBvczMyICsgajtcblx0ICAgICAgICAgICAgICAgIG8zMltwb3NqXSA9IGQzMltwb3NqXSBeIGIzMltqXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBwb3MgKz0gQkxPQ0tfTEVOO1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZm9yIChsZXQgaiA9IDAsIHBvc2o7IGogPCB0YWtlOyBqKyspIHtcblx0ICAgICAgICAgICAgcG9zaiA9IHBvcyArIGo7XG5cdCAgICAgICAgICAgIG91dHB1dFtwb3NqXSA9IGRhdGFbcG9zal0gXiBibG9ja1tqXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcG9zICs9IHRha2U7XG5cdCAgICB9XG5cdH1cblx0LyoqIENyZWF0ZXMgQVJYLWxpa2UgKENoYUNoYSwgU2Fsc2EpIGNpcGhlciBzdHJlYW0gZnJvbSBjb3JlIGZ1bmN0aW9uLiAqL1xuXHRmdW5jdGlvbiBjcmVhdGVDaXBoZXIoY29yZSwgb3B0cykge1xuXHQgICAgY29uc3QgeyBhbGxvd1Nob3J0S2V5cywgZXh0ZW5kTm9uY2VGbiwgY291bnRlckxlbmd0aCwgY291bnRlclJpZ2h0LCByb3VuZHMgfSA9ICgwLCB1dGlsc19qc18xLmNoZWNrT3B0cykoeyBhbGxvd1Nob3J0S2V5czogZmFsc2UsIGNvdW50ZXJMZW5ndGg6IDgsIGNvdW50ZXJSaWdodDogZmFsc2UsIHJvdW5kczogMjAgfSwgb3B0cyk7XG5cdCAgICBpZiAodHlwZW9mIGNvcmUgIT09ICdmdW5jdGlvbicpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3JlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHQgICAgKDAsIF9hc3NlcnRfanNfMS5hbnVtYmVyKShjb3VudGVyTGVuZ3RoKTtcblx0ICAgICgwLCBfYXNzZXJ0X2pzXzEuYW51bWJlcikocm91bmRzKTtcblx0ICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJvb2wpKGNvdW50ZXJSaWdodCk7XG5cdCAgICAoMCwgX2Fzc2VydF9qc18xLmFib29sKShhbGxvd1Nob3J0S2V5cyk7XG5cdCAgICByZXR1cm4gKGtleSwgbm9uY2UsIGRhdGEsIG91dHB1dCwgY291bnRlciA9IDApID0+IHtcblx0ICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmFieXRlcykoa2V5KTtcblx0ICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmFieXRlcykobm9uY2UpO1xuXHQgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJ5dGVzKShkYXRhKTtcblx0ICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcblx0ICAgICAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG5cdCAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKG91dHB1dCk7XG5cdCAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hbnVtYmVyKShjb3VudGVyKTtcblx0ICAgICAgICBpZiAoY291bnRlciA8IDAgfHwgY291bnRlciA+PSBNQVhfQ09VTlRFUilcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcng6IGNvdW50ZXIgb3ZlcmZsb3cnKTtcblx0ICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA8IGxlbilcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IG91dHB1dCAoJHtvdXRwdXQubGVuZ3RofSkgaXMgc2hvcnRlciB0aGFuIGRhdGEgKCR7bGVufSlgKTtcblx0ICAgICAgICBjb25zdCB0b0NsZWFuID0gW107XG5cdCAgICAgICAgLy8gS2V5ICYgc2lnbWFcblx0ICAgICAgICAvLyBrZXk9MTYgLT4gc2lnbWExNiwgaz1rZXl8a2V5XG5cdCAgICAgICAgLy8ga2V5PTMyIC0+IHNpZ21hMzIsIGs9a2V5XG5cdCAgICAgICAgbGV0IGwgPSBrZXkubGVuZ3RoO1xuXHQgICAgICAgIGxldCBrO1xuXHQgICAgICAgIGxldCBzaWdtYTtcblx0ICAgICAgICBpZiAobCA9PT0gMzIpIHtcblx0ICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChrID0gKDAsIHV0aWxzX2pzXzEuY29weUJ5dGVzKShrZXkpKSk7XG5cdCAgICAgICAgICAgIHNpZ21hID0gc2lnbWEzMl8zMjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAobCA9PT0gMTYgJiYgYWxsb3dTaG9ydEtleXMpIHtcblx0ICAgICAgICAgICAgayA9IG5ldyBVaW50OEFycmF5KDMyKTtcblx0ICAgICAgICAgICAgay5zZXQoa2V5KTtcblx0ICAgICAgICAgICAgay5zZXQoa2V5LCAxNik7XG5cdCAgICAgICAgICAgIHNpZ21hID0gc2lnbWExNl8zMjtcblx0ICAgICAgICAgICAgdG9DbGVhbi5wdXNoKGspO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IGludmFsaWQgMzItYnl0ZSBrZXksIGdvdCBsZW5ndGg9JHtsfWApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBOb25jZVxuXHQgICAgICAgIC8vIHNhbHNhMjA6ICAgICAgOCAgICg4LWJ5dGUgY291bnRlcilcblx0ICAgICAgICAvLyBjaGFjaGEyMG9yaWc6IDggICAoOC1ieXRlIGNvdW50ZXIpXG5cdCAgICAgICAgLy8gY2hhY2hhMjA6ICAgICAxMiAgKDQtYnl0ZSBjb3VudGVyKVxuXHQgICAgICAgIC8vIHhzYWxzYTIwOiAgICAgMjQgICgxNiAtPiBoc2Fsc2EsICA4IC0+IG9sZCBub25jZSlcblx0ICAgICAgICAvLyB4Y2hhY2hhMjA6ICAgIDI0ICAoMTYgLT4gaGNoYWNoYSwgOCAtPiBvbGQgbm9uY2UpXG5cdCAgICAgICAgLy8gQWxpZ24gbm9uY2UgdG8gNCBieXRlc1xuXHQgICAgICAgIGlmICghaXNBbGlnbmVkMzIobm9uY2UpKVxuXHQgICAgICAgICAgICB0b0NsZWFuLnB1c2goKG5vbmNlID0gKDAsIHV0aWxzX2pzXzEuY29weUJ5dGVzKShub25jZSkpKTtcblx0ICAgICAgICBjb25zdCBrMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGspO1xuXHQgICAgICAgIC8vIGhzYWxzYSAmIGhjaGFjaGE6IGhhbmRsZSBleHRlbmRlZCBub25jZVxuXHQgICAgICAgIGlmIChleHRlbmROb25jZUZuKSB7XG5cdCAgICAgICAgICAgIGlmIChub25jZS5sZW5ndGggIT09IDI0KVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IGV4dGVuZGVkIG5vbmNlIG11c3QgYmUgMjQgYnl0ZXNgKTtcblx0ICAgICAgICAgICAgZXh0ZW5kTm9uY2VGbihzaWdtYSwgazMyLCAoMCwgdXRpbHNfanNfMS51MzIpKG5vbmNlLnN1YmFycmF5KDAsIDE2KSksIGszMik7XG5cdCAgICAgICAgICAgIG5vbmNlID0gbm9uY2Uuc3ViYXJyYXkoMTYpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBIYW5kbGUgbm9uY2UgY291bnRlclxuXHQgICAgICAgIGNvbnN0IG5vbmNlTmNMZW4gPSAxNiAtIGNvdW50ZXJMZW5ndGg7XG5cdCAgICAgICAgaWYgKG5vbmNlTmNMZW4gIT09IG5vbmNlLmxlbmd0aClcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IG5vbmNlIG11c3QgYmUgJHtub25jZU5jTGVufSBvciAxNiBieXRlc2ApO1xuXHQgICAgICAgIC8vIFBhZCBjb3VudGVyIHdoZW4gbm9uY2UgaXMgNjQgYml0XG5cdCAgICAgICAgaWYgKG5vbmNlTmNMZW4gIT09IDEyKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IG5jID0gbmV3IFVpbnQ4QXJyYXkoMTIpO1xuXHQgICAgICAgICAgICBuYy5zZXQobm9uY2UsIGNvdW50ZXJSaWdodCA/IDAgOiAxMiAtIG5vbmNlLmxlbmd0aCk7XG5cdCAgICAgICAgICAgIG5vbmNlID0gbmM7XG5cdCAgICAgICAgICAgIHRvQ2xlYW4ucHVzaChub25jZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvbnN0IG4zMiA9ICgwLCB1dGlsc19qc18xLnUzMikobm9uY2UpO1xuXHQgICAgICAgIHJ1bkNpcGhlcihjb3JlLCBzaWdtYSwgazMyLCBuMzIsIGRhdGEsIG91dHB1dCwgY291bnRlciwgcm91bmRzKTtcblx0ICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoLi4udG9DbGVhbik7XG5cdCAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0ICAgIH07XG5cdH1cblx0XG5cdHJldHVybiBfYXJ4O1xufVxuXG52YXIgX3BvbHkxMzA1ID0ge307XG5cbnZhciBoYXNSZXF1aXJlZF9wb2x5MTMwNTtcblxuZnVuY3Rpb24gcmVxdWlyZV9wb2x5MTMwNSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9wb2x5MTMwNSkgcmV0dXJuIF9wb2x5MTMwNTtcblx0aGFzUmVxdWlyZWRfcG9seTEzMDUgPSAxO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoX3BvbHkxMzA1LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0X3BvbHkxMzA1LnBvbHkxMzA1ID0gdm9pZCAwO1xuXHRfcG9seTEzMDUud3JhcENvbnN0cnVjdG9yV2l0aEtleSA9IHdyYXBDb25zdHJ1Y3RvcldpdGhLZXk7XG5cdC8qKlxuXHQgKiBQb2x5MTMwNSAoW1BERl0oaHR0cHM6Ly9jci55cC50by9tYWMvcG9seTEzMDUtMjAwNTAzMjkucGRmKSxcblx0ICogW3dpa2ldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BvbHkxMzA1KSlcblx0ICogaXMgYSBmYXN0IGFuZCBwYXJhbGxlbCBzZWNyZXQta2V5IG1lc3NhZ2UtYXV0aGVudGljYXRpb24gY29kZSBzdWl0YWJsZSBmb3Jcblx0ICogYSB3aWRlIHZhcmlldHkgb2YgYXBwbGljYXRpb25zLiBJdCB3YXMgc3RhbmRhcmRpemVkIGluXG5cdCAqIFtSRkMgODQzOV0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM4NDM5KSBhbmQgaXMgbm93IHVzZWQgaW4gVExTIDEuMy5cblx0ICpcblx0ICogUG9seW5vbWlhbCBNQUNzIGFyZSBub3QgcGVyZmVjdCBmb3IgZXZlcnkgc2l0dWF0aW9uOlxuXHQgKiB0aGV5IGxhY2sgUmFuZG9tIEtleSBSb2J1c3RuZXNzOiB0aGUgTUFDIGNhbiBiZSBmb3JnZWQsIGFuZCBjYW4ndCBiZSB1c2VkIGluIFBBS0Ugc2NoZW1lcy5cblx0ICogU2VlIFtpbnZpc2libGUgc2FsYW1hbmRlcnMgYXR0YWNrXShodHRwczovL2tleW1hdGVyaWFsLm5ldC8yMDIwLzA5LzA3L2ludmlzaWJsZS1zYWxhbWFuZGVycy1pbi1hZXMtZ2NtLXNpdi8pLlxuXHQgKiBUbyBjb21iYXQgaW52aXNpYmxlIHNhbGFtYW5kZXJzLCBgaGFzaChrZXkpYCBjYW4gYmUgaW5jbHVkZWQgaW4gY2lwaGVydGV4dCxcblx0ICogaG93ZXZlciwgdGhpcyB3b3VsZCB2aW9sYXRlIGNpcGhlcnRleHQgaW5kaXN0aW5ndWlzaGFiaWxpdHk6XG5cdCAqIGFuIGF0dGFja2VyIHdvdWxkIGtub3cgd2hpY2gga2V5IHdhcyB1c2VkIC0gc28gYEhLREYoa2V5LCBpKWBcblx0ICogY291bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHQgKlxuXHQgKiBDaGVjayBvdXQgW29yaWdpbmFsIHdlYnNpdGVdKGh0dHBzOi8vY3IueXAudG8vbWFjLmh0bWwpLlxuXHQgKiBAbW9kdWxlXG5cdCAqL1xuXHRjb25zdCBfYXNzZXJ0X2pzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVfYXNzZXJ0JDEoKTtcblx0Y29uc3QgdXRpbHNfanNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZVV0aWxzJDMoKTtcblx0Ly8gQmFzZWQgb24gUHVibGljIERvbWFpbiBwb2x5MTMwNS1kb25uYSBodHRwczovL2dpdGh1Yi5jb20vZmxvb2R5YmVycnkvcG9seTEzMDUtZG9ubmFcblx0Y29uc3QgdTh0bzE2ID0gKGEsIGkpID0+IChhW2krK10gJiAweGZmKSB8ICgoYVtpKytdICYgMHhmZikgPDwgOCk7XG5cdGNsYXNzIFBvbHkxMzA1IHtcblx0ICAgIGNvbnN0cnVjdG9yKGtleSkge1xuXHQgICAgICAgIHRoaXMuYmxvY2tMZW4gPSAxNjtcblx0ICAgICAgICB0aGlzLm91dHB1dExlbiA9IDE2O1xuXHQgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXHQgICAgICAgIHRoaXMuciA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG5cdCAgICAgICAgdGhpcy5oID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcblx0ICAgICAgICB0aGlzLnBhZCA9IG5ldyBVaW50MTZBcnJheSg4KTtcblx0ICAgICAgICB0aGlzLnBvcyA9IDA7XG5cdCAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXHQgICAgICAgIGtleSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGtleSk7XG5cdCAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKGtleSwgMzIpO1xuXHQgICAgICAgIGNvbnN0IHQwID0gdTh0bzE2KGtleSwgMCk7XG5cdCAgICAgICAgY29uc3QgdDEgPSB1OHRvMTYoa2V5LCAyKTtcblx0ICAgICAgICBjb25zdCB0MiA9IHU4dG8xNihrZXksIDQpO1xuXHQgICAgICAgIGNvbnN0IHQzID0gdTh0bzE2KGtleSwgNik7XG5cdCAgICAgICAgY29uc3QgdDQgPSB1OHRvMTYoa2V5LCA4KTtcblx0ICAgICAgICBjb25zdCB0NSA9IHU4dG8xNihrZXksIDEwKTtcblx0ICAgICAgICBjb25zdCB0NiA9IHU4dG8xNihrZXksIDEyKTtcblx0ICAgICAgICBjb25zdCB0NyA9IHU4dG8xNihrZXksIDE0KTtcblx0ICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvb2R5YmVycnkvcG9seTEzMDUtZG9ubmEvYmxvYi9lNmFkNmUwOTFkMzBkN2Y0ZWMyZDRmOTc4YmUxZmNmY2JjZTcyNzgxL3BvbHkxMzA1LWRvbm5hLTE2LmgjTDQ3XG5cdCAgICAgICAgdGhpcy5yWzBdID0gdDAgJiAweDFmZmY7XG5cdCAgICAgICAgdGhpcy5yWzFdID0gKCh0MCA+Pj4gMTMpIHwgKHQxIDw8IDMpKSAmIDB4MWZmZjtcblx0ICAgICAgICB0aGlzLnJbMl0gPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgNikpICYgMHgxZjAzO1xuXHQgICAgICAgIHRoaXMuclszXSA9ICgodDIgPj4+IDcpIHwgKHQzIDw8IDkpKSAmIDB4MWZmZjtcblx0ICAgICAgICB0aGlzLnJbNF0gPSAoKHQzID4+PiA0KSB8ICh0NCA8PCAxMikpICYgMHgwMGZmO1xuXHQgICAgICAgIHRoaXMucls1XSA9ICh0NCA+Pj4gMSkgJiAweDFmZmU7XG5cdCAgICAgICAgdGhpcy5yWzZdID0gKCh0NCA+Pj4gMTQpIHwgKHQ1IDw8IDIpKSAmIDB4MWZmZjtcblx0ICAgICAgICB0aGlzLnJbN10gPSAoKHQ1ID4+PiAxMSkgfCAodDYgPDwgNSkpICYgMHgxZjgxO1xuXHQgICAgICAgIHRoaXMucls4XSA9ICgodDYgPj4+IDgpIHwgKHQ3IDw8IDgpKSAmIDB4MWZmZjtcblx0ICAgICAgICB0aGlzLnJbOV0gPSAodDcgPj4+IDUpICYgMHgwMDdmO1xuXHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKVxuXHQgICAgICAgICAgICB0aGlzLnBhZFtpXSA9IHU4dG8xNihrZXksIDE2ICsgMiAqIGkpO1xuXHQgICAgfVxuXHQgICAgcHJvY2VzcyhkYXRhLCBvZmZzZXQsIGlzTGFzdCA9IGZhbHNlKSB7XG5cdCAgICAgICAgY29uc3QgaGliaXQgPSBpc0xhc3QgPyAwIDogMSA8PCAxMTtcblx0ICAgICAgICBjb25zdCB7IGgsIHIgfSA9IHRoaXM7XG5cdCAgICAgICAgY29uc3QgcjAgPSByWzBdO1xuXHQgICAgICAgIGNvbnN0IHIxID0gclsxXTtcblx0ICAgICAgICBjb25zdCByMiA9IHJbMl07XG5cdCAgICAgICAgY29uc3QgcjMgPSByWzNdO1xuXHQgICAgICAgIGNvbnN0IHI0ID0gcls0XTtcblx0ICAgICAgICBjb25zdCByNSA9IHJbNV07XG5cdCAgICAgICAgY29uc3QgcjYgPSByWzZdO1xuXHQgICAgICAgIGNvbnN0IHI3ID0gcls3XTtcblx0ICAgICAgICBjb25zdCByOCA9IHJbOF07XG5cdCAgICAgICAgY29uc3QgcjkgPSByWzldO1xuXHQgICAgICAgIGNvbnN0IHQwID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDApO1xuXHQgICAgICAgIGNvbnN0IHQxID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDIpO1xuXHQgICAgICAgIGNvbnN0IHQyID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDQpO1xuXHQgICAgICAgIGNvbnN0IHQzID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDYpO1xuXHQgICAgICAgIGNvbnN0IHQ0ID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDgpO1xuXHQgICAgICAgIGNvbnN0IHQ1ID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDEwKTtcblx0ICAgICAgICBjb25zdCB0NiA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyAxMik7XG5cdCAgICAgICAgY29uc3QgdDcgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMTQpO1xuXHQgICAgICAgIGxldCBoMCA9IGhbMF0gKyAodDAgJiAweDFmZmYpO1xuXHQgICAgICAgIGxldCBoMSA9IGhbMV0gKyAoKCh0MCA+Pj4gMTMpIHwgKHQxIDw8IDMpKSAmIDB4MWZmZik7XG5cdCAgICAgICAgbGV0IGgyID0gaFsyXSArICgoKHQxID4+PiAxMCkgfCAodDIgPDwgNikpICYgMHgxZmZmKTtcblx0ICAgICAgICBsZXQgaDMgPSBoWzNdICsgKCgodDIgPj4+IDcpIHwgKHQzIDw8IDkpKSAmIDB4MWZmZik7XG5cdCAgICAgICAgbGV0IGg0ID0gaFs0XSArICgoKHQzID4+PiA0KSB8ICh0NCA8PCAxMikpICYgMHgxZmZmKTtcblx0ICAgICAgICBsZXQgaDUgPSBoWzVdICsgKCh0NCA+Pj4gMSkgJiAweDFmZmYpO1xuXHQgICAgICAgIGxldCBoNiA9IGhbNl0gKyAoKCh0NCA+Pj4gMTQpIHwgKHQ1IDw8IDIpKSAmIDB4MWZmZik7XG5cdCAgICAgICAgbGV0IGg3ID0gaFs3XSArICgoKHQ1ID4+PiAxMSkgfCAodDYgPDwgNSkpICYgMHgxZmZmKTtcblx0ICAgICAgICBsZXQgaDggPSBoWzhdICsgKCgodDYgPj4+IDgpIHwgKHQ3IDw8IDgpKSAmIDB4MWZmZik7XG5cdCAgICAgICAgbGV0IGg5ID0gaFs5XSArICgodDcgPj4+IDUpIHwgaGliaXQpO1xuXHQgICAgICAgIGxldCBjID0gMDtcblx0ICAgICAgICBsZXQgZDAgPSBjICsgaDAgKiByMCArIGgxICogKDUgKiByOSkgKyBoMiAqICg1ICogcjgpICsgaDMgKiAoNSAqIHI3KSArIGg0ICogKDUgKiByNik7XG5cdCAgICAgICAgYyA9IGQwID4+PiAxMztcblx0ICAgICAgICBkMCAmPSAweDFmZmY7XG5cdCAgICAgICAgZDAgKz0gaDUgKiAoNSAqIHI1KSArIGg2ICogKDUgKiByNCkgKyBoNyAqICg1ICogcjMpICsgaDggKiAoNSAqIHIyKSArIGg5ICogKDUgKiByMSk7XG5cdCAgICAgICAgYyArPSBkMCA+Pj4gMTM7XG5cdCAgICAgICAgZDAgJj0gMHgxZmZmO1xuXHQgICAgICAgIGxldCBkMSA9IGMgKyBoMCAqIHIxICsgaDEgKiByMCArIGgyICogKDUgKiByOSkgKyBoMyAqICg1ICogcjgpICsgaDQgKiAoNSAqIHI3KTtcblx0ICAgICAgICBjID0gZDEgPj4+IDEzO1xuXHQgICAgICAgIGQxICY9IDB4MWZmZjtcblx0ICAgICAgICBkMSArPSBoNSAqICg1ICogcjYpICsgaDYgKiAoNSAqIHI1KSArIGg3ICogKDUgKiByNCkgKyBoOCAqICg1ICogcjMpICsgaDkgKiAoNSAqIHIyKTtcblx0ICAgICAgICBjICs9IGQxID4+PiAxMztcblx0ICAgICAgICBkMSAmPSAweDFmZmY7XG5cdCAgICAgICAgbGV0IGQyID0gYyArIGgwICogcjIgKyBoMSAqIHIxICsgaDIgKiByMCArIGgzICogKDUgKiByOSkgKyBoNCAqICg1ICogcjgpO1xuXHQgICAgICAgIGMgPSBkMiA+Pj4gMTM7XG5cdCAgICAgICAgZDIgJj0gMHgxZmZmO1xuXHQgICAgICAgIGQyICs9IGg1ICogKDUgKiByNykgKyBoNiAqICg1ICogcjYpICsgaDcgKiAoNSAqIHI1KSArIGg4ICogKDUgKiByNCkgKyBoOSAqICg1ICogcjMpO1xuXHQgICAgICAgIGMgKz0gZDIgPj4+IDEzO1xuXHQgICAgICAgIGQyICY9IDB4MWZmZjtcblx0ICAgICAgICBsZXQgZDMgPSBjICsgaDAgKiByMyArIGgxICogcjIgKyBoMiAqIHIxICsgaDMgKiByMCArIGg0ICogKDUgKiByOSk7XG5cdCAgICAgICAgYyA9IGQzID4+PiAxMztcblx0ICAgICAgICBkMyAmPSAweDFmZmY7XG5cdCAgICAgICAgZDMgKz0gaDUgKiAoNSAqIHI4KSArIGg2ICogKDUgKiByNykgKyBoNyAqICg1ICogcjYpICsgaDggKiAoNSAqIHI1KSArIGg5ICogKDUgKiByNCk7XG5cdCAgICAgICAgYyArPSBkMyA+Pj4gMTM7XG5cdCAgICAgICAgZDMgJj0gMHgxZmZmO1xuXHQgICAgICAgIGxldCBkNCA9IGMgKyBoMCAqIHI0ICsgaDEgKiByMyArIGgyICogcjIgKyBoMyAqIHIxICsgaDQgKiByMDtcblx0ICAgICAgICBjID0gZDQgPj4+IDEzO1xuXHQgICAgICAgIGQ0ICY9IDB4MWZmZjtcblx0ICAgICAgICBkNCArPSBoNSAqICg1ICogcjkpICsgaDYgKiAoNSAqIHI4KSArIGg3ICogKDUgKiByNykgKyBoOCAqICg1ICogcjYpICsgaDkgKiAoNSAqIHI1KTtcblx0ICAgICAgICBjICs9IGQ0ID4+PiAxMztcblx0ICAgICAgICBkNCAmPSAweDFmZmY7XG5cdCAgICAgICAgbGV0IGQ1ID0gYyArIGgwICogcjUgKyBoMSAqIHI0ICsgaDIgKiByMyArIGgzICogcjIgKyBoNCAqIHIxO1xuXHQgICAgICAgIGMgPSBkNSA+Pj4gMTM7XG5cdCAgICAgICAgZDUgJj0gMHgxZmZmO1xuXHQgICAgICAgIGQ1ICs9IGg1ICogcjAgKyBoNiAqICg1ICogcjkpICsgaDcgKiAoNSAqIHI4KSArIGg4ICogKDUgKiByNykgKyBoOSAqICg1ICogcjYpO1xuXHQgICAgICAgIGMgKz0gZDUgPj4+IDEzO1xuXHQgICAgICAgIGQ1ICY9IDB4MWZmZjtcblx0ICAgICAgICBsZXQgZDYgPSBjICsgaDAgKiByNiArIGgxICogcjUgKyBoMiAqIHI0ICsgaDMgKiByMyArIGg0ICogcjI7XG5cdCAgICAgICAgYyA9IGQ2ID4+PiAxMztcblx0ICAgICAgICBkNiAmPSAweDFmZmY7XG5cdCAgICAgICAgZDYgKz0gaDUgKiByMSArIGg2ICogcjAgKyBoNyAqICg1ICogcjkpICsgaDggKiAoNSAqIHI4KSArIGg5ICogKDUgKiByNyk7XG5cdCAgICAgICAgYyArPSBkNiA+Pj4gMTM7XG5cdCAgICAgICAgZDYgJj0gMHgxZmZmO1xuXHQgICAgICAgIGxldCBkNyA9IGMgKyBoMCAqIHI3ICsgaDEgKiByNiArIGgyICogcjUgKyBoMyAqIHI0ICsgaDQgKiByMztcblx0ICAgICAgICBjID0gZDcgPj4+IDEzO1xuXHQgICAgICAgIGQ3ICY9IDB4MWZmZjtcblx0ICAgICAgICBkNyArPSBoNSAqIHIyICsgaDYgKiByMSArIGg3ICogcjAgKyBoOCAqICg1ICogcjkpICsgaDkgKiAoNSAqIHI4KTtcblx0ICAgICAgICBjICs9IGQ3ID4+PiAxMztcblx0ICAgICAgICBkNyAmPSAweDFmZmY7XG5cdCAgICAgICAgbGV0IGQ4ID0gYyArIGgwICogcjggKyBoMSAqIHI3ICsgaDIgKiByNiArIGgzICogcjUgKyBoNCAqIHI0O1xuXHQgICAgICAgIGMgPSBkOCA+Pj4gMTM7XG5cdCAgICAgICAgZDggJj0gMHgxZmZmO1xuXHQgICAgICAgIGQ4ICs9IGg1ICogcjMgKyBoNiAqIHIyICsgaDcgKiByMSArIGg4ICogcjAgKyBoOSAqICg1ICogcjkpO1xuXHQgICAgICAgIGMgKz0gZDggPj4+IDEzO1xuXHQgICAgICAgIGQ4ICY9IDB4MWZmZjtcblx0ICAgICAgICBsZXQgZDkgPSBjICsgaDAgKiByOSArIGgxICogcjggKyBoMiAqIHI3ICsgaDMgKiByNiArIGg0ICogcjU7XG5cdCAgICAgICAgYyA9IGQ5ID4+PiAxMztcblx0ICAgICAgICBkOSAmPSAweDFmZmY7XG5cdCAgICAgICAgZDkgKz0gaDUgKiByNCArIGg2ICogcjMgKyBoNyAqIHIyICsgaDggKiByMSArIGg5ICogcjA7XG5cdCAgICAgICAgYyArPSBkOSA+Pj4gMTM7XG5cdCAgICAgICAgZDkgJj0gMHgxZmZmO1xuXHQgICAgICAgIGMgPSAoKGMgPDwgMikgKyBjKSB8IDA7XG5cdCAgICAgICAgYyA9IChjICsgZDApIHwgMDtcblx0ICAgICAgICBkMCA9IGMgJiAweDFmZmY7XG5cdCAgICAgICAgYyA9IGMgPj4+IDEzO1xuXHQgICAgICAgIGQxICs9IGM7XG5cdCAgICAgICAgaFswXSA9IGQwO1xuXHQgICAgICAgIGhbMV0gPSBkMTtcblx0ICAgICAgICBoWzJdID0gZDI7XG5cdCAgICAgICAgaFszXSA9IGQzO1xuXHQgICAgICAgIGhbNF0gPSBkNDtcblx0ICAgICAgICBoWzVdID0gZDU7XG5cdCAgICAgICAgaFs2XSA9IGQ2O1xuXHQgICAgICAgIGhbN10gPSBkNztcblx0ICAgICAgICBoWzhdID0gZDg7XG5cdCAgICAgICAgaFs5XSA9IGQ5O1xuXHQgICAgfVxuXHQgICAgZmluYWxpemUoKSB7XG5cdCAgICAgICAgY29uc3QgeyBoLCBwYWQgfSA9IHRoaXM7XG5cdCAgICAgICAgY29uc3QgZyA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG5cdCAgICAgICAgbGV0IGMgPSBoWzFdID4+PiAxMztcblx0ICAgICAgICBoWzFdICY9IDB4MWZmZjtcblx0ICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IDEwOyBpKyspIHtcblx0ICAgICAgICAgICAgaFtpXSArPSBjO1xuXHQgICAgICAgICAgICBjID0gaFtpXSA+Pj4gMTM7XG5cdCAgICAgICAgICAgIGhbaV0gJj0gMHgxZmZmO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBoWzBdICs9IGMgKiA1O1xuXHQgICAgICAgIGMgPSBoWzBdID4+PiAxMztcblx0ICAgICAgICBoWzBdICY9IDB4MWZmZjtcblx0ICAgICAgICBoWzFdICs9IGM7XG5cdCAgICAgICAgYyA9IGhbMV0gPj4+IDEzO1xuXHQgICAgICAgIGhbMV0gJj0gMHgxZmZmO1xuXHQgICAgICAgIGhbMl0gKz0gYztcblx0ICAgICAgICBnWzBdID0gaFswXSArIDU7XG5cdCAgICAgICAgYyA9IGdbMF0gPj4+IDEzO1xuXHQgICAgICAgIGdbMF0gJj0gMHgxZmZmO1xuXHQgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgMTA7IGkrKykge1xuXHQgICAgICAgICAgICBnW2ldID0gaFtpXSArIGM7XG5cdCAgICAgICAgICAgIGMgPSBnW2ldID4+PiAxMztcblx0ICAgICAgICAgICAgZ1tpXSAmPSAweDFmZmY7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGdbOV0gLT0gMSA8PCAxMztcblx0ICAgICAgICBsZXQgbWFzayA9IChjIF4gMSkgLSAxO1xuXHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKylcblx0ICAgICAgICAgICAgZ1tpXSAmPSBtYXNrO1xuXHQgICAgICAgIG1hc2sgPSB+bWFzaztcblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspXG5cdCAgICAgICAgICAgIGhbaV0gPSAoaFtpXSAmIG1hc2spIHwgZ1tpXTtcblx0ICAgICAgICBoWzBdID0gKGhbMF0gfCAoaFsxXSA8PCAxMykpICYgMHhmZmZmO1xuXHQgICAgICAgIGhbMV0gPSAoKGhbMV0gPj4+IDMpIHwgKGhbMl0gPDwgMTApKSAmIDB4ZmZmZjtcblx0ICAgICAgICBoWzJdID0gKChoWzJdID4+PiA2KSB8IChoWzNdIDw8IDcpKSAmIDB4ZmZmZjtcblx0ICAgICAgICBoWzNdID0gKChoWzNdID4+PiA5KSB8IChoWzRdIDw8IDQpKSAmIDB4ZmZmZjtcblx0ICAgICAgICBoWzRdID0gKChoWzRdID4+PiAxMikgfCAoaFs1XSA8PCAxKSB8IChoWzZdIDw8IDE0KSkgJiAweGZmZmY7XG5cdCAgICAgICAgaFs1XSA9ICgoaFs2XSA+Pj4gMikgfCAoaFs3XSA8PCAxMSkpICYgMHhmZmZmO1xuXHQgICAgICAgIGhbNl0gPSAoKGhbN10gPj4+IDUpIHwgKGhbOF0gPDwgOCkpICYgMHhmZmZmO1xuXHQgICAgICAgIGhbN10gPSAoKGhbOF0gPj4+IDgpIHwgKGhbOV0gPDwgNSkpICYgMHhmZmZmO1xuXHQgICAgICAgIGxldCBmID0gaFswXSArIHBhZFswXTtcblx0ICAgICAgICBoWzBdID0gZiAmIDB4ZmZmZjtcblx0ICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICBmID0gKCgoaFtpXSArIHBhZFtpXSkgfCAwKSArIChmID4+PiAxNikpIHwgMDtcblx0ICAgICAgICAgICAgaFtpXSA9IGYgJiAweGZmZmY7XG5cdCAgICAgICAgfVxuXHQgICAgICAgICgwLCB1dGlsc19qc18xLmNsZWFuKShnKTtcblx0ICAgIH1cblx0ICAgIHVwZGF0ZShkYXRhKSB7XG5cdCAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hZXhpc3RzKSh0aGlzKTtcblx0ICAgICAgICBjb25zdCB7IGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG5cdCAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuXHQgICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuXHQgICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcblx0ICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG5cdCAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXRcblx0ICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGEsIHBvcyk7XG5cdCAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuXHQgICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuXHQgICAgICAgICAgICBwb3MgKz0gdGFrZTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGJ1ZmZlciwgMCwgZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXHQgICAgZGVzdHJveSgpIHtcblx0ICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikodGhpcy5oLCB0aGlzLnIsIHRoaXMuYnVmZmVyLCB0aGlzLnBhZCk7XG5cdCAgICB9XG5cdCAgICBkaWdlc3RJbnRvKG91dCkge1xuXHQgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWV4aXN0cykodGhpcyk7XG5cdCAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hb3V0cHV0KShvdXQsIHRoaXMpO1xuXHQgICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuXHQgICAgICAgIGNvbnN0IHsgYnVmZmVyLCBoIH0gPSB0aGlzO1xuXHQgICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcblx0ICAgICAgICBpZiAocG9zKSB7XG5cdCAgICAgICAgICAgIGJ1ZmZlcltwb3MrK10gPSAxO1xuXHQgICAgICAgICAgICBmb3IgKDsgcG9zIDwgMTY7IHBvcysrKVxuXHQgICAgICAgICAgICAgICAgYnVmZmVyW3Bvc10gPSAwO1xuXHQgICAgICAgICAgICB0aGlzLnByb2Nlc3MoYnVmZmVyLCAwLCB0cnVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5maW5hbGl6ZSgpO1xuXHQgICAgICAgIGxldCBvcG9zID0gMDtcblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICBvdXRbb3BvcysrXSA9IGhbaV0gPj4+IDA7XG5cdCAgICAgICAgICAgIG91dFtvcG9zKytdID0gaFtpXSA+Pj4gODtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG91dDtcblx0ICAgIH1cblx0ICAgIGRpZ2VzdCgpIHtcblx0ICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuXHQgICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuXHQgICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuXHQgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuXHQgICAgICAgIHJldHVybiByZXM7XG5cdCAgICB9XG5cdH1cblx0ZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aEtleShoYXNoQ29ucykge1xuXHQgICAgY29uc3QgaGFzaEMgPSAobXNnLCBrZXkpID0+IGhhc2hDb25zKGtleSkudXBkYXRlKCgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKG1zZykpLmRpZ2VzdCgpO1xuXHQgICAgY29uc3QgdG1wID0gaGFzaENvbnMobmV3IFVpbnQ4QXJyYXkoMzIpKTtcblx0ICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG5cdCAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcblx0ICAgIGhhc2hDLmNyZWF0ZSA9IChrZXkpID0+IGhhc2hDb25zKGtleSk7XG5cdCAgICByZXR1cm4gaGFzaEM7XG5cdH1cblx0LyoqIFBvbHkxMzA1IE1BQyBmcm9tIFJGQyA4NDM5LiAqL1xuXHRfcG9seTEzMDUucG9seTEzMDUgPSB3cmFwQ29uc3RydWN0b3JXaXRoS2V5KChrZXkpID0+IG5ldyBQb2x5MTMwNShrZXkpKTtcblx0XG5cdHJldHVybiBfcG9seTEzMDU7XG59XG5cbnZhciBoYXNSZXF1aXJlZENoYWNoYTtcblxuZnVuY3Rpb24gcmVxdWlyZUNoYWNoYSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENoYWNoYSkgcmV0dXJuIGNoYWNoYTtcblx0aGFzUmVxdWlyZWRDaGFjaGEgPSAxO1xuXHQoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0ZXhwb3J0cy54Y2hhY2hhMjBwb2x5MTMwNSA9IGV4cG9ydHMuY2hhY2hhMjBwb2x5MTMwNSA9IGV4cG9ydHMuX3BvbHkxMzA1X2FlYWQgPSBleHBvcnRzLmNoYWNoYTEyID0gZXhwb3J0cy5jaGFjaGE4ID0gZXhwb3J0cy54Y2hhY2hhMjAgPSBleHBvcnRzLmNoYWNoYTIwID0gZXhwb3J0cy5jaGFjaGEyMG9yaWcgPSB2b2lkIDA7XG5cdFx0ZXhwb3J0cy5oY2hhY2hhID0gaGNoYWNoYTtcblx0XHQvKipcblx0XHQgKiBbQ2hhQ2hhMjBdKGh0dHBzOi8vY3IueXAudG8vY2hhY2hhLmh0bWwpIHN0cmVhbSBjaXBoZXIsIHJlbGVhc2VkXG5cdFx0ICogaW4gMjAwOC4gRGV2ZWxvcGVkIGFmdGVyIFNhbHNhMjAsIENoYUNoYSBhaW1zIHRvIGluY3JlYXNlIGRpZmZ1c2lvbiBwZXIgcm91bmQuXG5cdFx0ICogSXQgd2FzIHN0YW5kYXJkaXplZCBpbiBbUkZDIDg0MzldKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjODQzOSkgYW5kXG5cdFx0ICogaXMgbm93IHVzZWQgaW4gVExTIDEuMy5cblx0XHQgKlxuXHRcdCAqIFtYQ2hhQ2hhMjBdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXhjaGFjaGEpXG5cdFx0ICogZXh0ZW5kZWQtbm9uY2UgdmFyaWFudCBpcyBhbHNvIHByb3ZpZGVkLiBTaW1pbGFyIHRvIFhTYWxzYSwgaXQncyBzYWZlIHRvIHVzZSB3aXRoXG5cdFx0ICogcmFuZG9tbHktZ2VuZXJhdGVkIG5vbmNlcy5cblx0XHQgKlxuXHRcdCAqIENoZWNrIG91dCBbUERGXShodHRwOi8vY3IueXAudG8vY2hhY2hhL2NoYWNoYS0yMDA4MDEyOC5wZGYpIGFuZFxuXHRcdCAqIFt3aWtpXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TYWxzYTIwKS5cblx0XHQgKiBAbW9kdWxlXG5cdFx0ICovXG5cdFx0Y29uc3QgX2FyeF9qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlX2FyeCgpO1xuXHRcdGNvbnN0IF9wb2x5MTMwNV9qc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlX3BvbHkxMzA1KCk7XG5cdFx0Y29uc3QgdXRpbHNfanNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZVV0aWxzJDMoKTtcblx0XHQvKipcblx0XHQgKiBDaGFDaGEgY29yZSBmdW5jdGlvbi5cblx0XHQgKi9cblx0XHQvLyBwcmV0dGllci1pZ25vcmVcblx0XHRmdW5jdGlvbiBjaGFjaGFDb3JlKHMsIGssIG4sIG91dCwgY250LCByb3VuZHMgPSAyMCkge1xuXHRcdCAgICBsZXQgeTAwID0gc1swXSwgeTAxID0gc1sxXSwgeTAyID0gc1syXSwgeTAzID0gc1szXSwgLy8gXCJleHBhXCIgICBcIm5kIDNcIiAgXCIyLWJ5XCIgIFwidGUga1wiXG5cdFx0ICAgIHkwNCA9IGtbMF0sIHkwNSA9IGtbMV0sIHkwNiA9IGtbMl0sIHkwNyA9IGtbM10sIC8vIEtleSAgICAgIEtleSAgICAgS2V5ICAgICBLZXlcblx0XHQgICAgeTA4ID0ga1s0XSwgeTA5ID0ga1s1XSwgeTEwID0ga1s2XSwgeTExID0ga1s3XSwgLy8gS2V5ICAgICAgS2V5ICAgICBLZXkgICAgIEtleVxuXHRcdCAgICB5MTIgPSBjbnQsIHkxMyA9IG5bMF0sIHkxNCA9IG5bMV0sIHkxNSA9IG5bMl07IC8vIENvdW50ZXIgIENvdW50ZXJcdE5vbmNlICAgTm9uY2Vcblx0XHQgICAgLy8gU2F2ZSBzdGF0ZSB0byB0ZW1wb3JhcnkgdmFyaWFibGVzXG5cdFx0ICAgIGxldCB4MDAgPSB5MDAsIHgwMSA9IHkwMSwgeDAyID0geTAyLCB4MDMgPSB5MDMsIHgwNCA9IHkwNCwgeDA1ID0geTA1LCB4MDYgPSB5MDYsIHgwNyA9IHkwNywgeDA4ID0geTA4LCB4MDkgPSB5MDksIHgxMCA9IHkxMCwgeDExID0geTExLCB4MTIgPSB5MTIsIHgxMyA9IHkxMywgeDE0ID0geTE0LCB4MTUgPSB5MTU7XG5cdFx0ICAgIGZvciAobGV0IHIgPSAwOyByIDwgcm91bmRzOyByICs9IDIpIHtcblx0XHQgICAgICAgIHgwMCA9ICh4MDAgKyB4MDQpIHwgMDtcblx0XHQgICAgICAgIHgxMiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEyIF4geDAwLCAxNik7XG5cdFx0ICAgICAgICB4MDggPSAoeDA4ICsgeDEyKSB8IDA7XG5cdFx0ICAgICAgICB4MDQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNCBeIHgwOCwgMTIpO1xuXHRcdCAgICAgICAgeDAwID0gKHgwMCArIHgwNCkgfCAwO1xuXHRcdCAgICAgICAgeDEyID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTIgXiB4MDAsIDgpO1xuXHRcdCAgICAgICAgeDA4ID0gKHgwOCArIHgxMikgfCAwO1xuXHRcdCAgICAgICAgeDA0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDQgXiB4MDgsIDcpO1xuXHRcdCAgICAgICAgeDAxID0gKHgwMSArIHgwNSkgfCAwO1xuXHRcdCAgICAgICAgeDEzID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTMgXiB4MDEsIDE2KTtcblx0XHQgICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcblx0XHQgICAgICAgIHgwNSA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDA1IF4geDA5LCAxMik7XG5cdFx0ICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG5cdFx0ICAgICAgICB4MTMgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxMyBeIHgwMSwgOCk7XG5cdFx0ICAgICAgICB4MDkgPSAoeDA5ICsgeDEzKSB8IDA7XG5cdFx0ICAgICAgICB4MDUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNSBeIHgwOSwgNyk7XG5cdFx0ICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG5cdFx0ICAgICAgICB4MTQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxNCBeIHgwMiwgMTYpO1xuXHRcdCAgICAgICAgeDEwID0gKHgxMCArIHgxNCkgfCAwO1xuXHRcdCAgICAgICAgeDA2ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDYgXiB4MTAsIDEyKTtcblx0XHQgICAgICAgIHgwMiA9ICh4MDIgKyB4MDYpIHwgMDtcblx0XHQgICAgICAgIHgxNCA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE0IF4geDAyLCA4KTtcblx0XHQgICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcblx0XHQgICAgICAgIHgwNiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDA2IF4geDEwLCA3KTtcblx0XHQgICAgICAgIHgwMyA9ICh4MDMgKyB4MDcpIHwgMDtcblx0XHQgICAgICAgIHgxNSA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE1IF4geDAzLCAxNik7XG5cdFx0ICAgICAgICB4MTEgPSAoeDExICsgeDE1KSB8IDA7XG5cdFx0ICAgICAgICB4MDcgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNyBeIHgxMSwgMTIpO1xuXHRcdCAgICAgICAgeDAzID0gKHgwMyArIHgwNykgfCAwO1xuXHRcdCAgICAgICAgeDE1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTUgXiB4MDMsIDgpO1xuXHRcdCAgICAgICAgeDExID0gKHgxMSArIHgxNSkgfCAwO1xuXHRcdCAgICAgICAgeDA3ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDcgXiB4MTEsIDcpO1xuXHRcdCAgICAgICAgeDAwID0gKHgwMCArIHgwNSkgfCAwO1xuXHRcdCAgICAgICAgeDE1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTUgXiB4MDAsIDE2KTtcblx0XHQgICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcblx0XHQgICAgICAgIHgwNSA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDA1IF4geDEwLCAxMik7XG5cdFx0ICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG5cdFx0ICAgICAgICB4MTUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxNSBeIHgwMCwgOCk7XG5cdFx0ICAgICAgICB4MTAgPSAoeDEwICsgeDE1KSB8IDA7XG5cdFx0ICAgICAgICB4MDUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNSBeIHgxMCwgNyk7XG5cdFx0ICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG5cdFx0ICAgICAgICB4MTIgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxMiBeIHgwMSwgMTYpO1xuXHRcdCAgICAgICAgeDExID0gKHgxMSArIHgxMikgfCAwO1xuXHRcdCAgICAgICAgeDA2ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDYgXiB4MTEsIDEyKTtcblx0XHQgICAgICAgIHgwMSA9ICh4MDEgKyB4MDYpIHwgMDtcblx0XHQgICAgICAgIHgxMiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEyIF4geDAxLCA4KTtcblx0XHQgICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcblx0XHQgICAgICAgIHgwNiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDA2IF4geDExLCA3KTtcblx0XHQgICAgICAgIHgwMiA9ICh4MDIgKyB4MDcpIHwgMDtcblx0XHQgICAgICAgIHgxMyA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEzIF4geDAyLCAxNik7XG5cdFx0ICAgICAgICB4MDggPSAoeDA4ICsgeDEzKSB8IDA7XG5cdFx0ICAgICAgICB4MDcgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNyBeIHgwOCwgMTIpO1xuXHRcdCAgICAgICAgeDAyID0gKHgwMiArIHgwNykgfCAwO1xuXHRcdCAgICAgICAgeDEzID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTMgXiB4MDIsIDgpO1xuXHRcdCAgICAgICAgeDA4ID0gKHgwOCArIHgxMykgfCAwO1xuXHRcdCAgICAgICAgeDA3ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDcgXiB4MDgsIDcpO1xuXHRcdCAgICAgICAgeDAzID0gKHgwMyArIHgwNCkgfCAwO1xuXHRcdCAgICAgICAgeDE0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTQgXiB4MDMsIDE2KTtcblx0XHQgICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcblx0XHQgICAgICAgIHgwNCA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDA0IF4geDA5LCAxMik7XG5cdFx0ICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG5cdFx0ICAgICAgICB4MTQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxNCBeIHgwMywgOCk7XG5cdFx0ICAgICAgICB4MDkgPSAoeDA5ICsgeDE0KSB8IDA7XG5cdFx0ICAgICAgICB4MDQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNCBeIHgwOSwgNyk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gV3JpdGUgb3V0cHV0XG5cdFx0ICAgIGxldCBvaSA9IDA7XG5cdFx0ICAgIG91dFtvaSsrXSA9ICh5MDAgKyB4MDApIHwgMDtcblx0XHQgICAgb3V0W29pKytdID0gKHkwMSArIHgwMSkgfCAwO1xuXHRcdCAgICBvdXRbb2krK10gPSAoeTAyICsgeDAyKSB8IDA7XG5cdFx0ICAgIG91dFtvaSsrXSA9ICh5MDMgKyB4MDMpIHwgMDtcblx0XHQgICAgb3V0W29pKytdID0gKHkwNCArIHgwNCkgfCAwO1xuXHRcdCAgICBvdXRbb2krK10gPSAoeTA1ICsgeDA1KSB8IDA7XG5cdFx0ICAgIG91dFtvaSsrXSA9ICh5MDYgKyB4MDYpIHwgMDtcblx0XHQgICAgb3V0W29pKytdID0gKHkwNyArIHgwNykgfCAwO1xuXHRcdCAgICBvdXRbb2krK10gPSAoeTA4ICsgeDA4KSB8IDA7XG5cdFx0ICAgIG91dFtvaSsrXSA9ICh5MDkgKyB4MDkpIHwgMDtcblx0XHQgICAgb3V0W29pKytdID0gKHkxMCArIHgxMCkgfCAwO1xuXHRcdCAgICBvdXRbb2krK10gPSAoeTExICsgeDExKSB8IDA7XG5cdFx0ICAgIG91dFtvaSsrXSA9ICh5MTIgKyB4MTIpIHwgMDtcblx0XHQgICAgb3V0W29pKytdID0gKHkxMyArIHgxMykgfCAwO1xuXHRcdCAgICBvdXRbb2krK10gPSAoeTE0ICsgeDE0KSB8IDA7XG5cdFx0ICAgIG91dFtvaSsrXSA9ICh5MTUgKyB4MTUpIHwgMDtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogaGNoYWNoYSBoZWxwZXIgbWV0aG9kLCB1c2VkIHByaW1hcmlseSBpbiB4Y2hhY2hhLCB0byBoYXNoXG5cdFx0ICoga2V5IGFuZCBub25jZSBpbnRvIGtleScgYW5kIG5vbmNlJy5cblx0XHQgKiBTYW1lIGFzIGNoYWNoYUNvcmUsIGJ1dCB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSB3YXkgdG8gbW92ZSB0aGUgYmxvY2tcblx0XHQgKiBvdXQgd2l0aG91dCAyNSUgcGVyZm9ybWFuY2UgaGl0LlxuXHRcdCAqL1xuXHRcdC8vIHByZXR0aWVyLWlnbm9yZVxuXHRcdGZ1bmN0aW9uIGhjaGFjaGEocywgaywgaSwgbzMyKSB7XG5cdFx0ICAgIGxldCB4MDAgPSBzWzBdLCB4MDEgPSBzWzFdLCB4MDIgPSBzWzJdLCB4MDMgPSBzWzNdLCB4MDQgPSBrWzBdLCB4MDUgPSBrWzFdLCB4MDYgPSBrWzJdLCB4MDcgPSBrWzNdLCB4MDggPSBrWzRdLCB4MDkgPSBrWzVdLCB4MTAgPSBrWzZdLCB4MTEgPSBrWzddLCB4MTIgPSBpWzBdLCB4MTMgPSBpWzFdLCB4MTQgPSBpWzJdLCB4MTUgPSBpWzNdO1xuXHRcdCAgICBmb3IgKGxldCByID0gMDsgciA8IDIwOyByICs9IDIpIHtcblx0XHQgICAgICAgIHgwMCA9ICh4MDAgKyB4MDQpIHwgMDtcblx0XHQgICAgICAgIHgxMiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEyIF4geDAwLCAxNik7XG5cdFx0ICAgICAgICB4MDggPSAoeDA4ICsgeDEyKSB8IDA7XG5cdFx0ICAgICAgICB4MDQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNCBeIHgwOCwgMTIpO1xuXHRcdCAgICAgICAgeDAwID0gKHgwMCArIHgwNCkgfCAwO1xuXHRcdCAgICAgICAgeDEyID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTIgXiB4MDAsIDgpO1xuXHRcdCAgICAgICAgeDA4ID0gKHgwOCArIHgxMikgfCAwO1xuXHRcdCAgICAgICAgeDA0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDQgXiB4MDgsIDcpO1xuXHRcdCAgICAgICAgeDAxID0gKHgwMSArIHgwNSkgfCAwO1xuXHRcdCAgICAgICAgeDEzID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTMgXiB4MDEsIDE2KTtcblx0XHQgICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcblx0XHQgICAgICAgIHgwNSA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDA1IF4geDA5LCAxMik7XG5cdFx0ICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG5cdFx0ICAgICAgICB4MTMgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxMyBeIHgwMSwgOCk7XG5cdFx0ICAgICAgICB4MDkgPSAoeDA5ICsgeDEzKSB8IDA7XG5cdFx0ICAgICAgICB4MDUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNSBeIHgwOSwgNyk7XG5cdFx0ICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG5cdFx0ICAgICAgICB4MTQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxNCBeIHgwMiwgMTYpO1xuXHRcdCAgICAgICAgeDEwID0gKHgxMCArIHgxNCkgfCAwO1xuXHRcdCAgICAgICAgeDA2ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDYgXiB4MTAsIDEyKTtcblx0XHQgICAgICAgIHgwMiA9ICh4MDIgKyB4MDYpIHwgMDtcblx0XHQgICAgICAgIHgxNCA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE0IF4geDAyLCA4KTtcblx0XHQgICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcblx0XHQgICAgICAgIHgwNiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDA2IF4geDEwLCA3KTtcblx0XHQgICAgICAgIHgwMyA9ICh4MDMgKyB4MDcpIHwgMDtcblx0XHQgICAgICAgIHgxNSA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE1IF4geDAzLCAxNik7XG5cdFx0ICAgICAgICB4MTEgPSAoeDExICsgeDE1KSB8IDA7XG5cdFx0ICAgICAgICB4MDcgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNyBeIHgxMSwgMTIpO1xuXHRcdCAgICAgICAgeDAzID0gKHgwMyArIHgwNykgfCAwO1xuXHRcdCAgICAgICAgeDE1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTUgXiB4MDMsIDgpO1xuXHRcdCAgICAgICAgeDExID0gKHgxMSArIHgxNSkgfCAwO1xuXHRcdCAgICAgICAgeDA3ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDcgXiB4MTEsIDcpO1xuXHRcdCAgICAgICAgeDAwID0gKHgwMCArIHgwNSkgfCAwO1xuXHRcdCAgICAgICAgeDE1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTUgXiB4MDAsIDE2KTtcblx0XHQgICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcblx0XHQgICAgICAgIHgwNSA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDA1IF4geDEwLCAxMik7XG5cdFx0ICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG5cdFx0ICAgICAgICB4MTUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxNSBeIHgwMCwgOCk7XG5cdFx0ICAgICAgICB4MTAgPSAoeDEwICsgeDE1KSB8IDA7XG5cdFx0ICAgICAgICB4MDUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNSBeIHgxMCwgNyk7XG5cdFx0ICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG5cdFx0ICAgICAgICB4MTIgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxMiBeIHgwMSwgMTYpO1xuXHRcdCAgICAgICAgeDExID0gKHgxMSArIHgxMikgfCAwO1xuXHRcdCAgICAgICAgeDA2ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDYgXiB4MTEsIDEyKTtcblx0XHQgICAgICAgIHgwMSA9ICh4MDEgKyB4MDYpIHwgMDtcblx0XHQgICAgICAgIHgxMiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEyIF4geDAxLCA4KTtcblx0XHQgICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcblx0XHQgICAgICAgIHgwNiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDA2IF4geDExLCA3KTtcblx0XHQgICAgICAgIHgwMiA9ICh4MDIgKyB4MDcpIHwgMDtcblx0XHQgICAgICAgIHgxMyA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEzIF4geDAyLCAxNik7XG5cdFx0ICAgICAgICB4MDggPSAoeDA4ICsgeDEzKSB8IDA7XG5cdFx0ICAgICAgICB4MDcgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNyBeIHgwOCwgMTIpO1xuXHRcdCAgICAgICAgeDAyID0gKHgwMiArIHgwNykgfCAwO1xuXHRcdCAgICAgICAgeDEzID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTMgXiB4MDIsIDgpO1xuXHRcdCAgICAgICAgeDA4ID0gKHgwOCArIHgxMykgfCAwO1xuXHRcdCAgICAgICAgeDA3ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDcgXiB4MDgsIDcpO1xuXHRcdCAgICAgICAgeDAzID0gKHgwMyArIHgwNCkgfCAwO1xuXHRcdCAgICAgICAgeDE0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTQgXiB4MDMsIDE2KTtcblx0XHQgICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcblx0XHQgICAgICAgIHgwNCA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDA0IF4geDA5LCAxMik7XG5cdFx0ICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG5cdFx0ICAgICAgICB4MTQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxNCBeIHgwMywgOCk7XG5cdFx0ICAgICAgICB4MDkgPSAoeDA5ICsgeDE0KSB8IDA7XG5cdFx0ICAgICAgICB4MDQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNCBeIHgwOSwgNyk7XG5cdFx0ICAgIH1cblx0XHQgICAgbGV0IG9pID0gMDtcblx0XHQgICAgbzMyW29pKytdID0geDAwO1xuXHRcdCAgICBvMzJbb2krK10gPSB4MDE7XG5cdFx0ICAgIG8zMltvaSsrXSA9IHgwMjtcblx0XHQgICAgbzMyW29pKytdID0geDAzO1xuXHRcdCAgICBvMzJbb2krK10gPSB4MTI7XG5cdFx0ICAgIG8zMltvaSsrXSA9IHgxMztcblx0XHQgICAgbzMyW29pKytdID0geDE0O1xuXHRcdCAgICBvMzJbb2krK10gPSB4MTU7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIE9yaWdpbmFsLCBub24tUkZDIGNoYWNoYTIwIGZyb20gREpCLiA4LWJ5dGUgbm9uY2UsIDgtYnl0ZSBjb3VudGVyLlxuXHRcdCAqL1xuXHRcdGV4cG9ydHMuY2hhY2hhMjBvcmlnID0gKDAsIF9hcnhfanNfMS5jcmVhdGVDaXBoZXIpKGNoYWNoYUNvcmUsIHtcblx0XHQgICAgY291bnRlclJpZ2h0OiBmYWxzZSxcblx0XHQgICAgY291bnRlckxlbmd0aDogOCxcblx0XHQgICAgYWxsb3dTaG9ydEtleXM6IHRydWUsXG5cdFx0fSk7XG5cdFx0LyoqXG5cdFx0ICogQ2hhQ2hhIHN0cmVhbSBjaXBoZXIuIENvbmZvcm1zIHRvIFJGQyA4NDM5IChJRVRGLCBUTFMpLiAxMi1ieXRlIG5vbmNlLCA0LWJ5dGUgY291bnRlci5cblx0XHQgKiBXaXRoIDEyLWJ5dGUgbm9uY2UsIGl0J3Mgbm90IHNhZmUgdG8gdXNlIGZpbGwgaXQgd2l0aCByYW5kb20gKENTUFJORyksIGR1ZSB0byBjb2xsaXNpb24gY2hhbmNlLlxuXHRcdCAqL1xuXHRcdGV4cG9ydHMuY2hhY2hhMjAgPSAoMCwgX2FyeF9qc18xLmNyZWF0ZUNpcGhlcikoY2hhY2hhQ29yZSwge1xuXHRcdCAgICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuXHRcdCAgICBjb3VudGVyTGVuZ3RoOiA0LFxuXHRcdCAgICBhbGxvd1Nob3J0S2V5czogZmFsc2UsXG5cdFx0fSk7XG5cdFx0LyoqXG5cdFx0ICogWENoYUNoYSBlWHRlbmRlZC1ub25jZSBDaGFDaGEuIDI0LWJ5dGUgbm9uY2UuXG5cdFx0ICogV2l0aCAyNC1ieXRlIG5vbmNlLCBpdCdzIHNhZmUgdG8gdXNlIGZpbGwgaXQgd2l0aCByYW5kb20gKENTUFJORykuXG5cdFx0ICogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmcteGNoYWNoYVxuXHRcdCAqL1xuXHRcdGV4cG9ydHMueGNoYWNoYTIwID0gKDAsIF9hcnhfanNfMS5jcmVhdGVDaXBoZXIpKGNoYWNoYUNvcmUsIHtcblx0XHQgICAgY291bnRlclJpZ2h0OiBmYWxzZSxcblx0XHQgICAgY291bnRlckxlbmd0aDogOCxcblx0XHQgICAgZXh0ZW5kTm9uY2VGbjogaGNoYWNoYSxcblx0XHQgICAgYWxsb3dTaG9ydEtleXM6IGZhbHNlLFxuXHRcdH0pO1xuXHRcdC8qKlxuXHRcdCAqIFJlZHVjZWQgOC1yb3VuZCBjaGFjaGEsIGRlc2NyaWJlZCBpbiBvcmlnaW5hbCBwYXBlci5cblx0XHQgKi9cblx0XHRleHBvcnRzLmNoYWNoYTggPSAoMCwgX2FyeF9qc18xLmNyZWF0ZUNpcGhlcikoY2hhY2hhQ29yZSwge1xuXHRcdCAgICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuXHRcdCAgICBjb3VudGVyTGVuZ3RoOiA0LFxuXHRcdCAgICByb3VuZHM6IDgsXG5cdFx0fSk7XG5cdFx0LyoqXG5cdFx0ICogUmVkdWNlZCAxMi1yb3VuZCBjaGFjaGEsIGRlc2NyaWJlZCBpbiBvcmlnaW5hbCBwYXBlci5cblx0XHQgKi9cblx0XHRleHBvcnRzLmNoYWNoYTEyID0gKDAsIF9hcnhfanNfMS5jcmVhdGVDaXBoZXIpKGNoYWNoYUNvcmUsIHtcblx0XHQgICAgY291bnRlclJpZ2h0OiBmYWxzZSxcblx0XHQgICAgY291bnRlckxlbmd0aDogNCxcblx0XHQgICAgcm91bmRzOiAxMixcblx0XHR9KTtcblx0XHRjb25zdCBaRVJPUzE2ID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50OEFycmF5KDE2KTtcblx0XHQvLyBQYWQgdG8gZGlnZXN0IHNpemUgd2l0aCB6ZXJvc1xuXHRcdGNvbnN0IHVwZGF0ZVBhZGRlZCA9IChoLCBtc2cpID0+IHtcblx0XHQgICAgaC51cGRhdGUobXNnKTtcblx0XHQgICAgY29uc3QgbGVmdCA9IG1zZy5sZW5ndGggJSAxNjtcblx0XHQgICAgaWYgKGxlZnQpXG5cdFx0ICAgICAgICBoLnVwZGF0ZShaRVJPUzE2LnN1YmFycmF5KGxlZnQpKTtcblx0XHR9O1xuXHRcdGNvbnN0IFpFUk9TMzIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuXHRcdGZ1bmN0aW9uIGNvbXB1dGVUYWcoZm4sIGtleSwgbm9uY2UsIGRhdGEsIEFBRCkge1xuXHRcdCAgICBjb25zdCBhdXRoS2V5ID0gZm4oa2V5LCBub25jZSwgWkVST1MzMik7XG5cdFx0ICAgIGNvbnN0IGggPSBfcG9seTEzMDVfanNfMS5wb2x5MTMwNS5jcmVhdGUoYXV0aEtleSk7XG5cdFx0ICAgIGlmIChBQUQpXG5cdFx0ICAgICAgICB1cGRhdGVQYWRkZWQoaCwgQUFEKTtcblx0XHQgICAgdXBkYXRlUGFkZGVkKGgsIGRhdGEpO1xuXHRcdCAgICBjb25zdCBudW0gPSBuZXcgVWludDhBcnJheSgxNik7XG5cdFx0ICAgIGNvbnN0IHZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShudW0pO1xuXHRcdCAgICAoMCwgdXRpbHNfanNfMS5zZXRCaWdVaW50NjQpKHZpZXcsIDAsIEJpZ0ludChBQUQgPyBBQUQubGVuZ3RoIDogMCksIHRydWUpO1xuXHRcdCAgICAoMCwgdXRpbHNfanNfMS5zZXRCaWdVaW50NjQpKHZpZXcsIDgsIEJpZ0ludChkYXRhLmxlbmd0aCksIHRydWUpO1xuXHRcdCAgICBoLnVwZGF0ZShudW0pO1xuXHRcdCAgICBjb25zdCByZXMgPSBoLmRpZ2VzdCgpO1xuXHRcdCAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoYXV0aEtleSwgbnVtKTtcblx0XHQgICAgcmV0dXJuIHJlcztcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogQUVBRCBhbGdvcml0aG0gZnJvbSBSRkMgODQzOS5cblx0XHQgKiBTYWxzYTIwIGFuZCBjaGFjaGEgKFJGQyA4NDM5KSB1c2UgcG9seTEzMDUgZGlmZmVyZW50bHkuXG5cdFx0ICogV2UgY291bGQgaGF2ZSBjb21wb3NlZCB0aGVtIHNpbWlsYXIgdG86XG5cdFx0ICogaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9zY3VyZS1iYXNlL2Jsb2IvYjI2NmM3M2RkZTk3N2IxZGQ3ZWY0MGVmN2EyM2NjMTVhYWI1MjZiMy9pbmRleC50cyNMMjUwXG5cdFx0ICogQnV0IGl0J3MgaGFyZCBiZWNhdXNlIG9mIGF1dGhLZXk6XG5cdFx0ICogSW4gc2Fsc2EyMCwgYXV0aEtleSBjaGFuZ2VzIHBvc2l0aW9uIGluIHNhbHNhIHN0cmVhbS5cblx0XHQgKiBJbiBjaGFjaGEsIGF1dGhLZXkgY2FuJ3QgYmUgY29tcHV0ZWQgaW5zaWRlIGNvbXB1dGVUYWcsIGl0IG1vZGlmaWVzIHRoZSBjb3VudGVyLlxuXHRcdCAqL1xuXHRcdGNvbnN0IF9wb2x5MTMwNV9hZWFkID0gKHhvclN0cmVhbSkgPT4gKGtleSwgbm9uY2UsIEFBRCkgPT4ge1xuXHRcdCAgICBjb25zdCB0YWdMZW5ndGggPSAxNjtcblx0XHQgICAgcmV0dXJuIHtcblx0XHQgICAgICAgIGVuY3J5cHQocGxhaW50ZXh0LCBvdXRwdXQpIHtcblx0XHQgICAgICAgICAgICBjb25zdCBwbGVuZ3RoID0gcGxhaW50ZXh0Lmxlbmd0aDtcblx0XHQgICAgICAgICAgICBvdXRwdXQgPSAoMCwgdXRpbHNfanNfMS5nZXRPdXRwdXQpKHBsZW5ndGggKyB0YWdMZW5ndGgsIG91dHB1dCwgZmFsc2UpO1xuXHRcdCAgICAgICAgICAgIG91dHB1dC5zZXQocGxhaW50ZXh0KTtcblx0XHQgICAgICAgICAgICBjb25zdCBvUGxhaW4gPSBvdXRwdXQuc3ViYXJyYXkoMCwgLXRhZ0xlbmd0aCk7XG5cdFx0ICAgICAgICAgICAgeG9yU3RyZWFtKGtleSwgbm9uY2UsIG9QbGFpbiwgb1BsYWluLCAxKTtcblx0XHQgICAgICAgICAgICBjb25zdCB0YWcgPSBjb21wdXRlVGFnKHhvclN0cmVhbSwga2V5LCBub25jZSwgb1BsYWluLCBBQUQpO1xuXHRcdCAgICAgICAgICAgIG91dHB1dC5zZXQodGFnLCBwbGVuZ3RoKTsgLy8gYXBwZW5kIHRhZ1xuXHRcdCAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmNsZWFuKSh0YWcpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG5cdFx0ICAgICAgICB9LFxuXHRcdCAgICAgICAgZGVjcnlwdChjaXBoZXJ0ZXh0LCBvdXRwdXQpIHtcblx0XHQgICAgICAgICAgICBvdXRwdXQgPSAoMCwgdXRpbHNfanNfMS5nZXRPdXRwdXQpKGNpcGhlcnRleHQubGVuZ3RoIC0gdGFnTGVuZ3RoLCBvdXRwdXQsIGZhbHNlKTtcblx0XHQgICAgICAgICAgICBjb25zdCBkYXRhID0gY2lwaGVydGV4dC5zdWJhcnJheSgwLCAtdGFnTGVuZ3RoKTtcblx0XHQgICAgICAgICAgICBjb25zdCBwYXNzZWRUYWcgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KC10YWdMZW5ndGgpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHRhZyA9IGNvbXB1dGVUYWcoeG9yU3RyZWFtLCBrZXksIG5vbmNlLCBkYXRhLCBBQUQpO1xuXHRcdCAgICAgICAgICAgIGlmICghKDAsIHV0aWxzX2pzXzEuZXF1YWxCeXRlcykocGFzc2VkVGFnLCB0YWcpKVxuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdGFnJyk7XG5cdFx0ICAgICAgICAgICAgb3V0cHV0LnNldChjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIC10YWdMZW5ndGgpKTtcblx0XHQgICAgICAgICAgICB4b3JTdHJlYW0oa2V5LCBub25jZSwgb3V0cHV0LCBvdXRwdXQsIDEpOyAvLyBzdGFydCBzdHJlYW0gd2l0aCBpPTFcblx0XHQgICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikodGFnKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuXHRcdCAgICAgICAgfSxcblx0XHQgICAgfTtcblx0XHR9O1xuXHRcdGV4cG9ydHMuX3BvbHkxMzA1X2FlYWQgPSBfcG9seTEzMDVfYWVhZDtcblx0XHQvKipcblx0XHQgKiBDaGFDaGEyMC1Qb2x5MTMwNSBmcm9tIFJGQyA4NDM5LlxuXHRcdCAqXG5cdFx0ICogVW5zYWZlIHRvIHVzZSByYW5kb20gbm9uY2VzIHVuZGVyIHRoZSBzYW1lIGtleSwgZHVlIHRvIGNvbGxpc2lvbiBjaGFuY2UuXG5cdFx0ICogUHJlZmVyIFhDaGFDaGEgaW5zdGVhZC5cblx0XHQgKi9cblx0XHRleHBvcnRzLmNoYWNoYTIwcG9seTEzMDUgPSAoMCwgdXRpbHNfanNfMS53cmFwQ2lwaGVyKSh7IGJsb2NrU2l6ZTogNjQsIG5vbmNlTGVuZ3RoOiAxMiwgdGFnTGVuZ3RoOiAxNiB9LCAoMCwgZXhwb3J0cy5fcG9seTEzMDVfYWVhZCkoZXhwb3J0cy5jaGFjaGEyMCkpO1xuXHRcdC8qKlxuXHRcdCAqIFhDaGFDaGEyMC1Qb2x5MTMwNSBleHRlbmRlZC1ub25jZSBjaGFjaGEuXG5cdFx0ICpcblx0XHQgKiBDYW4gYmUgc2FmZWx5IHVzZWQgd2l0aCByYW5kb20gbm9uY2VzIChDU1BSTkcpLlxuXHRcdCAqIFNlZSBbSVJURiBkcmFmdF0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmcteGNoYWNoYSkuXG5cdFx0ICovXG5cdFx0ZXhwb3J0cy54Y2hhY2hhMjBwb2x5MTMwNSA9ICgwLCB1dGlsc19qc18xLndyYXBDaXBoZXIpKHsgYmxvY2tTaXplOiA2NCwgbm9uY2VMZW5ndGg6IDI0LCB0YWdMZW5ndGg6IDE2IH0sICgwLCBleHBvcnRzLl9wb2x5MTMwNV9hZWFkKShleHBvcnRzLnhjaGFjaGEyMCkpO1xuXHRcdFxuXHR9IChjaGFjaGEpKTtcblx0cmV0dXJuIGNoYWNoYTtcbn1cblxudmFyIGhhc1JlcXVpcmVkTm9ibGU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVOb2JsZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZE5vYmxlKSByZXR1cm4gbm9ibGU7XG5cdGhhc1JlcXVpcmVkTm9ibGUgPSAxO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ibGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRub2JsZS5jaGFjaGEyMCA9IG5vYmxlLnhjaGFjaGEyMCA9IHZvaWQgMDtcblx0dmFyIGNoYWNoYV8xID0gLypAX19QVVJFX18qLyByZXF1aXJlQ2hhY2hhKCk7XG5cdHZhciB4Y2hhY2hhMjAgPSBmdW5jdGlvbiAoa2V5LCBub25jZSwgQUFEKSB7XG5cdCAgICByZXR1cm4gKDAsIGNoYWNoYV8xLnhjaGFjaGEyMHBvbHkxMzA1KShrZXksIG5vbmNlLCBBQUQpO1xuXHR9O1xuXHRub2JsZS54Y2hhY2hhMjAgPSB4Y2hhY2hhMjA7XG5cdHZhciBjaGFjaGEyMCA9IGZ1bmN0aW9uIChrZXksIG5vbmNlLCBBQUQpIHtcblx0ICAgIHJldHVybiAoMCwgY2hhY2hhXzEuY2hhY2hhMjBwb2x5MTMwNSkoa2V5LCBub25jZSwgQUFEKTtcblx0fTtcblx0bm9ibGUuY2hhY2hhMjAgPSBjaGFjaGEyMDtcblx0cmV0dXJuIG5vYmxlO1xufVxuXG52YXIgaGFzUmVxdWlyZWRTeW1tZXRyaWM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVTeW1tZXRyaWMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRTeW1tZXRyaWMpIHJldHVybiBzeW1tZXRyaWM7XG5cdGhhc1JlcXVpcmVkU3ltbWV0cmljID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRcdGV4cG9ydHMuYWVzRGVjcnlwdCA9IGV4cG9ydHMuYWVzRW5jcnlwdCA9IGV4cG9ydHMuc3ltRGVjcnlwdCA9IGV4cG9ydHMuc3ltRW5jcnlwdCA9IHZvaWQgMDtcblx0XHR2YXIgdXRpbHNfMSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZVV0aWxzJDMoKTtcblx0XHR2YXIgd2ViY3J5cHRvXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVXZWJjcnlwdG8oKTtcblx0XHR2YXIgYWVzXzEgPSByZXF1aXJlTm9ibGUkMSgpO1xuXHRcdHZhciBjaGFjaGFfMSA9IHJlcXVpcmVOb2JsZSgpO1xuXHRcdHZhciBjb25maWdfMSA9IHJlcXVpcmVDb25maWcoKTtcblx0XHR2YXIgY29uc3RzXzEgPSByZXF1aXJlQ29uc3RzKCk7XG5cdFx0dmFyIHN5bUVuY3J5cHQgPSBmdW5jdGlvbiAoa2V5LCBwbGFpblRleHQsIEFBRCkgeyByZXR1cm4gX2V4ZWMoX2VuY3J5cHQsIGtleSwgcGxhaW5UZXh0LCBBQUQpOyB9O1xuXHRcdGV4cG9ydHMuc3ltRW5jcnlwdCA9IHN5bUVuY3J5cHQ7XG5cdFx0dmFyIHN5bURlY3J5cHQgPSBmdW5jdGlvbiAoa2V5LCBjaXBoZXJUZXh0LCBBQUQpIHsgcmV0dXJuIF9leGVjKF9kZWNyeXB0LCBrZXksIGNpcGhlclRleHQsIEFBRCk7IH07XG5cdFx0ZXhwb3J0cy5zeW1EZWNyeXB0ID0gc3ltRGVjcnlwdDtcblx0XHQvKiogQGRlcHJlY2F0ZWQgLSB1c2UgYHN5bUVuY3J5cHRgIGluc3RlYWQuICovXG5cdFx0ZXhwb3J0cy5hZXNFbmNyeXB0ID0gZXhwb3J0cy5zeW1FbmNyeXB0OyAvLyBUT0RPOiBkZWxldGVcblx0XHQvKiogQGRlcHJlY2F0ZWQgLSB1c2UgYHN5bURlY3J5cHRgIGluc3RlYWQuICovXG5cdFx0ZXhwb3J0cy5hZXNEZWNyeXB0ID0gZXhwb3J0cy5zeW1EZWNyeXB0OyAvLyBUT0RPOiBkZWxldGVcblx0XHRmdW5jdGlvbiBfZXhlYyhjYWxsYmFjaywga2V5LCBkYXRhLCBBQUQpIHtcblx0XHQgICAgdmFyIGFsZ29yaXRobSA9ICgwLCBjb25maWdfMS5zeW1tZXRyaWNBbGdvcml0aG0pKCk7XG5cdFx0ICAgIGlmIChhbGdvcml0aG0gPT09IFwiYWVzLTI1Ni1nY21cIikge1xuXHRcdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFlc18xLmFlczI1NmdjbSwga2V5LCBkYXRhLCAoMCwgY29uZmlnXzEuc3ltbWV0cmljTm9uY2VMZW5ndGgpKCksIGNvbnN0c18xLkFFQURfVEFHX0xFTkdUSCwgQUFEKTtcblx0XHQgICAgfVxuXHRcdCAgICBlbHNlIGlmIChhbGdvcml0aG0gPT09IFwieGNoYWNoYTIwXCIpIHtcblx0XHQgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGFjaGFfMS54Y2hhY2hhMjAsIGtleSwgZGF0YSwgY29uc3RzXzEuWENIQUNIQTIwX05PTkNFX0xFTkdUSCwgY29uc3RzXzEuQUVBRF9UQUdfTEVOR1RILCBBQUQpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGVsc2UgaWYgKGFsZ29yaXRobSA9PT0gXCJhZXMtMjU2LWNiY1wiKSB7XG5cdFx0ICAgICAgICAvLyBOT1QgUkVDT01NRU5ERUQuIFRoZXJlIGlzIG5laXRoZXIgQUFEIG5vciBBRUFEIHRhZyBpbiBjYmMgbW9kZVxuXHRcdCAgICAgICAgLy8gYWVzLTI1Ni1jYmMgYWx3YXlzIHVzZXMgMTYgYnl0ZXMgaXZcblx0XHQgICAgICAgIHJldHVybiBjYWxsYmFjayhhZXNfMS5hZXMyNTZjYmMsIGtleSwgZGF0YSwgMTYsIDApO1xuXHRcdCAgICB9XG5cdFx0ICAgIGVsc2Uge1xuXHRcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuXHRcdCAgICB9XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIF9lbmNyeXB0KGZ1bmMsIGtleSwgZGF0YSwgbm9uY2VMZW5ndGgsIHRhZ0xlbmd0aCwgQUFEKSB7XG5cdFx0ICAgIHZhciBub25jZSA9ICgwLCB3ZWJjcnlwdG9fMS5yYW5kb21CeXRlcykobm9uY2VMZW5ndGgpO1xuXHRcdCAgICB2YXIgY2lwaGVyID0gZnVuYyhrZXksIG5vbmNlLCBBQUQpO1xuXHRcdCAgICAvLyBAbm9ibGUvY2lwaGVycyBmb3JtYXQ6IGNpcGhlclRleHQgfHwgdGFnXG5cdFx0ICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZW5jcnlwdChkYXRhKTtcblx0XHQgICAgaWYgKHRhZ0xlbmd0aCA9PT0gMCkge1xuXHRcdCAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShub25jZSwgZW5jcnlwdGVkKTtcblx0XHQgICAgfVxuXHRcdCAgICB2YXIgY2lwaGVyVGV4dExlbmd0aCA9IGVuY3J5cHRlZC5sZW5ndGggLSB0YWdMZW5ndGg7XG5cdFx0ICAgIHZhciBjaXBoZXJUZXh0ID0gZW5jcnlwdGVkLnN1YmFycmF5KDAsIGNpcGhlclRleHRMZW5ndGgpO1xuXHRcdCAgICB2YXIgdGFnID0gZW5jcnlwdGVkLnN1YmFycmF5KGNpcGhlclRleHRMZW5ndGgpO1xuXHRcdCAgICAvLyBlY2llcyBwYXlsb2FkIGZvcm1hdDogcGsgfHwgbm9uY2UgfHwgdGFnIHx8IGNpcGhlclRleHRcblx0XHQgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShub25jZSwgdGFnLCBjaXBoZXJUZXh0KTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gX2RlY3J5cHQoZnVuYywga2V5LCBkYXRhLCBub25jZUxlbmd0aCwgdGFnTGVuZ3RoLCBBQUQpIHtcblx0XHQgICAgdmFyIG5vbmNlID0gZGF0YS5zdWJhcnJheSgwLCBub25jZUxlbmd0aCk7XG5cdFx0ICAgIHZhciBjaXBoZXIgPSBmdW5jKGtleSwgVWludDhBcnJheS5mcm9tKG5vbmNlKSwgQUFEKTsgLy8gdG8gcmVzZXQgYnl0ZU9mZnNldFxuXHRcdCAgICB2YXIgZW5jcnlwdGVkID0gZGF0YS5zdWJhcnJheShub25jZUxlbmd0aCk7XG5cdFx0ICAgIGlmICh0YWdMZW5ndGggPT09IDApIHtcblx0XHQgICAgICAgIHJldHVybiBjaXBoZXIuZGVjcnlwdChlbmNyeXB0ZWQpO1xuXHRcdCAgICB9XG5cdFx0ICAgIHZhciB0YWcgPSBlbmNyeXB0ZWQuc3ViYXJyYXkoMCwgdGFnTGVuZ3RoKTtcblx0XHQgICAgdmFyIGNpcGhlclRleHQgPSBlbmNyeXB0ZWQuc3ViYXJyYXkodGFnTGVuZ3RoKTtcblx0XHQgICAgcmV0dXJuIGNpcGhlci5kZWNyeXB0KCgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShjaXBoZXJUZXh0LCB0YWcpKTtcblx0XHR9IFxuXHR9IChzeW1tZXRyaWMpKTtcblx0cmV0dXJuIHN5bW1ldHJpYztcbn1cblxudmFyIGhhc1JlcXVpcmVkVXRpbHM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVVdGlscyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFV0aWxzKSByZXR1cm4gdXRpbHMkNDtcblx0aGFzUmVxdWlyZWRVdGlscyA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdHZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodXRpbHMkNCAmJiB1dGlscyQ0Ll9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcblx0XHQgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcblx0XHQgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXHRcdCAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuXHRcdCAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcblx0XHR9KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuXHRcdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHRcdCAgICBvW2syXSA9IG1ba107XG5cdFx0fSkpO1xuXHRcdHZhciBfX2V4cG9ydFN0YXIgPSAodXRpbHMkNCAmJiB1dGlscyQ0Ll9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuXHRcdCAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG5cdFx0fTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0X19leHBvcnRTdGFyKHJlcXVpcmVFbGxpcHRpYygpLCBleHBvcnRzKTtcblx0XHRfX2V4cG9ydFN0YXIocmVxdWlyZUhhc2goKSwgZXhwb3J0cyk7XG5cdFx0X19leHBvcnRTdGFyKHJlcXVpcmVIZXgoKSwgZXhwb3J0cyk7XG5cdFx0X19leHBvcnRTdGFyKHJlcXVpcmVTeW1tZXRyaWMoKSwgZXhwb3J0cyk7IFxuXHR9ICh1dGlscyQ0KSk7XG5cdHJldHVybiB1dGlscyQ0O1xufVxuXG52YXIgUHVibGljS2V5ID0ge307XG5cbnZhciBoYXNSZXF1aXJlZFB1YmxpY0tleTtcblxuZnVuY3Rpb24gcmVxdWlyZVB1YmxpY0tleSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFB1YmxpY0tleSkgcmV0dXJuIFB1YmxpY0tleTtcblx0aGFzUmVxdWlyZWRQdWJsaWNLZXkgPSAxO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoUHVibGljS2V5LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0UHVibGljS2V5LlB1YmxpY0tleSA9IHZvaWQgMDtcblx0dmFyIHV0aWxzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVVdGlscyQzKCk7XG5cdHZhciB1dGlsc18yID0gcmVxdWlyZVV0aWxzKCk7XG5cdHZhciBQdWJsaWNLZXkkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFB1YmxpY0tleShkYXRhKSB7XG5cdCAgICAgICAgLy8gZGF0YSBjYW4gYmUgZWl0aGVyIGNvbXByZXNzZWQgb3IgdW5jb21wcmVzc2VkIGlmIHNlY3AyNTZrMVxuXHQgICAgICAgIHZhciBjb21wcmVzc2VkID0gKDAsIHV0aWxzXzIuY29udmVydFB1YmxpY0tleUZvcm1hdCkoZGF0YSwgdHJ1ZSk7XG5cdCAgICAgICAgdmFyIHVuY29tcHJlc3NlZCA9ICgwLCB1dGlsc18yLmNvbnZlcnRQdWJsaWNLZXlGb3JtYXQpKGRhdGEsIGZhbHNlKTtcblx0ICAgICAgICB0aGlzLmRhdGEgPSBjb21wcmVzc2VkO1xuXHQgICAgICAgIHRoaXMuZGF0YVVuY29tcHJlc3NlZCA9XG5cdCAgICAgICAgICAgIGNvbXByZXNzZWQubGVuZ3RoICE9PSB1bmNvbXByZXNzZWQubGVuZ3RoID8gdW5jb21wcmVzc2VkIDogbnVsbDtcblx0ICAgIH1cblx0ICAgIFB1YmxpY0tleS5mcm9tSGV4ID0gZnVuY3Rpb24gKGhleCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KCgwLCB1dGlsc18yLmhleFRvUHVibGljS2V5KShoZXgpKTtcblx0ICAgIH07XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHVibGljS2V5LnByb3RvdHlwZSwgXCJfdW5jb21wcmVzc2VkXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVVuY29tcHJlc3NlZCAhPT0gbnVsbCA/IHRoaXMuZGF0YVVuY29tcHJlc3NlZCA6IHRoaXMuZGF0YTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHVibGljS2V5LnByb3RvdHlwZSwgXCJ1bmNvbXByZXNzZWRcIiwge1xuXHQgICAgICAgIC8qKiBAZGVwcmVjYXRlZCAtIHVzZSBgUHVibGljS2V5LnRvQnl0ZXMoZmFsc2UpYCBpbnN0ZWFkLiBZb3UgbWF5IGFsc28gbmVlZCBgQnVmZmVyLmZyb21gLiAqL1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5fdW5jb21wcmVzc2VkKTsgLy8gVE9ETzogZGVsZXRlXG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFB1YmxpY0tleS5wcm90b3R5cGUsIFwiY29tcHJlc3NlZFwiLCB7XG5cdCAgICAgICAgLyoqIEBkZXByZWNhdGVkIC0gdXNlIGBQdWJsaWNLZXkudG9CeXRlcygpYCBpbnN0ZWFkLiBZb3UgbWF5IGFsc28gbmVlZCBgQnVmZmVyLmZyb21gLiAqL1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5kYXRhKTsgLy8gVE9ETzogZGVsZXRlXG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgUHVibGljS2V5LnByb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gKGNvbXByZXNzZWQpIHtcblx0ICAgICAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSB0cnVlOyB9XG5cdCAgICAgICAgcmV0dXJuIGNvbXByZXNzZWQgPyB0aGlzLmRhdGEgOiB0aGlzLl91bmNvbXByZXNzZWQ7XG5cdCAgICB9O1xuXHQgICAgUHVibGljS2V5LnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uIChjb21wcmVzc2VkKSB7XG5cdCAgICAgICAgaWYgKGNvbXByZXNzZWQgPT09IHZvaWQgMCkgeyBjb21wcmVzc2VkID0gdHJ1ZTsgfVxuXHQgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KSh0aGlzLnRvQnl0ZXMoY29tcHJlc3NlZCkpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogRGVyaXZlcyBhIHNoYXJlZCBzZWNyZXQgZnJvbSByZWNlaXZlcidzIHByaXZhdGUga2V5IChzaykgYW5kIGVwaGVtZXJhbCBwdWJsaWMga2V5ICh0aGlzKS5cblx0ICAgICAqIE9wcG9zaXRlIG9mIGBlbmNhcHN1bGF0ZWAuXG5cdCAgICAgKiBAc2VlIFByaXZhdGVLZXkuZW5jYXBzdWxhdGVcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gc2sgLSBSZWNlaXZlcidzIHByaXZhdGUga2V5LlxuXHQgICAgICogQHBhcmFtIGNvbXByZXNzZWQgLSAoZGVmYXVsdDogYGZhbHNlYCkgV2hldGhlciB0byB1c2UgY29tcHJlc3NlZCBvciB1bmNvbXByZXNzZWQgcHVibGljIGtleXMgaW4gdGhlIGtleSBkZXJpdmF0aW9uIChzZWNwMjU2azEgb25seSkuXG5cdCAgICAgKiBAcmV0dXJucyBTaGFyZWQgc2VjcmV0LCBkZXJpdmVkIHdpdGggSEtERi1TSEEyNTYuXG5cdCAgICAgKi9cblx0ICAgIFB1YmxpY0tleS5wcm90b3R5cGUuZGVjYXBzdWxhdGUgPSBmdW5jdGlvbiAoc2ssIGNvbXByZXNzZWQpIHtcblx0ICAgICAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSBmYWxzZTsgfVxuXHQgICAgICAgIHZhciBzZW5kZXJQb2ludCA9IHRoaXMudG9CeXRlcyhjb21wcmVzc2VkKTtcblx0ICAgICAgICB2YXIgc2hhcmVkUG9pbnQgPSBzay5tdWx0aXBseSh0aGlzLCBjb21wcmVzc2VkKTtcblx0ICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIuZ2V0U2hhcmVkS2V5KShzZW5kZXJQb2ludCwgc2hhcmVkUG9pbnQpO1xuXHQgICAgfTtcblx0ICAgIFB1YmxpY0tleS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmVxdWFsQnl0ZXMpKHRoaXMuZGF0YSwgb3RoZXIuZGF0YSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFB1YmxpY0tleTtcblx0fSgpKTtcblx0UHVibGljS2V5LlB1YmxpY0tleSA9IFB1YmxpY0tleSQxO1xuXHRyZXR1cm4gUHVibGljS2V5O1xufVxuXG52YXIgaGFzUmVxdWlyZWRQcml2YXRlS2V5O1xuXG5mdW5jdGlvbiByZXF1aXJlUHJpdmF0ZUtleSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFByaXZhdGVLZXkpIHJldHVybiBQcml2YXRlS2V5O1xuXHRoYXNSZXF1aXJlZFByaXZhdGVLZXkgPSAxO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpdmF0ZUtleSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFByaXZhdGVLZXkuUHJpdmF0ZUtleSA9IHZvaWQgMDtcblx0dmFyIHV0aWxzXzEgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVVdGlscyQzKCk7XG5cdHZhciB1dGlsc18yID0gcmVxdWlyZVV0aWxzKCk7XG5cdHZhciBQdWJsaWNLZXlfMSA9IHJlcXVpcmVQdWJsaWNLZXkoKTtcblx0dmFyIFByaXZhdGVLZXkkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFByaXZhdGVLZXkoc2VjcmV0KSB7XG5cdCAgICAgICAgaWYgKHNlY3JldCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZGF0YSA9ICgwLCB1dGlsc18yLmdldFZhbGlkU2VjcmV0KSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICgoMCwgdXRpbHNfMi5pc1ZhbGlkUHJpdmF0ZUtleSkoc2VjcmV0KSkge1xuXHQgICAgICAgICAgICB0aGlzLmRhdGEgPSBzZWNyZXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByaXZhdGUga2V5XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLnB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXlfMS5QdWJsaWNLZXkoKDAsIHV0aWxzXzIuZ2V0UHVibGljS2V5KSh0aGlzLmRhdGEpKTtcblx0ICAgIH1cblx0ICAgIFByaXZhdGVLZXkuZnJvbUhleCA9IGZ1bmN0aW9uIChoZXgpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByaXZhdGVLZXkoKDAsIHV0aWxzXzIuZGVjb2RlSGV4KShoZXgpKTtcblx0ICAgIH07XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwic2VjcmV0XCIsIHtcblx0ICAgICAgICAvKiogQGRlc2NyaXB0aW9uIEZyb20gdmVyc2lvbiAwLjUuMCwgYFVpbnQ4QXJyYXlgIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBgQnVmZmVyYC4gKi9cblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gVE9ETzogVWludDhBcnJheVxuXHQgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5kYXRhKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBQcml2YXRlS2V5LnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkodGhpcy5kYXRhKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIERlcml2ZXMgYSBzaGFyZWQgc2VjcmV0IGZyb20gZXBoZW1lcmFsIHByaXZhdGUga2V5ICh0aGlzKSBhbmQgcmVjZWl2ZXIncyBwdWJsaWMga2V5IChwaykuXG5cdCAgICAgKiBAZGVzY3JpcHRpb24gVGhlIHNoYXJlZCBrZXkgaXMgMzIgYnl0ZXMsIGRlcml2ZWQgd2l0aCBgSEtERi1TSEEyNTYoc2VuZGVyUG9pbnQgfHwgc2hhcmVkUG9pbnQpYC4gU2VlIGltcGxlbWVudGF0aW9uIGZvciBkZXRhaWxzLlxuXHQgICAgICpcblx0ICAgICAqIFRoZXJlIGFyZSBzb21lIHZhcmlhdGlvbnMgaW4gZGlmZmVyZW50IEVDSUVTIGltcGxlbWVudGF0aW9uczpcblx0ICAgICAqIHdoaWNoIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSwgY29tcHJlc3NlZCBvciB1bmNvbXByZXNzZWQgYHNlbmRlclBvaW50YC9gc2hhcmVkUG9pbnRgLCB3aGV0aGVyIHRvIGluY2x1ZGUgYHNlbmRlclBvaW50YCwgZXRjLlxuXHQgICAgICpcblx0ICAgICAqIEJlY2F1c2UgdGhlIGVudHJvcHkgb2YgYHNlbmRlclBvaW50YCwgYHNoYXJlZFBvaW50YCBpcyBlbm91Z2ggaGlnaFsxXSwgd2UgZG9uJ3QgbmVlZCBzYWx0IHRvIGRlcml2ZSBrZXlzLlxuXHQgICAgICpcblx0ICAgICAqIFsxXTogVHdvIHJlYXNvbnM6IHRoZSBwdWJsaWMga2V5cyBhcmUgXCJyYW5kb21cIiBieXRlcyAoYWxiZWl0IHNlY3AyNTZrMSBwdWJsaWMga2V5cyBhcmUgKipub3QgdW5pZm9ybWx5KiogcmFuZG9tKSwgYW5kIGVwaGVtZXJhbCBrZXlzIGFyZSBnZW5lcmF0ZWQgaW4gZXZlcnkgZW5jcnlwdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gcGsgLSBSZWNlaXZlcidzIHB1YmxpYyBrZXkuXG5cdCAgICAgKiBAcGFyYW0gY29tcHJlc3NlZCAtIChkZWZhdWx0OiBgZmFsc2VgKSBXaGV0aGVyIHRvIHVzZSBjb21wcmVzc2VkIG9yIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5cyBpbiB0aGUga2V5IGRlcml2YXRpb24gKHNlY3AyNTZrMSBvbmx5KS5cblx0ICAgICAqIEByZXR1cm5zIFNoYXJlZCBzZWNyZXQsIGRlcml2ZWQgd2l0aCBIS0RGLVNIQTI1Ni5cblx0ICAgICAqL1xuXHQgICAgUHJpdmF0ZUtleS5wcm90b3R5cGUuZW5jYXBzdWxhdGUgPSBmdW5jdGlvbiAocGssIGNvbXByZXNzZWQpIHtcblx0ICAgICAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSBmYWxzZTsgfVxuXHQgICAgICAgIHZhciBzZW5kZXJQb2ludCA9IHRoaXMucHVibGljS2V5LnRvQnl0ZXMoY29tcHJlc3NlZCk7XG5cdCAgICAgICAgdmFyIHNoYXJlZFBvaW50ID0gdGhpcy5tdWx0aXBseShwaywgY29tcHJlc3NlZCk7XG5cdCAgICAgICAgcmV0dXJuICgwLCB1dGlsc18yLmdldFNoYXJlZEtleSkoc2VuZGVyUG9pbnQsIHNoYXJlZFBvaW50KTtcblx0ICAgIH07XG5cdCAgICBQcml2YXRlS2V5LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChwaywgY29tcHJlc3NlZCkge1xuXHQgICAgICAgIGlmIChjb21wcmVzc2VkID09PSB2b2lkIDApIHsgY29tcHJlc3NlZCA9IGZhbHNlOyB9XG5cdCAgICAgICAgcmV0dXJuICgwLCB1dGlsc18yLmdldFNoYXJlZFBvaW50KSh0aGlzLmRhdGEsIHBrLnRvQnl0ZXModHJ1ZSksIGNvbXByZXNzZWQpO1xuXHQgICAgfTtcblx0ICAgIFByaXZhdGVLZXkucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5lcXVhbEJ5dGVzKSh0aGlzLmRhdGEsIG90aGVyLmRhdGEpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBQcml2YXRlS2V5O1xuXHR9KCkpO1xuXHRQcml2YXRlS2V5LlByaXZhdGVLZXkgPSBQcml2YXRlS2V5JDE7XG5cdHJldHVybiBQcml2YXRlS2V5O1xufVxuXG52YXIgaGFzUmVxdWlyZWRLZXlzO1xuXG5mdW5jdGlvbiByZXF1aXJlS2V5cyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEtleXMpIHJldHVybiBrZXlzO1xuXHRoYXNSZXF1aXJlZEtleXMgPSAxO1xuXHQoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0ZXhwb3J0cy5QdWJsaWNLZXkgPSBleHBvcnRzLlByaXZhdGVLZXkgPSB2b2lkIDA7XG5cdFx0Ly8gdHJlYXQgQnVmZmVyIGFzIFVpbnQ4YXJyYXksIGkuZS4gbm8gY2FsbCBvZiBCdWZmZXIgc3BlY2lmaWMgZnVuY3Rpb25zXG5cdFx0Ly8gZmluYWxseSBVaW50OEFycmF5IG9ubHlcblx0XHR2YXIgUHJpdmF0ZUtleV8xID0gcmVxdWlyZVByaXZhdGVLZXkoKTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcml2YXRlS2V5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQcml2YXRlS2V5XzEuUHJpdmF0ZUtleTsgfSB9KTtcblx0XHR2YXIgUHVibGljS2V5XzEgPSByZXF1aXJlUHVibGljS2V5KCk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHVibGljS2V5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQdWJsaWNLZXlfMS5QdWJsaWNLZXk7IH0gfSk7IFxuXHR9IChrZXlzKSk7XG5cdHJldHVybiBrZXlzO1xufVxuXG52YXIgaGFzUmVxdWlyZWREaXN0O1xuXG5mdW5jdGlvbiByZXF1aXJlRGlzdCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZERpc3QpIHJldHVybiBkaXN0O1xuXHRoYXNSZXF1aXJlZERpc3QgPSAxO1xuXHQoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0ZXhwb3J0cy51dGlscyA9IGV4cG9ydHMuUHVibGljS2V5ID0gZXhwb3J0cy5Qcml2YXRlS2V5ID0gZXhwb3J0cy5FQ0lFU19DT05GSUcgPSB2b2lkIDA7XG5cdFx0ZXhwb3J0cy5lbmNyeXB0ID0gZW5jcnlwdDtcblx0XHRleHBvcnRzLmRlY3J5cHQgPSBkZWNyeXB0O1xuXHRcdHZhciB1dGlsc18xID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMkMygpO1xuXHRcdHZhciBjb25maWdfMSA9IHJlcXVpcmVDb25maWcoKTtcblx0XHR2YXIga2V5c18xID0gcmVxdWlyZUtleXMoKTtcblx0XHR2YXIgdXRpbHNfMiA9IHJlcXVpcmVVdGlscygpO1xuXHRcdC8qKlxuXHRcdCAqIEVuY3J5cHRzIGRhdGEgd2l0aCBhIHJlY2VpdmVyJ3MgcHVibGljIGtleS5cblx0XHQgKiBAZGVzY3JpcHRpb24gRnJvbSB2ZXJzaW9uIDAuNS4wLCBgVWludDhBcnJheWAgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGBCdWZmZXJgLlxuXHRcdCAqIFRvIGtlZXAgdGhlIHNhbWUgYmVoYXZpb3IsIHVzZSBgQnVmZmVyLmZyb20oZW5jcnlwdCguLi4pKWAuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gcmVjZWl2ZXJSYXdQSyAtIFJhdyBwdWJsaWMga2V5IG9mIHRoZSByZWNlaXZlciwgZWl0aGVyIGFzIGEgaGV4IHN0cmluZyBvciBhIFVpbnQ4QXJyYXkuXG5cdFx0ICogQHBhcmFtIGRhdGEgLSBEYXRhIHRvIGVuY3J5cHQuXG5cdFx0ICogQHJldHVybnMgRW5jcnlwdGVkIHBheWxvYWQsIGZvcm1hdDogYHB1YmxpYyBrZXkgfHwgZW5jcnlwdGVkYC5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBlbmNyeXB0KHJlY2VpdmVyUmF3UEssIGRhdGEpIHtcblx0XHQgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKF9lbmNyeXB0KHJlY2VpdmVyUmF3UEssIGRhdGEpKTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gX2VuY3J5cHQocmVjZWl2ZXJSYXdQSywgZGF0YSkge1xuXHRcdCAgICB2YXIgZXBoZW1lcmFsU0sgPSBuZXcga2V5c18xLlByaXZhdGVLZXkoKTtcblx0XHQgICAgdmFyIHJlY2VpdmVyUEsgPSByZWNlaXZlclJhd1BLIGluc3RhbmNlb2YgVWludDhBcnJheVxuXHRcdCAgICAgICAgPyBuZXcga2V5c18xLlB1YmxpY0tleShyZWNlaXZlclJhd1BLKVxuXHRcdCAgICAgICAgOiBrZXlzXzEuUHVibGljS2V5LmZyb21IZXgocmVjZWl2ZXJSYXdQSyk7XG5cdFx0ICAgIHZhciBzaGFyZWRLZXkgPSBlcGhlbWVyYWxTSy5lbmNhcHN1bGF0ZShyZWNlaXZlclBLLCAoMCwgY29uZmlnXzEuaXNIa2RmS2V5Q29tcHJlc3NlZCkoKSk7XG5cdFx0ICAgIHZhciBlcGhlbWVyYWxQSyA9IGVwaGVtZXJhbFNLLnB1YmxpY0tleS50b0J5dGVzKCgwLCBjb25maWdfMS5pc0VwaGVtZXJhbEtleUNvbXByZXNzZWQpKCkpO1xuXHRcdCAgICB2YXIgZW5jcnlwdGVkID0gKDAsIHV0aWxzXzIuc3ltRW5jcnlwdCkoc2hhcmVkS2V5LCBkYXRhKTtcblx0XHQgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShlcGhlbWVyYWxQSywgZW5jcnlwdGVkKTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogRGVjcnlwdHMgZGF0YSB3aXRoIGEgcmVjZWl2ZXIncyBwcml2YXRlIGtleS5cblx0XHQgKiBAZGVzY3JpcHRpb24gRnJvbSB2ZXJzaW9uIDAuNS4wLCBgVWludDhBcnJheWAgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGBCdWZmZXJgLlxuXHRcdCAqIFRvIGtlZXAgdGhlIHNhbWUgYmVoYXZpb3IsIHVzZSBgQnVmZmVyLmZyb20oZGVjcnlwdCguLi4pKWAuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gcmVjZWl2ZXJSYXdTSyAtIFJhdyBwcml2YXRlIGtleSBvZiB0aGUgcmVjZWl2ZXIsIGVpdGhlciBhcyBhIGhleCBzdHJpbmcgb3IgYSBVaW50OEFycmF5LlxuXHRcdCAqIEBwYXJhbSBkYXRhIC0gRGF0YSB0byBkZWNyeXB0LlxuXHRcdCAqIEByZXR1cm5zIERlY3J5cHRlZCBwbGFpbiB0ZXh0LlxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGRlY3J5cHQocmVjZWl2ZXJSYXdTSywgZGF0YSkge1xuXHRcdCAgICByZXR1cm4gQnVmZmVyLmZyb20oX2RlY3J5cHQocmVjZWl2ZXJSYXdTSywgZGF0YSkpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBfZGVjcnlwdChyZWNlaXZlclJhd1NLLCBkYXRhKSB7XG5cdFx0ICAgIHZhciByZWNlaXZlclNLID0gcmVjZWl2ZXJSYXdTSyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcblx0XHQgICAgICAgID8gbmV3IGtleXNfMS5Qcml2YXRlS2V5KHJlY2VpdmVyUmF3U0spXG5cdFx0ICAgICAgICA6IGtleXNfMS5Qcml2YXRlS2V5LmZyb21IZXgocmVjZWl2ZXJSYXdTSyk7XG5cdFx0ICAgIHZhciBrZXlTaXplID0gKDAsIGNvbmZpZ18xLmVwaGVtZXJhbEtleVNpemUpKCk7XG5cdFx0ICAgIHZhciBlcGhlbWVyYWxQSyA9IG5ldyBrZXlzXzEuUHVibGljS2V5KGRhdGEuc3ViYXJyYXkoMCwga2V5U2l6ZSkpO1xuXHRcdCAgICB2YXIgZW5jcnlwdGVkID0gZGF0YS5zdWJhcnJheShrZXlTaXplKTtcblx0XHQgICAgdmFyIHNoYXJlZEtleSA9IGVwaGVtZXJhbFBLLmRlY2Fwc3VsYXRlKHJlY2VpdmVyU0ssICgwLCBjb25maWdfMS5pc0hrZGZLZXlDb21wcmVzc2VkKSgpKTtcblx0XHQgICAgcmV0dXJuICgwLCB1dGlsc18yLnN5bURlY3J5cHQpKHNoYXJlZEtleSwgZW5jcnlwdGVkKTtcblx0XHR9XG5cdFx0dmFyIGNvbmZpZ18yID0gcmVxdWlyZUNvbmZpZygpO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVDSUVTX0NPTkZJR1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnXzIuRUNJRVNfQ09ORklHOyB9IH0pO1xuXHRcdHZhciBrZXlzXzIgPSByZXF1aXJlS2V5cygpO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByaXZhdGVLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtleXNfMi5Qcml2YXRlS2V5OyB9IH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlB1YmxpY0tleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ga2V5c18yLlB1YmxpY0tleTsgfSB9KTtcblx0XHQvKiogQGRlcHJlY2F0ZWQgLSB1c2UgYGltcG9ydCB1dGlscyBmcm9tIFwiZWNpZXNqcy91dGlsc1wiYCBpbnN0ZWFkLiAqL1xuXHRcdGV4cG9ydHMudXRpbHMgPSB7XG5cdFx0ICAgIC8vIFRPRE86IHJlbW92ZSB0aGVzZSBhZnRlciAwLjUuMFxuXHRcdCAgICBhZXNFbmNyeXB0OiB1dGlsc18yLmFlc0VuY3J5cHQsXG5cdFx0ICAgIGFlc0RlY3J5cHQ6IHV0aWxzXzIuYWVzRGVjcnlwdCxcblx0XHQgICAgc3ltRW5jcnlwdDogdXRpbHNfMi5zeW1FbmNyeXB0LFxuXHRcdCAgICBzeW1EZWNyeXB0OiB1dGlsc18yLnN5bURlY3J5cHQsXG5cdFx0ICAgIGRlY29kZUhleDogdXRpbHNfMi5kZWNvZGVIZXgsXG5cdFx0ICAgIGdldFZhbGlkU2VjcmV0OiB1dGlsc18yLmdldFZhbGlkU2VjcmV0LFxuXHRcdCAgICByZW1vdmUweDogdXRpbHNfMi5yZW1vdmUweCxcblx0XHR9OyBcblx0fSAoZGlzdCkpO1xuXHRyZXR1cm4gZGlzdDtcbn1cblxudmFyIGRpc3RFeHBvcnRzID0gcmVxdWlyZURpc3QoKTtcblxuLyoqXG4gKiBFbnZpcm9ubWVudCBkZXRlY3Rpb24gdXRpbGl0eVxuICogSGVscHMgZGlzdGluZ3Vpc2ggYmV0d2VlbiBOb2RlLmpzIGFuZCBicm93c2VyIGVudmlyb25tZW50c1xuICovXG5jb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB7XG4gICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyk7XG59O1xuY29uc3QgaXNOb2RlID0gKCkgPT4ge1xuICAgIHJldHVybiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHByb2Nlc3MudmVyc2lvbnMgJiZcbiAgICAgICAgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSB1bmRlZmluZWQpO1xufTtcbmNvbnN0IGlzV2ViV29ya2VyID0gKCkgPT4ge1xuICAgIHJldHVybiAodHlwZW9mIGdsb2JhbFRoaXMuaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyk7XG59O1xuY29uc3QgaGFzV2ViQ3J5cHRvID0gKCkgPT4ge1xuICAgIHJldHVybiAoaXNCcm93c2VyKCkgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdy5jcnlwdG8gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiB3aW5kb3cuY3J5cHRvLnN1YnRsZSAhPT0gJ3VuZGVmaW5lZCcpO1xufTtcblxuY2xhc3MgTm9kZUNyeXB0b0FkYXB0ZXIge1xuICAgIGNyeXB0bztcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGVDcnlwdG9BZGFwdGVyIGNhbiBvbmx5IGJlIHVzZWQgaW4gTm9kZS5qcyBlbnZpcm9ubWVudCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldENyeXB0bygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNyeXB0bykge1xuICAgICAgICAgICAgdGhpcy5jcnlwdG8gPSBhd2FpdCBpbXBvcnQoJ2NyeXB0bycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNyeXB0bztcbiAgICB9XG4gICAgYXN5bmMgYWVzR0NNRW5jcnlwdChrZXksIGRhdGEsIGl2KSB7XG4gICAgICAgIGNvbnN0IGNyeXB0byA9IGF3YWl0IHRoaXMuZ2V0Q3J5cHRvKCk7XG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdignYWVzLTI1Ni1nY20nLCBrZXksIGl2KTtcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkID0gQnVmZmVyLmNvbmNhdChbY2lwaGVyLnVwZGF0ZShkYXRhKSwgY2lwaGVyLmZpbmFsKCldKTtcbiAgICAgICAgY29uc3QgYXV0aFRhZyA9IGNpcGhlci5nZXRBdXRoVGFnKCk7XG4gICAgICAgIHJldHVybiB7IGVuY3J5cHRlZCwgYXV0aFRhZyB9O1xuICAgIH1cbiAgICBhc3luYyBhZXNHQ01EZWNyeXB0KGtleSwgZW5jcnlwdGVkRGF0YSwgaXYsIGF1dGhUYWcpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvID0gYXdhaXQgdGhpcy5nZXRDcnlwdG8oKTtcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTI1Ni1nY20nLCBrZXksIGl2KTtcbiAgICAgICAgZGVjaXBoZXIuc2V0QXV0aFRhZyhhdXRoVGFnKTtcbiAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICBkZWNpcGhlci51cGRhdGUoZW5jcnlwdGVkRGF0YSksXG4gICAgICAgICAgICBkZWNpcGhlci5maW5hbCgpLFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIGRlY3J5cHRlZDtcbiAgICB9XG4gICAgcmFuZG9tQnl0ZXMobGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLmNyeXB0bykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIHN5bmNocm9ub3VzIHJhbmRvbSBieXRlcyBpbiBOb2RlLmpzLCB3ZSdsbCBuZWVkIHRvIGhhbmRsZSB0aGlzIGRpZmZlcmVudGx5XG4gICAgICAgIC8vIFRoaXMgaXMgYSBsaW1pdGF0aW9uIC0gaWRlYWxseSB0aGlzIHNob3VsZCBiZSBhc3luY1xuICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgIC8vIFVzZSBOb2RlLmpzIGNyeXB0byBpZiBhdmFpbGFibGUgKHNpbXBsaWZpZWQgZmFsbGJhY2spXG4gICAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgc2hvdWxkIGlkZWFsbHkgYmUgYXN5bmNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIE5vZGUuanMgZW52aXJvbm1lbnQgYnkgY2hlY2tpbmcgZm9yIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucz8ubm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIEltcG9ydCBjcnlwdG8tYnJvd3NlcmlmeSBhcyBmYWxsYmFjayBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgY29uc3QgY3J5cHRvQnJvd3NlcmlmeSA9IHJlcXVpcmUoJ2NyeXB0by1icm93c2VyaWZ5Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0b0Jyb3dzZXJpZnkucmFuZG9tQnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAvLyBDcnlwdG8gbm90IGF2YWlsYWJsZVxuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIE1hdGgucmFuZG9tIChub3QgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlLCBidXQgZnVuY3Rpb25hbClcbiAgICAgICAgY29uc29sZS53YXJuKCdVc2luZyBNYXRoLnJhbmRvbSBmb3IgcmFuZG9tIGJ5dGVzIC0gbm90IGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1Nik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycmF5KTtcbiAgICB9XG59XG5jbGFzcyBCcm93c2VyQ3J5cHRvQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGlmICghaGFzV2ViQ3J5cHRvKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViIENyeXB0byBBUEkgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBhZXNHQ01FbmNyeXB0KGtleSwgZGF0YSwgaXYpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGtleSwgeyBuYW1lOiAnQUVTLUdDTScgfSwgZmFsc2UsIFsnZW5jcnlwdCddKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5lbmNyeXB0KHtcbiAgICAgICAgICAgIG5hbWU6ICdBRVMtR0NNJyxcbiAgICAgICAgICAgIGl2OiBpdixcbiAgICAgICAgICAgIHRhZ0xlbmd0aDogMTI4LFxuICAgICAgICB9LCBjcnlwdG9LZXksIGRhdGEpO1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWQgPSBuZXcgVWludDhBcnJheShyZXN1bHQuc2xpY2UoMCwgLTE2KSk7XG4gICAgICAgIGNvbnN0IGF1dGhUYWcgPSBuZXcgVWludDhBcnJheShyZXN1bHQuc2xpY2UoLTE2KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmNyeXB0ZWQ6IEJ1ZmZlci5mcm9tKGVuY3J5cHRlZCksXG4gICAgICAgICAgICBhdXRoVGFnOiBCdWZmZXIuZnJvbShhdXRoVGFnKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgYWVzR0NNRGVjcnlwdChrZXksIGVuY3J5cHRlZERhdGEsIGl2LCBhdXRoVGFnKSB7XG4gICAgICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBrZXksIHsgbmFtZTogJ0FFUy1HQ00nIH0sIGZhbHNlLCBbJ2RlY3J5cHQnXSk7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkID0gbmV3IFVpbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YS5sZW5ndGggKyBhdXRoVGFnLmxlbmd0aCk7XG4gICAgICAgIGNvbWJpbmVkLnNldChlbmNyeXB0ZWREYXRhLCAwKTtcbiAgICAgICAgY29tYmluZWQuc2V0KGF1dGhUYWcsIGVuY3J5cHRlZERhdGEubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kZWNyeXB0KHtcbiAgICAgICAgICAgIG5hbWU6ICdBRVMtR0NNJyxcbiAgICAgICAgICAgIGl2OiBpdixcbiAgICAgICAgICAgIHRhZ0xlbmd0aDogMTI4LFxuICAgICAgICB9LCBjcnlwdG9LZXksIGNvbWJpbmVkKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG4gICAgfVxuICAgIHJhbmRvbUJ5dGVzKGxlbmd0aCkge1xuICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyYXkpO1xuICAgIH1cbn1cbmxldCBjcnlwdG9BZGFwdGVyID0gbnVsbDtcbmZ1bmN0aW9uIGdldENyeXB0b0FkYXB0ZXIoKSB7XG4gICAgaWYgKCFjcnlwdG9BZGFwdGVyKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICAgICAgY3J5cHRvQWRhcHRlciA9IG5ldyBCcm93c2VyQ3J5cHRvQWRhcHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3J5cHRvQWRhcHRlciA9IG5ldyBOb2RlQ3J5cHRvQWRhcHRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcnlwdG9BZGFwdGVyO1xufVxuXG5jb25zdCBpdkxlbmd0aCA9IDEyO1xuY29uc3QgdGFnTGVuZ3RoID0gMTY7XG5jb25zdCBzaWdMZW5ndGggPSA2NTtcbmNvbnN0IGNodW5rTGVuZ3RoID0gNjQgKiAxMDI0ICogMTAyNCArIHRhZ0xlbmd0aDtcbi8vIEluZmVyZW5jZVxuYXN5bmMgZnVuY3Rpb24gZGVyaXZlRW5jcnlwdGlvbktleShzaWduZXIpIHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzaWduZXIuc2lnbk1lc3NhZ2UoTUVTU0FHRV9GT1JfRU5DUllQVElPTl9LRVkpO1xuICAgIGNvbnN0IGhhc2ggPSBldGhlcnMuc2hhMjU2KGV0aGVycy50b1V0ZjhCeXRlcyhzaWduYXR1cmUpKTtcbiAgICByZXR1cm4gaGFzaDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHREYXRhKHNpZ25lciwgZGF0YSkge1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IGRlcml2ZUVuY3J5cHRpb25LZXkoc2lnbmVyKTtcbiAgICBjb25zdCBlbmNyeXB0ZWQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChkYXRhLCBrZXkpLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIGVuY3J5cHRlZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHREYXRhKHNpZ25lciwgZW5jcnlwdGVkRGF0YSkge1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IGRlcml2ZUVuY3J5cHRpb25LZXkoc2lnbmVyKTtcbiAgICBjb25zdCBieXRlcyA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KGVuY3J5cHRlZERhdGEsIGtleSk7XG4gICAgY29uc3QgZGVjcnlwdGVkID0gYnl0ZXMudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xuICAgIHJldHVybiBkZWNyeXB0ZWQ7XG59XG4vLyBGaW5lLXR1bmluZ1xuZnVuY3Rpb24gaGV4VG9Sb290cyhoZXhTdHJpbmcpIHtcbiAgICBpZiAoaGV4U3RyaW5nLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgaGV4U3RyaW5nID0gaGV4U3RyaW5nLnNsaWNlKDIpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaGV4U3RyaW5nLCAnaGV4JykudG9TdHJpbmcoJ3V0ZjgnKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25SZXF1ZXN0KHNpZ25lciwgdXNlckFkZHJlc3MsIG5vbmNlLCBkYXRhc2V0Um9vdEhhc2gsIGZlZSkge1xuICAgIGNvbnN0IGhhc2ggPSBldGhlcnMuc29saWRpdHlQYWNrZWRLZWNjYWsyNTYoWydhZGRyZXNzJywgJ3VpbnQyNTYnLCAnc3RyaW5nJywgJ3VpbnQyNTYnXSwgW3VzZXJBZGRyZXNzLCBub25jZSwgZGF0YXNldFJvb3RIYXNoLCBmZWVdKTtcbiAgICByZXR1cm4gYXdhaXQgc2lnbmVyLnNpZ25NZXNzYWdlKGV0aGVycy50b0JlQXJyYXkoaGFzaCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2lnblRhc2tJRChzaWduZXIsIHRhc2tJRCkge1xuICAgIGNvbnN0IGhhc2ggPSBldGhlcnMuc29saWRpdHlQYWNrZWRLZWNjYWsyNTYoWydieXRlcyddLCBbJzB4JyArIHRhc2tJRC5yZXBsYWNlKC8tL2csICcnKV0pO1xuICAgIHJldHVybiBhd2FpdCBzaWduZXIuc2lnbk1lc3NhZ2UoZXRoZXJzLnRvQmVBcnJheShoYXNoKSk7XG59XG5hc3luYyBmdW5jdGlvbiBlY2llc0RlY3J5cHQoc2lnbmVyLCBlbmNyeXB0ZWREYXRhKSB7XG4gICAgZW5jcnlwdGVkRGF0YSA9IGVuY3J5cHRlZERhdGEuc3RhcnRzV2l0aCgnMHgnKVxuICAgICAgICA/IGVuY3J5cHRlZERhdGEuc2xpY2UoMilcbiAgICAgICAgOiBlbmNyeXB0ZWREYXRhO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBkaXN0RXhwb3J0cy5Qcml2YXRlS2V5LmZyb21IZXgoc2lnbmVyLnByaXZhdGVLZXkpO1xuICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuZnJvbShlbmNyeXB0ZWREYXRhLCAnaGV4Jyk7XG4gICAgY29uc3QgZGVjcnlwdGVkID0gZGlzdEV4cG9ydHMuZGVjcnlwdChwcml2YXRlS2V5LnNlY3JldCwgZGF0YSk7XG4gICAgcmV0dXJuIGRlY3J5cHRlZC50b1N0cmluZygnaGV4Jyk7XG59XG5hc3luYyBmdW5jdGlvbiBhZXNHQ01EZWNyeXB0VG9GaWxlKGtleSwgZW5jcnlwdGVkTW9kZWxQYXRoLCBkZWNyeXB0ZWRNb2RlbFBhdGgsIHByb3ZpZGVyU2lnbmVyKSB7XG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsZSBvcGVyYXRpb25zIGFyZSBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgZW52aXJvbm1lbnQuIFVzZSBhZXNHQ01EZWNyeXB0IHdpdGggQXJyYXlCdWZmZXIgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgLy8gT25seSBpbXBvcnQgZnMgd2hlbiBpbiBOb2RlLmpzIGVudmlyb25tZW50XG4gICAgY29uc3QgeyBwcm9taXNlczogZnMgfSA9IGF3YWl0IGltcG9ydCgnZnMnKTtcbiAgICBjb25zdCBmZCA9IGF3YWl0IGZzLm9wZW4oZW5jcnlwdGVkTW9kZWxQYXRoLCAncicpO1xuICAgIC8vIHJlYWQgc2lnbmF0dXJlIGFuZCBub25jZVxuICAgIGNvbnN0IHRhZ1NpZyA9IEJ1ZmZlci5hbGxvYyhzaWdMZW5ndGgpO1xuICAgIGNvbnN0IGl2ID0gQnVmZmVyLmFsbG9jKGl2TGVuZ3RoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBsZXQgcmVhZFJlc3VsdCA9IGF3YWl0IGZkLnJlYWQodGFnU2lnLCAwLCBzaWdMZW5ndGgsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHJlYWRSZXN1bHQuYnl0ZXNSZWFkO1xuICAgIHJlYWRSZXN1bHQgPSBhd2FpdCBmZC5yZWFkKGl2LCAwLCBpdkxlbmd0aCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gcmVhZFJlc3VsdC5ieXRlc1JlYWQ7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IEJ1ZmZlci5mcm9tKGtleSwgJ2hleCcpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhjaHVua0xlbmd0aCk7XG4gICAgbGV0IHRhZ3NCdWZmZXIgPSBCdWZmZXIuZnJvbShbXSk7XG4gICAgY29uc3Qgd3JpdGVGZCA9IGF3YWl0IGZzLm9wZW4oZGVjcnlwdGVkTW9kZWxQYXRoLCAndycpO1xuICAgIGNvbnN0IGNyeXB0b0FkYXB0ZXIgPSBnZXRDcnlwdG9BZGFwdGVyKCk7XG4gICAgLy8gcmVhZCBjaHVua3NcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICByZWFkUmVzdWx0ID0gYXdhaXQgZmQucmVhZChidWZmZXIsIDAsIGNodW5rTGVuZ3RoLCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSByZWFkUmVzdWx0LmJ5dGVzUmVhZDtcbiAgICAgICAgaWYgKGNodW5rU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFnID0gYnVmZmVyLnN1YmFycmF5KGNodW5rU2l6ZSAtIHRhZ0xlbmd0aCwgY2h1bmtTaXplKTtcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkQ2h1bmsgPSBidWZmZXIuc3ViYXJyYXkoMCwgY2h1bmtTaXplIC0gdGFnTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgY3J5cHRvQWRhcHRlci5hZXNHQ01EZWNyeXB0KHByaXZhdGVLZXksIEJ1ZmZlci5mcm9tKGVuY3J5cHRlZENodW5rKSwgQnVmZmVyLmZyb20oaXYpLCBCdWZmZXIuZnJvbSh0YWcpKTtcbiAgICAgICAgYXdhaXQgd3JpdGVGZC5hcHBlbmRGaWxlKGRlY3J5cHRlZCk7XG4gICAgICAgIHRhZ3NCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFt0YWdzQnVmZmVyLCB0YWddKTtcbiAgICAgICAgb2Zmc2V0ICs9IGNodW5rU2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGl2Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpdltpXSsrO1xuICAgICAgICAgICAgaWYgKGl2W2ldICE9PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHdyaXRlRmQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuICAgIGNvbnN0IHJlY292ZXJlZEFkZHJlc3MgPSBldGhlcnMucmVjb3ZlckFkZHJlc3MoZXRoZXJzLmtlY2NhazI1Nih0YWdzQnVmZmVyKSwgJzB4JyArIHRhZ1NpZy50b1N0cmluZygnaGV4JykpO1xuICAgIGlmIChyZWNvdmVyZWRBZGRyZXNzLnRvTG93ZXJDYXNlKCkgIT09IHByb3ZpZGVyU2lnbmVyLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhZyBzaWduYXR1cmUnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN0clRvUHJpdmF0ZUtleShzdHIpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0cik7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnNlZCkgfHwgcGFyc2VkLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IFtmaXJzdCwgc2Vjb25kXSA9IHBhcnNlZC5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgZm9ybWF0Jyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtmaXJzdCwgc2Vjb25kXTtcbn1cbmZ1bmN0aW9uIHByaXZhdGVLZXlUb1N0cihrZXkpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5Lm1hcCgodikgPT4gdi50b1N0cmluZygpKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5cbmNsYXNzIE1ldGFkYXRhIHtcbiAgICBub2RlU3RvcmFnZSA9IHt9O1xuICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdy5sb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnO1xuICAgIHN0b3JhZ2VQcmVmaXggPSAnMGdfbWV0YWRhdGFfJztcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgdGhpcy5ub2RlU3RvcmFnZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIGNvbnN0IGZ1bGxLZXkgPSB0aGlzLnN0b3JhZ2VQcmVmaXggKyBrZXk7XG4gICAgICAgIGlmICh0aGlzLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZyBsb2NhbFN0b3JhZ2UgaXRlbTonLCBmdWxsS2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGZ1bGxLZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2V0IGxvY2FsU3RvcmFnZSBpdGVtOicsIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0b3JhZ2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ub2RlU3RvcmFnZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIGNvbnN0IGZ1bGxLZXkgPSB0aGlzLnN0b3JhZ2VQcmVmaXggKyBrZXk7XG4gICAgICAgIGlmICh0aGlzLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGZ1bGxLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBnZXQgbG9jYWxTdG9yYWdlIGl0ZW06JywgZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZVN0b3JhZ2Vba2V5XSA/PyBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZVN0b3JhZ2Vba2V5XSA/PyBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHN0b3JlU2V0dGxlU2lnbmVyUHJpdmF0ZUtleShrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGJpZ0ludFN0cmluZ0FycmF5ID0gdmFsdWUubWFwKChiaSkgPT4gYmkudG9TdHJpbmcoKSk7XG4gICAgICAgIGNvbnN0IGJpZ0ludEpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShiaWdJbnRTdHJpbmdBcnJheSk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2V0SXRlbShgJHtrZXl9X3NldHRsZVNpZ25lclByaXZhdGVLZXlgLCBiaWdJbnRKc29uU3RyaW5nKTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcmVTaWduaW5nS2V5KGtleSwgdmFsdWUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXRJdGVtKGAke2tleX1fc2lnbmluZ0tleWAsIHZhbHVlKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2V0dGxlU2lnbmVyUHJpdmF0ZUtleShrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLmdldEl0ZW0oYCR7a2V5fV9zZXR0bGVTaWduZXJQcml2YXRlS2V5YCk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJpZ0ludFN0cmluZ0FycmF5ID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBiaWdJbnRTdHJpbmdBcnJheS5tYXAoKHN0cikgPT4gQmlnSW50KHN0cikpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTaWduaW5nS2V5KGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuZ2V0SXRlbShgJHtrZXl9X3NpZ25pbmdLZXlgKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8/IG51bGw7XG4gICAgfVxufVxuXG52YXIgQ2FjaGVWYWx1ZVR5cGVFbnVtO1xuKGZ1bmN0aW9uIChDYWNoZVZhbHVlVHlwZUVudW0pIHtcbiAgICBDYWNoZVZhbHVlVHlwZUVudW1bXCJTZXJ2aWNlXCJdID0gXCJzZXJ2aWNlXCI7XG4gICAgQ2FjaGVWYWx1ZVR5cGVFbnVtW1wiQmlnSW50XCJdID0gXCJiaWdpbnRcIjtcbiAgICBDYWNoZVZhbHVlVHlwZUVudW1bXCJPdGhlclwiXSA9IFwib3RoZXJcIjtcbn0pKENhY2hlVmFsdWVUeXBlRW51bSB8fCAoQ2FjaGVWYWx1ZVR5cGVFbnVtID0ge30pKTtcbmNsYXNzIENhY2hlIHtcbiAgICBub2RlU3RvcmFnZSA9IHt9O1xuICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdy5sb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnO1xuICAgIHN0b3JhZ2VQcmVmaXggPSAnMGdfY2FjaGVfJztcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIHNldExvY2soa2V5LCB2YWx1ZSwgdHRsLCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICBpZiAodGhpcy5nZXRTdG9yYWdlSXRlbShrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRJdGVtKGtleSwgdmFsdWUsIHR0bCwgdHlwZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZW1vdmVMb2NrKGtleSkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVTdG9yYWdlSXRlbShrZXkpO1xuICAgIH1cbiAgICBzZXRJdGVtKGtleSwgdmFsdWUsIHR0bCwgdHlwZSkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB2YWx1ZTogQ2FjaGUuZW5jb2RlVmFsdWUodmFsdWUpLFxuICAgICAgICAgICAgZXhwaXJ5OiBub3cuZ2V0VGltZSgpICsgdHRsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFN0b3JhZ2VJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkoaXRlbSkpO1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgY29uc3QgaXRlbVN0ciA9IHRoaXMuZ2V0U3RvcmFnZUl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtU3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtID0gSlNPTi5wYXJzZShpdGVtU3RyKTtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKG5vdy5nZXRUaW1lKCkgPiBpdGVtLmV4cGlyeSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTdG9yYWdlSXRlbShrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhY2hlLmRlY29kZVZhbHVlKGl0ZW0udmFsdWUsIGl0ZW0udHlwZSk7XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgdGhpcy5ub2RlU3RvcmFnZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwRXhwaXJlZEl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICAgIHNldFN0b3JhZ2VJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgZnVsbEtleSA9IHRoaXMuc3RvcmFnZVByZWZpeCArIGtleTtcbiAgICAgICAgaWYgKHRoaXMuaXNCcm93c2VyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShmdWxsS2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNldCBsb2NhbFN0b3JhZ2UgaXRlbTonLCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdG9yYWdlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubm9kZVN0b3JhZ2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFN0b3JhZ2VJdGVtKGtleSkge1xuICAgICAgICBjb25zdCBmdWxsS2V5ID0gdGhpcy5zdG9yYWdlUHJlZml4ICsga2V5O1xuICAgICAgICBpZiAodGhpcy5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShmdWxsS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZ2V0IGxvY2FsU3RvcmFnZSBpdGVtOicsIGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVTdG9yYWdlW2tleV0gPz8gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVTdG9yYWdlW2tleV0gPz8gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVTdG9yYWdlSXRlbShrZXkpIHtcbiAgICAgICAgY29uc3QgZnVsbEtleSA9IHRoaXMuc3RvcmFnZVByZWZpeCArIGtleTtcbiAgICAgICAgaWYgKHRoaXMuaXNCcm93c2VyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShmdWxsS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmVtb3ZlIGxvY2FsU3RvcmFnZSBpdGVtOicsIGUpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVTdG9yYWdlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ub2RlU3RvcmFnZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFudXBFeHBpcmVkSXRlbXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Jyb3dzZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzVG9SZW1vdmUgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2luZG93LmxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Uua2V5KGkpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgJiYga2V5LnN0YXJ0c1dpdGgodGhpcy5zdG9yYWdlUHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtU3RyID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBKU09OLnBhcnNlKGl0ZW1TdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IGl0ZW0uZXhwaXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXNUb1JlbW92ZS5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzVG9SZW1vdmUucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5c1RvUmVtb3ZlLmZvckVhY2goKGtleSkgPT4gd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjbGVhbnVwIGV4cGlyZWQgaXRlbXM6JywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGVuY29kZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKF8sIHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcgPyBgJHt2YWwudG9TdHJpbmcoKX1uYCA6IHZhbCk7XG4gICAgfVxuICAgIHN0YXRpYyBkZWNvZGVWYWx1ZShlbmNvZGVkVmFsdWUsIHR5cGUpIHtcbiAgICAgICAgbGV0IHJldCA9IEpTT04ucGFyc2UoZW5jb2RlZFZhbHVlLCAoXywgdmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgL15cXGQrbiQvLnRlc3QodmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsLnNsaWNlKDAsIC0xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGUgPT09IENhY2hlVmFsdWVUeXBlRW51bS5TZXJ2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2FjaGUuY3JlYXRlU2VydmljZVN0cnVjdE91dHB1dChyZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVTZXJ2aWNlU3RydWN0T3V0cHV0KGZpZWxkcykge1xuICAgICAgICBjb25zdCB0dXBsZSA9IGZpZWxkcztcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0ge1xuICAgICAgICAgICAgcHJvdmlkZXI6IGZpZWxkc1swXSxcbiAgICAgICAgICAgIHNlcnZpY2VUeXBlOiBmaWVsZHNbMV0sXG4gICAgICAgICAgICB1cmw6IGZpZWxkc1syXSxcbiAgICAgICAgICAgIGlucHV0UHJpY2U6IGZpZWxkc1szXSxcbiAgICAgICAgICAgIG91dHB1dFByaWNlOiBmaWVsZHNbNF0sXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IGZpZWxkc1s1XSxcbiAgICAgICAgICAgIG1vZGVsOiBmaWVsZHNbNl0sXG4gICAgICAgICAgICB2ZXJpZmlhYmlsaXR5OiBmaWVsZHNbN10sXG4gICAgICAgICAgICBhZGRpdGlvbmFsSW5mbzogZmllbGRzWzhdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0dXBsZSwgb2JqZWN0KTtcbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldE5vbmNlV2l0aENhY2hlKGNhY2hlKSB7XG4gICAgY29uc3QgbG9ja0tleSA9ICdub25jZV9sb2NrJztcbiAgICBjb25zdCBub25jZUtleSA9ICdub25jZSc7XG4gICAgd2hpbGUgKCEoYXdhaXQgYWNxdWlyZUxvY2soY2FjaGUsIGxvY2tLZXkpKSkge1xuICAgICAgICBhd2FpdCBkZWxheSgxMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IGxhc3ROb25jZSA9IGNhY2hlLmdldEl0ZW0obm9uY2VLZXkpIHx8IDA7XG4gICAgICAgIGxldCBub25jZSA9IG5vdy5nZXRUaW1lKCkgKiAxMDAwMCArIDQwO1xuICAgICAgICBpZiAobGFzdE5vbmNlID49IG5vbmNlKSB7XG4gICAgICAgICAgICBub25jZSA9IGxhc3ROb25jZSArIDQwO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlLnNldEl0ZW0obm9uY2VLZXksIG5vbmNlLCAxMDAwMDAwMCAqIDYwICogMTAwMCwgQ2FjaGVWYWx1ZVR5cGVFbnVtLk90aGVyKTtcbiAgICAgICAgcmV0dXJuIG5vbmNlO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgYXdhaXQgcmVsZWFzZUxvY2soY2FjaGUsIGxvY2tLZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE5vbmNlKCkge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgcmV0dXJuIG5vdy5nZXRUaW1lKCkgKiAxMDAwMCArIDQwO1xufVxuYXN5bmMgZnVuY3Rpb24gYWNxdWlyZUxvY2soY2FjaGUsIGtleSkge1xuICAgIGNvbnN0IGxvY2sgPSBhd2FpdCBjYWNoZS5zZXRMb2NrKGtleSwgJ3RydWUnLCAxMDAwLCBDYWNoZVZhbHVlVHlwZUVudW0uT3RoZXIpO1xuICAgIHJldHVybiBsb2NrO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVsZWFzZUxvY2soY2FjaGUsIGtleSkge1xuICAgIGF3YWl0IGNhY2hlLnJlbW92ZUxvY2soa2V5KTtcbn1cbmZ1bmN0aW9uIGRlbGF5KG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5cbi8qIEF1dG9nZW5lcmF0ZWQgZmlsZS4gRG8gbm90IGVkaXQgbWFudWFsbHkuICovXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IF9hYmkkMiA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnSW5zdWZmaWNpZW50QmFsYW5jZScsXG4gICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnTGVkZ2VyRXhpc3RzJyxcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdMZWRnZXJOb3RFeGlzdHMnLFxuICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgIH0sXG4gICAge1xuICAgICAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcmV2aW91c093bmVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ25ld093bmVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnT3duZXJzaGlwVHJhbnNmZXJyZWQnLFxuICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2WzJdJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnaW5mZXJlbmNlU2lnbmVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NlsyXScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2FkZGl0aW9uYWxJbmZvJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdhZGRMZWRnZXInLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdwYXlhYmxlJyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogJ2RlbGV0ZUxlZGdlcicsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogJ2RlcG9zaXRGdW5kJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3BheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiAnZmluZVR1bmluZ0FkZHJlc3MnLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcyBwYXlhYmxlJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogJ2dldEFsbExlZGdlcnMnLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYXZhaWxhYmxlQmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RvdGFsQmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTZbMl0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2luZmVyZW5jZVNpZ25lcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NlsyXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRkaXRpb25hbEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3NbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnaW5mZXJlbmNlUHJvdmlkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzW10nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzW10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2ZpbmVUdW5pbmdQcm92aWRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3NbXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgTGVkZ2VyW10nLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdsZWRnZXJzJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndHVwbGVbXScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdnZXRMZWRnZXInLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYXZhaWxhYmxlQmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RvdGFsQmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTZbMl0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2luZmVyZW5jZVNpZ25lcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NlsyXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRkaXRpb25hbEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3NbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnaW5mZXJlbmNlUHJvdmlkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzW10nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzW10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2ZpbmVUdW5pbmdQcm92aWRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3NbXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgTGVkZ2VyJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndHVwbGUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6ICdpbmZlcmVuY2VBZGRyZXNzJyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MgcGF5YWJsZScsXG4gICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdfaW5mZXJlbmNlQWRkcmVzcycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnX2ZpbmVUdW5pbmdBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdvd25lcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ2luaXRpYWxpemUnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6ICdpbml0aWFsaXplZCcsXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogJ293bmVyJyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAncmVmdW5kJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiAncmVub3VuY2VPd25lcnNoaXAnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3NbXScsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVycycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3NbXScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3NlcnZpY2VUeXBlJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdyZXRyaWV2ZUZ1bmQnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdzcGVuZEZ1bmQnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzZXJ2aWNlVHlwZVN0cicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICd0cmFuc2ZlckZ1bmQnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICduZXdPd25lcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ3RyYW5zZmVyT3duZXJzaGlwJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdwYXlhYmxlJyxcbiAgICAgICAgdHlwZTogJ3JlY2VpdmUnLFxuICAgIH0sXG5dO1xuY29uc3QgX2J5dGVjb2RlJDIgPSAnMHg2MDgwNjA0MDUyMzQ4MDE1NjEwMDEwNTc2MDAwODBmZDViNTA2MTAwMWEzMzYxMDAyMzU2NWI2MDAxODA1NTYxMDA3MzU2NWI2MDAwODA1NDYwMDE2MDAxNjBhMDFiMDM4MzgxMTY2MDAxNjAwMTYwYTAxYjAzMTk4MzE2ODExNzg0NTU2MDQwNTE5MTkwOTIxNjkyODM5MTdmOGJlMDA3OWM1MzE2NTkxNDEzNDRjZDFmZDBhNGYyODQxOTQ5N2Y5NzIyYTNkYWFmZTNiNDE4NmY2YjY0NTdlMDkxOTBhMzUwNTA1NjViNjEyMzlhODA2MTAwODI2MDAwMzk2MDAwZjNmZTYwODA2MDQwNTI2MDA0MzYxMDYxMDBmNzU3NjAwMDM1NjBlMDFjODA2MzcyYWRjMGQ5MTE2MTAwOGE1NzgwNjNkZDhhNDExODExNjEwMDU5NTc4MDYzZGQ4YTQxMTgxNDYxMDI4ZDU3ODA2M2U1ZDlmZGFiMTQ2MTAyYWQ1NzgwNjNmMmZkZTM4YjE0NjEwMmNkNTc4MDYzZjdjZDZhZjkxNDYxMDJlZDU3NjAwMDgwZmQ1YjgwNjM3MmFkYzBkOTE0NjEwMjFmNTc4MDYzOGQwZDhjYjYxNDYxMDI0NzU3ODA2MzhkYTVjYjViMTQ2MTAyNGY1NzgwNjNjMGM1M2I4YjE0NjEwMjZkNTc2MDAwODBmZDViODA2MzMxNDA0YTE5MTE2MTAwYzY1NzgwNjMzMTQwNGExOTE0NjEwMTlkNTc4MDYzMzgyZTExMTIxNDYxMDFiZDU3ODA2MzQxMGIzODE1MTQ2MTAxZjU1NzgwNjM3MTUwMThhNjE0NjEwMjBhNTc2MDAwODBmZDViODA2MzE1OGVmOTNlMTQ2MTAxMDM1NzgwNjMxNjY1Yzc5YjE0NjEwMTM5NTc4MDYzMjc4ZWNkZTExNDYxMDE1YjU3ODA2MzJiYTQzYjgyMTQ2MTAxN2Q1NzYwMDA4MGZkNWIzNjYxMDBmZTU3MDA1YjYwMDA4MGZkNWIzNDgwMTU2MTAxMGY1NzYwMDA4MGZkNWI1MDYwMDA1NDYxMDEyNDkwNjAwMTYwYTAxYjkwMDQ2MGZmMTY4MTU2NWI2MDQwNTE5MDE1MTU4MTUyNjAyMDAxNWI2MDQwNTE4MDkxMDM5MGYzNWIzNDgwMTU2MTAxNDU1NzYwMDA4MGZkNWI1MDYxMDE0ZTYxMDMxYTU2NWI2MDQwNTE2MTAxMzA5MTkwNjExYzc1NTY1YjM0ODAxNTYxMDE2NzU3NjAwMDgwZmQ1YjUwNjEwMTdiNjEwMTc2MzY2MDA0NjExY2Q3NTY1YjYxMDU3ZDU2NWIwMDViMzQ4MDE1NjEwMTg5NTc2MDAwODBmZDViNTA2MTAxN2I2MTAxOTgzNjYwMDQ2MTFkYzM1NjViNjEwNjhjNTY1YjM0ODAxNTYxMDFhOTU3NjAwMDgwZmQ1YjUwNjEwMTdiNjEwMWI4MzY2MDA0NjExZTFhNTY1YjYxMGE2MjU2NWIzNDgwMTU2MTAxYzk1NzYwMDA4MGZkNWI1MDYwMDM1NDYxMDFkZDkwNjAwMTYwMDE2MGEwMWIwMzE2ODE1NjViNjA0MDUxNjAwMTYwMDE2MGEwMWIwMzkwOTExNjgxNTI2MDIwMDE2MTAxMzA1NjViMzQ4MDE1NjEwMjAxNTc2MDAwODBmZDViNTA2MTAxN2I2MTBjN2U1NjViMzQ4MDE1NjEwMjE2NTc2MDAwODBmZDViNTA2MTAxN2I2MTBlZjQ1NjViNjEwMjMyNjEwMjJkMzY2MDA0NjExZWU5NTY1YjYxMGYwNjU2NWI2MDQwODA1MTkyODM1MjYwMjA4MzAxOTE5MDkxNTIwMTYxMDEzMDU2NWI2MTAxN2I2MTBmYzQ1NjViMzQ4MDE1NjEwMjViNTc2MDAwODBmZDViNTA2MDAwNTQ2MDAxNjAwMTYwYTAxYjAzMTY2MTAxZGQ1NjViMzQ4MDE1NjEwMjc5NTc2MDAwODBmZDViNTA2MTAxN2I2MTAyODgzNjYwMDQ2MTFmMzI1NjViNjExMDc0NTY1YjM0ODAxNTYxMDI5OTU3NjAwMDgwZmQ1YjUwNjEwMTdiNjEwMmE4MzY2MDA0NjExZjc1NTY1YjYxMTEzZTU2NWIzNDgwMTU2MTAyYjk1NzYwMDA4MGZkNWI1MDYwMDI1NDYxMDFkZDkwNjAwMTYwMDE2MGEwMWIwMzE2ODE1NjViMzQ4MDE1NjEwMmQ5NTc2MDAwODBmZDViNTA2MTAxN2I2MTAyZTgzNjYwMDQ2MTFmOWY1NjViNjExMjRlNTY1YjM0ODAxNTYxMDJmOTU3NjAwMDgwZmQ1YjUwNjEwMzBkNjEwMzA4MzY2MDA0NjExZjlmNTY1YjYxMTJjNzU2NWI2MDQwNTE2MTAxMzA5MTkwNjExZmJhNTY1YjYwNjA2MDAwNjEwMzI2NjExNDk2NTY1YjkwNTA4MDY3ZmZmZmZmZmZmZmZmZmZmZjgxMTExNTYxMDM0MTU3NjEwMzQxNjExZDBjNTY1YjYwNDA1MTkwODA4MjUyODA2MDIwMDI2MDIwMDE4MjAxNjA0MDUyODAxNTYxMDM3YTU3ODE2MDIwMDE1YjYxMDM2NzYxMWEyNjU2NWI4MTUyNjAyMDAxOTA2MDAxOTAwMzkwODE2MTAzNWY1NzkwNTA1YjUwOTE1MDYwMDA1YjgxODExMDE1NjEwNTc4NTc2MTAzOTE4MTYxMTRhNzU2NWI2MDQwODA1MTYwZTA4MTAxODI1MjgyNTQ2MDAxNjAwMTYwYTAxYjAzMTY4MTUyNjAwMTgzMDE1NDYwMjA4MjAxNTI2MDAyODA4NDAxNTQ4Mjg0MDE1MjgyNTE4MDg0MDE5Mzg0OTA1MjkxOTM5MjYwNjA4NTAxOTI5MTYwMDM4NTAxOTE4Mjg0NWI4MTU0ODE1MjYwMjAwMTkwNjAwMTAxOTA4MDgzMTE2MTAzZDY1NzUwNTA1MDUwNTA4MTUyNjAyMDAxNjAwNTgyMDE4MDU0NjEwNDAyOTA2MTFmY2Q1NjViODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTgyODA1NDYxMDQyZTkwNjExZmNkNTY1YjgwMTU2MTA0N2I1NzgwNjAxZjEwNjEwNDUwNTc2MTAxMDA4MDgzNTQwNDAyODM1MjkxNjAyMDAxOTE2MTA0N2I1NjViODIwMTkxOTA2MDAwNTI2MDIwNjAwMDIwOTA1YjgxNTQ4MTUyOTA2MDAxMDE5MDYwMjAwMTgwODMxMTYxMDQ1ZTU3ODI5MDAzNjAxZjE2ODIwMTkxNWI1MDUwNTA1MDUwODE1MjYwMjAwMTYwMDY4MjAxODA1NDgwNjAyMDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ4MDE1NjEwNGRkNTc2MDIwMDI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDYwMDE2MDAxNjBhMDFiMDMxNjgxNTI2MDAxOTA5MTAxOTA2MDIwMDE4MDgzMTE2MTA0YmY1NzViNTA1MDUwNTA1MDgxNTI2MDIwMDE2MDA3ODIwMTgwNTQ4MDYwMjAwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0ODAxNTYxMDUzZjU3NjAyMDAyODIwMTkxOTA2MDAwNTI2MDIwNjAwMDIwOTA1YjgxNTQ2MDAxNjAwMTYwYTAxYjAzMTY4MTUyNjAwMTkwOTEwMTkwNjAyMDAxODA4MzExNjEwNTIxNTc1YjUwNTA1MDUwNTA4MTUyNTA1MDgzODI4MTUxODExMDYxMDU1YTU3NjEwNTVhNjEyMDA3NTY1YjYwMjAwMjYwMjAwMTAxODE5MDUyNTA4MDgwNjEwNTcwOTA2MTIwMzM1NjViOTE1MDUwNjEwMzgwNTY1YjUwNTA5MDU2NWIzMzYwMDA2MTA1ODk4MjYxMTRjYTU2NWI2MDAwODE4MTUyNjAwNzYwMjA1MjYwNDA5MDIwNTQ5MDkxNTA2MGZmMTYxNTYxMDVjNDU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAwNDAxNjEwNWJiOTA2MTIwNGM1NjViNjA0MDUxODA5MTAzOTBmZDViNjAwMDgxODE1MjYwMDc2MDIwNTI2MDQwODEyMDgwNTQ2MGZmMTkxNjYwMDExNzkwNTU2MTA1ZTYzMzYxMTRmZTU2NWI5MDUwODM4MTYwMDEwMTU0MTAxNTYxMDYwZjU3NjA0MDUxNjMxMTJmZWQ4YjYwZTMxYjgxNTIzMzYwMDQ4MjAxNTI2MDI0MDE2MTA1YmI1NjViODM4MTYwMDEwMTYwMDA4MjgyNTQ2MTA2MjM5MTkwNjEyMDgzNTY1YjkyNTA1MDgxOTA1NTUwODM4MTYwMDIwMTYwMDA4MjgyNTQ2MTA2M2U5MTkwNjEyMDgzNTY1YjkwOTE1NTUwNTA2MDQwNTEzMzkwODUxNTYxMDhmYzAyOTA4NjkwNjAwMDgxODE4MTg1ODg4OGYxOTM1MDUwNTA1MDE1ODAxNTYxMDY3MDU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNjAwMDkwODE1MjYwMDc2MDIwNTI2MDQwOTAyMDgwNTQ2MGZmMTkxNjkwNTU1MDUwNTY1YjYxMDY5NDYxMTU1MTU2NWIzMzYwMDA2MTA2YTA4MjYxMTRjYTU2NWI2MDAwODE4MTUyNjAwNzYwMjA1MjYwNDA5MDIwNTQ5MDkxNTA2MGZmMTYxNTYxMDZkMjU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAwNDAxNjEwNWJiOTA2MTIwNGM1NjViNjAwMDgxODE1MjYwMDc2MDIwNTI2MDQwODEyMDgwNTQ2MGZmMTkxNjYwMDExNzkwNTU2MTA2ZjQzMzYxMTRmZTU2NWI5MDUwNjAwMDgwNjAwMDYxMDcwNDg4NjExNWFhNTY1YjYwNDA1MTYzMTQ3NTAwZTM2MGUwMWI4MTUyMzM2MDA0ODIwMTUyNjAwMTYwMDE2MGEwMWIwMzhkODExNjYwMjQ4MzAxNTI5Mzk2NTA5MTk0NTA5MjUwODg5MTYwNjA5MTkwODUxNjkwNjMxNDc1MDBlMzkwNjA0NDAxNjAyMDYwNDA1MTgwODMwMzgxODY1YWZhMTU4MDE1NjEwNzVlNTczZDYwMDA4MDNlM2Q2MDAwZmQ1YjUwNTA1MDUwNjA0MDUxM2Q2MDFmMTk2MDFmODIwMTE2ODIwMTgwNjA0MDUyNTA4MTAxOTA2MTA3ODI5MTkwNjEyMDk2NTY1YjE1NjEwODZlNTc2MDQwNTE2MzEzMjBiOWViNjBlMTFiODE1MjMzNjAwNDgyMDE1MjYwMDE2MDAxNjBhMDFiMDM4YzgxMTY2MDI0ODMwMTUyNjAwMDkxOTA4NjE2OTA2MzI2NDE3M2Q2OTA2MDQ0MDE2MDIwNjA0MDUxODA4MzAzODE4NjVhZmExNTgwMTU2MTA3ZDc1NzNkNjAwMDgwM2UzZDYwMDBmZDViNTA1MDUwNTA2MDQwNTEzZDYwMWYxOTYwMWY4MjAxMTY4MjAxODA2MDQwNTI1MDgxMDE5MDYxMDdmYjkxOTA2MTIwYmY1NjViOTA1MDYwMDA2MTA4MDk4YjgzNjExNmFiNTY1YjkwNTA2MTA4MTU4MTg1NjEyMDgzNTY1YjYwNDA1MTMzNjAyNDgyMDE1MjYwMDE2MDAxNjBhMDFiMDM4ZjE2NjA0NDgyMDE1MjYwNjQ4MTAxODM5MDUyOTA5NDUwNjA4NDAxNjA0MDgwNTE2MDFmMTk4MTg0MDMwMTgxNTI5MTkwNTI2MDIwODEwMTgwNTE2MDAxNjAwMTYwZTAxYjAzMTY2Mzc0NWU4N2Y3NjBlMDFiMTc5MDUyOTI1MDYxMDkyMjkxNTA1MDU2NWI4MjYwMDAwMzYxMDhkMTU3MzM4Yjg3NjAwMzAxODg2MDA1MDE2MDQwNTE2MDI0MDE2MTA4OTM5NDkzOTI5MTkwNjEyMTU1NTY1YjYwNDA4MDUxNjAxZjE5ODE4NDAzMDE4MTUyOTE5MDUyNjAyMDgxMDE4MDUxNjAwMTYwMDE2MGUwMWIwMzE2NjMxMmYwZWJmZDYwZTIxYjE3OTA1MjkwNTA2MTA4Y2M2MDA2ODcwMThjNjExNmM1NTY1YjYxMDkyMjU2NWIzMzhiODc2MDA1MDE2MDQwNTE2MDI0MDE2MTA4ZTk5MzkyOTE5MDYxMjFiNzU2NWI2MDQwODA1MTYwMWYxOTgxODQwMzAxODE1MjkxOTA1MjYwMjA4MTAxODA1MTYwMDE2MDAxNjBlMDFiMDMxNjYzZTUwNjg4Zjk2MGUwMWIxNzkwNTI5MDUwNjEwOTIyNjAwNzg3MDE4YzYxMTZjNTU2NWI4MTg2NjAwMTAxNTQxMDE1NjEwOTZkNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwMTQ2MDI0ODIwMTUyNzM0OTZlNzM3NTY2NjY2OTYzNjk2NTZlNzQyMDYyNjE2YzYxNmU2MzY1NjA2MDFiNjA0NDgyMDE1MjYwNjQwMTYxMDViYjU2NWI4MTg2NjAwMTAxNjAwMDgyODI1NDYxMDk4MTkxOTA2MTIwODM1NjViOTI1MDUwODE5MDU1NTA2MDAwODU2MDAxNjAwMTYwYTAxYjAzMTY4MzgzNjA0MDUxNjEwOWEzOTE5MDYxMjFlMzU2NWI2MDAwNjA0MDUxODA4MzAzODE4NTg3NWFmMTkyNTA1MDUwM2Q4MDYwMDA4MTE0NjEwOWUwNTc2MDQwNTE5MTUwNjAxZjE5NjAzZjNkMDExNjgyMDE2MDQwNTIzZDgyNTIzZDYwMDA2MDIwODQwMTNlNjEwOWU1NTY1YjYwNjA5MTUwNWI1MDUwOTA1MDgwNjEwYTM2NTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwMWQ2MDI0ODIwMTUyN2Y0MzYxNmM2YzIwNzQ2ZjIwNjM2ODY5NmM2NDIwNjM2ZjZlNzQ3MjYxNjM3NDIwNjY2MTY5NmM2NTY0MDAwMDAwNjA0NDgyMDE1MjYwNjQwMTYxMDViYjU2NWI1MDUwNTA2MDAwOTQ4NTUyNTA1MDYwMDc2MDIwNTI1MDUwNjA0MDkwMjA4MDU0NjBmZjE5MTY5MDU1NTA2MTBhNWQ2MDAxODA1NTU2NWI1MDUwNTA1NjViNjEwYTZhNjExNTUxNTY1YjMzNjAwMDYxMGE3NjgyNjExNGNhNTY1YjYwMDA4MTgxNTI2MDA3NjAyMDUyNjA0MDkwMjA1NDkwOTE1MDYwZmYxNjE1NjEwYWE4NTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDA0MDE2MTA1YmI5MDYxMjA0YzU2NWI2MDAwODE4MTUyNjAwNzYwMjA1MjYwNDA4MTIwODA1NDYwZmYxOTE2NjAwMTE3OTA1NTYxMGFjYTg0NjExNWFhNTY1YjUwOTE1MDUwNjAwMDYxMGFkOTMzNjExNGZlNTY1YjkwNTA2MDAwODA1Yjg3NTE4MTEwMTU2MTBjM2Q1NzYwMDA4NDYwMDE2MDAxNjBhMDFiMDMxNjYzNGUzYzRmMjIzMzhiODU4MTUxODExMDYxMGIwYzU3NjEwYjBjNjEyMDA3NTY1YjYwMjAwMjYwMjAwMTAxNTE2MDQwNTE4MzYzZmZmZmZmZmYxNjYwZTAxYjgxNTI2MDA0MDE2MTBiNDY5MjkxOTA2MDAxNjAwMTYwYTAxYjAzOTI4MzE2ODE1MjkxMTY2MDIwODIwMTUyNjA0MDAxOTA1NjViNjA2MDYwNDA1MTgwODMwMzgxNjAwMDg3NWFmMTE1ODAxNTYxMGI2NTU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA1MDYwNDA1MTNkNjAxZjE5NjAxZjgyMDExNjgyMDE4MDYwNDA1MjUwODEwMTkwNjEwYjg5OTE5MDYxMjFmZjU2NWI1MDUwOTA1MDgwODM2MTBiOTk5MTkwNjEyMjJkNTY1YjkyNTA4NDYwMDE2MDAxNjBhMDFiMDMxNjYzNmM3OTE1OGQzMzhiODU4MTUxODExMDYxMGJiZDU3NjEwYmJkNjEyMDA3NTY1YjYwMjAwMjYwMjAwMTAxNTE2MDQwNTE4MzYzZmZmZmZmZmYxNjYwZTAxYjgxNTI2MDA0MDE2MTBiZjc5MjkxOTA2MDAxNjAwMTYwYTAxYjAzOTI4MzE2ODE1MjkxMTY2MDIwODIwMTUyNjA0MDAxOTA1NjViNjAwMDYwNDA1MTgwODMwMzgxNjAwMDg3ODAzYjE1ODAxNTYxMGMxMTU3NjAwMDgwZmQ1YjUwNWFmMTE1ODAxNTYxMGMyNTU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA1MDUwODA4MDYxMGMzNTkwNjEyMDMzNTY1YjkxNTA1MDYxMGFkZjU2NWI1MDgwODI2MDAxMDE2MDAwODI4MjU0NjEwYzUyOTE5MDYxMjIyZDU2NWI5MDkxNTU1MDUwNTA2MDAwOTI4MzUyNTA1MDYwMDc2MDIwNTI2MDQwOTAyMDgwNTQ2MGZmMTkxNjkwNTU1MDYxMGM3YTYwMDE4MDU1NTY1YjUwNTA1NjViNjEwYzg2NjExNTUxNTY1YjMzNjAwMDYxMGM5MjgyNjExNGNhNTY1YjYwMDA4MTgxNTI2MDA3NjAyMDUyNjA0MDkwMjA1NDkwOTE1MDYwZmYxNjE1NjEwY2M0NTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDA0MDE2MTA1YmI5MDYxMjA0YzU2NWI2MDAwODE4MTUyNjAwNzYwMjA1MjYwNDA4MTIwODA1NDYwZmYxOTE2NjAwMTE3OTA1NTYxMGNlNjMzNjExNGNhNTY1YjkwNTA2MDAwNjEwY2YzMzM2MTE0ZmU1NjViOTA1MDYwMDA1YjYwMDY4MjAxNTQ4MTEwMTU2MTBkYTk1NzYwMDk1NDYwMDY4MzAxODA1NDYwMDE2MDAxNjBhMDFiMDM5MDkyMTY5MTYzOTcyMTY3MjU5MTMzOTE4NTkwODExMDYxMGQzMTU3NjEwZDMxNjEyMDA3NTY1YjYwMDA5MTgyNTI2MDIwOTA5MTIwMDE1NDYwNDA1MTYwZTA4NDkwMWI2MDAxNjAwMTYwZTAxYjAzMTkxNjgxNTI2MDAxNjAwMTYwYTAxYjAzOTI4MzE2NjAwNDgyMDE1MjkxMTY2MDI0ODIwMTUyNjA0NDAxNjAwMDYwNDA1MTgwODMwMzgxNjAwMDg3ODAzYjE1ODAxNTYxMGQ4NTU3NjAwMDgwZmQ1YjUwNWFmMTkyNTA1MDUwODAxNTYxMGQ5NjU3NTA2MDAxNWI1MDgwNjEwZGExODE2MTIwMzM1NjViOTE1MDUwNjEwY2Y4NTY1YjUwNjAwMDViNjAwNzgyMDE1NDgxMTAxNTYxMGU1ZTU3NjAwODU0NjAwNzgzMDE4MDU0NjAwMTYwMDE2MGEwMWIwMzkwOTIxNjkxNjM5NzIxNjcyNTkxMzM5MTg1OTA4MTEwNjEwZGU2NTc2MTBkZTY2MTIwMDc1NjViNjAwMDkxODI1MjYwMjA5MDkxMjAwMTU0NjA0MDUxNjBlMDg0OTAxYjYwMDE2MDAxNjBlMDFiMDMxOTE2ODE1MjYwMDE2MDAxNjBhMDFiMDM5MjgzMTY2MDA0ODIwMTUyOTExNjYwMjQ4MjAxNTI2MDQ0MDE2MDAwNjA0MDUxODA4MzAzODE2MDAwODc4MDNiMTU4MDE1NjEwZTNhNTc2MDAwODBmZDViNTA1YWYxOTI1MDUwNTA4MDE1NjEwZTRiNTc1MDYwMDE1YjUwODA2MTBlNTY4MTYxMjAzMzU2NWI5MTUwNTA2MTBkYWQ1NjViNTA2MTBlNmE2MDA0ODM2MTE3NTM1NjViNTA2MDAwODI4MTUyNjAwNjYwMjA1MjYwNDA4MTIwODA1NDYwMDE2MDAxNjBhMDFiMDMxOTE2ODE1NTYwMDE4MTAxODI5MDU1NjAwMjgxMDE4MjkwNTU2MDAzODEwMTgyOTA1NTYwMDQ4MTAxODI5MDU1OTA2MTBlYjI2MDA1ODMwMTYwMDA2MTFhNzI1NjViNjEwZWMwNjAwNjgzMDE2MDAwNjExYWFjNTY1YjYxMGVjZTYwMDc4MzAxNjAwMDYxMWFhYzU2NWI1MDUwNTA2MDAwOTE4MjUyNTA2MDA3NjAyMDUyNjA0MDkwMjA4MDU0NjBmZjE5MTY5MDU1NTA2MTBlZjI2MDAxODA1NTU2NWI1NjViNjEwZWZjNjExNzVmNTY1YjYxMGVmMjYwMDA2MTE3Yjk1NjViNjAwMDgwMzM2MDAwNjEwZjE1ODI2MTE0Y2E1NjViNjAwMDgxODE1MjYwMDc2MDIwNTI2MDQwOTAyMDU0OTA5MTUwNjBmZjE2MTU2MTBmNDc1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMDQwMTYxMDViYjkwNjEyMDRjNTY1YjYwMDA4MTgxNTI2MDA3NjAyMDUyNjA0MDgxMjA4MDU0NjBmZjE5MTY2MDAxMTc5MDU1NjEwZjY5MzM2MTE0Y2E1NjViOTA1MDYxMGY3NDgxNjExODA5NTY1YjE1NjEwZjk0NTc2MDQwNTE2M2NkZTU4YWExNjBlMDFiODE1MjMzNjAwNDgyMDE1MjYwMjQwMTYxMDViYjU2NWI2MTBmYTE4MTMzODkzNDhhNjExODE2NTY1YjUwNjAwMDkwODE1MjYwMDc2MDIwNTI2MDQwODEyMDgwNTQ2MGZmMTkxNjkwNTUzNDk2OTA5NTUwOTM1MDUwNTA1MDU2NWIzMzYwMDA2MTBmZDA4MjYxMTRjYTU2NWI2MDAwODE4MTUyNjAwNzYwMjA1MjYwNDA5MDIwNTQ5MDkxNTA2MGZmMTYxNTYxMTAwMjU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAwNDAxNjEwNWJiOTA2MTIwNGM1NjViNjAwMDgxODE1MjYwMDc2MDIwNTI2MDQwODEyMDgwNTQ2MGZmMTkxNjYwMDExNzkwNTU2MTEwMjQzMzYxMTRmZTU2NWI5MDUwMzQ4MTYwMDEwMTYwMDA4MjgyNTQ2MTEwM2E5MTkwNjEyMjJkNTY1YjkyNTA1MDgxOTA1NTUwMzQ4MTYwMDIwMTYwMDA4MjgyNTQ2MTEwNTU5MTkwNjEyMjJkNTY1YjkwOTE1NTUwNTA1MDYwMDA5MDgxNTI2MDA3NjAyMDUyNjA0MDkwMjA4MDU0NjBmZjE5MTY5MDU1NTA1NjViNjAwMDU0NjAwMTYwYTAxYjkwMDQ2MGZmMTYxNTYxMTBkOTU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDIyNjAyNDgyMDE1MjdmNDk2ZTY5NzQ2OTYxNmM2OTdhNjE2MjZjNjUzYTIwNjE2YzcyNjU2MTY0NzkyMDY5NmU2OTc0Njk2MTZjNjk3YTYwNDQ4MjAxNTI2MTE5NTk2MGYyMWI2MDY0ODIwMTUyNjA4NDAxNjEwNWJiNTY1YjYwMDA4MDU0NjBmZjYwYTAxYjE5MTY2MDAxNjBhMDFiMTc5MDU1NjExMGY1ODE2MTE3Yjk1NjViNTA2MDAyODA1NDYwMDE2MDAxNjBhMDFiMDM5Mzg0MTY2MDAxNjAwMTYwYTAxYjAzMTk5MTgyMTY4MTE3OTA5MjU1NjAwMzgwNTQ5MzkwOTQxNjkyODExNjgzMTc5MDkzNTU2MDA4ODA1NDg0MTY5MDkyMTc5MDkxNTU2MDA5ODA1NDkwOTIxNjE3OTA1NTU2NWI2MDAzNTQ2MDAxNjAwMTYwYTAxYjAzMTYzMzE0ODA2MTExNjE1NzUwNjAwMjU0NjAwMTYwMDE2MGEwMWIwMzE2MzMxNDViNjExMWM5NTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwMzM2MDI0ODIwMTUyN2Y0MzYxNmM2YzY1NzIyMDY5NzMyMDZlNmY3NDIwNzQ2ODY1MjA2NjY5NmU2NTIwNzQ3NTZlNjk2ZTY3MjA2ZjcyNjA0NDgyMDE1MjcyMDgxYTViOTk5OTVjOTk1Yjk4ZDk0ODE4ZGJkYjlkMWM5ODU4ZGQ2MDZhMWI2MDY0ODIwMTUyNjA4NDAxNjEwNWJiNTY1YjYwMDA2MTExZDQ4MzYxMTRmZTU2NWI5MDUwODE4MTYwMDEwMTU0ODI2MDAyMDE1NDYxMTFlYjkxOTA2MTIwODM1NjViMTAxNTYxMTIzMDU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDE0NjAyNDgyMDE1MjczNDk2ZTczNzU2NjY2Njk2MzY5NjU2ZTc0MjA2MjYxNmM2MTZlNjM2NTYwNjAxYjYwNDQ4MjAxNTI2MDY0MDE2MTA1YmI1NjViODE4MTYwMDIwMTYwMDA4MjgyNTQ2MTEyNDQ5MTkwNjEyMDgzNTY1YjkwOTE1NTUwNTA1MDUwNTA1NjViNjExMjU2NjExNzVmNTY1YjYwMDE2MDAxNjBhMDFiMDM4MTE2NjExMmJiNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwMjY2MDI0ODIwMTUyN2Y0Zjc3NmU2MTYyNmM2NTNhMjA2ZTY1NzcyMDZmNzc2ZTY1NzIyMDY5NzMyMDc0Njg2NTIwN2E2NTcyNmYyMDYxNjA0NDgyMDE1MjY1NjQ2NDcyNjU3MzczNjBkMDFiNjA2NDgyMDE1MjYwODQwMTYxMDViYjU2NWI2MTEyYzQ4MTYxMTdiOTU2NWI1MDU2NWI2MTEyY2Y2MTFhMjY1NjViNjExMmQ4ODI2MTE0ZmU1NjViNjA0MDgwNTE2MGUwODEwMTgyNTI4MjU0NjAwMTYwMDE2MGEwMWIwMzE2ODE1MjYwMDE4MzAxNTQ2MDIwODIwMTUyNjAwMjgwODQwMTU0ODI4NDAxNTI4MjUxODA4NDAxOTM4NDkwNTI5MTkzOTI2MDYwODUwMTkyOTE2MDAzODUwMTkxODI4NDViODE1NDgxNTI2MDIwMDE5MDYwMDEwMTkwODA4MzExNjExMzFkNTc1MDUwNTA1MDUwODE1MjYwMjAwMTYwMDU4MjAxODA1NDYxMTM0OTkwNjExZmNkNTY1YjgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ2MTEzNzU5MDYxMWZjZDU2NWI4MDE1NjExM2MyNTc4MDYwMWYxMDYxMTM5NzU3NjEwMTAwODA4MzU0MDQwMjgzNTI5MTYwMjAwMTkxNjExM2MyNTY1YjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0ODE1MjkwNjAwMTAxOTA2MDIwMDE4MDgzMTE2MTEzYTU1NzgyOTAwMzYwMWYxNjgyMDE5MTViNTA1MDUwNTA1MDgxNTI2MDIwMDE2MDA2ODIwMTgwNTQ4MDYwMjAwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0ODAxNTYxMTQyNDU3NjAyMDAyODIwMTkxOTA2MDAwNTI2MDIwNjAwMDIwOTA1YjgxNTQ2MDAxNjAwMTYwYTAxYjAzMTY4MTUyNjAwMTkwOTEwMTkwNjAyMDAxODA4MzExNjExNDA2NTc1YjUwNTA1MDUwNTA4MTUyNjAyMDAxNjAwNzgyMDE4MDU0ODA2MDIwMDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTgyODA1NDgwMTU2MTE0ODY1NzYwMjAwMjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0NjAwMTYwMDE2MGEwMWIwMzE2ODE1MjYwMDE5MDkxMDE5MDYwMjAwMTgwODMxMTYxMTQ2ODU3NWI1MDUwNTA1MDUwODE1MjUwNTA5MDUwOTE5MDUwNTY1YjYwMDA2MTE0YTI2MDA0NjExODgwNTY1YjkwNTA5MDU2NWI2MDAwODA2MTE0YjU2MDA0ODQ2MTE4OGE1NjViNjAwMDkwODE1MjYwMDY2MDIwNTI2MDQwOTAyMDkzOTI1MDUwNTA1NjViNjA0MDgwNTE2MDAxNjAwMTYwYTAxYjAzODMxNjYwMjA4MjAxNTI2MDAwOTEwMTYwNDA1MTYwMjA4MTgzMDMwMzgxNTI5MDYwNDA1MjgwNTE5MDYwMjAwMTIwOTA1MDkxOTA1MDU2NWI2MDAwODA2MTE1MGE4MzYxMTRjYTU2NWI5MDUwNjExNTE1ODE2MTE4MDk1NjViNjExNTNkNTc2MDQwNTE2MzdkMmQ1MzZiNjBlMDFiODE1MjYwMDE2MDAxNjBhMDFiMDM4NDE2NjAwNDgyMDE1MjYwMjQwMTYxMDViYjU2NWI2MDAwOTA4MTUyNjAwNjYwMjA1MjYwNDA5MDIwOTI5MTUwNTA1NjViNjAwMjYwMDE1NDAzNjExNWEzNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwMWY2MDI0ODIwMTUyN2Y1MjY1NjU2ZTc0NzI2MTZlNjM3OTQ3NzU2MTcyNjQzYTIwNzI2NTY1NmU3NDcyNjE2ZTc0MjA2MzYxNmM2YzAwNjA0NDgyMDE1MjYwNjQwMTYxMDViYjU2NWI2MDAyNjAwMTU1NTY1YjYwMDA4MDYwMDA4MDg0NjA0MDUxNjAyMDAxNjExNWMxOTE5MDYxMjFlMzU2NWI2MDQwNTE2MDIwODE4MzAzMDM4MTUyOTA2MDQwNTI4MDUxOTA2MDIwMDEyMDkwNTA3ZjJhNTJiNjI2MWYzODUwYjg5NTQxYWI0NDQ0ODY5MDA0ZmU1NTJlNTA1MzI4MDg2NDE4MDAwNzZmOGU5ZWM0NjU4MTAzNjExNjFmNTc1MDUwNjAwMjU0NjAwOTU0NjAwMTYwMDE2MGEwMWIwMzkxODIxNjkzNTAxNjkwNTA2MDAwNjExNmE0NTY1YjdmMzdmMGQxZjIzMDM3MjBiYWI5NWUzYzczOWIxNTE4OGQ4YzE5ZmFkZTMyZWI2M2Y4MGVmM2QwNmI2NGRhYTlkMjgxMDM2MTE2NjU1NzUwNTA2MDAzNTQ2MDA4NTQ2MDAxNjAwMTYwYTAxYjAzOTE4MjE2OTM1MDE2OTA1MDYwMDE2MTE2YTQ1NjViNjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDE0NjAyNDgyMDE1MjczNDk2ZTc2NjE2YzY5NjQyMDczNjU3Mjc2Njk2MzY1MjA3NDc5NzA2NTYwNjAxYjYwNDQ4MjAxNTI2MDY0MDE2MTA1YmI1NjViOTE5MzkwOTI1MDU2NWI2MDAwODE4MzEwNjExNmJhNTc4MTYxMTZiYzU2NWI4MjViOTA1MDViOTI5MTUwNTA1NjViNjAwMDViODI1NDgxMTAxNTYxMTcxZTU3ODE2MDAxNjAwMTYwYTAxYjAzMTY4MzgyODE1NDgxMTA2MTE2ZWQ1NzYxMTZlZDYxMjAwNzU2NWI2MDAwOTE4MjUyNjAyMDkwOTEyMDAxNTQ2MDAxNjAwMTYwYTAxYjAzMTYwMzYxMTcwYzU3NTA1MDUwNTY1YjgwNjExNzE2ODE2MTIwMzM1NjViOTE1MDUwNjExNmM4NTY1YjUwODE1NDYwMDE4MTAxODM1NTYwMDA5MjgzNTI2MDIwOTA5MjIwOTA5MTAxODA1NDYwMDE2MDAxNjBhMDFiMDMxOTE2NjAwMTYwMDE2MGEwMWIwMzkwOTIxNjkxOTA5MTE3OTA1NTU2NWI2MDAwNjExNmJjODM4MzYxMTg5NjU2NWI2MDAwNTQ2MDAxNjAwMTYwYTAxYjAzMTYzMzE0NjEwZWYyNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE4MTkwNTI2MDI0ODIwMTUyN2Y0Zjc3NmU2MTYyNmM2NTNhMjA2MzYxNmM2YzY1NzIyMDY5NzMyMDZlNmY3NDIwNzQ2ODY1MjA2Zjc3NmU2NTcyNjA0NDgyMDE1MjYwNjQwMTYxMDViYjU2NWI2MDAwODA1NDYwMDE2MDAxNjBhMDFiMDM4MzgxMTY2MDAxNjAwMTYwYTAxYjAzMTk4MzE2ODExNzg0NTU2MDQwNTE5MTkwOTIxNjkyODM5MTdmOGJlMDA3OWM1MzE2NTkxNDEzNDRjZDFmZDBhNGYyODQxOTQ5N2Y5NzIyYTNkYWFmZTNiNDE4NmY2YjY0NTdlMDkxOTBhMzUwNTA1NjViNjAwMDYxMTZiZjYwMDQ4MzYxMTk4OTU2NWI2MDAwODU4MTUyNjAwNjYwMjA1MjYwNDA5MDIwNjAwMTgxMDE4MzkwNTU2MDAyODA4MjAxODQ5MDU1ODE1NDYwMDE2MDAxNjBhMDFiMDMxOTE2NjAwMTYwMDE2MGEwMWIwMzg3MTYxNzgyNTU2MTE4NWM5MDYwMDM4MzAxOTA4NjkwNjExYWNhNTY1YjUwNjAwNTgxMDE2MTE4NmI4MzgyNjEyMjhlNTY1YjUwNjExODc3NjAwNDg3NjExOWExNTY1YjUwNTA1MDUwNTA1MDUwNTY1YjYwMDA2MTE2YmY4MjU0OTA1NjViNjAwMDYxMTZiYzgzODM2MTE5YWQ1NjViNjAwMDgxODE1MjYwMDE4MzAxNjAyMDUyNjA0MDgxMjA1NDgwMTU2MTE5N2Y1NzYwMDA2MTE4YmE2MDAxODM2MTIwODM1NjViODU1NDkwOTE1MDYwMDA5MDYxMThjZTkwNjAwMTkwNjEyMDgzNTY1YjkwNTA4MTgxMTQ2MTE5MzM1NzYwMDA4NjYwMDAwMTgyODE1NDgxMTA2MTE4ZWU1NzYxMThlZTYxMjAwNzU2NWI5MDYwMDA1MjYwMjA2MDAwMjAwMTU0OTA1MDgwODc2MDAwMDE4NDgxNTQ4MTEwNjExOTExNTc2MTE5MTE2MTIwMDc1NjViNjAwMDkxODI1MjYwMjA4MDgzMjA5MDkxMDE5MjkwOTI1NTkxODI1MjYwMDE4ODAxOTA1MjYwNDA5MDIwODM5MDU1NWI4NTU0ODY5MDgwNjExOTQ0NTc2MTE5NDQ2MTIzNGU1NjViNjAwMTkwMDM4MTgxOTA2MDAwNTI2MDIwNjAwMDIwMDE2MDAwOTA1NTkwNTU4NTYwMDEwMTYwMDA4NjgxNTI2MDIwMDE5MDgxNTI2MDIwMDE2MDAwMjA2MDAwOTA1NTYwMDE5MzUwNTA1MDUwNjExNmJmNTY1YjYwMDA5MTUwNTA2MTE2YmY1NjViNjAwMDgxODE1MjYwMDE4MzAxNjAyMDUyNjA0MDgxMjA1NDE1MTU2MTE2YmM1NjViNjAwMDYxMTZiYzgzODM2MTE5ZDc1NjViNjAwMDgyNjAwMDAxODI4MTU0ODExMDYxMTljNDU3NjExOWM0NjEyMDA3NTY1YjkwNjAwMDUyNjAyMDYwMDAyMDAxNTQ5MDUwOTI5MTUwNTA1NjViNjAwMDgxODE1MjYwMDE4MzAxNjAyMDUyNjA0MDgxMjA1NDYxMWExZTU3NTA4MTU0NjAwMTgxODEwMTg0NTU2MDAwODQ4MTUyNjAyMDgwODIyMDkwOTMwMTg0OTA1NTg0NTQ4NDgyNTI4Mjg2MDE5MDkzNTI2MDQwOTAyMDkxOTA5MTU1NjExNmJmNTY1YjUwNjAwMDYxMTZiZjU2NWI2MDQwNTE4MDYwZTAwMTYwNDA1MjgwNjAwMDYwMDE2MDAxNjBhMDFiMDMxNjgxNTI2MDIwMDE2MDAwODE1MjYwMjAwMTYwMDA4MTUyNjAyMDAxNjExYTU3NjExYjA4NTY1YjgxNTI2MDIwMDE2MDYwODE1MjYwMjAwMTYwNjA4MTUyNjAyMDAxNjA2MDgxNTI1MDkwNTY1YjUwODA1NDYxMWE3ZTkwNjExZmNkNTY1YjYwMDA4MjU1ODA2MDFmMTA2MTFhOGU1NzUwNTA1NjViNjAxZjAxNjAyMDkwMDQ5MDYwMDA1MjYwMjA2MDAwMjA5MDgxMDE5MDYxMTJjNDkxOTA2MTFiMjY1NjViNTA4MDU0NjAwMDgyNTU5MDYwMDA1MjYwMjA2MDAwMjA5MDgxMDE5MDYxMTJjNDkxOTA2MTFiMjY1NjViODI2MDAyODEwMTkyODIxNTYxMWFmODU3OTE2MDIwMDI4MjAxNWI4MjgxMTExNTYxMWFmODU3ODIzNTgyNTU5MTYwMjAwMTkxOTA2MDAxMDE5MDYxMWFkZDU2NWI1MDYxMWIwNDkyOTE1MDYxMWIyNjU2NWI1MDkwNTY1YjYwNDA1MTgwNjA0MDAxNjA0MDUyODA2MDAyOTA2MDIwODIwMjgwMzY4MzM3NTA5MTkyOTE1MDUwNTY1YjViODA4MjExMTU2MTFiMDQ1NzYwMDA4MTU1NjAwMTAxNjExYjI3NTY1YjYwMDA1YjgzODExMDE1NjExYjU2NTc4MTgxMDE1MTgzODIwMTUyNjAyMDAxNjExYjNlNTY1YjUwNTA2MDAwOTEwMTUyNTY1YjYwMDA4MTUxODA4NDUyNjExYjc3ODE2MDIwODYwMTYwMjA4NjAxNjExYjNiNTY1YjYwMWYwMTYwMWYxOTE2OTI5MDkyMDE2MDIwMDE5MjkxNTA1MDU2NWI2MDAwODE1MTgwODQ1MjYwMjA4MDg1MDE5NDUwODA4NDAxNjAwMDViODM4MTEwMTU2MTFiYzQ1NzgxNTE2MDAxNjAwMTYwYTAxYjAzMTY4NzUyOTU4MjAxOTU5MDgyMDE5MDYwMDEwMTYxMWI5ZjU2NWI1MDk0OTU5NDUwNTA1MDUwNTA1NjViNjAwMDYxMDEwMDYwMDE4MDYwYTAxYjAzODM1MTE2ODQ1MjYwMjA4MDg0MDE1MTgxODYwMTUyNjA0MDg0MDE1MTYwNDA4NjAxNTI2MDYwODQwMTUxNjA2MDg2MDE2MDAwNWI2MDAyODExMDE1NjExYzFkNTc4MjUxODI1MjkxODMwMTkxOTA4MzAxOTA2MDAxMDE2MTFjMDA1NjViNTA1MDUwNTA2MDgwODMwMTUxODE2MGEwODYwMTUyNjExYzM4ODI4NjAxODI2MTFiNWY1NjViOTE1MDUwNjBhMDgzMDE1MTg0ODIwMzYwYzA4NjAxNTI2MTFjNTI4MjgyNjExYjhiNTY1YjkxNTA1MDYwYzA4MzAxNTE4NDgyMDM2MGUwODYwMTUyNjExYzZjODI4MjYxMWI4YjU2NWI5NTk0NTA1MDUwNTA1MDU2NWI2MDAwNjAyMDgwODMwMTgxODQ1MjgwODU1MTgwODM1MjYwNDA4NjAxOTE1MDYwNDA4MTYwMDUxYjg3MDEwMTkyNTA4Mzg3MDE2MDAwNWI4MjgxMTAxNTYxMWNjYTU3NjAzZjE5ODg4NjAzMDE4NDUyNjExY2I4ODU4MzUxNjExYmNmNTY1Yjk0NTA5Mjg1MDE5MjkwODUwMTkwNjAwMTAxNjExYzljNTY1YjUwOTI5Nzk2NTA1MDUwNTA1MDUwNTA1NjViNjAwMDYwMjA4Mjg0MDMxMjE1NjExY2U5NTc2MDAwODBmZDViNTAzNTkxOTA1MDU2NWI4MDM1NjAwMTYwMDE2MGEwMWIwMzgxMTY4MTE0NjExZDA3NTc2MDAwODBmZDViOTE5MDUwNTY1YjYzNGU0ODdiNzE2MGUwMWI2MDAwNTI2MDQxNjAwNDUyNjAyNDYwMDBmZDViNjA0MDUxNjAxZjgyMDE2MDFmMTkxNjgxMDE2N2ZmZmZmZmZmZmZmZmZmZmY4MTExODI4MjEwMTcxNTYxMWQ0YjU3NjExZDRiNjExZDBjNTY1YjYwNDA1MjkxOTA1MDU2NWI2MDAwODI2MDFmODMwMTEyNjExZDY0NTc2MDAwODBmZDViODEzNTY3ZmZmZmZmZmZmZmZmZmZmZjgxMTExNTYxMWQ3ZTU3NjExZDdlNjExZDBjNTY1YjYxMWQ5MTYwMWY4MjAxNjAxZjE5MTY2MDIwMDE2MTFkMjI1NjViODE4MTUyODQ2MDIwODM4NjAxMDExMTE1NjExZGE2NTc2MDAwODBmZDViODE2MDIwODUwMTYwMjA4MzAxMzc2MDAwOTE4MTAxNjAyMDAxOTE5MDkxNTI5MzkyNTA1MDUwNTY1YjYwMDA4MDYwMDA2MDYwODQ4NjAzMTIxNTYxMWRkODU3NjAwMDgwZmQ1YjYxMWRlMTg0NjExY2YwNTY1YjkyNTA2MDIwODQwMTM1NjdmZmZmZmZmZmZmZmZmZmZmODExMTE1NjExZGZkNTc2MDAwODBmZDViNjExZTA5ODY4Mjg3MDE2MTFkNTM1NjViOTI1MDUwNjA0MDg0MDEzNTkwNTA5MjUwOTI1MDkyNTY1YjYwMDA4MDYwNDA4Mzg1MDMxMjE1NjExZTJkNTc2MDAwODBmZDViODIzNTY3ZmZmZmZmZmZmZmZmZmZmZjgwODIxMTE1NjExZTQ1NTc2MDAwODBmZDViODE4NTAxOTE1MDg1NjAxZjgzMDExMjYxMWU1OTU3NjAwMDgwZmQ1YjgxMzU2MDIwODI4MjExMTU2MTFlNmQ1NzYxMWU2ZDYxMWQwYzU2NWI4MTYwMDUxYjYxMWU3YzgyODIwMTYxMWQyMjU2NWI5MjgzNTI4NDgxMDE4MjAxOTI4MjgxMDE5MDhhODUxMTE1NjExZTk2NTc2MDAwODBmZDViOTU4MzAxOTU1Yjg0ODcxMDE1NjExZWJiNTc2MTFlYWM4NzYxMWNmMDU2NWI4MjUyOTU4MzAxOTU5MDgzMDE5MDYxMWU5YjU2NWI5NzUwNTA1MDg2MDEzNTkyNTA1MDgwODIxMTE1NjExZWQyNTc2MDAwODBmZDViNTA2MTFlZGY4NTgyODYwMTYxMWQ1MzU2NWI5MTUwNTA5MjUwOTI5MDUwNTY1YjYwMDA4MDYwNjA4Mzg1MDMxMjE1NjExZWZjNTc2MDAwODBmZDViNjA0MDgzMDE4NDgxMTExNTYxMWYwZDU3NjAwMDgwZmQ1YjgzOTI1MDM1NjdmZmZmZmZmZmZmZmZmZmZmODExMTE1NjExZjI2NTc2MDAwODBmZDViNjExZWRmODU4Mjg2MDE2MTFkNTM1NjViNjAwMDgwNjAwMDYwNjA4NDg2MDMxMjE1NjExZjQ3NTc2MDAwODBmZDViNjExZjUwODQ2MTFjZjA1NjViOTI1MDYxMWY1ZTYwMjA4NTAxNjExY2YwNTY1YjkxNTA2MTFmNmM2MDQwODUwMTYxMWNmMDU2NWI5MDUwOTI1MDkyNTA5MjU2NWI2MDAwODA2MDQwODM4NTAzMTIxNTYxMWY4ODU3NjAwMDgwZmQ1YjYxMWY5MTgzNjExY2YwNTY1Yjk0NjAyMDkzOTA5MzAxMzU5MzUwNTA1MDU2NWI2MDAwNjAyMDgyODQwMzEyMTU2MTFmYjE1NzYwMDA4MGZkNWI2MTE2YmM4MjYxMWNmMDU2NWI2MDIwODE1MjYwMDA2MTE2YmM2MDIwODMwMTg0NjExYmNmNTY1YjYwMDE4MTgxMWM5MDgyMTY4MDYxMWZlMTU3NjA3ZjgyMTY5MTUwNWI2MDIwODIxMDgxMDM2MTIwMDE1NzYzNGU0ODdiNzE2MGUwMWI2MDAwNTI2MDIyNjAwNDUyNjAyNDYwMDBmZDViNTA5MTkwNTA1NjViNjM0ZTQ4N2I3MTYwZTAxYjYwMDA1MjYwMzI2MDA0NTI2MDI0NjAwMGZkNWI2MzRlNDg3YjcxNjBlMDFiNjAwMDUyNjAxMTYwMDQ1MjYwMjQ2MDAwZmQ1YjYwMDA2MDAxODIwMTYxMjA0NTU3NjEyMDQ1NjEyMDFkNTY1YjUwNjAwMTAxOTA1NjViNjAyMDgwODI1MjYwMWI5MDgyMDE1MjdmNGM2NTY0Njc2NTcyMjA2YzZmNjM2YjY1NjQyMDY2NmY3MjIwNmY3MDY1NzI2MTc0Njk2ZjZlMDAwMDAwMDAwMDYwNDA4MjAxNTI2MDYwMDE5MDU2NWI4MTgxMDM4MTgxMTExNTYxMTZiZjU3NjExNmJmNjEyMDFkNTY1YjYwMDA2MDIwODI4NDAzMTIxNTYxMjBhODU3NjAwMDgwZmQ1YjgxNTE4MDE1MTU4MTE0NjEyMGI4NTc2MDAwODBmZDViOTM5MjUwNTA1MDU2NWI2MDAwNjAyMDgyODQwMzEyMTU2MTIwZDE1NzYwMDA4MGZkNWI1MDUxOTE5MDUwNTY1YjYwMDA4MTU0NjEyMGU1ODE2MTFmY2Q1NjViODA4NTUyNjAyMDYwMDE4MzgxMTY4MDE1NjEyMTAyNTc2MDAxODExNDYxMjExYzU3NjEyMTRhNTY1YjYwZmYxOTg1MTY4ODg0MDE1MjgzMTUxNTYwMDUxYjg4MDE4MzAxOTU1MDYxMjE0YTU2NWI4NjYwMDA1MjgyNjAwMDIwNjAwMDViODU4MTEwMTU2MTIxNDI1NzgxNTQ4YTgyMDE4NjAxNTI5MDgzMDE5MDg0MDE2MTIxMjc1NjViODkwMTg0MDE5NjUwNTA1YjUwNTA1MDUwNTA5MjkxNTA1MDU2NWI2MDAxNjAwMTYwYTAxYjAzODU4MTE2ODI1Mjg0MTY2MDIwODA4MzAxOTE5MDkxNTI2MDAwOTA2MDQwODMwMTkwODU4MzViNjAwMjgxMTAxNTYxMjE5NTU3ODE1NDg0NTI5MjgyMDE5MjYwMDE5MTgyMDE5MTAxNjEyMTc4NTY1YjUwNTA1MDUwNjBhMDYwODA4MzAxNTI2MTIxYWQ2MGEwODMwMTg0NjEyMGQ4NTY1Yjk2OTU1MDUwNTA1MDUwNTA1NjViNjAwMTYwMDE2MGEwMWIwMzg0ODExNjgyNTI4MzE2NjAyMDgyMDE1MjYwNjA2MDQwODIwMTgxOTA1MjYwMDA5MDYxMWM2YzkwODMwMTg0NjEyMGQ4NTY1YjYwMDA4MjUxNjEyMWY1ODE4NDYwMjA4NzAxNjExYjNiNTY1YjkxOTA5MTAxOTI5MTUwNTA1NjViNjAwMDgwNjAwMDYwNjA4NDg2MDMxMjE1NjEyMjE0NTc2MDAwODBmZDViODM1MTkyNTA2MDIwODQwMTUxOTE1MDYwNDA4NDAxNTE5MDUwOTI1MDkyNTA5MjU2NWI4MDgyMDE4MDgyMTExNTYxMTZiZjU3NjExNmJmNjEyMDFkNTY1YjYwMWY4MjExMTU2MTBhNWQ1NzYwMDA4MTgxNTI2MDIwODEyMDYwMWY4NTAxNjAwNTFjODEwMTYwMjA4NjEwMTU2MTIyNjc1NzUwODA1YjYwMWY4NTAxNjAwNTFjODIwMTkxNTA1YjgxODExMDE1NjEyMjg2NTc4MjgxNTU2MDAxMDE2MTIyNzM1NjViNTA1MDUwNTA1MDUwNTY1YjgxNTE2N2ZmZmZmZmZmZmZmZmZmZmY4MTExMTU2MTIyYTg1NzYxMjJhODYxMWQwYzU2NWI2MTIyYmM4MTYxMjJiNjg0NTQ2MTFmY2Q1NjViODQ2MTIyNDA1NjViNjAyMDgwNjAxZjgzMTE2MDAxODExNDYxMjJmMTU3NjAwMDg0MTU2MTIyZDk1NzUwODU4MzAxNTE1YjYwMDAxOTYwMDM4NjkwMWIxYzE5MTY2MDAxODU5MDFiMTc4NTU1NjEyMjg2NTY1YjYwMDA4NTgxNTI2MDIwODEyMDYwMWYxOTg2MTY5MTViODI4MTEwMTU2MTIzMjA1Nzg4ODYwMTUxODI1NTk0ODQwMTk0NjAwMTkwOTEwMTkwODQwMTYxMjMwMTU2NWI1MDg1ODIxMDE1NjEyMzNlNTc4Nzg1MDE1MTYwMDAxOTYwMDM4ODkwMWI2MGY4MTYxYzE5MTY4MTU1NWI1MDUwNTA1MDUwNjAwMTkwODExYjAxOTA1NTUwNTY1YjYzNGU0ODdiNzE2MGUwMWI2MDAwNTI2MDMxNjAwNDUyNjAyNDYwMDBmZGZlYTI2NDY5NzA2NjczNTgyMjEyMjBjNDdjOTZhODFkMTgxNmIwMzdlNGZhM2UyMjEyYjgwYzUxNDY0ZTk5MzA4MTU3NTVkOTM3ZDU1Y2VlZDZiZjQ4NjQ3MzZmNmM2MzQzMDAwODE0MDAzMyc7XG5jb25zdCBpc1N1cGVyQXJncyQyID0gKHhzKSA9PiB4cy5sZW5ndGggPiAxO1xuY2xhc3MgTGVkZ2VyTWFuYWdlcl9fZmFjdG9yeSBleHRlbmRzIENvbnRyYWN0RmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBpZiAoaXNTdXBlckFyZ3MkMihhcmdzKSkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcihfYWJpJDIsIF9ieXRlY29kZSQyLCBhcmdzWzBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREZXBsb3lUcmFuc2FjdGlvbihvdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldERlcGxveVRyYW5zYWN0aW9uKG92ZXJyaWRlcyB8fCB7fSk7XG4gICAgfVxuICAgIGRlcGxveShvdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRlcGxveShvdmVycmlkZXMgfHwge30pO1xuICAgIH1cbiAgICBjb25uZWN0KHJ1bm5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIuY29ubmVjdChydW5uZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgYnl0ZWNvZGUgPSBfYnl0ZWNvZGUkMjtcbiAgICBzdGF0aWMgYWJpID0gX2FiaSQyO1xuICAgIHN0YXRpYyBjcmVhdGVJbnRlcmZhY2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKF9hYmkkMik7XG4gICAgfVxuICAgIHN0YXRpYyBjb25uZWN0KGFkZHJlc3MsIHJ1bm5lcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0KGFkZHJlc3MsIF9hYmkkMiwgcnVubmVyKTtcbiAgICB9XG59XG5cbi8qIEF1dG9nZW5lcmF0ZWQgZmlsZS4gRG8gbm90IGVkaXQgbWFudWFsbHkuICovXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IF9hYmkkMSA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ0FjY291bnRFeGlzdHMnLFxuICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndXNlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdBY2NvdW50Tm90RXhpc3RzJyxcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncmVhc29uJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdJbnZhbGlkUHJvb2ZJbnB1dHMnLFxuICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdTZXJ2aWNlTm90RXhpc3QnLFxuICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgIH0sXG4gICAge1xuICAgICAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BlbmRpbmdSZWZ1bmQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdCYWxhbmNlVXBkYXRlZCcsXG4gICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFub255bW91czogZmFsc2UsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3ByZXZpb3VzT3duZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbmV3T3duZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdPd25lcnNoaXBUcmFuc2ZlcnJlZCcsXG4gICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFub255bW91czogZmFsc2UsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnaW5kZXgnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3RpbWVzdGFtcCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ1JlZnVuZFJlcXVlc3RlZCcsXG4gICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFub255bW91czogZmFsc2UsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3NlcnZpY2UnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdTZXJ2aWNlUmVtb3ZlZCcsXG4gICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFub255bW91czogZmFsc2UsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3NlcnZpY2UnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc2VydmljZVR5cGUnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1cmwnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnaW5wdXRQcmljZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnb3V0cHV0UHJpY2UnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VwZGF0ZWRBdCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdtb2RlbCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3ZlcmlmaWFiaWxpdHknLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ1NlcnZpY2VVcGRhdGVkJyxcbiAgICAgICAgdHlwZTogJ2V2ZW50JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnYWNjb3VudEV4aXN0cycsXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTZbMl0nLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlclB1YktleScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTZbMl0nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ2Fja25vd2xlZGdlUHJvdmlkZXJTaWduZXInLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2WzJdJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc2lnbmVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NlsyXScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2FkZGl0aW9uYWxJbmZvJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdhZGRBY2NvdW50JyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3BheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2VydmljZVR5cGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndXJsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21vZGVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3ZlcmlmaWFiaWxpdHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2lucHV0UHJpY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdvdXRwdXRQcmljZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRkaXRpb25hbEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgU2VydmljZVBhcmFtcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BhcmFtcycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdhZGRPclVwZGF0ZVNlcnZpY2UnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6ICdiYXRjaFZlcmlmaWVyQWRkcmVzcycsXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnZGVsZXRlQWNjb3VudCcsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjYW5jZWxSZXRyaWV2aW5nQW1vdW50JyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnZGVwb3NpdEZ1bmQnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAncGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ2dldEFjY291bnQnLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdub25jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwZW5kaW5nUmVmdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NlsyXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2lnbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2WzJdJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpbmRleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY3JlYXRlZEF0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb2Nlc3NlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBSZWZ1bmRbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVmdW5kcycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndHVwbGVbXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRkaXRpb25hbEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTZbMl0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyUHViS2V5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2WzJdJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBBY2NvdW50JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndHVwbGUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ2dldEFjY291bnRzQnlQcm92aWRlcicsXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ25vbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3BlbmRpbmdSZWZ1bmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2WzJdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzaWduZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTZbMl0nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2luZGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjcmVhdGVkQXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJvY2Vzc2VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RydWN0IFJlZnVuZFtdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdyZWZ1bmRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0dXBsZVtdJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhZGRpdGlvbmFsSW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NlsyXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXJQdWJLZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTZbMl0nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RydWN0IEFjY291bnRbXScsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2FjY291bnRzJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndHVwbGVbXScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0b3RhbCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnZ2V0QWNjb3VudHNCeVVzZXInLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdub25jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwZW5kaW5nUmVmdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NlsyXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2lnbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2WzJdJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpbmRleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY3JlYXRlZEF0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb2Nlc3NlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBSZWZ1bmRbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVmdW5kcycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndHVwbGVbXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRkaXRpb25hbEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTZbMl0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyUHViS2V5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2WzJdJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBBY2NvdW50W10nLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhY2NvdW50cycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlW10nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndG90YWwnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiAnZ2V0QWxsQWNjb3VudHMnLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdub25jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwZW5kaW5nUmVmdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NlsyXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2lnbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2WzJdJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpbmRleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY3JlYXRlZEF0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb2Nlc3NlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBSZWZ1bmRbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVmdW5kcycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndHVwbGVbXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRkaXRpb25hbEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTZbMl0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyUHViS2V5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2WzJdJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBBY2NvdW50W10nLFxuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0dXBsZVtdJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiAnZ2V0QWxsU2VydmljZXMnLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2VydmljZVR5cGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndXJsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpbnB1dFByaWNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnb3V0cHV0UHJpY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1cGRhdGVkQXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21vZGVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3ZlcmlmaWFiaWxpdHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRkaXRpb25hbEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgU2VydmljZVtdJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc2VydmljZXMnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0dXBsZVtdJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzW10nLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VycycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3NbXScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnZ2V0QmF0Y2hBY2NvdW50c0J5VXNlcnMnLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdub25jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwZW5kaW5nUmVmdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NlsyXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2lnbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2WzJdJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpbmRleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY3JlYXRlZEF0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb2Nlc3NlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBSZWZ1bmRbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVmdW5kcycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndHVwbGVbXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRkaXRpb25hbEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTZbMl0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyUHViS2V5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2WzJdJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBBY2NvdW50W10nLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhY2NvdW50cycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlW10nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ2dldFBlbmRpbmdSZWZ1bmQnLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ2dldFNlcnZpY2UnLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2VydmljZVR5cGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndXJsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpbnB1dFByaWNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnb3V0cHV0UHJpY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1cGRhdGVkQXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21vZGVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3ZlcmlmaWFiaWxpdHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRkaXRpb25hbEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgU2VydmljZScsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3NlcnZpY2UnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0dXBsZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ19sb2NrdGltZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnX2JhdGNoVmVyaWZpZXJBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdfbGVkZ2VyQWRkcmVzcycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnb3duZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdpbml0aWFsaXplJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiAnaW5pdGlhbGl6ZWQnLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6ICdsZWRnZXJBZGRyZXNzJyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiAnbG9ja1RpbWUnLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6ICdvd25lcicsXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAncHJvY2Vzc1JlZnVuZCcsXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndG90YWxBbW91bnQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BlbmRpbmdSZWZ1bmQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiAncmVtb3ZlU2VydmljZScsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogJ3Jlbm91bmNlT3duZXJzaGlwJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndXNlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdyZXF1ZXN0UmVmdW5kQWxsJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTZbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnaW5Qcm9vZicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NltdJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NltdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwcm9vZklucHV0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NltdJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbnVtQ2h1bmtzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NltdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzZWdtZW50U2l6ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NltdJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBWZXJpZmllcklucHV0JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndmVyaWZpZXJJbnB1dCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdzZXR0bGVGZWVzJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbmV3T3duZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICd0cmFuc2Zlck93bmVyc2hpcCcsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ19iYXRjaFZlcmlmaWVyQWRkcmVzcycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ3VwZGF0ZUJhdGNoVmVyaWZpZXJBZGRyZXNzJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnX2xvY2t0aW1lJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAndXBkYXRlTG9ja1RpbWUnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbl07XG5jb25zdCBfYnl0ZWNvZGUkMSA9ICcweDYwODA2MDQwNTIzNDgwMTU2MjAwMDAxMTU3NjAwMDgwZmQ1YjUwNjIwMDAwMWQzMzYyMDAwMDIzNTY1YjYyMDAwMDczNTY1YjYwMDA4MDU0NjAwMTYwMDE2MGEwMWIwMzgzODExNjYwMDE2MDAxNjBhMDFiMDMxOTgzMTY4MTE3ODQ1NTYwNDA1MTkxOTA5MjE2OTI4MzkxN2Y4YmUwMDc5YzUzMTY1OTE0MTM0NGNkMWZkMGE0ZjI4NDE5NDk3Zjk3MjJhM2RhYWZlM2I0MTg2ZjZiNjQ1N2UwOTE5MGEzNTA1MDU2NWI2MTQ5MmM4MDYyMDAwMDgzNjAwMDM5NjAwMGYzZmU2MDgwNjA0MDUyNjAwNDM2MTA2MTAxYjc1NzYwMDAzNTYwZTAxYzgwNjM3NDVlODdmNzExNjEwMGVjNTc4MDYzYmExNmE3NTAxMTYxMDA4YTU3ODA2M2Q5ZjQxNDBiMTE2MTAwNjQ1NzgwNjNkOWY0MTQwYjE0NjEwNGZjNTc4MDYzZjJmZGUzOGIxNDYxMDUxYzU3ODA2M2ZiZmE0ZTExMTQ2MTA1M2M1NzgwNjNmZDU5MDg0NzE0NjEwNTVjNTc2MDAwODBmZDViODA2M2JhMTZhNzUwMTQ2MTA0YTc1NzgwNjNiYmVlNDJkOTE0NjEwNGM3NTc4MDYzZDFkMjAwNTYxNDYxMDRkYzU3NjAwMDgwZmQ1YjgwNjM3OGMwMDQzNjExNjEwMGM2NTc4MDYzNzhjMDA0MzYxNDYxMDQyOTU3ODA2MzhkYTVjYjViMTQ2MTA0NDk1NzgwNjM5NDg0MmQxNDE0NjEwNDY3NTc4MDYzOTcyMTY3MjUxNDYxMDQ4NzU3NjAwMDgwZmQ1YjgwNjM3NDVlODdmNzE0NjEwM2Q2NTc4MDYzNzQ2ZTc4ZDcxNDYxMDNlOTU3ODA2Mzc1NGQxZDU0MTQ2MTA0MDk1NzYwMDA4MGZkNWI4MDYzMjY0MTczZDYxMTYxMDE1OTU3ODA2MzRlM2M0ZjIyMTE2MTAxMzM1NzgwNjM0ZTNjNGYyMjE0NjEwMzQ2NTc4MDYzNGZlNjNmNGQxNDYxMDM4MTU3ODA2MzZjNzkxNThkMTQ2MTAzYTE1NzgwNjM3MTUwMThhNjE0NjEwM2MxNTc2MDAwODBmZDViODA2MzI2NDE3M2Q2MTQ2MTAyZDk1NzgwNjMzNzFjMjJjNTE0NjEwMmY5NTc4MDYzNGJjM2FmZjQxNDYxMDMzMTU3NjAwMDgwZmQ1YjgwNjMxNThlZjkzZTExNjEwMTk1NTc4MDYzMTU4ZWY5M2UxNDYxMDIzYjU3ODA2MzE1YTUyMzAyMTQ2MTAyNWM1NzgwNjMxZDczYjlmNTE0NjEwMjg5NTc4MDYzMjFmZTBmMzAxNDYxMDJiNzU3NjAwMDgwZmQ1YjgwNjMwOGU5M2QwYTE0NjEwMWJjNTc4MDYzMGQ2NjgwODcxNDYxMDFlNzU3ODA2MzE0NzUwMGUzMTQ2MTAyMGI1NzViNjAwMDgwZmQ1YjM0ODAxNTYxMDFjODU3NjAwMDgwZmQ1YjUwNjEwMWQxNjEwNTg5NTY1YjYwNDA1MTYxMDFkZTkxOTA2MTNmNGE1NjViNjA0MDUxODA5MTAzOTBmMzViMzQ4MDE1NjEwMWYzNTc2MDAwODBmZDViNTA2MTAxZmQ2MDAxNTQ4MTU2NWI2MDQwNTE5MDgxNTI2MDIwMDE2MTAxZGU1NjViMzQ4MDE1NjEwMjE3NTc2MDAwODBmZDViNTA2MTAyMmI2MTAyMjYzNjYwMDQ2MTNmNzk1NjViNjEwNTlhNTY1YjYwNDA1MTkwMTUxNTgxNTI2MDIwMDE2MTAxZGU1NjViMzQ4MDE1NjEwMjQ3NTc2MDAwODBmZDViNTA2MDAwNTQ2MTAyMmI5MDYwMDE2MGEwMWI5MDA0NjBmZjE2ODE1NjViMzQ4MDE1NjEwMjY4NTc2MDAwODBmZDViNTA2MTAyN2M2MTAyNzczNjYwMDQ2MTNmYWM1NjViNjEwNWIxNTY1YjYwNDA1MTYxMDFkZTkxOTA2MTQwODE1NjViMzQ4MDE1NjEwMjk1NTc2MDAwODBmZDViNTA2MTAyYTk2MTAyYTQzNjYwMDQ2MTQwOTQ1NjViNjEwOGU0NTY1YjYwNDA1MTYxMDFkZTkyOTE5MDYxNDBjNzU2NWIzNDgwMTU2MTAyYzM1NzYwMDA4MGZkNWI1MDYxMDJjYzYxMDk1MjU2NWI2MDQwNTE2MTAxZGU5MTkwNjE0MGU5NTY1YjM0ODAxNTYxMDJlNTU3NjAwMDgwZmQ1YjUwNjEwMWZkNjEwMmY0MzY2MDA0NjEzZjc5NTY1YjYxMDk1ZTU2NWIzNDgwMTU2MTAzMDU1NzYwMDA4MGZkNWI1MDYwMDI1NDYxMDMxOTkwNjAwMTYwMDE2MGEwMWIwMzE2ODE1NjViNjA0MDUxNjAwMTYwMDE2MGEwMWIwMzkwOTExNjgxNTI2MDIwMDE2MTAxZGU1NjViNjEwMzQ0NjEwMzNmMzY2MDA0NjE0MTcyNTY1YjYxMDk2YzU2NWIwMDViMzQ4MDE1NjEwMzUyNTc2MDAwODBmZDViNTA2MTAzNjY2MTAzNjEzNjYwMDQ2MTNmNzk1NjViNjEwOWY4NTY1YjYwNDA4MDUxOTM4NDUyNjAyMDg0MDE5MjkwOTI1MjkwODIwMTUyNjA2MDAxNjEwMWRlNTY1YjM0ODAxNTYxMDM4ZDU3NjAwMDgwZmQ1YjUwNjEwMmE5NjEwMzljMzY2MDA0NjE0MDk0NTY1YjYxMGFjMzU2NWIzNDgwMTU2MTAzYWQ1NzYwMDA4MGZkNWI1MDYxMDM0NDYxMDNiYzM2NjAwNDYxM2Y3OTU2NWI2MTBiMjA1NjViMzQ4MDE1NjEwM2NkNTc2MDAwODBmZDViNTA2MTAzNDQ2MTBkYTI1NjViNjEwMzQ0NjEwM2U0MzY2MDA0NjE0MjU1NTY1YjYxMGRiNjU2NWIzNDgwMTU2MTAzZjU1NzYwMDA4MGZkNWI1MDYxMDM0NDYxMDQwNDM2NjAwNDYxM2ZhYzU2NWI2MTBlNDA1NjViMzQ4MDE1NjEwNDE1NTc2MDAwODBmZDViNTA2MTAzNDQ2MTA0MjQzNjYwMDQ2MTQyOTE1NjViNjEwZTc0NTY1YjM0ODAxNTYxMDQzNTU3NjAwMDgwZmQ1YjUwNjEwMzQ0NjEwNDQ0MzY2MDA0NjE0MmRlNTY1YjYxMGY0NDU2NWIzNDgwMTU2MTA0NTU1NzYwMDA4MGZkNWI1MDYwMDA1NDYwMDE2MDAxNjBhMDFiMDMxNjYxMDMxOTU2NWIzNDgwMTU2MTA0NzM1NzYwMDA4MGZkNWI1MDYxMDM0NDYxMDQ4MjM2NjAwNDYxNDMxZjU2NWI2MTE2MmQ1NjViMzQ4MDE1NjEwNDkzNTc2MDAwODBmZDViNTA2MTAzNDQ2MTA0YTIzNjYwMDQ2MTNmNzk1NjViNjExNmI5NTY1YjM0ODAxNTYxMDRiMzU3NjAwMDgwZmQ1YjUwNjEwMWQxNjEwNGMyMzY2MDA0NjE0MzU5NTY1YjYxMTZmMzU2NWIzNDgwMTU2MTA0ZDM1NzYwMDA4MGZkNWI1MDYxMDM0NDYxMTcwMjU2NWIzNDgwMTU2MTA0ZTg1NzYwMDA4MGZkNWI1MDYwMDM1NDYxMDMxOTkwNjAwMTYwMDE2MGEwMWIwMzE2ODE1NjViMzQ4MDE1NjEwNTA4NTc2MDAwODBmZDViNTA2MTAzNDQ2MTA1MTczNjYwMDQ2MTQzY2Q1NjViNjExNzNhNTY1YjM0ODAxNTYxMDUyODU3NjAwMDgwZmQ1YjUwNjEwMzQ0NjEwNTM3MzY2MDA0NjEzZmFjNTY1YjYxMTc0NzU2NWIzNDgwMTU2MTA1NDg1NzYwMDA4MGZkNWI1MDYxMDM0NDYxMDU1NzM2NjAwNDYxNDNmODU2NWI2MTE3YzA1NjViMzQ4MDE1NjEwNTY4NTc2MDAwODBmZDViNTA2MTA1N2M2MTA1NzczNjYwMDQ2MTNmNzk1NjViNjExN2NkNTY1YjYwNDA1MTYxMDFkZTkxOTA2MTQ0MTE1NjViNjA2MDYxMDU5NTYwMDY2MTE5YjI1NjViOTA1MDkwNTY1YjYwMDA2MTA1YTg2MDA2ODQ4NDYxMWMyYTU2NWI5MDUwNWI5MjkxNTA1MDU2NWI2MTA1Yjk2MTNiYzc1NjViNjEwNWM0NjAwYjgzNjExYzQ3NTY1YjYwNDA4MDUxNjEwMTIwODEwMTkwOTE1MjgxNTQ2MDAxNjAwMTYwYTAxYjAzMTY4MTUyNjAwMTgyMDE4MDU0OTE5MjkxNjAyMDg0MDE5MTkwNjEwNWY1OTA2MTQ0MjQ1NjViODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTgyODA1NDYxMDYyMTkwNjE0NDI0NTY1YjgwMTU2MTA2NmU1NzgwNjAxZjEwNjEwNjQzNTc2MTAxMDA4MDgzNTQwNDAyODM1MjkxNjAyMDAxOTE2MTA2NmU1NjViODIwMTkxOTA2MDAwNTI2MDIwNjAwMDIwOTA1YjgxNTQ4MTUyOTA2MDAxMDE5MDYwMjAwMTgwODMxMTYxMDY1MTU3ODI5MDAzNjAxZjE2ODIwMTkxNWI1MDUwNTA1MDUwODE1MjYwMjAwMTYwMDI4MjAxODA1NDYxMDY4NzkwNjE0NDI0NTY1YjgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ2MTA2YjM5MDYxNDQyNDU2NWI4MDE1NjEwNzAwNTc4MDYwMWYxMDYxMDZkNTU3NjEwMTAwODA4MzU0MDQwMjgzNTI5MTYwMjAwMTkxNjEwNzAwNTY1YjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0ODE1MjkwNjAwMTAxOTA2MDIwMDE4MDgzMTE2MTA2ZTM1NzgyOTAwMzYwMWYxNjgyMDE5MTViNTA1MDUwNTA1MDgxNTI2MDIwMDE2MDAzODIwMTU0ODE1MjYwMjAwMTYwMDQ4MjAxNTQ4MTUyNjAyMDAxNjAwNTgyMDE1NDgxNTI2MDIwMDE2MDA2ODIwMTgwNTQ2MTA3Mzc5MDYxNDQyNDU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjEwNzYzOTA2MTQ0MjQ1NjViODAxNTYxMDdiMDU3ODA2MDFmMTA2MTA3ODU1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMDdiMDU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjEwNzkzNTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDUwNTA4MTUyNjAyMDAxNjAwNzgyMDE4MDU0NjEwN2M5OTA2MTQ0MjQ1NjViODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTgyODA1NDYxMDdmNTkwNjE0NDI0NTY1YjgwMTU2MTA4NDI1NzgwNjAxZjEwNjEwODE3NTc2MTAxMDA4MDgzNTQwNDAyODM1MjkxNjAyMDAxOTE2MTA4NDI1NjViODIwMTkxOTA2MDAwNTI2MDIwNjAwMDIwOTA1YjgxNTQ4MTUyOTA2MDAxMDE5MDYwMjAwMTgwODMxMTYxMDgyNTU3ODI5MDAzNjAxZjE2ODIwMTkxNWI1MDUwNTA1MDUwODE1MjYwMjAwMTYwMDg4MjAxODA1NDYxMDg1YjkwNjE0NDI0NTY1YjgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ2MTA4ODc5MDYxNDQyNDU2NWI4MDE1NjEwOGQ0NTc4MDYwMWYxMDYxMDhhOTU3NjEwMTAwODA4MzU0MDQwMjgzNTI5MTYwMjAwMTkxNjEwOGQ0NTY1YjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0ODE1MjkwNjAwMTAxOTA2MDIwMDE4MDgzMTE2MTA4Yjc1NzgyOTAwMzYwMWYxNjgyMDE5MTViNTA1MDUwNTA1MDgxNTI1MDUwOTA1MDkxOTA1MDU2NWI2MDYwNjAwMDgyMTU4MDYxMDhmNjU3NTA2MDMyODMxMTE1NWI2MTA5Mzk1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMjA2MDA0ODIwMTUyNjAwZjYwMjQ4MjAxNTI2ZTRjNjk2ZDY5NzQyMDc0NmY2ZjIwNmM2MTcyNjc2NTYwODgxYjYwNDQ4MjAxNTI2MDY0MDE1YjYwNDA1MTgwOTEwMzkwZmQ1YjYxMDk0NjYwMDY4Njg2ODY2MTFjNTM1NjViOTE1MDkxNTA5MzUwOTM5MTUwNTA1NjViNjA2MDYxMDU5NTYwMGI2MTFmODQ1NjViNjAwMDYxMDVhODYwMDY4NDg0NjEyMzQzNTY1YjYwMDM1NDYwMDE2MDAxNjBhMDFiMDMxNjMzMTQ2MTA5OTY1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMDQwMTYxMDkzMDkwNjE0NDVlNTY1YjYwMDA4MDYxMDlhODYwMDY4Nzg3ODczNDg4NjEyMzVlNTY1YjkxNTA5MTUwODQ2MDAxNjAwMTYwYTAxYjAzMTY4NjYwMDE2MDAxNjBhMDFiMDMxNjYwMDA4MDUxNjAyMDYxNDhkNzgzMzk4MTUxOTE1Mjg0ODQ2MDQwNTE2MTA5ZTg5MjkxOTA5MTgyNTI2MDIwODIwMTUyNjA0MDAxOTA1NjViNjA0MDUxODA5MTAzOTBhMzUwNTA1MDUwNTA1MDU2NWI2MDAzNTQ2MDAwOTA4MTkwODE5MDYwMDE2MDAxNjBhMDFiMDMxNjMzMTQ2MTBhMjk1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMDQwMTYxMDkzMDkwNjE0NDVlNTY1YjYwMDE1NDYxMGEzYzkwNjAwNjkwODc5MDg3OTA2MTI0MTM1NjViOTE5NDUwOTI1MDkwNTA4MjE1NjEwYWJjNTc2MDQwNTEzMzkwODQxNTYxMDhmYzAyOTA4NTkwNjAwMDgxODE4MTg1ODg4OGYxOTM1MDUwNTA1MDE1ODAxNTYxMGE3NjU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDgzNjAwMTYwMDE2MGEwMWIwMzE2ODU2MDAxNjAwMTYwYTAxYjAzMTY2MDAwODA1MTYwMjA2MTQ4ZDc4MzM5ODE1MTkxNTI4NDg0NjA0MDUxNjEwYWIzOTI5MTkwOTE4MjUyNjAyMDgyMDE1MjYwNDAwMTkwNTY1YjYwNDA1MTgwOTEwMzkwYTM1YjkyNTA5MjUwOTI1NjViNjA2MDYwMDA4MjE1ODA2MTBhZDU1NzUwNjAzMjgzMTExNTViNjEwYjEzNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwMGY2MDI0ODIwMTUyNmU0YzY5NmQ2OTc0MjA3NDZmNmYyMDZjNjE3MjY3NjU2MDg4MWI2MDQ0ODIwMTUyNjA2NDAxNjEwOTMwNTY1YjYxMDk0NjYwMDY4Njg2ODY2MTI2MDI1NjViNjAwMzU0NjAwMTYwMDE2MGEwMWIwMzE2MzMxNDYxMGI0YTU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAwNDAxNjEwOTMwOTA2MTQ0NWU1NjViNjEwYjU2NjAwNjgzODM2MTI5MWQ1NjViNjAwMDYxMGI2NDYwMDY4NDg0NjEyOWRlNTY1YjYwNDA4MDUxNjEwMTIwODEwMTgyNTI4MjU0NjAwMTYwMDE2MGEwMWIwMzkwODExNjgyNTI2MDAxODQwMTU0MTY2MDIwODIwMTUyNjAwMjgwODQwMTU0ODI4NDAxNTI2MDAzODQwMTU0NjA2MDgzMDE1MjYwMDQ4NDAxNTQ2MDgwODMwMTUyODI1MTgwODQwMTkzODQ5MDUyOTE5MzkyNjBhMDg1MDE5MjkxNjAwNTg1MDE5MTgyODQ1YjgxNTQ4MTUyNjAyMDAxOTA2MDAxMDE5MDgwODMxMTYxMGJjMTU3NTA1MDUwNTA1MDgxNTI2MDIwMDE2MDA3ODIwMTgwNTQ4MDYwMjAwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxNjAwMDkwNWI4MjgyMTAxNTYxMGM1YjU3NjAwMDg0ODE1MjYwMjA5MDgxOTAyMDYwNDA4MDUxNjA4MDgxMDE4MjUyNjAwNDg2MDI5MDkyMDE4MDU0ODM1MjYwMDE4MDgyMDE1NDg0ODYwMTUyNjAwMjgyMDE1NDkyODQwMTkyOTA5MjUyNjAwMzAxNTQ2MGZmMTYxNTE1NjA2MDgzMDE1MjkwODM1MjkwOTIwMTkxMDE2MTBjMDI1NjViNTA1MDUwNTA4MTUyNjAyMDAxNjAwODgyMDE4MDU0NjEwYzczOTA2MTQ0MjQ1NjViODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTgyODA1NDYxMGM5ZjkwNjE0NDI0NTY1YjgwMTU2MTBjZWM1NzgwNjAxZjEwNjEwY2MxNTc2MTAxMDA4MDgzNTQwNDAyODM1MjkxNjAyMDAxOTE2MTBjZWM1NjViODIwMTkxOTA2MDAwNTI2MDIwNjAwMDIwOTA1YjgxNTQ4MTUyOTA2MDAxMDE5MDYwMjAwMTgwODMxMTYxMGNjZjU3ODI5MDAzNjAxZjE2ODIwMTkxNWI1MDUwNTA5MTgzNTI1MDUwNjA0MDgwNTE4MDgyMDE5MTgyOTA1MjYwMjA5MDkyMDE5MTkwNjAwOTg0MDE5MDYwMDI5MDgyODQ1YjgxNTQ4MTUyNjAyMDAxOTA2MDAxMDE5MDgwODMxMTYxMGQxMTU3NTA1MDUwNTA1MDgxNTI1MDUwOTA1MDYwMDA4MTYwYzAwMTUxNTExMTE1NjEwZDlkNTc2MDAxODE2MGMwMDE1MTUxNjEwZDRmOTE5MDYxNDRiNTU2NWI4MjYwMDE2MDAxNjBhMDFiMDMxNjg0NjAwMTYwMDE2MGEwMWIwMzE2N2Y1NDM3N2RmZGViZjA2ZjZkZjUzZmJkYTczN2QyZGNkN2UxNDFmOTViYmZiMGMxMjIzNDM3ZTg1NmI5ZGUzYWMzNDI2MDQwNTE2MTBkOTQ5MTgxNTI2MDIwMDE5MDU2NWI2MDQwNTE4MDkxMDM5MGE0NWI1MDUwNTA1NjViNjEwZGFhNjEyOWViNTY1YjYxMGRiNDYwMDA2MTJhNDU1NjViNTY1YjYwMDM1NDYwMDE2MDAxNjBhMDFiMDMxNjMzMTQ2MTBkZTA1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMDQwMTYxMDkzMDkwNjE0NDVlNTY1YjYwMDA4MDYxMGRmMTYwMDY4Njg2ODYzNDYxMmE5NTU2NWI5MTUwOTE1MDgzNjAwMTYwMDE2MGEwMWIwMzE2ODU2MDAxNjAwMTYwYTAxYjAzMTY2MDAwODA1MTYwMjA2MTQ4ZDc4MzM5ODE1MTkxNTI4NDg0NjA0MDUxNjEwZTMxOTI5MTkwOTE4MjUyNjAyMDgyMDE1MjYwNDAwMTkwNTY1YjYwNDA1MTgwOTEwMzkwYTM1MDUwNTA1MDUwNTY1YjYxMGU0ODYxMjllYjU2NWI2MDAyODA1NDYwMDE2MDAxNjBhMDFiMDM5MDkyMTY2MDAxNjAwMTYwYTAxYjAzMTk5MjgzMTY4MTE3OTA5MTU1NjAwNDgwNTQ5MDkyMTYxNzkwNTU1NjViNjAwMDU0NjAwMTYwYTAxYjkwMDQ2MGZmMTYxNTYxMGVkOTU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDIyNjAyNDgyMDE1MjdmNDk2ZTY5NzQ2OTYxNmM2OTdhNjE2MjZjNjUzYTIwNjE2YzcyNjU2MTY0NzkyMDY5NmU2OTc0Njk2MTZjNjk3YTYwNDQ4MjAxNTI2MTE5NTk2MGYyMWI2MDY0ODIwMTUyNjA4NDAxNjEwOTMwNTY1YjYwMDA4MDU0NjBmZjYwYTAxYjE5MTY2MDAxNjBhMDFiMTc5MDU1NjEwZWY1ODE2MTJhNDU1NjViNTA2MDAxOTI5MDkyNTU2MDAyODA1NDYwMDE2MDAxNjBhMDFiMDM5MjgzMTY2MDAxNjAwMTYwYTAxYjAzMTk5MTgyMTY4MTE3OTA5MjU1NjAwMzgwNTQ5MzkwOTQxNjkyODExNjgzMTc5MDkzNTU2MDA1ODA1NDg0MTY5MDkyMTc5MDkxNTU2MDA0ODA1NDkwOTIxNjE3OTA1NTU2NWI2MDA0NTQ2MDAwOTA2MDAxNjAwMTYwYTAxYjAzMTY2M2FkMTIyNTlhNjEwZjYyODQ4MDYxNDRjODU2NWI2MTBmNmY2MDIwODcwMTg3NjE0NGM4NTY1Yjg3NjA0MDAxMzU2MDQwNTE4NjYzZmZmZmZmZmYxNjYwZTAxYjgxNTI2MDA0MDE2MTBmOTQ5NTk0OTM5MjkxOTA2MTQ1NGE1NjViNjAyMDYwNDA1MTgwODMwMzgxODY1YWZhMTU4MDE1NjEwZmIxNTczZDYwMDA4MDNlM2Q2MDAwZmQ1YjUwNTA1MDUwNjA0MDUxM2Q2MDFmMTk2MDFmODIwMTE2ODIwMTgwNjA0MDUyNTA4MTAxOTA2MTBmZDU5MTkwNjE0NTg0NTY1YjkwNTA4MDYxMTAyNTU3NjA0MDUxNjM4ODVlMjg3OTYwZTAxYjgxNTI2MDIwNjAwNDgyMDE1MjYwMWY2MDI0ODIwMTUyN2Y1YTRiMjA3MzY1NzQ3NDZjNjU2ZDY1NmU3NDIwNzY2MTZjNjk2NDYxNzQ2OTZmNmUyMDY2NjE2OTZjNjU2NDAwNjA0NDgyMDE1MjYwNjQwMTYxMDkzMDU2NWI2MDAwNjExMDM0NjAyMDg0MDE4NDYxNDRjODU2NWI4MDgwNjAyMDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MzkyOTE5MDgxODE1MjYwMjAwMTgzODM2MDIwMDI4MDgyODQzNzYwMDA5MjAxODI5MDUyNTA5Mzk0NTAzMzkyNTA4MzkxNTA1MDViNjExMDc5NjA2MDg3MDE4NzYxNDRjODU2NWI5MDUwODExMDE1NjExNWI3NTc2MDAwNjExMDkxNjA2MDg4MDE4ODYxNDRjODU2NWI4MzgxODExMDYxMTBhMTU3NjExMGExNjE0NWE2NTY1YjkwNTA2MDIwMDIwMTM1OTA1MDYwMDA4MTg1NjExMGI4OTE5MDYxNDViYzU2NWI5MDUwNjAwMDgwODc4NzgxNTE4MTEwNjExMGNmNTc2MTEwY2Y2MTQ1YTY1NjViNjAyMDAyNjAyMDAxMDE1MTkwNTA2MDAwODg4ODYwMDI2MTEwZTk5MTkwNjE0NWJjNTY1YjgxNTE4MTEwNjExMGY5NTc2MTEwZjk2MTQ1YTY1NjViNjAyMDAyNjAyMDAxMDE1MTkwNTA2MDAwODk4OTYwMDM2MTExMTM5MTkwNjE0NWJjNTY1YjgxNTE4MTEwNjExMTIzNTc2MTExMjM2MTQ1YTY1NjViNjAyMDAyNjAyMDAxMDE1MTkwNTA2MDAwNjExMTQ1ODQzMzYwMDY2MTI5ZGU5MDkyOTE5MDYzZmZmZmZmZmYxNjU2NWI5MDUwOGE2MTExNTM4YjYwMDU2MTQ1YmM1NjViODE1MTgxMTA2MTExNjM1NzYxMTE2MzYxNDVhNjU2NWI2MDIwMDI2MDIwMDEwMTUxODE2MDA1MDE2MDAwNjAwMjgxMTA2MTExODE1NzYxMTE4MTYxNDVhNjU2NWIwMTU0MTQxNTgwNjExMWNhNTc1MDhhNjExMTk3OGI2MDA2NjE0NWJjNTY1YjgxNTE4MTEwNjExMWE3NTc2MTExYTc2MTQ1YTY1NjViNjAyMDAyNjAyMDAxMDE1MTgxNjAwNTAxNjAwMTYwMDI4MTEwNjExMWM1NTc2MTExYzU2MTQ1YTY1NjViMDE1NDE0MTU1YjE1NjExMjE4NTc2MDQwNTE2Mzg4NWUyODc5NjBlMDFiODE1MjYwMjA2MDA0ODIwMTUyNjAxNzYwMjQ4MjAxNTI3ZjczNjk2NzZlNjU3MjIwNmI2NTc5MjA2OTczMjA2OTZlNjM2ZjcyNzI2NTYzNzQwMDAwMDAwMDAwMDAwMDAwMDA2MDQ0ODIwMTUyNjA2NDAxNjEwOTMwNTY1YjhhNjExMjI0OGI2MDA3NjE0NWJjNTY1YjgxNTE4MTEwNjExMjM0NTc2MTEyMzQ2MTQ1YTY1NjViNjAyMDAyNjAyMDAxMDE1MTgxNjAwOTAxNjAwMDYwMDI4MTEwNjExMjUyNTc2MTEyNTI2MTQ1YTY1NjViMDE1NDE0MTU4MDYxMTI5YjU3NTA4YTYxMTI2ODhiNjAwODYxNDViYzU2NWI4MTUxODExMDYxMTI3ODU3NjExMjc4NjE0NWE2NTY1YjYwMjAwMjYwMjAwMTAxNTE4MTYwMDkwMTYwMDE2MDAyODExMDYxMTI5NjU3NjExMjk2NjE0NWE2NTY1YjAxNTQxNDE1NWIxNTYxMTJlOTU3NjA0MDUxNjM4ODVlMjg3OTYwZTAxYjgxNTI2MDIwNjAwNDgyMDE4MTkwNTI2MDI0ODIwMTUyN2Y3MDcyNmY3NjY5NjQ2NTcyMjA3MzY5Njc2ZTY1NzIyMDZiNjU3OTIwNjk3MzIwNjk2ZTYzNmY3MjcyNjU2Mzc0NjA0NDgyMDE1MjYwNjQwMTYxMDkzMDU2NWI4MjgxNjAwMjAxNTQxMTE1NjExMzNlNTc2MDQwNTE2Mzg4NWUyODc5NjBlMDFiODE1MjYwMjA2MDA0ODIwMTUyNjAxYTYwMjQ4MjAxNTI3ZjY5NmU2OTc0Njk2MTZjMjA2ZTZmNmU2MzY1MjA2OTczMjA2OTZlNjM2ZjcyNzI2NTYzNzQwMDAwMDAwMDAwMDA2MDQ0ODIwMTUyNjA2NDAxNjEwOTMwNTY1Yjg5NWI4NjgxMTAxNTYxMTU0MDU3NjAwMDhjODI4MTUxODExMDYxMTM1YzU3NjExMzVjNjE0NWE2NTY1YjYwMjAwMjYwMjAwMTAxNTE5MDUwNjAwMDhkODM2MDAxNjExMzc2OTE5MDYxNDViYzU2NWI4MTUxODExMDYxMTM4NjU3NjExMzg2NjE0NWE2NTY1YjYwMjAwMjYwMjAwMTAxNTE5MDUwOGQ4MzYwMDM2MTEzOWU5MTkwNjE0NWJjNTY1YjgxNTE4MTEwNjExM2FlNTc2MTEzYWU2MTQ1YTY1NjViNjAyMDAyNjAyMDAxMDE1MTk0NTA2MDAwOGU4NDYwMDQ2MTEzYzg5MTkwNjE0NWJjNTY1YjgxNTE4MTEwNjExM2Q4NTc2MTEzZDg2MTQ1YTY1NjViNjAyMDAyNjAyMDAxMDE1MTkwNTA2MDAwOGE4NTYwMGI2MTEzZjI5MTkwNjE0NWJjNTY1YjEwNjExM2ZlNTc2MDAwNjExNDIzNTY1YjhmNjExNDBhODY2MDBiNjE0NWJjNTY1YjgxNTE4MTEwNjExNDFhNTc2MTE0MWE2MTQ1YTY1NjViNjAyMDAyNjAyMDAxMDE1MTViOTA1MDgwMTU4MDE1OTA2MTE0MzQ1NzUwODA4NzEwMTU1YjE1NjExNDc1NTc2MDQwNTE2Mzg4NWUyODc5NjBlMDFiODE1MjYwMjA2MDA0ODIwMTUyNjAxMDYwMjQ4MjAxNTI2ZjFiOWJkYjk4ZDk0ODFiZGQ5OTVjOWIxODVjMWMxOTU5NjA4MjFiNjA0NDgyMDE1MjYwNjQwMTYxMDkzMDU2NWI4ODg0MTQxNTgwNjExNDg0NTc1MDhkODMxNDE1NWIxNTYxMTUxYzU3ODg4NDAzNjExNGNiNTc2MDQwNTE4MDYwNDAwMTYwNDA1MjgwNjAxZDgxNTI2MDIwMDE3ZjcwNzI2Zjc2Njk2NDY1NzIyMDYxNjQ2NDcyNjU3MzczMjA2OTczMjA2OTZlNjM2ZjcyNzI2NTYzNzQwMDAwMDA4MTUyNTA2MTE1MDI1NjViNjA0MDUxODA2MDQwMDE2MDQwNTI4MDYwMTk4MTUyNjAyMDAxN2Y3NTczNjU3MjIwNjE2NDY0NzI2NTczNzMyMDY5NzMyMDY5NmU2MzZmNzI3MjY1NjM3NDAwMDAwMDAwMDAwMDAwODE1MjUwNWI2MDQwNTE2Mzg4NWUyODc5NjBlMDFiODE1MjYwMDQwMTYxMDkzMDkxOTA2MTQ1Y2Y1NjViNjExNTI2ODI4YjYxNDViYzU2NWI5OTUwNTA1MDUwNTA2MDA5ODE2MTE1Mzk5MTkwNjE0NWJjNTY1YjkwNTA2MTEzNDA1NjViNTA4NDgxNjAwMzAxNTQxMDE1NjExNThkNTc2MDQwNTE2Mzg4NWUyODc5NjBlMDFiODE1MjYwMjA2MDA0ODIwMTUyNjAxNDYwMjQ4MjAxNTI3MzY5NmU3Mzc1NjY2NjY5NjM2OTY1NmU3NDIwNjI2MTZjNjE2ZTYzNjU2MDYwMWI2MDQ0ODIwMTUyNjA2NDAxNjEwOTMwNTY1YjYxMTU5NzgxODY2MTJjZjg1NjViNjAwMjAxNTU1MDkxOTU1MDgzOTI1MDYxMTVhZjkxNTA4MjkwNTA2MTQ1ZTI1NjViOTE1MDUwNjExMDZjNTY1YjUwODI1MTgyMTQ2MTE2MjY1NzYwNDA1MTYzODg1ZTI4Nzk2MGUwMWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDM0NjAyNDgyMDE1MjdmNjE3MjcyNjE3OTIwNzM2NTY3NmQ2NTZlNzQ1MzY5N2E2NTIwNzM3NTZkMjA2ZDY5NzM2ZDYxNzQ2MzY4NjU3MzYwNDQ4MjAxNTI3MzA0MGUwZWFjNGQ4ZDJjNjQwZDJkY2UwZWFlODQwZDhjYWRjY2VlOGQ2MDYzMWI2MDY0ODIwMTUyNjA4NDAxNjEwOTMwNTY1YjUwNTA1MDUwNTA1NjViNjExNjM5NjAwYjMzODM2MTJmNjA1NjViMzM3ZjMwZWNjMjAzNjkxYjJkMThlMTdlZTc1ZDQ3Y2FmMzRhM2ZiOWY4NmU4NTVmN2UwNDE0ZDNjZWMyNmQwYzQyNGI2MTE2NjU4MzgwNjE0NWZiNTY1YjYxMTY3MjYwMjA4NjAxODY2MTQ1ZmI1NjViNjA4MDg3MDEzNTYwYTA4ODAxMzU0MjYxMTY4YTYwNDA4YjAxOGI2MTQ1ZmI1NjViNjExNjk3NjA2MDhkMDE4ZDYxNDVmYjU2NWI2MDQwNTE2MTE2YWU5YjlhOTk5ODk3OTY5NTk0OTM5MjkxOTA2MTQ2NmE1NjViNjA0MDUxODA5MTAzOTBhMjUwNTY1YjYwMDM1NDYwMDE2MDAxNjBhMDFiMDMxNjMzMTQ2MTE2ZTM1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMDQwMTYxMDkzMDkwNjE0NDVlNTY1YjYxMTZlZjYwMDY4MzgzNjEzMWU0NTY1YjUwNTA1NjViNjA2MDYxMDVhODYwMDY4NDg0MzM2MTMyZDk1NjViNjExNzBkNjAwYjMzNjEzNWU3NTY1YjYwNDA1MTMzOTA3ZjI5ZDU0NmFiYjZlOTRmNGYwNGQ1YmRjY2I2NjgyMzE2ZjU5N2Q0Mzc3NjA3OGY0N2UyNzNmMDAwZTc3YjJhOTE5MDYwMDA5MGEyNTY1YjYxMTZlZjYwMDYzMzg0ODQ2MTM2MzY1NjViNjExNzRmNjEyOWViNTY1YjYwMDE2MDAxNjBhMDFiMDM4MTE2NjExN2I0NTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwMjY2MDI0ODIwMTUyN2Y0Zjc3NmU2MTYyNmM2NTNhMjA2ZTY1NzcyMDZmNzc2ZTY1NzIyMDY5NzMyMDc0Njg2NTIwN2E2NTcyNmYyMDYxNjA0NDgyMDE1MjY1NjQ2NDcyNjU3MzczNjBkMDFiNjA2NDgyMDE1MjYwODQwMTYxMDkzMDU2NWI2MTE3YmQ4MTYxMmE0NTU2NWI1MDU2NWI2MTE3Yzg2MTI5ZWI1NjViNjAwMTU1NTY1YjYxMTdkNTYxM2MxYzU2NWI2MTE3ZTE2MDA2ODQ4NDYxMjlkZTU2NWI2MDQwODA1MTYxMDEyMDgxMDE4MjUyODI1NDYwMDE2MDAxNjBhMDFiMDM5MDgxMTY4MjUyNjAwMTg0MDE1NDE2NjAyMDgyMDE1MjYwMDI4MDg0MDE1NDgyODQwMTUyNjAwMzg0MDE1NDYwNjA4MzAxNTI2MDA0ODQwMTU0NjA4MDgzMDE1MjgyNTE4MDg0MDE5Mzg0OTA1MjkxOTM5MjYwYTA4NTAxOTI5MTYwMDU4NTAxOTE4Mjg0NWI4MTU0ODE1MjYwMjAwMTkwNjAwMTAxOTA4MDgzMTE2MTE4M2U1NzUwNTA1MDUwNTA4MTUyNjAyMDAxNjAwNzgyMDE4MDU0ODA2MDIwMDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTYwMDA5MDViODI4MjEwMTU2MTE4ZDg1NzYwMDA4NDgxNTI2MDIwOTA4MTkwMjA2MDQwODA1MTYwODA4MTAxODI1MjYwMDQ4NjAyOTA5MjAxODA1NDgzNTI2MDAxODA4MjAxNTQ4NDg2MDE1MjYwMDI4MjAxNTQ5Mjg0MDE5MjkwOTI1MjYwMDMwMTU0NjBmZjE2MTUxNTYwNjA4MzAxNTI5MDgzNTI5MDkyMDE5MTAxNjExODdmNTY1YjUwNTA1MDUwODE1MjYwMjAwMTYwMDg4MjAxODA1NDYxMThmMDkwNjE0NDI0NTY1YjgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ2MTE5MWM5MDYxNDQyNDU2NWI4MDE1NjExOTY5NTc4MDYwMWYxMDYxMTkzZTU3NjEwMTAwODA4MzU0MDQwMjgzNTI5MTYwMjAwMTkxNjExOTY5NTY1YjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0ODE1MjkwNjAwMTAxOTA2MDIwMDE4MDgzMTE2MTE5NGM1NzgyOTAwMzYwMWYxNjgyMDE5MTViNTA1MDUwOTE4MzUyNTA1MDYwNDA4MDUxODA4MjAxOTE4MjkwNTI2MDIwOTA5MjAxOTE5MDYwMDk4NDAxOTA2MDAyOTA4Mjg0NWI4MTU0ODE1MjYwMjAwMTkwNjAwMTAxOTA4MDgzMTE2MTE5OGU1NzUwNTA1MDUwNTA4MTUyNTA1MDkwNTA5MjkxNTA1MDU2NWI2MDYwNjAwMDYxMTliZjgzNjEzNjU0NTY1YjkwNTA4MDYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTE5ZDk1NzYxMTlkOTYxNDE1YzU2NWI2MDQwNTE5MDgwODI1MjgwNjAyMDAyNjAyMDAxODIwMTYwNDA1MjgwMTU2MTFhMTI1NzgxNjAyMDAxNWI2MTE5ZmY2MTNjMWM1NjViODE1MjYwMjAwMTkwNjAwMTkwMDM5MDgxNjExOWY3NTc5MDUwNWI1MDkxNTA2MDAwNWI4MTgxMTAxNTYxMWMyMzU3NjExYTJhODQ4MjYxMzY1ZjU2NWI2MDQwODA1MTYxMDEyMDgxMDE4MjUyODI1NDYwMDE2MDAxNjBhMDFiMDM5MDgxMTY4MjUyNjAwMTg0MDE1NDE2NjAyMDgyMDE1MjYwMDI4MDg0MDE1NDgyODQwMTUyNjAwMzg0MDE1NDYwNjA4MzAxNTI2MDA0ODQwMTU0NjA4MDgzMDE1MjgyNTE4MDg0MDE5Mzg0OTA1MjkxOTM5MjYwYTA4NTAxOTI5MTYwMDU4NTAxOTE4Mjg0NWI4MTU0ODE1MjYwMjAwMTkwNjAwMTAxOTA4MDgzMTE2MTFhODc1NzUwNTA1MDUwNTA4MTUyNjAyMDAxNjAwNzgyMDE4MDU0ODA2MDIwMDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTYwMDA5MDViODI4MjEwMTU2MTFiMjE1NzYwMDA4NDgxNTI2MDIwOTA4MTkwMjA2MDQwODA1MTYwODA4MTAxODI1MjYwMDQ4NjAyOTA5MjAxODA1NDgzNTI2MDAxODA4MjAxNTQ4NDg2MDE1MjYwMDI4MjAxNTQ5Mjg0MDE5MjkwOTI1MjYwMDMwMTU0NjBmZjE2MTUxNTYwNjA4MzAxNTI5MDgzNTI5MDkyMDE5MTAxNjExYWM4NTY1YjUwNTA1MDUwODE1MjYwMjAwMTYwMDg4MjAxODA1NDYxMWIzOTkwNjE0NDI0NTY1YjgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ2MTFiNjU5MDYxNDQyNDU2NWI4MDE1NjExYmIyNTc4MDYwMWYxMDYxMWI4NzU3NjEwMTAwODA4MzU0MDQwMjgzNTI5MTYwMjAwMTkxNjExYmIyNTY1YjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0ODE1MjkwNjAwMTAxOTA2MDIwMDE4MDgzMTE2MTFiOTU1NzgyOTAwMzYwMWYxNjgyMDE5MTViNTA1MDUwOTE4MzUyNTA1MDYwNDA4MDUxODA4MjAxOTE4MjkwNTI2MDIwOTA5MjAxOTE5MDYwMDk4NDAxOTA2MDAyOTA4Mjg0NWI4MTU0ODE1MjYwMjAwMTkwNjAwMTAxOTA4MDgzMTE2MTFiZDc1NzUwNTA1MDUwNTA4MTUyNTA1MDgzODI4MTUxODExMDYxMWMwNTU3NjExYzA1NjE0NWE2NTY1YjYwMjAwMjYwMjAwMTAxODE5MDUyNTA4MDgwNjExYzFiOTA2MTQ1ZTI1NjViOTE1MDUwNjExYTE4NTY1YjUwNTA5MTkwNTA1NjViNjAwMDYxMWMzZjg0NjExYzNhODU4NTYxMzY4NTU2NWI2MTM2YmQ1NjViOTQ5MzUwNTA1MDUwNTY1YjYwMDA2MTA1YTg4MzgzNjEzNmM5NTY1YjYwMDE2MDAxNjBhMDFiMDM4MzE2NjAwMDkwODE1MjYwMDM4NTAxNjAyMDUyNjA0MDgxMjA2MDYwOTE5MDYxMWM3YTgxNjEzNzFhNTY1YjkxNTA4MTg1MTA2MTFjYmQ1NzYwNDA4MDUxNjAwMDgwODI1MjYwMjA4MjAxOTA5MjUyOTA2MTFjYjQ1NjViNjExY2ExNjEzYzFjNTY1YjgxNTI2MDIwMDE5MDYwMDE5MDAzOTA4MTYxMWM5OTU3OTA1MDViNTA5MjUwNTA2MTFmN2I1NjViNjAwMDg0MTU2MTFjZDQ1NzYxMWNjZjg1ODc2MTQ1YmM1NjViNjExY2Q2NTY1YjgyNWI5MDUwODI4MTExMTU2MTFjZTM1NzUwODE1YjYwMDA2MTFjZWY4NzgzNjE0NGI1NTY1YjkwNTA4MDYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTFkMDk1NzYxMWQwOTYxNDE1YzU2NWI2MDQwNTE5MDgwODI1MjgwNjAyMDAyNjAyMDAxODIwMTYwNDA1MjgwMTU2MTFkNDI1NzgxNjAyMDAxNWI2MTFkMmY2MTNjMWM1NjViODE1MjYwMjAwMTkwNjAwMTkwMDM5MDgxNjExZDI3NTc5MDUwNWI1MDk0NTA2MDAwNWI4MTgxMTAxNTYxMWY3NjU3NjAwMDYxMWQ2NjYxMWQ1ZjgzOGI2MTQ1YmM1NjViODY5MDYxMzcyNDU2NWI2MDAwODE4MTUyNjAwMjhkODEwMTYwMjA5MDgxNTI2MDQwOTI4MzkwMjA4MzUxNjEwMTIwODEwMTg1NTI4MTU0NjAwMTYwMDE2MGEwMWIwMzkwODExNjgyNTI2MDAxODMwMTU0MTY5MjgxMDE5MjkwOTI1MjgwODMwMTU0ODI4NTAxNTI2MDAzODEwMTU0NjA2MDgzMDE1MjYwMDQ4MTAxNTQ2MDgwODMwMTUyODM1MTgwODUwMTk0ODU5MDUyOTQ5NTUwOTA5MzkwOTI2MGEwODUwMTkyNjAwNTg1MDE5MTgyODQ1YjgxNTQ4MTUyNjAyMDAxOTA2MDAxMDE5MDgwODMxMTYxMWRkOTU3NTA1MDUwNTA1MDgxNTI2MDIwMDE2MDA3ODIwMTgwNTQ4MDYwMjAwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxNjAwMDkwNWI4MjgyMTAxNTYxMWU3MzU3NjAwMDg0ODE1MjYwMjA5MDgxOTAyMDYwNDA4MDUxNjA4MDgxMDE4MjUyNjAwNDg2MDI5MDkyMDE4MDU0ODM1MjYwMDE4MDgyMDE1NDg0ODYwMTUyNjAwMjgyMDE1NDkyODQwMTkyOTA5MjUyNjAwMzAxNTQ2MGZmMTYxNTE1NjA2MDgzMDE1MjkwODM1MjkwOTIwMTkxMDE2MTFlMWE1NjViNTA1MDUwNTA4MTUyNjAyMDAxNjAwODgyMDE4MDU0NjExZThiOTA2MTQ0MjQ1NjViODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTgyODA1NDYxMWViNzkwNjE0NDI0NTY1YjgwMTU2MTFmMDQ1NzgwNjAxZjEwNjExZWQ5NTc2MTAxMDA4MDgzNTQwNDAyODM1MjkxNjAyMDAxOTE2MTFmMDQ1NjViODIwMTkxOTA2MDAwNTI2MDIwNjAwMDIwOTA1YjgxNTQ4MTUyOTA2MDAxMDE5MDYwMjAwMTgwODMxMTYxMWVlNzU3ODI5MDAzNjAxZjE2ODIwMTkxNWI1MDUwNTA5MTgzNTI1MDUwNjA0MDgwNTE4MDgyMDE5MTgyOTA1MjYwMjA5MDkyMDE5MTkwNjAwOTg0MDE5MDYwMDI5MDgyODQ1YjgxNTQ4MTUyNjAyMDAxOTA2MDAxMDE5MDgwODMxMTYxMWYyOTU3NTA1MDUwNTA1MDgxNTI1MDUwODc4MzgxNTE4MTEwNjExZjU3NTc2MTFmNTc2MTQ1YTY1NjViNjAyMDAyNjAyMDAxMDE4MTkwNTI1MDUwODA4MDYxMWY2ZTkwNjE0NWUyNTY1YjkxNTA1MDYxMWQ0ODU2NWI1MDUwNTA1MDViOTQ1MDk0OTI1MDUwNTA1NjViNjA2MDYwMDA2MTFmOTE4MzYxMzY1NDU2NWI5MDUwODA2MDAxNjAwMTYwNDAxYjAzODExMTE1NjExZmFiNTc2MTFmYWI2MTQxNWM1NjViNjA0MDUxOTA4MDgyNTI4MDYwMjAwMjYwMjAwMTgyMDE2MDQwNTI4MDE1NjExZmU0NTc4MTYwMjAwMTViNjExZmQxNjEzYmM3NTY1YjgxNTI2MDIwMDE5MDYwMDE5MDAzOTA4MTYxMWZjOTU3OTA1MDViNTA5MTUwNjAwMDViODE4MTEwMTU2MTFjMjM1NzYxMWZmYzg0ODI2MTM2NWY1NjViNjA0MDgwNTE2MTAxMjA4MTAxOTA5MTUyODE1NDYwMDE2MDAxNjBhMDFiMDMxNjgxNTI2MDAxODIwMTgwNTQ5MTkyOTE2MDIwODQwMTkxOTA2MTIwMmQ5MDYxNDQyNDU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjEyMDU5OTA2MTQ0MjQ1NjViODAxNTYxMjBhNjU3ODA2MDFmMTA2MTIwN2I1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMjBhNjU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjEyMDg5NTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDUwNTA4MTUyNjAyMDAxNjAwMjgyMDE4MDU0NjEyMGJmOTA2MTQ0MjQ1NjViODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTgyODA1NDYxMjBlYjkwNjE0NDI0NTY1YjgwMTU2MTIxMzg1NzgwNjAxZjEwNjEyMTBkNTc2MTAxMDA4MDgzNTQwNDAyODM1MjkxNjAyMDAxOTE2MTIxMzg1NjViODIwMTkxOTA2MDAwNTI2MDIwNjAwMDIwOTA1YjgxNTQ4MTUyOTA2MDAxMDE5MDYwMjAwMTgwODMxMTYxMjExYjU3ODI5MDAzNjAxZjE2ODIwMTkxNWI1MDUwNTA1MDUwODE1MjYwMjAwMTYwMDM4MjAxNTQ4MTUyNjAyMDAxNjAwNDgyMDE1NDgxNTI2MDIwMDE2MDA1ODIwMTU0ODE1MjYwMjAwMTYwMDY4MjAxODA1NDYxMjE2ZjkwNjE0NDI0NTY1YjgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ2MTIxOWI5MDYxNDQyNDU2NWI4MDE1NjEyMWU4NTc4MDYwMWYxMDYxMjFiZDU3NjEwMTAwODA4MzU0MDQwMjgzNTI5MTYwMjAwMTkxNjEyMWU4NTY1YjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0ODE1MjkwNjAwMTAxOTA2MDIwMDE4MDgzMTE2MTIxY2I1NzgyOTAwMzYwMWYxNjgyMDE5MTViNTA1MDUwNTA1MDgxNTI2MDIwMDE2MDA3ODIwMTgwNTQ2MTIyMDE5MDYxNDQyNDU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjEyMjJkOTA2MTQ0MjQ1NjViODAxNTYxMjI3YTU3ODA2MDFmMTA2MTIyNGY1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMjI3YTU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjEyMjVkNTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDUwNTA4MTUyNjAyMDAxNjAwODgyMDE4MDU0NjEyMjkzOTA2MTQ0MjQ1NjViODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTgyODA1NDYxMjJiZjkwNjE0NDI0NTY1YjgwMTU2MTIzMGM1NzgwNjAxZjEwNjEyMmUxNTc2MTAxMDA4MDgzNTQwNDAyODM1MjkxNjAyMDAxOTE2MTIzMGM1NjViODIwMTkxOTA2MDAwNTI2MDIwNjAwMDIwOTA1YjgxNTQ4MTUyOTA2MDAxMDE5MDYwMjAwMTgwODMxMTYxMjJlZjU3ODI5MDAzNjAxZjE2ODIwMTkxNWI1MDUwNTA1MDUwODE1MjUwNTA4MzgyODE1MTgxMTA2MTIzMjc1NzYxMjMyNzYxNDVhNjU2NWI2MDIwMDI2MDIwMDEwMTgxOTA1MjUwODA2MTIzM2M5MDYxNDVlMjU2NWI5MDUwNjExZmVhNTY1YjYwMDA4MDYxMjM1MTg1ODU4NTYxMzczMDU2NWI2MDA0MDE1NDk1OTQ1MDUwNTA1MDUwNTY1YjYwMDA4MDYwMDA2MTIzNmQ4ODg4NjEzNjg1NTY1YjkwNTA2MTIzNzk4OTgyNjEzNmJkNTY1YjE1NjEyM2FhNTc2MDQwNTE2MzJjZjA2NzU5NjBlMjFiODE1MjYwMDE2MDAxNjBhMDFiMDM4MDhhMTY2MDA0ODMwMTUyODgxNjYwMjQ4MjAxNTI2MDQ0MDE2MTA5MzA1NjViNjEyM2I5ODk4MjhhOGE4YThhOGE2MTM3OTI1NjViNjAwMTYwMDE2MGEwMWIwMzg3MTY2MDAwOTA4MTUyNjAwMzhhMDE2MDIwNTI2MDQwOTAyMDYxMjNkZDkwODI2MTM4MGQ1NjViNTA2MDAxNjAwMTYwYTAxYjAzODgxNjYwMDA5MDgxNTI2MDA0OGEwMTYwMjA1MjYwNDA5MDIwNjEyNDAyOTA4MjYxMzgwZDU2NWI1MDkzOTg2MDAwOTg1MDk2NTA1MDUwNTA1MDUwNTA1NjViNjAwMDgwNjAwMDgwNjEyNDI0ODg4ODg4NjEzNzMwNTY1YjYwMDc4MTAxNTQ5MDkxNTA2MDAwMDM2MTI0NDM1NzYwMDA5MzUwODA2MDA0MDE1NDkxNTA2MTI1ZDA1NjViNjAwNzgxMDE1NDYwMDA5MDYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTI0NjI1NzYxMjQ2MjYxNDE1YzU2NWI2MDQwNTE5MDgwODI1MjgwNjAyMDAyNjAyMDAxODIwMTYwNDA1MjgwMTU2MTI0YzA1NzgxNjAyMDAxNWI2MTI0YWQ2MDQwNTE4MDYwODAwMTYwNDA1MjgwNjAwMDgxNTI2MDIwMDE2MDAwODE1MjYwMjAwMTYwMDA4MTUyNjAyMDAxNjAwMDE1MTU4MTUyNTA5MDU2NWI4MTUyNjAyMDAxOTA2MDAxOTAwMzkwODE2MTI0ODA1NzkwNTA1YjUwOTA1MDYwMDA4MDk1NTA2MDAwOTM1MDYwMDA1YjYwMDc4NDAxNTQ4MTEwMTU2MTI1YzE1NzYwMDA4NDYwMDcwMTgyODE1NDgxMTA2MTI0ZjI1NzYxMjRmMjYxNDVhNjU2NWI2MDAwOTE4MjUyNjAyMDkwOTEyMDYwMDQ5MDkxMDIwMTYwMDM4MTAxNTQ5MDkxNTA2MGZmMTYxNTYxMjUxODU3NTA2MTI1YWY1NjViODg4MTYwMDIwMTU0NjEyNTI4OTE5MDYxNDViYzU2NWI0MjEwNjEyNTQ0NTc2MDAxODEwMTU0NjEyNTNkOTA4OTYxNDViYzU2NWI5NzUwNjEyNWFkNTY1YjYwNDA1MTgwNjA4MDAxNjA0MDUyODA4NDgxNTI2MDIwMDE4MjYwMDEwMTU0ODE1MjYwMjAwMTgyNjAwMjAxNTQ4MTUyNjAyMDAxNjAwMDE1MTU4MTUyNTA4NDg0ODE1MTgxMTA2MTI1ODI1NzYxMjU4MjYxNDVhNjU2NWI2MDIwMDI2MDIwMDEwMTgxOTA1MjUwODA2MDAxMDE1NDg2NjEyNTlkOTE5MDYxNDViYzU2NWI5NTUwODI2MTI1YTk4MTYxNDVlMjU2NWI5MzUwNTA1YjUwNWI4MDYxMjViOTgxNjE0NWUyNTY1YjkxNTA1MDYxMjRjZjU2NWI1MDYxMjVjZDgzODM4MzYxMzgxOTU2NWI1MDUwNWI4MzgxNjAwMzAxNjAwMDgyODI1NDYxMjVlNDkxOTA2MTQ0YjU1NjViOTA5MTU1NTA1MDYwMDQ4MTAxODI5MDU1NjAwMzAxNTQ5Mjk3OTI5NjUwOTQ1MDkwOTI1MDUwNTA1NjViNjAwMTYwMDE2MGEwMWIwMzgzMTY2MDAwOTA4MTUyNjAwNDg1MDE2MDIwNTI2MDQwODEyMDYwNjA5MTkwNjEyNjI5ODE2MTM3MWE1NjViOTE1MDgxODUxMDYxMjY2YjU3NjA0MDgwNTE2MDAwODA4MjUyNjAyMDgyMDE5MDkyNTI5MDYxMWNiNDU2NWI2MTI2NTA2MTNjMWM1NjViODE1MjYwMjAwMTkwNjAwMTkwMDM5MDgxNjEyNjQ4NTc5MDUwNTA5MjUwNTA2MTFmN2I1NjViNjAwMDg0MTU2MTI2ODI1NzYxMjY3ZDg1ODc2MTQ1YmM1NjViNjEyNjg0NTY1YjgyNWI5MDUwODI4MTExMTU2MTI2OTE1NzUwODE1YjYwMDA2MTI2OWQ4NzgzNjE0NGI1NTY1YjkwNTA4MDYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTI2Yjc1NzYxMjZiNzYxNDE1YzU2NWI2MDQwNTE5MDgwODI1MjgwNjAyMDAyNjAyMDAxODIwMTYwNDA1MjgwMTU2MTI2ZjA1NzgxNjAyMDAxNWI2MTI2ZGQ2MTNjMWM1NjViODE1MjYwMjAwMTkwNjAwMTkwMDM5MDgxNjEyNmQ1NTc5MDUwNWI1MDk0NTA2MDAwNWI4MTgxMTAxNTYxMWY3NjU3NjAwMDYxMjcwZDYxMWQ1ZjgzOGI2MTQ1YmM1NjViNjAwMDgxODE1MjYwMDI4ZDgxMDE2MDIwOTA4MTUyNjA0MDkyODM5MDIwODM1MTYxMDEyMDgxMDE4NTUyODE1NDYwMDE2MDAxNjBhMDFiMDM5MDgxMTY4MjUyNjAwMTgzMDE1NDE2OTI4MTAxOTI5MDkyNTI4MDgzMDE1NDgyODUwMTUyNjAwMzgxMDE1NDYwNjA4MzAxNTI2MDA0ODEwMTU0NjA4MDgzMDE1MjgzNTE4MDg1MDE5NDg1OTA1Mjk0OTU1MDkwOTM5MDkyNjBhMDg1MDE5MjYwMDU4NTAxOTE4Mjg0NWI4MTU0ODE1MjYwMjAwMTkwNjAwMTAxOTA4MDgzMTE2MTI3ODA1NzUwNTA1MDUwNTA4MTUyNjAyMDAxNjAwNzgyMDE4MDU0ODA2MDIwMDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTYwMDA5MDViODI4MjEwMTU2MTI4MWE1NzYwMDA4NDgxNTI2MDIwOTA4MTkwMjA2MDQwODA1MTYwODA4MTAxODI1MjYwMDQ4NjAyOTA5MjAxODA1NDgzNTI2MDAxODA4MjAxNTQ4NDg2MDE1MjYwMDI4MjAxNTQ5Mjg0MDE5MjkwOTI1MjYwMDMwMTU0NjBmZjE2MTUxNTYwNjA4MzAxNTI5MDgzNTI5MDkyMDE5MTAxNjEyN2MxNTY1YjUwNTA1MDUwODE1MjYwMjAwMTYwMDg4MjAxODA1NDYxMjgzMjkwNjE0NDI0NTY1YjgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ2MTI4NWU5MDYxNDQyNDU2NWI4MDE1NjEyOGFiNTc4MDYwMWYxMDYxMjg4MDU3NjEwMTAwODA4MzU0MDQwMjgzNTI5MTYwMjAwMTkxNjEyOGFiNTY1YjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0ODE1MjkwNjAwMTAxOTA2MDIwMDE4MDgzMTE2MTI4OGU1NzgyOTAwMzYwMWYxNjgyMDE5MTViNTA1MDUwOTE4MzUyNTA1MDYwNDA4MDUxODA4MjAxOTE4MjkwNTI2MDIwOTA5MjAxOTE5MDYwMDk4NDAxOTA2MDAyOTA4Mjg0NWI4MTU0ODE1MjYwMjAwMTkwNjAwMTAxOTA4MDgzMTE2MTI4ZDA1NzUwNTA1MDUwNTA4MTUyNTA1MDg3ODM4MTUxODExMDYxMjhmZTU3NjEyOGZlNjE0NWE2NTY1YjYwMjAwMjYwMjAwMTAxODE5MDUyNTA1MDgwODA2MTI5MTU5MDYxNDVlMjU2NWI5MTUwNTA2MTI2ZjY1NjViNjAwMDYxMjkyYTg0ODQ4NDYxMzczMDU2NWI5MDUwNjAwMDgxNjAwNDAxNTQ4MjYwMDMwMTU0NjEyOTQyOTE5MDYxNDRiNTU2NWI5MDUwODA2MDAwMDM2MTI5NTM1NzUwNTA1MDUwNTA1NjViNjA0MDgwNTE2MDgwODEwMTgyNTI2MDA3ODQwMTgwNTQ4MDgzNTI2MDIwODA4NDAxODY4MTUyNDI5NTg1MDE5NTg2NTI2MDAwNjA2MDg2MDE4MTgxNTI2MDAxODA4NjAxODc1NTk1ODI1MjkyODEyMDk1NTE2MDA0OTQ4NTAyOTA5NjAxOTU4NjU1OTA1MTkzODUwMTkzOTA5MzU1OTM1MTYwMDI4NDAxNTU5MjUxNjAwMzkwOTIwMTgwNTQ2MGZmMTkxNjkyMTUxNTkyOTA5MjE3OTA5MTU1OTA4MzAxODA1NDgzOTI5MDYxMjlkMjkwODQ5MDYxNDViYzU2NWI5MDkxNTU1MDUwNTA1MDUwNTA1MDU2NWI2MDAwNjExYzNmODQ4NDg0NjEzNzMwNTY1YjYwMDA1NDYwMDE2MDAxNjBhMDFiMDMxNjMzMTQ2MTBkYjQ1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMjA2MDA0ODIwMTgxOTA1MjYwMjQ4MjAxNTI3ZjRmNzc2ZTYxNjI2YzY1M2EyMDYzNjE2YzZjNjU3MjIwNjk3MzIwNmU2Zjc0MjA3NDY4NjUyMDZmNzc2ZTY1NzI2MDQ0ODIwMTUyNjA2NDAxNjEwOTMwNTY1YjYwMDA4MDU0NjAwMTYwMDE2MGEwMWIwMzgzODExNjYwMDE2MDAxNjBhMDFiMDMxOTgzMTY4MTE3ODQ1NTYwNDA1MTkxOTA5MjE2OTI4MzkxN2Y4YmUwMDc5YzUzMTY1OTE0MTM0NGNkMWZkMGE0ZjI4NDE5NDk3Zjk3MjJhM2RhYWZlM2I0MTg2ZjZiNjQ1N2UwOTE5MGEzNTA1MDU2NWI2MDAwODA2MDAwNjEyYWE1ODg4ODg4NjEzNzMwNTY1YjkwNTA4NDE1NjEyY2M2NTc2MDA3ODEwMTU0MTU2MTJjYzY1NzYwMDc4MTAxNTQ2MDAwOTA2MDAxNjAwMTYwNDAxYjAzODExMTE1NjEyYWQ2NTc2MTJhZDY2MTQxNWM1NjViNjA0MDUxOTA4MDgyNTI4MDYwMjAwMjYwMjAwMTgyMDE2MDQwNTI4MDE1NjEyYjM0NTc4MTYwMjAwMTViNjEyYjIxNjA0MDUxODA2MDgwMDE2MDQwNTI4MDYwMDA4MTUyNjAyMDAxNjAwMDgxNTI2MDIwMDE2MDAwODE1MjYwMjAwMTYwMDAxNTE1ODE1MjUwOTA1NjViODE1MjYwMjAwMTkwNjAwMTkwMDM5MDgxNjEyYWY0NTc5MDUwNWI1MDkwNTA2MDAwODY4MTgwNWI2MDA3ODYwMTU0ODExMDE1NjEyY2FlNTc2MDAwODY2MDA3MDE4MjgxNTQ4MTEwNjEyYjYwNTc2MTJiNjA2MTQ1YTY1NjViNjAwMDkxODI1MjYwMjA5MDkxMjA2MDA0OTA5MTAyMDE2MDAzODEwMTU0OTA5MTUwNjBmZjE2MTU2MTJiODY1NzUwNjEyYzljNTY1YjgwNjAwMTAxNTQ4NDEwNjEyYmE3NTc2MDAxODEwMTU0NjEyYmEwOTA4NTYxNDRiNTU2NWI5MzUwNjEyYzlhNTY1YjgzMTU2MTJjMjk1NzYwMDA4NDgyNjAwMTAxNTQ2MTJiYmY5MTkwNjE0NGI1NTY1YjkwNTA2MDQwNTE4MDYwODAwMTYwNDA1MjgwODc4MTUyNjAyMDAxODI4MTUyNjAyMDAxODM2MDAyMDE1NDgxNTI2MDIwMDE2MDAwMTUxNTgxNTI1MDg3ODc4MTUxODExMDYxMmJmYjU3NjEyYmZiNjE0NWE2NTY1YjYwMjA5MDgxMDI5MTkwOTEwMTAxNTI2MTJjMTA4MTg1NjE0NWJjNTY1YjkzNTA4NTYxMmMxYzgxNjE0NWUyNTY1Yjk2NTA1MDYwMDA5NDUwNTA2MTJjOWE1NjViNjA0MDgwNTE2MDgwODEwMTgyNTI4NjgxNTI2MDAxODMwMTU0NjAyMDgyMDE1MjYwMDI4MzAxNTQ5MTgxMDE5MTkwOTE1MjYwMDM4MjAxNTQ2MGZmMTYxNTE1NjA2MDgyMDE1Mjg2NTE4NzkwODc5MDgxMTA2MTJjNmY1NzYxMmM2ZjYxNDVhNjU2NWI2MDIwMDI2MDIwMDEwMTgxOTA1MjUwODA2MDAxMDE1NDgzNjEyYzhhOTE5MDYxNDViYzU2NWI5MjUwODQ2MTJjOTY4MTYxNDVlMjU2NWI5NTUwNTA1YjUwNWI4MDYxMmNhNjgxNjE0NWUyNTY1YjkxNTA1MDYxMmIzZDU2NWI1MDYwMDQ4NTAxODE5MDU1NjEyY2MxODU4NTg1NjEzODE5NTY1YjUwNTA1MDUwNWI4MzgxNjAwMzAxNjAwMDgyODI1NDYxMmNkYTkxOTA2MTQ1YmM1NjViOTA5MTU1NTA1MDYwMDM4MTAxNTQ2MDA0OTA5MTAxNTQ5MDk4OTA5NzUwOTU1MDUwNTA1MDUwNTA1NjViODE2MDA0MDE1NDgyNjAwMzAxNTQ2MTJkMGM5MTkwNjE0NGI1NTY1YjgxMTExNTYxMmU3MTU3NjAwMDgyNjAwNDAxNTQ4MzYwMDMwMTU0NjEyZDI5OTE5MDYxNDRiNTU2NWI2MTJkMzM5MDgzNjE0NGI1NTY1YjkwNTA4MDgzNjAwNDAxNTQxMDE1NjEyZDk4NTc2MDQwNTE2Mzg4NWUyODc5NjBlMDFiODE1MjYwMjA2MDA0ODIwMTUyNjAyNTYwMjQ4MjAxNTI3ZjY5NmU3Mzc1NjY2NjY5NjM2OTY1NmU3NDIwNjI2MTZjNjE2ZTYzNjUyMDY5NmUyMDcwNjU2ZTY0Njk2ZTY3NTI2MDQ0ODIwMTUyNjQxOTU5OWQ1Yjk5NjBkYTFiNjA2NDgyMDE1MjYwODQwMTYxMDkzMDU2NWI4MDgzNjAwNDAxNjAwMDgyODI1NDYxMmRhYzkxOTA2MTQ0YjU1NjViOTA5MTU1NTA1MDYwMDc4MzAxNTQ2MDAwOTA2MTJkYzU5MDYwMDE5MDYxNDRiNTU2NWI5MDUwNWI2MDAwODExMjYxMmU2ZTU3NjAwMDg0NjAwNzAxODI4MTU0ODExMDYxMmRlNzU3NjEyZGU3NjE0NWE2NTY1YjYwMDA5MTgyNTI2MDIwOTA5MTIwNjAwNDkwOTEwMjAxNjAwMzgxMDE1NDkwOTE1MDYwZmYxNjE1NjEyZTBkNTc1MDYxMmU1YzU2NWI4MjgxNjAwMTAxNTQxMTYxMmUyZTU3NjAwMTgxMDE1NDYxMmUyNzkwODQ2MTQ0YjU1NjViOTI1MDYxMmU0YzU2NWI4MjgxNjAwMTAxNjAwMDgyODI1NDYxMmU0MjkxOTA2MTQ0YjU1NjViOTA5MTU1NTA2MDAwOTM1MDUwNWI4MjYwMDAwMzYxMmU1YTU3NTA2MTJlNmU1NjViNTA1YjgwNjEyZTY2ODE2MTQ2ZGY1NjViOTE1MDUwNjEyZGM4NTY1YjUwNTA1YjgwODI2MDAzMDE2MDAwODI4MjU0NjEyZTg1OTE5MDYxNDRiNTU2NWI5MDkxNTU1MDUwNjAwNTU0ODI1NDYwNDA1MTYzMWJiMTQ4MjM2MGUzMWI4MTUyNjAwMTYwMDE2MGEwMWIwMzkxODIxNjYwMDQ4MjAxNTI2MDI0ODEwMTg0OTA1MjkxMTY5MDYzZGQ4YTQxMTg5MDYwNDQwMTYwMDA2MDQwNTE4MDgzMDM4MTYwMDA4NzgwM2IxNTgwMTU2MTJlZDk1NzYwMDA4MGZkNWI1MDVhZjExNTgwMTU2MTJlZWQ1NzNkNjAwMDgwM2UzZDYwMDBmZDViNTA1MDgzNTQ2MDAzODUwMTU0NjAwNDg2MDE1NDYwNDA4MDUxOTI4MzUyNjAyMDgzMDE5MTkwOTE1MjMzOTQ1MDYwMDE2MDAxNjBhMDFiMDM5MDkyMTY5MjUwNjAwMDgwNTE2MDIwNjE0OGQ3ODMzOTgxNTE5MTUyOTEwMTYwNDA1MTgwOTEwMzkwYTM2MDQwNTEzMzkwODIxNTYxMDhmYzAyOTA4MzkwNjAwMDgxODE4MTg1ODg4OGYxOTM1MDUwNTA1MDE1ODAxNTYxMGQ5ZDU3M2Q2MDAwODAzZTNkNjAwMGZkNWI2MDAwNjEyZjZiODM2MTM4YjI1NjViOTA1MDYxMmY3Nzg0ODI2MTM2YmQ1NjViNjEzMTIyNTc2MTE2MjY4NDgyNjA0MDUxODA2MTAxMjAwMTYwNDA1MjgwODc2MDAxNjAwMTYwYTAxYjAzMTY4MTUyNjAyMDAxODY4MDYwMDAwMTkwNjEyZmFiOTE5MDYxNDVmYjU2NWI4MDgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MzkyOTE5MDgxODE1MjYwMjAwMTgzODM4MDgyODQzNzYwMDA5MjAxOTE5MDkxNTI1MDUwNTA5MDgyNTI1MDYwMjA5MDgxMDE5MDYxMmZmNDkwODgwMTg4NjE0NWZiNTY1YjgwODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkzOTI5MTkwODE4MTUyNjAyMDAxODM4MzgwODI4NDM3NjAwMDkyMDE5MTkwOTE1MjUwNTA1MDkwODI1MjUwNjA4MDgwODgwMTM1NjAyMDgzMDE1MjYwYTA4ODAxMzU2MDQwODA4NDAxOTE5MDkxNTI0MjYwNjA4NDAxNTI5MTAxOTA2MTMwNTk5MDg4MDE4ODYxNDVmYjU2NWI4MDgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MzkyOTE5MDgxODE1MjYwMjAwMTgzODM4MDgyODQzNzYwMDA5MjAxOTE5MDkxNTI1MDUwNTA5MDgyNTI1MDYwMjAwMTYxMzBhMDYwNjA4ODAxODg2MTQ1ZmI1NjViODA4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTM5MjkxOTA4MTgxNTI2MDIwMDE4MzgzODA4Mjg0Mzc2MDAwOTIwMTkxOTA5MTUyNTA1MDUwOTA4MjUyNTA2MDIwMDE2MTMwZTc2MGMwODgwMTg4NjE0NWZiNTY1YjgwODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkzOTI5MTkwODE4MTUyNjAyMDAxODM4MzgwODI4NDM3NjAwMDkyMDE5MTkwOTE1MjUwNTA1MDkxNTI1MDYxMzhlNjU2NWI2MDAwNjEzMTJlODU4NTYxMzZjOTU2NWI5MDUwNjEzMTNhODM4MDYxNDVmYjU2NWI2MDAxODMwMTkxNjEzMTRhOTE5MDgzNjE0NzQyNTY1YjUwNjA4MDgzMDEzNTYwMDM4MjAxNTU2MGEwODMwMTM1NjAwNDgyMDE1NTYxMzE2YzYwMjA4NDAxODQ2MTQ1ZmI1NjViNjAwMjgzMDE5MTYxMzE3YzkxOTA4MzYxNDc0MjU2NWI1MDQyNjAwNTgyMDE1NTYxMzE5MDYwNDA4NDAxODQ2MTQ1ZmI1NjViNjAwNjgzMDE5MTYxMzFhMDkxOTA4MzYxNDc0MjU2NWI1MDYxMzFhZTYwNjA4NDAxODQ2MTQ1ZmI1NjViNjAwNzgzMDE5MTYxMzFiZTkxOTA4MzYxNDc0MjU2NWI1MDYxMzFjYzYwYzA4NDAxODQ2MTQ1ZmI1NjViNjAwODgzMDE5MTYxMzFkYzkxOTA4MzYxNDc0MjU2NWI1MDUwNTA1MDUwNTA1NjViNjAwMDYxMzFmMDgzODM2MTM2ODU1NjViOTA1MDYxMzFmYzg0ODI2MTM2YmQ1NjViNjEzMjA2NTc1MDUwNTA1MDU2NWI2MDAxNjAwMTYwYTAxYjAzODIxNjYwMDA5MDgxNTI2MDAzODUwMTYwMjA1MjYwNDA5MDIwNjEzMjJhOTA4MjYxMzlhYzU2NWI1MDYwMDE2MDAxNjBhMDFiMDM4MzE2NjAwMDkwODE1MjYwMDQ4NTAxNjAyMDUyNjA0MDkwMjA2MTMyNGY5MDgyNjEzOWFjNTY1YjUwNjEzMjVhODQ4MjYxMzlhYzU2NWI1MDYwMDA4MTgxNTI2MDAyODA4NjAxNjAyMDUyNjA0MDgyMjA4MDU0NjAwMTYwMDE2MGEwMWIwMzE5OTA4MTE2ODI1NTYwMDE4MjAxODA1NDkwOTExNjkwNTU5MDgxMDE4MjkwNTU2MDAzODEwMTgyOTA1NTYwMDQ4MTAxODI5MDU1NjAwNTgxMDE4MjkwNTU2MDA2ODEwMTgyOTA1NTkwNjEzMmI4NjAwNzgzMDE2MDAwNjEzYzg1NTY1YjYxMzJjNjYwMDg4MzAxNjAwMDYxM2NhNjU2NWI2MDAwNjAwOTgzMDE4MTkwNTU2MDBhODMwMTU1NjEzMWRjNTY1YjYwNjA2MTAxZjQ4MzExMTU2MTMzMmQ1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMjA2MDA0ODIwMTUyNjAxZTYwMjQ4MjAxNTI3ZjQyNjE3NDYzNjgyMDczNjk3YTY1MjA3NDZmNmYyMDZjNjE3MjY3NjUyMDI4NmQ2MTc4MjAzNTMwMzAyOTAwMDA2MDQ0ODIwMTUyNjA2NDAxNjEwOTMwNTY1YjgyNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMzM0NTU3NjEzMzQ1NjE0MTVjNTY1YjYwNDA1MTkwODA4MjUyODA2MDIwMDI2MDIwMDE4MjAxNjA0MDUyODAxNTYxMzM3ZTU3ODE2MDIwMDE1YjYxMzM2YjYxM2MxYzU2NWI4MTUyNjAyMDAxOTA2MDAxOTAwMzkwODE2MTMzNjM1NzkwNTA1YjUwOTA1MDYwMDA1YjgzODExMDE1NjEzNWRlNTc2MDAwNjEzM2JlODY4Njg0ODE4MTEwNjEzM2EzNTc2MTMzYTM2MTQ1YTY1NjViOTA1MDYwMjAwMjAxNjAyMDgxMDE5MDYxMzNiODkxOTA2MTNmYWM1NjViODU2MTM2ODU1NjViOTA1MDYxMzNjYTg3ODI2MTM2YmQ1NjViMTU2MTM1Y2I1NzYwMDA4MTgxNTI2MDAyODg4MTAxNjAyMDkwODE1MjYwNDA5MjgzOTAyMDgzNTE2MTAxMjA4MTAxODU1MjgxNTQ2MDAxNjAwMTYwYTAxYjAzOTA4MTE2ODI1MjYwMDE4MzAxNTQxNjkyODEwMTkyOTA5MjUyODA4MzAxNTQ4Mjg1MDE1MjYwMDM4MTAxNTQ2MDYwODMwMTUyNjAwNDgxMDE1NDYwODA4MzAxNTI4MzUxODA4NTAxOTQ4NTkwNTI5MTkzOTA5MjYwYTA4NTAxOTI5MTYwMDU4NTAxOTE5MDgyODQ1YjgxNTQ4MTUyNjAyMDAxOTA2MDAxMDE5MDgwODMxMTYxMzQ0MTU3NTA1MDUwNTA1MDgxNTI2MDIwMDE2MDA3ODIwMTgwNTQ4MDYwMjAwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxNjAwMDkwNWI4MjgyMTAxNTYxMzRkYjU3NjAwMDg0ODE1MjYwMjA5MDgxOTAyMDYwNDA4MDUxNjA4MDgxMDE4MjUyNjAwNDg2MDI5MDkyMDE4MDU0ODM1MjYwMDE4MDgyMDE1NDg0ODYwMTUyNjAwMjgyMDE1NDkyODQwMTkyOTA5MjUyNjAwMzAxNTQ2MGZmMTYxNTE1NjA2MDgzMDE1MjkwODM1MjkwOTIwMTkxMDE2MTM0ODI1NjViNTA1MDUwNTA4MTUyNjAyMDAxNjAwODgyMDE4MDU0NjEzNGYzOTA2MTQ0MjQ1NjViODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTgyODA1NDYxMzUxZjkwNjE0NDI0NTY1YjgwMTU2MTM1NmM1NzgwNjAxZjEwNjEzNTQxNTc2MTAxMDA4MDgzNTQwNDAyODM1MjkxNjAyMDAxOTE2MTM1NmM1NjViODIwMTkxOTA2MDAwNTI2MDIwNjAwMDIwOTA1YjgxNTQ4MTUyOTA2MDAxMDE5MDYwMjAwMTgwODMxMTYxMzU0ZjU3ODI5MDAzNjAxZjE2ODIwMTkxNWI1MDUwNTA5MTgzNTI1MDUwNjA0MDgwNTE4MDgyMDE5MTgyOTA1MjYwMjA5MDkyMDE5MTkwNjAwOTg0MDE5MDYwMDI5MDgyODQ1YjgxNTQ4MTUyNjAyMDAxOTA2MDAxMDE5MDgwODMxMTYxMzU5MTU3NTA1MDUwNTA1MDgxNTI1MDUwODM4MzgxNTE4MTEwNjEzNWJmNTc2MTM1YmY2MTQ1YTY1NjViNjAyMDAyNjAyMDAxMDE4MTkwNTI1MDViNTA4MDYxMzVkNjgxNjE0NWUyNTY1YjkxNTA1MDYxMzM4NDU2NWI1MDk0OTM1MDUwNTA1MDU2NWI2MDAwNjEzNWYyODI2MTM4YjI1NjViOTA1MDYxMzVmZTgzODI2MTM2YmQ1NjViNjEzNjI2NTc2MDQwNTE2MzA0Yzc2ZDNmNjBlMTFiODE1MjYwMDE2MDAxNjBhMDFiMDM4MzE2NjAwNDgyMDE1MjYwMjQwMTYxMDkzMDU2NWI2MTM2MzA4MzgyNjEzOWI4NTY1YjUwNTA1MDUwNTY1YjYwMDA2MTM2NDM4NTg1ODU2MTM3MzA1NjViOTA1MDYxMzFkYzYwMDk4MjAxODM2MDAyNjEzY2UwNTY1YjYwMDA2MTA1YWI4MjYxMzcxYTU2NWI2MDAwODA2MTM2NmM4NDg0NjEzNzI0NTY1YjYwMDA5MDgxNTI2MDAyODUwMTYwMjA1MjYwNDA5MDIwOTE1MDUwOTI5MTUwNTA1NjViNjA0MDgwNTE2MDAxNjAwMTYwYTAxYjAzOTM4NDE2NjAyMDgwODMwMTkxOTA5MTUyOTI5MDkzMTY4MzgyMDE1MjgwNTE4MDg0MDM4MjAxODE1MjYwNjA5MDkzMDE5MDUyODE1MTkxMDEyMDkwNTY1YjYwMDA2MTA1YTg4MzgzNjEzYTQzNTY1YjYwMDA4MDYxMzZkNTgzNjEzOGIyNTY1YjYwMDA4MTgxNTI2MDAyODYwMTYwMjA1MjYwNDA5MDIwOTA5MTUwNjEzNmYyODU4MzYxMzZiZDU2NWI2MTFjM2Y1NzYwNDA1MTYzMDRjNzZkM2Y2MGUxMWI4MTUyNjAwMTYwMDE2MGEwMWIwMzg1MTY2MDA0ODIwMTUyNjAyNDAxNjEwOTMwNTY1YjYwMDA2MTA1YWI4MjU0OTA1NjViNjAwMDYxMDVhODgzODM2MTNhNWI1NjViNjAwMDgwNjEzNzNkODQ4NDYxMzY4NTU2NWI5MDUwNjEzNzQ5ODU4MjYxMzZiZDU2NWI2MTM3Nzk1NzYwNDA1MTYzMDIzMjgwZWI2MGUyMWI4MTUyNjAwMTYwMDE2MGEwMWIwMzgwODYxNjYwMDQ4MzAxNTI4NDE2NjAyNDgyMDE1MjYwNDQwMTYxMDkzMDU2NWI2MDAwOTA4MTUyNjAwMjg1MDE2MDIwNTI2MDQwOTAyMDkwNTA5MzkyNTA1MDUwNTY1YjYwMDA4NjgxNTI2MDAyODA4OTAxNjAyMDUyNjA0MDkwOTEyMDYwMDM4MTAxODQ5MDU1ODA1NDYwMDE2MDAxNjBhMDFiMDM4MDg5MTY2MDAxNjAwMTYwYTAxYjAzMTk5MjgzMTYxNzgzNTU2MDAxODMwMTgwNTQ5MTg5MTY5MTkwOTIxNjE3OTA1NTkwNjEzN2U4OTA2MDA1ODMwMTkwODY5MDYxM2NlMDU2NWI1MDYwMDg4MTAxNjEzN2Y3ODM4MjYxNDgwMTU2NWI1MDYxMzgwMjg4ODg2MTM4MGQ1NjViNTA1MDUwNTA1MDUwNTA1MDUwNTY1YjYwMDA2MTA1YTg4MzgzNjEzYTg1NTY1YjYxMzgyNzYwMDc4NDAxNjAwMDYxM2M4NTU2NWI2MDAwNWI4MTgxMTAxNTYxMzYzMDU3ODM2MDA3MDE4MzgyODE1MTgxMTA2MTM4NDg1NzYxMzg0ODYxNDVhNjU2NWI2MDIwOTA4MTAyOTE5MDkxMDE4MTAxNTE4MjU0NjAwMTgwODIwMTg1NTU2MDAwOTQ4NTUyOTM4MzkwMjA4MjUxNjAwNDkwOTIwMjAxOTA4MTU1OTE4MTAxNTE5MjgyMDE5MjkwOTI1NTYwNDA4MjAxNTE2MDAyODIwMTU1NjA2MDkwOTEwMTUxNjAwMzkwOTEwMTgwNTQ2MGZmMTkxNjkxMTUxNTkxOTA5MTE3OTA1NTgwNjEzOGFhODE2MTQ1ZTI1NjViOTE1MDUwNjEzODJhNTY1YjYwNDA4MDUxNjAwMTYwMDE2MGEwMWIwMzgzMTY2MDIwODIwMTUyNjAwMDkxMDE2MDQwNTE2MDIwODE4MzAzMDM4MTUyOTA2MDQwNTI4MDUxOTA2MDIwMDEyMDkwNTA5MTkwNTA1NjViNjAwMDgyODE1MjYwMDI4NDAxNjAyMDkwODE1MjYwNDA4MjIwODM1MTgxNTQ2MDAxNjAwMTYwYTAxYjAzMTkxNjYwMDE2MDAxNjBhMDFiMDM5MDkxMTYxNzgxNTU5MDgzMDE1MTgzOTE5MDYwMDE4MjAxOTA2MTM5MmE5MDgyNjE0ODAxNTY1YjUwNjA0MDgyMDE1MTYwMDI4MjAxOTA2MTM5M2Y5MDgyNjE0ODAxNTY1YjUwNjA2MDgyMDE1MTYwMDM4MjAxNTU2MDgwODIwMTUxNjAwNDgyMDE1NTYwYTA4MjAxNTE2MDA1ODIwMTU1NjBjMDgyMDE1MTYwMDY4MjAxOTA2MTM5NzI5MDgyNjE0ODAxNTY1YjUwNjBlMDgyMDE1MTYwMDc4MjAxOTA2MTM5ODc5MDgyNjE0ODAxNTY1YjUwNjEwMTAwODIwMTUxNjAwODgyMDE5MDYxMzk5ZDkwODI2MTQ4MDE1NjViNTA2MTFjM2Y5MTUwODU5MDUwODQ2MTM4MGQ1NjViNjAwMDYxMDVhODgzODM2MTNhZDQ1NjViNjAwMDgxODE1MjYwMDI4MzAxNjAyMDUyNjA0MDgxMjA4MDU0NjAwMTYwMDE2MGEwMWIwMzE5MTY4MTU1ODE2MTM5ZTQ2MDAxODMwMTgyNjEzY2E2NTY1YjYxMzlmMjYwMDI4MzAxNjAwMDYxM2NhNjU2NWI2MDAzODIwMTYwMDA5MDU1NjAwNDgyMDE2MDAwOTA1NTYwMDU4MjAxNjAwMDkwNTU2MDA2ODIwMTYwMDA2MTNhMWE5MTkwNjEzY2E2NTY1YjYxM2EyODYwMDc4MzAxNjAwMDYxM2NhNjU2NWI2MTNhMzY2MDA4ODMwMTYwMDA2MTNjYTY1NjViNTA2MTA1YTg5MDUwODM4MzYxMzlhYzU2NWI2MDAwODE4MTUyNjAwMTgzMDE2MDIwNTI2MDQwODEyMDU0MTUxNTYxMDVhODU2NWI2MDAwODI2MDAwMDE4MjgxNTQ4MTEwNjEzYTcyNTc2MTNhNzI2MTQ1YTY1NjViOTA2MDAwNTI2MDIwNjAwMDIwMDE1NDkwNTA5MjkxNTA1MDU2NWI2MDAwODE4MTUyNjAwMTgzMDE2MDIwNTI2MDQwODEyMDU0NjEzYWNjNTc1MDgxNTQ2MDAxODE4MTAxODQ1NTYwMDA4NDgxNTI2MDIwODA4MjIwOTA5MzAxODQ5MDU1ODQ1NDg0ODI1MjgyODYwMTkwOTM1MjYwNDA5MDIwOTE5MDkxNTU2MTA1YWI1NjViNTA2MDAwNjEwNWFiNTY1YjYwMDA4MTgxNTI2MDAxODMwMTYwMjA1MjYwNDA4MTIwNTQ4MDE1NjEzYmJkNTc2MDAwNjEzYWY4NjAwMTgzNjE0NGI1NTY1Yjg1NTQ5MDkxNTA2MDAwOTA2MTNiMGM5MDYwMDE5MDYxNDRiNTU2NWI5MDUwODE4MTE0NjEzYjcxNTc2MDAwODY2MDAwMDE4MjgxNTQ4MTEwNjEzYjJjNTc2MTNiMmM2MTQ1YTY1NjViOTA2MDAwNTI2MDIwNjAwMDIwMDE1NDkwNTA4MDg3NjAwMDAxODQ4MTU0ODExMDYxM2I0ZjU3NjEzYjRmNjE0NWE2NTY1YjYwMDA5MTgyNTI2MDIwODA4MzIwOTA5MTAxOTI5MDkyNTU5MTgyNTI2MDAxODgwMTkwNTI2MDQwOTAyMDgzOTA1NTViODU1NDg2OTA4MDYxM2I4MjU3NjEzYjgyNjE0OGMwNTY1YjYwMDE5MDAzODE4MTkwNjAwMDUyNjAyMDYwMDAyMDAxNjAwMDkwNTU5MDU1ODU2MDAxMDE2MDAwODY4MTUyNjAyMDAxOTA4MTUyNjAyMDAxNjAwMDIwNjAwMDkwNTU2MDAxOTM1MDUwNTA1MDYxMDVhYjU2NWI2MDAwOTE1MDUwNjEwNWFiNTY1YjYwNDA1MTgwNjEwMTIwMDE2MDQwNTI4MDYwMDA2MDAxNjAwMTYwYTAxYjAzMTY4MTUyNjAyMDAxNjA2MDgxNTI2MDIwMDE2MDYwODE1MjYwMjAwMTYwMDA4MTUyNjAyMDAxNjAwMDgxNTI2MDIwMDE2MDAwODE1MjYwMjAwMTYwNjA4MTUyNjAyMDAxNjA2MDgxNTI2MDIwMDE2MDYwODE1MjUwOTA1NjViNjA0MDUxODA2MTAxMjAwMTYwNDA1MjgwNjAwMDYwMDE2MDAxNjBhMDFiMDMxNjgxNTI2MDIwMDE2MDAwNjAwMTYwMDE2MGEwMWIwMzE2ODE1MjYwMjAwMTYwMDA4MTUyNjAyMDAxNjAwMDgxNTI2MDIwMDE2MDAwODE1MjYwMjAwMTYxM2M2NTYxM2QxZTU2NWI4MTUyNjAyMDAxNjA2MDgxNTI2MDIwMDE2MDYwODE1MjYwMjAwMTYxM2M4MDYxM2QxZTU2NWI5MDUyOTA1NjViNTA4MDU0NjAwMDgyNTU2MDA0MDI5MDYwMDA1MjYwMjA2MDAwMjA5MDgxMDE5MDYxMTdiZDkxOTA2MTNkM2M1NjViNTA4MDU0NjEzY2IyOTA2MTQ0MjQ1NjViNjAwMDgyNTU4MDYwMWYxMDYxM2NjMjU3NTA1MDU2NWI2MDFmMDE2MDIwOTAwNDkwNjAwMDUyNjAyMDYwMDAyMDkwODEwMTkwNjExN2JkOTE5MDYxM2Q2YTU2NWI4MjYwMDI4MTAxOTI4MjE1NjEzZDBlNTc5MTYwMjAwMjgyMDE1YjgyODExMTE1NjEzZDBlNTc4MjM1ODI1NTkxNjAyMDAxOTE5MDYwMDEwMTkwNjEzY2YzNTY1YjUwNjEzZDFhOTI5MTUwNjEzZDZhNTY1YjUwOTA1NjViNjA0MDUxODA2MDQwMDE2MDQwNTI4MDYwMDI5MDYwMjA4MjAyODAzNjgzMzc1MDkxOTI5MTUwNTA1NjViNWI4MDgyMTExNTYxM2QxYTU3NjAwMDgwODI1NTYwMDE4MjAxODE5MDU1NjAwMjgyMDE1NTYwMDM4MTAxODA1NDYwZmYxOTE2OTA1NTYwMDQwMTYxM2QzZDU2NWI1YjgwODIxMTE1NjEzZDFhNTc2MDAwODE1NTYwMDEwMTYxM2Q2YjU2NWI4MDYwMDA1YjYwMDI4MTEwMTU2MTM2MzA1NzgxNTE4NDUyNjAyMDkzODQwMTkzOTA5MTAxOTA2MDAxMDE2MTNkODM1NjViNjAwMDgxNTE4MDg0NTI2MDIwODA4NTAxOTQ1MDgwODQwMTYwMDA1YjgzODExMDE1NjEzZGY0NTc4MTUxODA1MTg4NTI4MzgxMDE1MTg0ODkwMTUyNjA0MDgwODIwMTUxOTA4OTAxNTI2MDYwOTA4MTAxNTExNTE1OTA4ODAxNTI2MDgwOTA5NjAxOTU5MDgyMDE5MDYwMDEwMTYxM2RiNjU2NWI1MDk0OTU5NDUwNTA1MDUwNTA1NjViNjAwMDgxNTE4MDg0NTI2MDAwNWI4MTgxMTAxNTYxM2UyNTU3NjAyMDgxODUwMTgxMDE1MTg2ODMwMTgyMDE1MjAxNjEzZTA5NTY1YjUwNjAwMDYwMjA4Mjg2MDEwMTUyNjAyMDYwMWYxOTYwMWY4MzAxMTY4NTAxMDE5MTUwNTA5MjkxNTA1MDU2NWI4MDUxNjAwMTYwMDE2MGEwMWIwMzE2ODI1MjYwMDA2MTAxNjA2MDIwODMwMTUxNjEzZTcxNjAyMDg2MDE4MjYwMDE2MDAxNjBhMDFiMDMxNjkwNTI1NjViNTA2MDQwODMwMTUxNjA0MDg1MDE1MjYwNjA4MzAxNTE2MDYwODUwMTUyNjA4MDgzMDE1MTYwODA4NTAxNTI2MGEwODMwMTUxNjEzZWEyNjBhMDg2MDE4MjYxM2Q3ZjU2NWI1MDYwYzA4MzAxNTE4MTYwZTA4NjAxNTI2MTNlYmE4Mjg2MDE4MjYxM2RhMjU2NWI5MTUwNTA2MGUwODMwMTUxNjEwMTAwODU4MzAzODE4NzAxNTI2MTNlZDY4MzgzNjEzZGZmNTY1YjkyNTA4MDg1MDE1MTkxNTA1MDYxM2VlZDYxMDEyMDg2MDE4MjYxM2Q3ZjU2NWI1MDkzOTI1MDUwNTA1NjViNjAwMDgxNTE4MDg0NTI2MDIwODA4NTAxODA4MTk2NTA4MzYwMDUxYjgxMDE5MTUwODI4NjAxNjAwMDViODU4MTEwMTU2MTNmM2Q1NzgyODQwMzg5NTI2MTNmMmI4NDgzNTE2MTNlNDU1NjViOTg4NTAxOTg5MzUwOTA4NDAxOTA2MDAxMDE2MTNmMTM1NjViNTA5MTk3OTY1MDUwNTA1MDUwNTA1MDU2NWI2MDIwODE1MjYwMDA2MTA1YTg2MDIwODMwMTg0NjEzZWY1NTY1YjgwMzU2MDAxNjAwMTYwYTAxYjAzODExNjgxMTQ2MTNmNzQ1NzYwMDA4MGZkNWI5MTkwNTA1NjViNjAwMDgwNjA0MDgzODUwMzEyMTU2MTNmOGM1NzYwMDA4MGZkNWI2MTNmOTU4MzYxM2Y1ZDU2NWI5MTUwNjEzZmEzNjAyMDg0MDE2MTNmNWQ1NjViOTA1MDkyNTA5MjkwNTA1NjViNjAwMDYwMjA4Mjg0MDMxMjE1NjEzZmJlNTc2MDAwODBmZDViNjEwNWE4ODI2MTNmNWQ1NjViODA1MTYwMDE2MDAxNjBhMDFiMDMxNjgyNTI2MDAwNjEwMTIwNjAyMDgzMDE1MTgxNjAyMDg2MDE1MjYxM2ZmMDgyODYwMTgyNjEzZGZmNTY1YjkxNTA1MDYwNDA4MzAxNTE4NDgyMDM2MDQwODYwMTUyNjE0MDBhODI4MjYxM2RmZjU2NWI5MTUwNTA2MDYwODMwMTUxNjA2MDg1MDE1MjYwODA4MzAxNTE2MDgwODUwMTUyNjBhMDgzMDE1MTYwYTA4NTAxNTI2MGMwODMwMTUxODQ4MjAzNjBjMDg2MDE1MjYxNDA0MjgyODI2MTNkZmY1NjViOTE1MDUwNjBlMDgzMDE1MTg0ODIwMzYwZTA4NjAxNTI2MTQwNWM4MjgyNjEzZGZmNTY1YjkxNTA1MDYxMDEwMDgwODQwMTUxODU4MzAzODI4NzAxNTI2MTQwNzc4MzgyNjEzZGZmNTY1Yjk2OTU1MDUwNTA1MDUwNTA1NjViNjAyMDgxNTI2MDAwNjEwNWE4NjAyMDgzMDE4NDYxM2ZjNzU2NWI2MDAwODA2MDAwNjA2MDg0ODYwMzEyMTU2MTQwYTk1NzYwMDA4MGZkNWI2MTQwYjI4NDYxM2Y1ZDU2NWI5NTYwMjA4NTAxMzU5NTUwNjA0MDkwOTQwMTM1OTM5MjUwNTA1MDU2NWI2MDQwODE1MjYwMDA2MTQwZGE2MDQwODMwMTg1NjEzZWY1NTY1YjkwNTA4MjYwMjA4MzAxNTI5MzkyNTA1MDUwNTY1YjYwMDA2MDIwODA4MzAxODE4NDUyODA4NTUxODA4MzUyNjA0MDg2MDE5MTUwNjA0MDgxNjAwNTFiODcwMTAxOTI1MDgzODcwMTYwMDA1YjgyODExMDE1NjE0MTNlNTc2MDNmMTk4ODg2MDMwMTg0NTI2MTQxMmM4NTgzNTE2MTNmYzc1NjViOTQ1MDkyODUwMTkyOTA4NTAxOTA2MDAxMDE2MTQxMTA1NjViNTA5Mjk3OTY1MDUwNTA1MDUwNTA1MDU2NWI4MDYwNDA4MTAxODMxMDE1NjEwNWFiNTc2MDAwODBmZDViNjM0ZTQ4N2I3MTYwZTAxYjYwMDA1MjYwNDE2MDA0NTI2MDI0NjAwMGZkNWI2MDAwODA2MDAwODA2MGEwODU4NzAzMTIxNTYxNDE4ODU3NjAwMDgwZmQ1YjYxNDE5MTg1NjEzZjVkNTY1YjkzNTA2MTQxOWY2MDIwODYwMTYxM2Y1ZDU2NWI5MjUwNjE0MWFlODY2MDQwODcwMTYxNDE0YjU2NWI5MTUwNjA4MDg1MDEzNTYwMDE2MDAxNjA0MDFiMDM4MDgyMTExNTYxNDFjYTU3NjAwMDgwZmQ1YjgxODcwMTkxNTA4NzYwMWY4MzAxMTI2MTQxZGU1NzYwMDA4MGZkNWI4MTM1ODE4MTExMTU2MTQxZjA1NzYxNDFmMDYxNDE1YzU2NWI2MDQwNTE2MDFmODIwMTYwMWYxOTkwODExNjYwM2YwMTE2ODEwMTkwODM4MjExODE4MzEwMTcxNTYxNDIxODU3NjE0MjE4NjE0MTVjNTY1YjgxNjA0MDUyODI4MTUyOGE2MDIwODQ4NzAxMDExMTE1NjE0MjMxNTc2MDAwODBmZDViODI2MDIwODYwMTYwMjA4MzAxMzc2MDAwNjAyMDg0ODMwMTAxNTI4MDk1NTA1MDUwNTA1MDUwOTI5NTkxOTQ1MDkyNTA1NjViNjAwMDgwNjAwMDYwNjA4NDg2MDMxMjE1NjE0MjZhNTc2MDAwODBmZDViNjE0MjczODQ2MTNmNWQ1NjViOTI1MDYxNDI4MTYwMjA4NTAxNjEzZjVkNTY1YjkxNTA2MDQwODQwMTM1OTA1MDkyNTA5MjUwOTI1NjViNjAwMDgwNjAwMDgwNjA4MDg1ODcwMzEyMTU2MTQyYTc1NzYwMDA4MGZkNWI4NDM1OTM1MDYxNDJiNzYwMjA4NjAxNjEzZjVkNTY1YjkyNTA2MTQyYzU2MDQwODYwMTYxM2Y1ZDU2NWI5MTUwNjE0MmQzNjA2MDg2MDE2MTNmNWQ1NjViOTA1MDkyOTU5MTk0NTA5MjUwNTY1YjYwMDA2MDIwODI4NDAzMTIxNTYxNDJmMDU3NjAwMDgwZmQ1YjgxMzU2MDAxNjAwMTYwNDAxYjAzODExMTE1NjE0MzA2NTc2MDAwODBmZDViODIwMTYwODA4MTg1MDMxMjE1NjE0MzE4NTc2MDAwODBmZDViOTM5MjUwNTA1MDU2NWI2MDAwNjAyMDgyODQwMzEyMTU2MTQzMzE1NzYwMDA4MGZkNWI4MTM1NjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxNDM0NzU3NjAwMDgwZmQ1YjgyMDE2MGUwODE4NTAzMTIxNTYxNDMxODU3NjAwMDgwZmQ1YjYwMDA4MDYwMjA4Mzg1MDMxMjE1NjE0MzZjNTc2MDAwODBmZDViODIzNTYwMDE2MDAxNjA0MDFiMDM4MDgyMTExNTYxNDM4MzU3NjAwMDgwZmQ1YjgxODUwMTkxNTA4NTYwMWY4MzAxMTI2MTQzOTc1NzYwMDA4MGZkNWI4MTM1ODE4MTExMTU2MTQzYTY1NzYwMDA4MGZkNWI4NjYwMjA4MjYwMDUxYjg1MDEwMTExMTU2MTQzYmI1NzYwMDA4MGZkNWI2MDIwOTI5MDkyMDE5NjkxOTU1MDkwOTM1MDUwNTA1MDU2NWI2MDAwODA2MDYwODM4NTAzMTIxNTYxNDNlMDU3NjAwMDgwZmQ1YjYxNDNlOTgzNjEzZjVkNTY1YjkxNTA2MTNmYTM4NDYwMjA4NTAxNjE0MTRiNTY1YjYwMDA2MDIwODI4NDAzMTIxNTYxNDQwYTU3NjAwMDgwZmQ1YjUwMzU5MTkwNTA1NjViNjAyMDgxNTI2MDAwNjEwNWE4NjAyMDgzMDE4NDYxM2U0NTU2NWI2MDAxODE4MTFjOTA4MjE2ODA2MTQ0Mzg1NzYwN2Y4MjE2OTE1MDViNjAyMDgyMTA4MTAzNjE0NDU4NTc2MzRlNDg3YjcxNjBlMDFiNjAwMDUyNjAyMjYwMDQ1MjYwMjQ2MDAwZmQ1YjUwOTE5MDUwNTY1YjYwMjA4MDgyNTI2MDIxOTA4MjAxNTI3ZjQzNjE2YzZjNjU3MjIwNjk3MzIwNmU2Zjc0MjA3NDY4NjUyMDZjNjU2NDY3NjU3MjIwNjM2ZjZlNzQ3MjYxNjM2MDQwODIwMTUyNjAxZDYwZmExYjYwNjA4MjAxNTI2MDgwMDE5MDU2NWI2MzRlNDg3YjcxNjBlMDFiNjAwMDUyNjAxMTYwMDQ1MjYwMjQ2MDAwZmQ1YjgxODEwMzgxODExMTE1NjEwNWFiNTc2MTA1YWI2MTQ0OWY1NjViNjAwMDgwODMzNTYwMWUxOTg0MzYwMzAxODExMjYxNDRkZjU3NjAwMDgwZmQ1YjgzMDE4MDM1OTE1MDYwMDE2MDAxNjA0MDFiMDM4MjExMTU2MTQ0Zjk1NzYwMDA4MGZkNWI2MDIwMDE5MTUwNjAwNTgxOTAxYjM2MDM4MjEzMTU2MTQ1MTE1NzYwMDA4MGZkNWI5MjUwOTI5MDUwNTY1YjgxODM1MjYwMDA2MDAxNjAwMTYwZmIxYjAzODMxMTE1NjE0NTMxNTc2MDAwODBmZDViODI2MDA1MWI4MDgzNjAyMDg3MDEzNzkzOTA5MzAxNjAyMDAxOTM5MjUwNTA1MDU2NWI2MDYwODE1MjYwMDA2MTQ1NWU2MDYwODMwMTg3ODk2MTQ1MTg1NjViODI4MTAzNjAyMDg0MDE1MjYxNDU3MTgxODY4ODYxNDUxODU2NWI5MTUwNTA4MjYwNDA4MzAxNTI5Njk1NTA1MDUwNTA1MDUwNTY1YjYwMDA2MDIwODI4NDAzMTIxNTYxNDU5NjU3NjAwMDgwZmQ1YjgxNTE4MDE1MTU4MTE0NjE0MzE4NTc2MDAwODBmZDViNjM0ZTQ4N2I3MTYwZTAxYjYwMDA1MjYwMzI2MDA0NTI2MDI0NjAwMGZkNWI4MDgyMDE4MDgyMTExNTYxMDVhYjU3NjEwNWFiNjE0NDlmNTY1YjYwMjA4MTUyNjAwMDYxMDVhODYwMjA4MzAxODQ2MTNkZmY1NjViNjAwMDYwMDE4MjAxNjE0NWY0NTc2MTQ1ZjQ2MTQ0OWY1NjViNTA2MDAxMDE5MDU2NWI2MDAwODA4MzM1NjAxZTE5ODQzNjAzMDE4MTEyNjE0NjEyNTc2MDAwODBmZDViODMwMTgwMzU5MTUwNjAwMTYwMDE2MDQwMWIwMzgyMTExNTYxNDYyYzU3NjAwMDgwZmQ1YjYwMjAwMTkxNTAzNjgxOTAwMzgyMTMxNTYxNDUxMTU3NjAwMDgwZmQ1YjgxODM1MjgxODE2MDIwODUwMTM3NTA2MDAwODI4MjAxNjAyMDkwODEwMTkxOTA5MTUyNjAxZjkwOTEwMTYwMWYxOTE2OTA5MTAxMDE5MDU2NWI2MGUwODE1MjYwMDA2MTQ2N2U2MGUwODMwMThkOGY2MTQ2NDE1NjViODI4MTAzNjAyMDg0MDE1MjYxNDY5MTgxOGM4ZTYxNDY0MTU2NWI5MDUwODk2MDQwODQwMTUyODg2MDYwODQwMTUyODc2MDgwODQwMTUyODI4MTAzNjBhMDg0MDE1MjYxNDZiODgxODc4OTYxNDY0MTU2NWI5MDUwODI4MTAzNjBjMDg0MDE1MjYxNDZjZDgxODU4NzYxNDY0MTU2NWI5ZTlkNTA1MDUwNTA1MDUwNTA1MDUwNTA1MDUwNTA1MDU2NWI2MDAwNjAwMTYwZmYxYjgyMDE2MTQ2ZjQ1NzYxNDZmNDYxNDQ5ZjU2NWI1MDYwMDAxOTAxOTA1NjViNjAxZjgyMTExNTYxMGQ5ZDU3NjAwMDgxODE1MjYwMjA4MTIwNjAxZjg1MDE2MDA1MWM4MTAxNjAyMDg2MTAxNTYxNDcyMzU3NTA4MDViNjAxZjg1MDE2MDA1MWM4MjAxOTE1MDViODE4MTEwMTU2MTMxZGM1NzgyODE1NTYwMDEwMTYxNDcyZjU2NWI2MDAxNjAwMTYwNDAxYjAzODMxMTE1NjE0NzU5NTc2MTQ3NTk2MTQxNWM1NjViNjE0NzZkODM2MTQ3Njc4MzU0NjE0NDI0NTY1YjgzNjE0NmZjNTY1YjYwMDA2MDFmODQxMTYwMDE4MTE0NjE0N2ExNTc2MDAwODUxNTYxNDc4OTU3NTA4MzgyMDEzNTViNjAwMDE5NjAwMzg3OTAxYjFjMTkxNjYwMDE4NjkwMWIxNzgzNTU2MTE2MjY1NjViNjAwMDgzODE1MjYwMjA5MDIwNjAxZjE5ODYxNjkwODM1YjgyODExMDE1NjE0N2QyNTc4Njg1MDEzNTgyNTU2MDIwOTQ4NTAxOTQ2MDAxOTA5MjAxOTEwMTYxNDdiMjU2NWI1MDg2ODIxMDE1NjE0N2VmNTc2MDAwMTk2MGY4ODg2MDAzMWIxNjFjMTk4NDg3MDEzNTE2ODE1NTViNTA1MDYwMDE4NTYwMDExYjAxODM1NTUwNTA1MDUwNTA1NjViODE1MTYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTQ4MWE1NzYxNDgxYTYxNDE1YzU2NWI2MTQ4MmU4MTYxNDgyODg0NTQ2MTQ0MjQ1NjViODQ2MTQ2ZmM1NjViNjAyMDgwNjAxZjgzMTE2MDAxODExNDYxNDg2MzU3NjAwMDg0MTU2MTQ4NGI1NzUwODU4MzAxNTE1YjYwMDAxOTYwMDM4NjkwMWIxYzE5MTY2MDAxODU5MDFiMTc4NTU1NjEzMWRjNTY1YjYwMDA4NTgxNTI2MDIwODEyMDYwMWYxOTg2MTY5MTViODI4MTEwMTU2MTQ4OTI1Nzg4ODYwMTUxODI1NTk0ODQwMTk0NjAwMTkwOTEwMTkwODQwMTYxNDg3MzU2NWI1MDg1ODIxMDE1NjE0OGIwNTc4Nzg1MDE1MTYwMDAxOTYwMDM4ODkwMWI2MGY4MTYxYzE5MTY4MTU1NWI1MDUwNTA1MDUwNjAwMTkwODExYjAxOTA1NTUwNTY1YjYzNGU0ODdiNzE2MGUwMWI2MDAwNTI2MDMxNjAwNDUyNjAyNDYwMDBmZGZlNTI2ODI0OTQ0MDQ3ZGE1YjgxMDcxZmI2MzQ5NDEyMDA1YzVkYTgxMzgwYjMzNjEwM2ZiZTVkZDM0NTU2Yzc3NmEyNjQ2OTcwNjY3MzU4MjIxMjIwOTU0OGFmNTJjZDg2YjhiZDNhZjFhMTY1ZjNkMGFmYjkyODlkMjIxODI5MDEzZTUzNDcxNDQ3OTBhNzY0MWViNzY0NzM2ZjZjNjM0MzAwMDgxNDAwMzMnO1xuY29uc3QgaXNTdXBlckFyZ3MkMSA9ICh4cykgPT4geHMubGVuZ3RoID4gMTtcbmNsYXNzIEluZmVyZW5jZVNlcnZpbmdfX2ZhY3RvcnkgZXh0ZW5kcyBDb250cmFjdEZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGlzU3VwZXJBcmdzJDEoYXJncykpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIoX2FiaSQxLCBfYnl0ZWNvZGUkMSwgYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVwbG95VHJhbnNhY3Rpb24ob3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXREZXBsb3lUcmFuc2FjdGlvbihvdmVycmlkZXMgfHwge30pO1xuICAgIH1cbiAgICBkZXBsb3kob3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5kZXBsb3kob3ZlcnJpZGVzIHx8IHt9KTtcbiAgICB9XG4gICAgY29ubmVjdChydW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNvbm5lY3QocnVubmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGJ5dGVjb2RlID0gX2J5dGVjb2RlJDE7XG4gICAgc3RhdGljIGFiaSA9IF9hYmkkMTtcbiAgICBzdGF0aWMgY3JlYXRlSW50ZXJmYWNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZShfYWJpJDEpO1xuICAgIH1cbiAgICBzdGF0aWMgY29ubmVjdChhZGRyZXNzLCBydW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdChhZGRyZXNzLCBfYWJpJDEsIHJ1bm5lcik7XG4gICAgfVxufVxuXG4vKiBBdXRvZ2VuZXJhdGVkIGZpbGUuIERvIG5vdCBlZGl0IG1hbnVhbGx5LiAqL1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBfYWJpID0gW1xuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnQWNjb3VudEV4aXN0cycsXG4gICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ0FjY291bnROb3RFeGlzdHMnLFxuICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdyZWFzb24nLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ0ludmFsaWRWZXJpZmllcklucHV0JyxcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnU2VydmljZU5vdEV4aXN0JyxcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndXNlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwZW5kaW5nUmVmdW5kJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnQmFsYW5jZVVwZGF0ZWQnLFxuICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcmV2aW91c093bmVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ25ld093bmVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnT3duZXJzaGlwVHJhbnNmZXJyZWQnLFxuICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2luZGV4JyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0aW1lc3RhbXAnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdSZWZ1bmRSZXF1ZXN0ZWQnLFxuICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnU2VydmljZVJlbW92ZWQnLFxuICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VybCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY3B1Q291bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdub2RlTWVtb3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZ3B1Q291bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdub2RlU3RvcmFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZ3B1VHlwZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBRdW90YScsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3F1b3RhJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndHVwbGUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncHJpY2VQZXJUb2tlbicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXJTaWduZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ29jY3VwaWVkJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnU2VydmljZVVwZGF0ZWQnLFxuICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndXNlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdhY2NvdW50RXhpc3RzJyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdib29sJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2luZGV4JyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnYWNrbm93bGVkZ2VEZWxpdmVyYWJsZScsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlclNpZ25lcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ2Fja25vd2xlZGdlUHJvdmlkZXJTaWduZXInLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhZGRpdGlvbmFsSW5mbycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnYWRkQWNjb3VudCcsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdwYXlhYmxlJyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdtb2RlbFJvb3RIYXNoJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ2FkZERlbGl2ZXJhYmxlJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1cmwnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NwdUNvdW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbm9kZU1lbW9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2dwdUNvdW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbm9kZVN0b3JhZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2dwdVR5cGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgUXVvdGEnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdxdW90YScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3ByaWNlUGVyVG9rZW4nLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyU2lnbmVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdvY2N1cGllZCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmdbXScsXG4gICAgICAgICAgICAgICAgbmFtZTogJ21vZGVscycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZ1tdJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdhZGRPclVwZGF0ZVNlcnZpY2UnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ2RlbGV0ZUFjY291bnQnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2FuY2VsUmV0cmlldmluZ0Ftb3VudCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ2RlcG9zaXRGdW5kJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3BheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndXNlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdnZXRBY2NvdW50JyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbm9uY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncGVuZGluZ1JlZnVuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnaW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NyZWF0ZWRBdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwcm9jZXNzZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgUmVmdW5kW10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3JlZnVuZHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlW10nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2FkZGl0aW9uYWxJbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlclNpZ25lcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21vZGVsUm9vdEhhc2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdlbmNyeXB0ZWRTZWNyZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Fja25vd2xlZGdlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBEZWxpdmVyYWJsZVtdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdkZWxpdmVyYWJsZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlW10nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RydWN0IEFjY291bnQnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0dXBsZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnZ2V0QWNjb3VudHNCeVByb3ZpZGVyJyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbm9uY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncGVuZGluZ1JlZnVuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnaW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NyZWF0ZWRBdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwcm9jZXNzZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgUmVmdW5kW10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3JlZnVuZHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlW10nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2FkZGl0aW9uYWxJbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlclNpZ25lcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21vZGVsUm9vdEhhc2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdlbmNyeXB0ZWRTZWNyZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Fja25vd2xlZGdlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBEZWxpdmVyYWJsZVtdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdkZWxpdmVyYWJsZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlW10nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RydWN0IEFjY291bnRbXScsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2FjY291bnRzJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndHVwbGVbXScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0b3RhbCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnZ2V0QWNjb3VudHNCeVVzZXInLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdub25jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwZW5kaW5nUmVmdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpbmRleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY3JlYXRlZEF0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb2Nlc3NlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBSZWZ1bmRbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVmdW5kcycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndHVwbGVbXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRkaXRpb25hbEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyU2lnbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbW9kZWxSb290SGFzaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2VuY3J5cHRlZFNlY3JldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWNrbm93bGVkZ2VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RydWN0IERlbGl2ZXJhYmxlW10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2RlbGl2ZXJhYmxlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndHVwbGVbXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgQWNjb3VudFtdJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0dXBsZVtdJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3RvdGFsJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogJ2dldEFsbEFjY291bnRzJyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbm9uY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncGVuZGluZ1JlZnVuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnaW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NyZWF0ZWRBdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwcm9jZXNzZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgUmVmdW5kW10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3JlZnVuZHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlW10nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2FkZGl0aW9uYWxJbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlclNpZ25lcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21vZGVsUm9vdEhhc2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdlbmNyeXB0ZWRTZWNyZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Fja25vd2xlZGdlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBEZWxpdmVyYWJsZVtdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdkZWxpdmVyYWJsZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlW10nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RydWN0IEFjY291bnRbXScsXG4gICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlW10nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6ICdnZXRBbGxTZXJ2aWNlcycsXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1cmwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY3B1Q291bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbm9kZU1lbW9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdncHVDb3VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdub2RlU3RvcmFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2dwdVR5cGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBRdW90YScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncXVvdGEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJpY2VQZXJUb2tlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyU2lnbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnb2NjdXBpZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmdbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbW9kZWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmdbXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgU2VydmljZVtdJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc2VydmljZXMnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0dXBsZVtdJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzW10nLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VycycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3NbXScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnZ2V0QmF0Y2hBY2NvdW50c0J5VXNlcnMnLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdub25jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwZW5kaW5nUmVmdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpbmRleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY3JlYXRlZEF0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb2Nlc3NlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBSZWZ1bmRbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVmdW5kcycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndHVwbGVbXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWRkaXRpb25hbEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyU2lnbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbW9kZWxSb290SGFzaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2VuY3J5cHRlZFNlY3JldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYWNrbm93bGVkZ2VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RydWN0IERlbGl2ZXJhYmxlW10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2RlbGl2ZXJhYmxlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndHVwbGVbXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgQWNjb3VudFtdJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0dXBsZVtdJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndXNlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2luZGV4JyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnZ2V0RGVsaXZlcmFibGUnLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbW9kZWxSb290SGFzaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZW5jcnlwdGVkU2VjcmV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Fja25vd2xlZGdlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgRGVsaXZlcmFibGUnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0dXBsZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnZ2V0UGVuZGluZ1JlZnVuZCcsXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnZ2V0U2VydmljZScsXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1cmwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY3B1Q291bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbm9kZU1lbW9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdncHVDb3VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdub2RlU3RvcmFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2dwdVR5cGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBRdW90YScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncXVvdGEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJpY2VQZXJUb2tlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Byb3ZpZGVyU2lnbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnb2NjdXBpZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJpbmdbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbW9kZWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmdbXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgU2VydmljZScsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3NlcnZpY2UnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0dXBsZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ19sb2NrdGltZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnX2xlZGdlckFkZHJlc3MnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgbmFtZTogJ293bmVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdfcGVuYWx0eVBlcmNlbnRhZ2UnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdpbml0aWFsaXplJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiAnaW5pdGlhbGl6ZWQnLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6ICdsZWRnZXJBZGRyZXNzJyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiAnbG9ja1RpbWUnLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6ICdvd25lcicsXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogJ3BlbmFsdHlQZXJjZW50YWdlJyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndXNlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdwcm9jZXNzUmVmdW5kJyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0b3RhbEFtb3VudCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncGVuZGluZ1JlZnVuZCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6ICdyZW1vdmVTZXJ2aWNlJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiAncmVub3VuY2VPd25lcnNoaXAnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm92aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ3JlcXVlc3RSZWZ1bmRBbGwnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnaW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZW5jcnlwdGVkU2VjcmV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdtb2RlbFJvb3RIYXNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ25vbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJvdmlkZXJTaWduZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2lnbmF0dXJlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Rhc2tGZWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3N0cnVjdCBWZXJpZmllcklucHV0JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndmVyaWZpZXJJbnB1dCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdzZXR0bGVGZWVzJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbmV3T3duZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICd0cmFuc2Zlck93bmVyc2hpcCcsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ19sb2NrdGltZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ3VwZGF0ZUxvY2tUaW1lJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnX3BlbmFsdHlQZXJjZW50YWdlJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAndXBkYXRlUGVuYWx0eVBlcmNlbnRhZ2UnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbl07XG5jb25zdCBfYnl0ZWNvZGUgPSAnMHg2MDgwNjA0MDUyMzQ4MDE1NjIwMDAwMTE1NzYwMDA4MGZkNWI1MDYyMDAwMDFkMzM2MjAwMDAyMzU2NWI2MjAwMDA3MzU2NWI2MDAwODA1NDYwMDE2MDAxNjBhMDFiMDM4MzgxMTY2MDAxNjAwMTYwYTAxYjAzMTk4MzE2ODExNzg0NTU2MDQwNTE5MTkwOTIxNjkyODM5MTdmOGJlMDA3OWM1MzE2NTkxNDEzNDRjZDFmZDBhNGYyODQxOTQ5N2Y5NzIyYTNkYWFmZTNiNDE4NmY2YjY0NTdlMDkxOTBhMzUwNTA1NjViNjE1MWM4ODA2MjAwMDA4MzYwMDAzOTYwMDBmM2ZlNjA4MDYwNDA1MjYwMDQzNjEwNjEwMWQ4NTc2MDAwMzU2MGUwMWM4MDYzNzE1MDE4YTYxMTYxMDEwMjU3ODA2M2QxZDIwMDU2MTE2MTAwOTU1NzgwNjNmMmM2NzQxYTExNjEwMDY0NTc4MDYzZjJjNjc0MWExNDYxMDU3YzU3ODA2M2YyZmRlMzhiMTQ2MTA1OWM1NzgwNjNmYmZhNGUxMTE0NjEwNWJjNTc4MDYzZmQ1OTA4NDcxNDYxMDVkYzU3NjAwMDgwZmQ1YjgwNjNkMWQyMDA1NjE0NjEwNTA5NTc4MDYzZTM3MjU5ZTkxNDYxMDUyOTU3ODA2M2U1MDY4OGY5MTQ2MTA1NDk1NzgwNjNlYjk2MTY5MzE0NjEwNTVjNTc2MDAwODBmZDViODA2Mzk3ZTE5NDAzMTE2MTAwZDE1NzgwNjM5N2UxOTQwMzE0NjEwNDk0NTc4MDYzOTgyNDg5OTcxNDYxMDRiNDU3ODA2M2JhMTZhNzUwMTQ2MTA0ZDQ1NzgwNjNiYmVlNDJkOTE0NjEwNGY0NTc2MDAwODBmZDViODA2MzcxNTAxOGE2MTQ2MTA0MWE1NzgwNjM3NDVlODdmNzE0NjEwNDJmNTc4MDYzOGRhNWNiNWIxNDYxMDQ0MjU3ODA2Mzk3MjE2NzI1MTQ2MTA0NzQ1NzYwMDA4MGZkNWI4MDYzMjFmZTBmMzAxMTYxMDE3YTU3ODA2MzRlM2M0ZjIyMTE2MTAxNDk1NzgwNjM0ZTNjNGYyMjE0NjEwMzdmNTc4MDYzNGZlNjNmNGQxNDYxMDNiYTU3ODA2MzVmNzA2OWRiMTQ2MTAzZGE1NzgwNjM2Yzc5MTU4ZDE0NjEwM2ZhNTc2MDAwODBmZDViODA2MzIxZmUwZjMwMTQ2MTAyZWU1NzgwNjMyNjQxNzNkNjE0NjEwMzEwNTc4MDYzMjkwYTY4ZGYxNDYxMDMzMDU3ODA2MzM4OWY2OGVlMTQ2MTAzNWQ1NzYwMDA4MGZkNWI4MDYzMTU4ZWY5M2UxMTYxMDFiNjU3ODA2MzE1OGVmOTNlMTQ2MTAyNWM1NzgwNjMxNTkwOGQ1MTE0NjEwMjdkNTc4MDYzMTVhNTIzMDIxNDYxMDI5MzU3ODA2MzFkNzNiOWY1MTQ2MTAyYzA1NzYwMDA4MGZkNWI4MDYzMDhlOTNkMGExNDYxMDFkZDU3ODA2MzBkNjY4MDg3MTQ2MTAyMDg1NzgwNjMxNDc1MDBlMzE0NjEwMjJjNTc1YjYwMDA4MGZkNWIzNDgwMTU2MTAxZTk1NzYwMDA4MGZkNWI1MDYxMDFmMjYxMDYwOTU2NWI2MDQwNTE2MTAxZmY5MTkwNjE0NDdjNTY1YjYwNDA1MTgwOTEwMzkwZjM1YjM0ODAxNTYxMDIxNDU3NjAwMDgwZmQ1YjUwNjEwMjFlNjAwMTU0ODE1NjViNjA0MDUxOTA4MTUyNjAyMDAxNjEwMWZmNTY1YjM0ODAxNTYxMDIzODU3NjAwMDgwZmQ1YjUwNjEwMjRjNjEwMjQ3MzY2MDA0NjE0NGFiNTY1YjYxMDYxYTU2NWI2MDQwNTE5MDE1MTU4MTUyNjAyMDAxNjEwMWZmNTY1YjM0ODAxNTYxMDI2ODU3NjAwMDgwZmQ1YjUwNjAwMDU0NjEwMjRjOTA2MDAxNjBhMDFiOTAwNDYwZmYxNjgxNTY1YjM0ODAxNTYxMDI4OTU3NjAwMDgwZmQ1YjUwNjEwMjFlNjAwYzU0ODE1NjViMzQ4MDE1NjEwMjlmNTc2MDAwODBmZDViNTA2MTAyYjM2MTAyYWUzNjYwMDQ2MTQ0ZGU1NjViNjEwNjMxNTY1YjYwNDA1MTYxMDFmZjkxOTA2MTQ2MDE1NjViMzQ4MDE1NjEwMmNjNTc2MDAwODBmZDViNTA2MTAyZTA2MTAyZGIzNjYwMDQ2MTQ2MTQ1NjViNjEwOGRiNTY1YjYwNDA1MTYxMDFmZjkyOTE5MDYxNDY0NzU2NWIzNDgwMTU2MTAyZmE1NzYwMDA4MGZkNWI1MDYxMDMwMzYxMDk0OTU2NWI2MDQwNTE2MTAxZmY5MTkwNjE0NjY5NTY1YjM0ODAxNTYxMDMxYzU3NjAwMDgwZmQ1YjUwNjEwMjFlNjEwMzJiMzY2MDA0NjE0NGFiNTY1YjYxMDk1NTU2NWIzNDgwMTU2MTAzM2M1NzYwMDA4MGZkNWI1MDYxMDM1MDYxMDM0YjM2NjAwNDYxNDZjYjU2NWI2MTA5NjM1NjViNjA0MDUxNjEwMWZmOTE5MDYxNDcwNzU2NWIzNDgwMTU2MTAzNjk1NzYwMDA4MGZkNWI1MDYxMDM3ZDYxMDM3ODM2NjAwNDYxNDkzMjU2NWI2MTBhZjU1NjViMDA1YjM0ODAxNTYxMDM4YjU3NjAwMDgwZmQ1YjUwNjEwMzlmNjEwMzlhMzY2MDA0NjE0NGFiNTY1YjYxMGI5NDU2NWI2MDQwODA1MTkzODQ1MjYwMjA4NDAxOTI5MDkyNTI5MDgyMDE1MjYwNjAwMTYxMDFmZjU2NWIzNDgwMTU2MTAzYzY1NzYwMDA4MGZkNWI1MDYxMDJlMDYxMDNkNTM2NjAwNDYxNDYxNDU2NWI2MTBjN2Q1NjViMzQ4MDE1NjEwM2U2NTc2MDAwODBmZDViNTA2MTAzN2Q2MTAzZjUzNjYwMDQ2MTRhMTU1NjViNjEwY2RhNTY1YjM0ODAxNTYxMDQwNjU3NjAwMDgwZmQ1YjUwNjEwMzdkNjEwNDE1MzY2MDA0NjE0NGFiNTY1YjYxMGNlYjU2NWIzNDgwMTU2MTA0MjY1NzYwMDA4MGZkNWI1MDYxMDM3ZDYxMGQyMTU2NWI2MTAzN2Q2MTA0M2QzNjYwMDQ2MTQ2Y2I1NjViNjEwZDM1NTY1YjM0ODAxNTYxMDQ0ZTU3NjAwMDgwZmQ1YjUwNjAwMDU0NjAwMTYwMDE2MGEwMWIwMzE2NWI2MDQwNTE2MDAxNjAwMTYwYTAxYjAzOTA5MTE2ODE1MjYwMjAwMTYxMDFmZjU2NWIzNDgwMTU2MTA0ODA1NzYwMDA4MGZkNWI1MDYxMDM3ZDYxMDQ4ZjM2NjAwNDYxNDRhYjU2NWI2MTBkZDE1NjViMzQ4MDE1NjEwNGEwNTc2MDAwODBmZDViNTA2MTAzN2Q2MTA0YWYzNjYwMDQ2MTRhM2Y1NjViNjEwZTA3NTY1YjM0ODAxNTYxMDRjMDU3NjAwMDgwZmQ1YjUwNjEwMzdkNjEwNGNmMzY2MDA0NjE0YTgxNTY1YjYxMTFkNjU2NWIzNDgwMTU2MTA0ZTA1NzYwMDA4MGZkNWI1MDYxMDFmMjYxMDRlZjM2NjAwNDYxNGFjZTU2NWI2MTExZTM1NjViMzQ4MDE1NjEwNTAwNTc2MDAwODBmZDViNTA2MTAzN2Q2MTExZjI1NjViMzQ4MDE1NjEwNTE1NTc2MDAwODBmZDViNTA2MDAyNTQ2MTA0NWM5MDYwMDE2MDAxNjBhMDFiMDMxNjgxNTY1YjM0ODAxNTYxMDUzNTU3NjAwMDgwZmQ1YjUwNjEwMzdkNjEwNTQ0MzY2MDA0NjE0YjQyNTY1YjYxMTIyYTU2NWI2MTAzN2Q2MTA1NTczNjYwMDQ2MTRiODY1NjViNjExMmUxNTY1YjM0ODAxNTYxMDU2ODU3NjAwMDgwZmQ1YjUwNjEwMzdkNjEwNTc3MzY2MDA0NjE0YmUzNTY1YjYxMTMxYzU2NWIzNDgwMTU2MTA1ODg1NzYwMDA4MGZkNWI1MDYxMDM3ZDYxMDU5NzM2NjAwNDYxNDRhYjU2NWI2MTEzMjk1NjViMzQ4MDE1NjEwNWE4NTc2MDAwODBmZDViNTA2MTAzN2Q2MTA1YjczNjYwMDQ2MTQ0ZGU1NjViNjExMzM2NTY1YjM0ODAxNTYxMDVjODU3NjAwMDgwZmQ1YjUwNjEwMzdkNjEwNWQ3MzY2MDA0NjE0YmUzNTY1YjYxMTNhZjU2NWIzNDgwMTU2MTA1ZTg1NzYwMDA4MGZkNWI1MDYxMDVmYzYxMDVmNzM2NjAwNDYxNDRhYjU2NWI2MTEzYmM1NjViNjA0MDUxNjEwMWZmOTE5MDYxNGJmYzU2NWI2MDYwNjEwNjE1NjAwNDYxMTZkYjU2NWI5MDUwOTA1NjViNjAwMDYxMDYyODYwMDQ4NDg0NjExYThlNTY1YjkwNTA1YjkyOTE1MDUwNTY1YjYxMDYzOTYxM2ZiNDU2NWI2MTA2NDQ2MDA5ODM2MTFhYWI1NjViNjA0MDgwNTE2MGUwODEwMTkwOTE1MjgxNTQ2MDAxNjAwMTYwYTAxYjAzMTY4MTUyNjAwMTgyMDE4MDU0OTE5MjkxNjAyMDg0MDE5MTkwNjEwNjc0OTA2MTRjMGY1NjViODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTgyODA1NDYxMDZhMDkwNjE0YzBmNTY1YjgwMTU2MTA2ZWQ1NzgwNjAxZjEwNjEwNmMyNTc2MTAxMDA4MDgzNTQwNDAyODM1MjkxNjAyMDAxOTE2MTA2ZWQ1NjViODIwMTkxOTA2MDAwNTI2MDIwNjAwMDIwOTA1YjgxNTQ4MTUyOTA2MDAxMDE5MDYwMjAwMTgwODMxMTYxMDZkMDU3ODI5MDAzNjAxZjE2ODIwMTkxNWI1MDUwNTA1MDUwODE1MjYwMjAwMTYwMDI4MjAxNjA0MDUxODA2MGEwMDE2MDQwNTI5MDgxNjAwMDgyMDE1NDgxNTI2MDIwMDE2MDAxODIwMTU0ODE1MjYwMjAwMTYwMDI4MjAxNTQ4MTUyNjAyMDAxNjAwMzgyMDE1NDgxNTI2MDIwMDE2MDA0ODIwMTgwNTQ2MTA3M2U5MDYxNGMwZjU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjEwNzZhOTA2MTRjMGY1NjViODAxNTYxMDdiNzU3ODA2MDFmMTA2MTA3OGM1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMDdiNzU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjEwNzlhNTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDkxOTA5MjUyNTA1MDUwODE1MjYwMDc4MjAxNTQ2MDIwODA4MzAxOTE5MDkxNTI2MDA4ODMwMTU0NjAwMTYwMDE2MGEwMWIwMzgxMTY2MDQwODA4NTAxOTE5MDkxNTI2MDAxNjBhMDFiOTA5MTA0NjBmZjE2MTUxNTYwNjA4NDAxNTI2MDA5ODQwMTgwNTQ4MjUxODE4NTAyODEwMTg1MDE5MDkzNTI4MDgzNTI2MDgwOTA5NDAxOTM5MTkyOTA5MTkwNjAwMDkwODQwMTViODI4MjEwMTU2MTA4Y2Q1NzgzODI5MDYwMDA1MjYwMjA2MDAwMjAwMTgwNTQ2MTA4NDA5MDYxNGMwZjU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjEwODZjOTA2MTRjMGY1NjViODAxNTYxMDhiOTU3ODA2MDFmMTA2MTA4OGU1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMDhiOTU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjEwODljNTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDUwNTA4MTUyNjAyMDAxOTA2MDAxMDE5MDYxMDgyMTU2NWI1MDUwNTA5MTUyNTA5MDkzOTI1MDUwNTA1NjViNjA2MDYwMDA4MjE1ODA2MTA4ZWQ1NzUwNjAzMjgzMTExNTViNjEwOTMwNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwMGY2MDI0ODIwMTUyNmU0YzY5NmQ2OTc0MjA3NDZmNmYyMDZjNjE3MjY3NjU2MDg4MWI2MDQ0ODIwMTUyNjA2NDAxNWI2MDQwNTE4MDkxMDM5MGZkNWI2MTA5M2Q2MDA0ODY4Njg2NjExYWI3NTY1YjkxNTA5MTUwOTM1MDkzOTE1MDUwNTY1YjYwNjA2MTA2MTU2MDA5NjExZjFhNTY1YjYwMDA2MTA2Mjg2MDA0ODQ4NDYxMjI1MTU2NWI2MDQwODA1MTYwNjA4MDgyMDE4MzUyODA4MjUyNjAyMDgyMDE1MjYwMDA5MTgxMDE5MTkwOTE1MjYxMDk4YjYwMDQ4NTg1NjEyMjZjNTY1YjYwMDgwMTgyODE1NDgxMTA2MTA5OWY1NzYxMDk5ZjYxNGM0OTU2NWI5MDYwMDA1MjYwMjA2MDAwMjA5MDYwMDMwMjAxNjA0MDUxODA2MDYwMDE2MDQwNTI5MDgxNjAwMDgyMDE4MDU0NjEwOWM4OTA2MTRjMGY1NjViODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTgyODA1NDYxMDlmNDkwNjE0YzBmNTY1YjgwMTU2MTBhNDE1NzgwNjAxZjEwNjEwYTE2NTc2MTAxMDA4MDgzNTQwNDAyODM1MjkxNjAyMDAxOTE2MTBhNDE1NjViODIwMTkxOTA2MDAwNTI2MDIwNjAwMDIwOTA1YjgxNTQ4MTUyOTA2MDAxMDE5MDYwMjAwMTgwODMxMTYxMGEyNDU3ODI5MDAzNjAxZjE2ODIwMTkxNWI1MDUwNTA1MDUwODE1MjYwMjAwMTYwMDE4MjAxODA1NDYxMGE1YTkwNjE0YzBmNTY1YjgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ2MTBhODY5MDYxNGMwZjU2NWI4MDE1NjEwYWQzNTc4MDYwMWYxMDYxMGFhODU3NjEwMTAwODA4MzU0MDQwMjgzNTI5MTYwMjAwMTkxNjEwYWQzNTY1YjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0ODE1MjkwNjAwMTAxOTA2MDIwMDE4MDgzMTE2MTBhYjY1NzgyOTAwMzYwMWYxNjgyMDE5MTViNTA1MDUwOTE4MzUyNTA1MDYwMDI5MTkwOTEwMTU0NjBmZjE2MTUxNTYwMjA5MDkxMDE1Mjk0OTM1MDUwNTA1MDU2NWI2MTBiNDAzMzg4ODg4MDgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MzkyOTE5MDgxODE1MjYwMjAwMTgzODM4MDgyODQzNzYwMDA5MjAxOTE5MDkxNTI1MDYwMDk5NDkzOTI1MDhhOTE1MDg5OTA1MDg4ODg4ODYxMjI3OTU2NWIzMzYwMDE2MDAxNjBhMDFiMDMxNjdmOTY1NzUxOGYwMmQyM2VmYzhhMTVjMDQyYzAwNmEwNjQ2NGRkNzkxZjY1Mzk0ZmY4NzMxMGEyODdjNjk0OTQ2Mjg4ODg4ODg4ODg4ODYwNDA1MTYxMGI4Mzk2OTU5NDkzOTI5MTkwNjE0YzVmNTY1YjYwNDA1MTgwOTEwMzkwYTI1MDUwNTA1MDUwNTA1MDU2NWI2MDAyNTQ2MDAwOTA4MTkwODE5MDYwMDE2MDAxNjBhMDFiMDMxNjMzMTQ2MTBiYzU1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMDQwMTYxMDkyNzkwNjE0Y2M3NTY1YjYwMDE1NDYxMGJkODkwNjAwNDkwODc5MDg3OTA2MTIzOWU1NjViOTE5NDUwOTI1MDkwNTA2MDAwODM5MDAzNjEwYmYxNTc2MDAwOTI1MDYxMGM3NjU2NWI2MDQwNTEzMzkwODQxNTYxMDhmYzAyOTA4NTkwNjAwMDgxODE4MTg1ODg4OGYxOTM1MDUwNTA1MDE1ODAxNTYxMGMxZTU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDgzNjAwMTYwMDE2MGEwMWIwMzE2ODU2MDAxNjAwMTYwYTAxYjAzMTY3ZjUyNjgyNDk0NDA0N2RhNWI4MTA3MWZiNjM0OTQxMjAwNWM1ZGE4MTM4MGIzMzYxMDNmYmU1ZGQzNDU1NmM3NzY4NDg0NjA0MDUxNjEwYzZkOTI5MTkwOTE4MjUyNjAyMDgyMDE1MjYwNDAwMTkwNTY1YjYwNDA1MTgwOTEwMzkwYTM1YjkyNTA5MjUwOTI1NjViNjA2MDYwMDA4MjE1ODA2MTBjOGY1NzUwNjAzMjgzMTExNTViNjEwY2NkNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwMGY2MDI0ODIwMTUyNmU0YzY5NmQ2OTc0MjA3NDZmNmYyMDZjNjE3MjY3NjU2MDg4MWI2MDQ0ODIwMTUyNjA2NDAxNjEwOTI3NTY1YjYxMDkzZDYwMDQ4Njg2ODY2MTI1OGQ1NjViNjEwY2U3NjAwNDMzODQ4NDYxMjlkYTU2NWI1MDUwNTY1YjYwMDI1NDYwMDE2MDAxNjBhMDFiMDMxNjMzMTQ2MTBkMTU1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMDQwMTYxMDkyNzkwNjE0Y2M3NTY1YjYxMGNlNzYwMDQ4MzgzNjEyYWU5NTY1YjYxMGQyOTYxMmJhYTU2NWI2MTBkMzM2MDAwNjEyYzA0NTY1YjU2NWI2MDAyNTQ2MDAxNjAwMTYwYTAxYjAzMTYzMzE0NjEwZDVmNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDA0MDE2MTA5Mjc5MDYxNGNjNzU2NWI2MDAwODA2MTBkNzA2MDA0ODY4Njg2MzQ2MTJjNTQ1NjViOTE1MDkxNTA4MzYwMDE2MDAxNjBhMDFiMDMxNjg1NjAwMTYwMDE2MGEwMWIwMzE2N2Y1MjY4MjQ5NDQwNDdkYTViODEwNzFmYjYzNDk0MTIwMDVjNWRhODEzODBiMzM2MTAzZmJlNWRkMzQ1NTZjNzc2ODQ4NDYwNDA1MTYxMGRjMjkyOTE5MDkxODI1MjYwMjA4MjAxNTI2MDQwMDE5MDU2NWI2MDQwNTE4MDkxMDM5MGEzNTA1MDUwNTA1MDU2NWI2MDAyNTQ2MDAxNjAwMTYwYTAxYjAzMTYzMzE0NjEwZGZiNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDA0MDE2MTA5Mjc5MDYxNGNjNzU2NWI2MTBjZTc2MDA0ODM4MzYxMmViZjU2NWI2MDAwNjEwZTI2NjEwZTFkNjEwMTAwODQwMTYwZTA4NTAxNjE0NGRlNTY1YjYwMDQ5MDMzNjEyMjZjNTY1YjkwNTA2MTBlMzg2MGEwODMwMTYwODA4NDAxNjE0NGRlNTY1YjYwMDc4MjAxNTQ2MDAxNjAwMTYwYTAxYjAzOTA4MTE2OTExNjE0NjEwZWFkNTc2MDQwNTE2M2RlODNjNTQzNjBlMDFiODE1MjYwMjA2MDA0ODIwMTUyNjAyYzYwMjQ4MjAxNTI3ZjcwNzI2Zjc2Njk2NDY1NzIyMDczNjk2NzZlNjk2ZTY3MjA2MTY0NjQ3MjY1NzM3MzIwNjk3MzIwNmU2Zjc0MjA2MDQ0ODIwMTUyNmIxODU4ZGFkYjliZGRkYjE5NTkxOWQ5NTk2MGEyMWI2MDY0ODIwMTUyNjA4NDAxNjEwOTI3NTY1YjgxNjA2MDAxMzU4MTYwMDIwMTU0MTA2MTBmMTg1NzYwNDA1MTYzZGU4M2M1NDM2MGUwMWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDJhNjAyNDgyMDE1MjdmNmU2ZjZlNjM2NTIwNzM2ODZmNzU2YzY0MjA2YzYxNzI2NzY1NzIyMDc0Njg2MTZlMjA3NDY4NjUyMDYzNzU3MjYwNDQ4MjAxNTI2OTcyNjU2ZTc0MjA2ZTZmNmU2MzY1NjBiMDFiNjA2NDgyMDE1MjYwODQwMTYxMDkyNzU2NWI4MTYwYzAwMTM1ODE2MDAzMDE1NDEwMTU2MTBmNjg1NzYwNDA1MTYzZGU4M2M1NDM2MGUwMWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDE0NjAyNDgyMDE1MjczNjk2ZTczNzU2NjY2Njk2MzY5NjU2ZTc0MjA2MjYxNmM2MTZlNjM2NTYwNjAxYjYwNDQ4MjAxNTI2MDY0MDE2MTA5Mjc1NjViNjAwMDgxNjAwODAxODM2MDAwMDEzNTgxNTQ4MTEwNjEwZjgzNTc2MTBmODM2MTRjNDk1NjViOTA2MDAwNTI2MDIwNjAwMDIwOTA2MDAzMDIwMTkwNTA4MjgwNjA0MDAxOTA2MTBmYTM5MTkwNjE0ZDA4NTY1YjYwNDA1MTYxMGZiMTkyOTE5MDYxNGQ1NTU2NWI2MDQwNTE5MDgxOTAwMzgxMjA5MDYxMGZjNjkwODM5MDYxNGQ2NTU2NWI2MDQwNTE4MDkxMDM5MDIwMTQ2MTEwMWM1NzYwNDA1MTYzZGU4M2M1NDM2MGUwMWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDE4NjAyNDgyMDE1MjdmNmQ2ZjY0NjU2YzIwNzI2ZjZmNzQyMDY4NjE3MzY4MjA2ZDY5NzM2ZDYxNzQ2MzY4MDAwMDAwMDAwMDAwMDAwMDYwNDQ4MjAxNTI2MDY0MDE2MTA5Mjc1NjViNjAwNzgyMDE1NDYwMDA5MDYxMTA0MDkwNjAwMTYwMDE2MGEwMWIwMzE2NjExMDNhODY2MTRkZGI1NjViOTA2MTJmYmE1NjViOTA1MDgwNjExMDkwNTc2MDQwNTE2M2RlODNjNTQzNjBlMDFiODE1MjYwMjA2MDA0ODIwMTgxOTA1MjYwMjQ4MjAxNTI3ZjU0NDU0NTIwNzM2NTc0NzQ2YzY1NmQ2NTZlNzQyMDc2NjE2YzY5NjQ2MTc0Njk2ZjZlMjA2NjYxNjk2YzY1NjQ2MDQ0ODIwMTUyNjA2NDAxNjEwOTI3NTY1YjYwMDI4MjAxNTQ2MGMwODUwMTM1OTA2MGZmMTYxNTYxMTE0OTU3NjExMGIwNjAyMDg2MDE4NjYxNGQwODU2NWI5MDUwNjAwMDAzNjExMTAxNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwMWE2MDI0ODIwMTUyN2Y3MzY1NjM3MjY1NzQyMDczNjg2Zjc1NmM2NDIwNmU2Zjc0MjA2MjY1MjA2NTZkNzA3NDc5MDAwMDAwMDAwMDAwNjA0NDgyMDE1MjYwNjQwMTYxMDkyNzU2NWI2MTExMGU2MDIwODYwMTg2NjE0ZDA4NTY1YjYwMDg4NjAxODA1NDg4MzU5MDgxMTA2MTExMjU1NzYxMTEyNTYxNGM0OTU2NWI5MDYwMDA1MjYwMjA2MDAwMjA5MDYwMDMwMjAxNjAwMTAxOTE4MjYxMTE0MzkyOTE5MDYxNGVmMzU2NWI1MDYxMTFiYjU2NWI2MTExNTY2MDIwODYwMTg2NjE0ZDA4NTY1YjE1OTA1MDYxMTE5ZTU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDE2NjAyNDgyMDE1Mjc1NzM2NTYzNzI2NTc0MjA3MzY4NmY3NTZjNjQyMDYyNjUyMDY1NmQ3MDc0Nzk2MDUwMWI2MDQ0ODIwMTUyNjA2NDAxNjEwOTI3NTY1YjYwNjQ2MDBjNTQ4MjYxMTFhZTkxOTA2MTRmYzg1NjViNjExMWI4OTE5MDYxNGZkZjU2NWI5MDUwNWI2MDYwODUwMTM1NjAwMjg1MDE1NTYxMTFjZjg0ODI2MTMwMDA1NjViNTA1MDUwNTA1MDU2NWI2MTBjZTc2MDA0ODMzMzg0NjEzMjdmNTY1YjYwNjA2MTA2Mjg2MDA0ODQ4NDMzNjEzMzU5NTY1YjYxMTFmZDYwMDkzMzYxMzc5OTU2NWI2MDQwNTEzMzkwN2YyOWQ1NDZhYmI2ZTk0ZjRmMDRkNWJkY2NiNjY4MjMxNmY1OTdkNDM3NzYwNzhmNDdlMjczZjAwMGU3N2IyYTkxOTA2MDAwOTBhMjU2NWI2MDAwNTQ2MDAxNjBhMDFiOTAwNDYwZmYxNjE1NjExMjhmNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwMjI2MDI0ODIwMTUyN2Y0OTZlNjk3NDY5NjE2YzY5N2E2MTYyNmM2NTNhMjA2MTZjNzI2NTYxNjQ3OTIwNjk2ZTY5NzQ2OTYxNmM2OTdhNjA0NDgyMDE1MjYxMTk1OTYwZjIxYjYwNjQ4MjAxNTI2MDg0MDE2MTA5Mjc1NjViNjAwMDgwNTQ2MGZmNjBhMDFiMTkxNjYwMDE2MGEwMWIxNzkwNTU2MTEyYWI4MjYxMmMwNDU2NWI2MDAxOTM5MDkzNTU1MDYwMDI4MDU0NjAwMTYwMDE2MGEwMWIwMzkwOTIxNjYwMDE2MDAxNjBhMDFiMDMxOTkyODMxNjgxMTc5MDkxNTU2MDAzODA1NDkwOTIxNjE3OTA1NTYwMGM1NTU2NWI2MDAyNTQ2MDAxNjAwMTYwYTAxYjAzMTYzMzE0NjExMzBiNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDA0MDE2MTA5Mjc5MDYxNGNjNzU2NWI2MDAwODA2MTBkNzA2MDA0ODY4NjM0ODc2MTM3ZTg1NjViNjExMzI0NjEyYmFhNTY1YjYwMGM1NTU2NWI2MTBjZTc2MDA0MzM4NDg0NjEzODliNTY1YjYxMTMzZTYxMmJhYTU2NWI2MDAxNjAwMTYwYTAxYjAzODExNjYxMTNhMzU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDI2NjAyNDgyMDE1MjdmNGY3NzZlNjE2MjZjNjUzYTIwNmU2NTc3MjA2Zjc3NmU2NTcyMjA2OTczMjA3NDY4NjUyMDdhNjU3MjZmMjA2MTYwNDQ4MjAxNTI2NTY0NjQ3MjY1NzM3MzYwZDAxYjYwNjQ4MjAxNTI2MDg0MDE2MTA5Mjc1NjViNjExM2FjODE2MTJjMDQ1NjViNTA1NjViNjExM2I3NjEyYmFhNTY1YjYwMDE1NTU2NWI2MTEzYzQ2MTQwMzU1NjViNjExM2QwNjAwNDg0ODQ2MTIyNmM1NjViNjA0MDgwNTE2MTAxMjA4MTAxODI1MjgyNTQ2MDAxNjAwMTYwYTAxYjAzOTA4MTE2ODI1MjYwMDE4NDAxNTQxNjYwMjA4MDgzMDE5MTkwOTE1MjYwMDI4NDAxNTQ4Mjg0MDE1MjYwMDM4NDAxNTQ2MDYwODMwMTUyNjAwNDg0MDE1NDYwODA4MzAxNTI2MDA1ODQwMTgwNTQ4NDUxODE4NDAyODEwMTg0MDE5MDk1NTI4MDg1NTI5Mjk0OTM2MGEwODYwMTkzOTA5MjYwMDA5MDg0MDE1YjgyODIxMDE1NjExNDk0NTc2MDAwODQ4MTUyNjAyMDkwODE5MDIwNjA0MDgwNTE2MDgwODEwMTgyNTI2MDA0ODYwMjkwOTIwMTgwNTQ4MzUyNjAwMTgwODIwMTU0ODQ4NjAxNTI2MDAyODIwMTU0OTI4NDAxOTI5MDkyNTI2MDAzMDE1NDYwZmYxNjE1MTU2MDYwODMwMTUyOTA4MzUyOTA5MjAxOTEwMTYxMTQzYjU2NWI1MDUwNTA1MDgxNTI2MDIwMDE2MDA2ODIwMTgwNTQ2MTE0YWM5MDYxNGMwZjU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjExNGQ4OTA2MTRjMGY1NjViODAxNTYxMTUyNTU3ODA2MDFmMTA2MTE0ZmE1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMTUyNTU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjExNTA4NTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDkxODM1MjUwNTA2MDA3ODIwMTU0NjAwMTYwMDE2MGEwMWIwMzE2NjAyMDgwODMwMTkxOTA5MTUyNjAwODgzMDE4MDU0NjA0MDgwNTE4Mjg1MDI4MTAxODUwMTgyNTI4MjgxNTI5NDAxOTM5MjYwMDA5MDg0MDE1YjgyODIxMDE1NjExNmNjNTc4MzgyOTA2MDAwNTI2MDIwNjAwMDIwOTA2MDAzMDIwMTYwNDA1MTgwNjA2MDAxNjA0MDUyOTA4MTYwMDA4MjAxODA1NDYxMTU5NzkwNjE0YzBmNTY1YjgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ2MTE1YzM5MDYxNGMwZjU2NWI4MDE1NjExNjEwNTc4MDYwMWYxMDYxMTVlNTU3NjEwMTAwODA4MzU0MDQwMjgzNTI5MTYwMjAwMTkxNjExNjEwNTY1YjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0ODE1MjkwNjAwMTAxOTA2MDIwMDE4MDgzMTE2MTE1ZjM1NzgyOTAwMzYwMWYxNjgyMDE5MTViNTA1MDUwNTA1MDgxNTI2MDIwMDE2MDAxODIwMTgwNTQ2MTE2Mjk5MDYxNGMwZjU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjExNjU1OTA2MTRjMGY1NjViODAxNTYxMTZhMjU3ODA2MDFmMTA2MTE2Nzc1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMTZhMjU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjExNjg1NTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDkxODM1MjUwNTA2MDAyOTE5MDkxMDE1NDYwZmYxNjE1MTU2MDIwOTE4MjAxNTI5MDgyNTI2MDAxOTI5MDkyMDE5MTAxNjExNTY0NTY1YjUwNTA1MDkxNTI1MDkwOTQ5MzUwNTA1MDUwNTY1YjYwNjA2MDAwNjExNmU4ODM2MTM5MGU1NjViOTA1MDgwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMTcwMjU3NjExNzAyNjE0NzFhNTY1YjYwNDA1MTkwODA4MjUyODA2MDIwMDI2MDIwMDE4MjAxNjA0MDUyODAxNTYxMTczYjU3ODE2MDIwMDE1YjYxMTcyODYxNDAzNTU2NWI4MTUyNjAyMDAxOTA2MDAxOTAwMzkwODE2MTE3MjA1NzkwNTA1YjUwOTE1MDYwMDA1YjgxODExMDE1NjExYTg3NTc2MTE3NTM4NDgyNjEzOTE5NTY1YjYwNDA4MDUxNjEwMTIwODEwMTgyNTI4MjU0NjAwMTYwMDE2MGEwMWIwMzkwODExNjgyNTI2MDAxODQwMTU0MTY2MDIwODA4MzAxOTE5MDkxNTI2MDAyODQwMTU0ODI4NDAxNTI2MDAzODQwMTU0NjA2MDgzMDE1MjYwMDQ4NDAxNTQ2MDgwODMwMTUyNjAwNTg0MDE4MDU0ODQ1MTgxODQwMjgxMDE4NDAxOTA5NTUyODA4NTUyOTI5NDkzNjBhMDg2MDE5MzkwOTI2MDAwOTA4NDAxNWI4MjgyMTAxNTYxMTgxNzU3NjAwMDg0ODE1MjYwMjA5MDgxOTAyMDYwNDA4MDUxNjA4MDgxMDE4MjUyNjAwNDg2MDI5MDkyMDE4MDU0ODM1MjYwMDE4MDgyMDE1NDg0ODYwMTUyNjAwMjgyMDE1NDkyODQwMTkyOTA5MjUyNjAwMzAxNTQ2MGZmMTYxNTE1NjA2MDgzMDE1MjkwODM1MjkwOTIwMTkxMDE2MTE3YmU1NjViNTA1MDUwNTA4MTUyNjAyMDAxNjAwNjgyMDE4MDU0NjExODJmOTA2MTRjMGY1NjViODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTgyODA1NDYxMTg1YjkwNjE0YzBmNTY1YjgwMTU2MTE4YTg1NzgwNjAxZjEwNjExODdkNTc2MTAxMDA4MDgzNTQwNDAyODM1MjkxNjAyMDAxOTE2MTE4YTg1NjViODIwMTkxOTA2MDAwNTI2MDIwNjAwMDIwOTA1YjgxNTQ4MTUyOTA2MDAxMDE5MDYwMjAwMTgwODMxMTYxMTg4YjU3ODI5MDAzNjAxZjE2ODIwMTkxNWI1MDUwNTA5MTgzNTI1MDUwNjAwNzgyMDE1NDYwMDE2MDAxNjBhMDFiMDMxNjYwMjA4MDgzMDE5MTkwOTE1MjYwMDg4MzAxODA1NDYwNDA4MDUxODI4NTAyODEwMTg1MDE4MjUyODI4MTUyOTQwMTkzOTI2MDAwOTA4NDAxNWI4MjgyMTAxNTYxMWE0ZjU3ODM4MjkwNjAwMDUyNjAyMDYwMDAyMDkwNjAwMzAyMDE2MDQwNTE4MDYwNjAwMTYwNDA1MjkwODE2MDAwODIwMTgwNTQ2MTE5MWE5MDYxNGMwZjU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjExOTQ2OTA2MTRjMGY1NjViODAxNTYxMTk5MzU3ODA2MDFmMTA2MTE5Njg1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMTk5MzU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjExOTc2NTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDUwNTA4MTUyNjAyMDAxNjAwMTgyMDE4MDU0NjExOWFjOTA2MTRjMGY1NjViODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkyOTE5MDgxODE1MjYwMjAwMTgyODA1NDYxMTlkODkwNjE0YzBmNTY1YjgwMTU2MTFhMjU1NzgwNjAxZjEwNjExOWZhNTc2MTAxMDA4MDgzNTQwNDAyODM1MjkxNjAyMDAxOTE2MTFhMjU1NjViODIwMTkxOTA2MDAwNTI2MDIwNjAwMDIwOTA1YjgxNTQ4MTUyOTA2MDAxMDE5MDYwMjAwMTgwODMxMTYxMWEwODU3ODI5MDAzNjAxZjE2ODIwMTkxNWI1MDUwNTA5MTgzNTI1MDUwNjAwMjkxOTA5MTAxNTQ2MGZmMTYxNTE1NjAyMDkxODIwMTUyOTA4MjUyNjAwMTkyOTA5MjAxOTEwMTYxMThlNzU2NWI1MDUwNTA1MDgxNTI1MDUwODM4MjgxNTE4MTEwNjExYTY5NTc2MTFhNjk2MTRjNDk1NjViNjAyMDAyNjAyMDAxMDE4MTkwNTI1MDgwODA2MTFhN2Y5MDYxNTAwMTU2NWI5MTUwNTA2MTE3NDE1NjViNTA1MDkxOTA1MDU2NWI2MDAwNjExYWEzODQ2MTFhOWU4NTg1NjEzOTNmNTY1YjYxMzk3NzU2NWI5NDkzNTA1MDUwNTA1NjViNjAwMDYxMDYyODgzODM2MTM5ODM1NjViNjAwMTYwMDE2MGEwMWIwMzgzMTY2MDAwOTA4MTUyNjAwMzg1MDE2MDIwNTI2MDQwODEyMDYwNjA5MTkwNjExYWRlODE2MTM5ZDQ1NjViOTE1MDgxODUxMDYxMWIyMTU3NjA0MDgwNTE2MDAwODA4MjUyNjAyMDgyMDE5MDkyNTI5MDYxMWIxODU2NWI2MTFiMDU2MTQwMzU1NjViODE1MjYwMjAwMTkwNjAwMTkwMDM5MDgxNjExYWZkNTc5MDUwNWI1MDkyNTA1MDYxMWYxMTU2NWI2MDAwODQxNTYxMWIzODU3NjExYjMzODU4NzYxNTAxYTU2NWI2MTFiM2E1NjViODI1YjkwNTA4MjgxMTExNTYxMWI0NzU3NTA4MTViNjAwMDYxMWI1Mzg3ODM2MTUwMmQ1NjViOTA1MDgwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMWI2ZDU3NjExYjZkNjE0NzFhNTY1YjYwNDA1MTkwODA4MjUyODA2MDIwMDI2MDIwMDE4MjAxNjA0MDUyODAxNTYxMWJhNjU3ODE2MDIwMDE1YjYxMWI5MzYxNDAzNTU2NWI4MTUyNjAyMDAxOTA2MDAxOTAwMzkwODE2MTFiOGI1NzkwNTA1YjUwOTQ1MDYwMDA1YjgxODExMDE1NjExZjBjNTc2MDAwNjExYmNhNjExYmMzODM4YjYxNTAxYTU2NWI4NjkwNjEzOWRlNTY1YjYwMDA4MTgxNTI2MDAyODA4ZTAxNjAyMDkwODE1MjYwNDA4MDg0MjA4MTUxNjEwMTIwODEwMTgzNTI4MTU0NjAwMTYwMDE2MGEwMWIwMzkwODExNjgyNTI2MDAxODMwMTU0MTY4MTg1MDE1MjkzODEwMTU0ODQ4MzAxNTI2MDAzODEwMTU0NjA2MDg1MDE1MjYwMDQ4MTAxNTQ2MDgwODUwMTUyNjAwNTgxMDE4MDU0ODM1MTgxODYwMjgxMDE4NjAxOTA5NDUyODA4NDUyOTY5NzUwOTM5NTkwOTQ2MGEwODcwMTk0OTI5Mzg0MDE1YjgyODIxMDE1NjExYzliNTc2MDAwODQ4MTUyNjAyMDkwODE5MDIwNjA0MDgwNTE2MDgwODEwMTgyNTI2MDA0ODYwMjkwOTIwMTgwNTQ4MzUyNjAwMTgwODIwMTU0ODQ4NjAxNTI2MDAyODIwMTU0OTI4NDAxOTI5MDkyNTI2MDAzMDE1NDYwZmYxNjE1MTU2MDYwODMwMTUyOTA4MzUyOTA5MjAxOTEwMTYxMWM0MjU2NWI1MDUwNTA1MDgxNTI2MDIwMDE2MDA2ODIwMTgwNTQ2MTFjYjM5MDYxNGMwZjU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjExY2RmOTA2MTRjMGY1NjViODAxNTYxMWQyYzU3ODA2MDFmMTA2MTFkMDE1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMWQyYzU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjExZDBmNTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDkxODM1MjUwNTA2MDA3ODIwMTU0NjAwMTYwMDE2MGEwMWIwMzE2NjAyMDgwODMwMTkxOTA5MTUyNjAwODgzMDE4MDU0NjA0MDgwNTE4Mjg1MDI4MTAxODUwMTgyNTI4MjgxNTI5NDAxOTM5MjYwMDA5MDg0MDE1YjgyODIxMDE1NjExZWQzNTc4MzgyOTA2MDAwNTI2MDIwNjAwMDIwOTA2MDAzMDIwMTYwNDA1MTgwNjA2MDAxNjA0MDUyOTA4MTYwMDA4MjAxODA1NDYxMWQ5ZTkwNjE0YzBmNTY1YjgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ2MTFkY2E5MDYxNGMwZjU2NWI4MDE1NjExZTE3NTc4MDYwMWYxMDYxMWRlYzU3NjEwMTAwODA4MzU0MDQwMjgzNTI5MTYwMjAwMTkxNjExZTE3NTY1YjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0ODE1MjkwNjAwMTAxOTA2MDIwMDE4MDgzMTE2MTFkZmE1NzgyOTAwMzYwMWYxNjgyMDE5MTViNTA1MDUwNTA1MDgxNTI2MDIwMDE2MDAxODIwMTgwNTQ2MTFlMzA5MDYxNGMwZjU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjExZTVjOTA2MTRjMGY1NjViODAxNTYxMWVhOTU3ODA2MDFmMTA2MTFlN2U1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMWVhOTU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjExZThjNTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDkxODM1MjUwNTA2MDAyOTE5MDkxMDE1NDYwZmYxNjE1MTU2MDIwOTE4MjAxNTI5MDgyNTI2MDAxOTI5MDkyMDE5MTAxNjExZDZiNTY1YjUwNTA1MDUwODE1MjUwNTA4NzgzODE1MTgxMTA2MTFlZWQ1NzYxMWVlZDYxNGM0OTU2NWI2MDIwMDI2MDIwMDEwMTgxOTA1MjUwNTA4MDgwNjExZjA0OTA2MTUwMDE1NjViOTE1MDUwNjExYmFjNTY1YjUwNTA1MDUwNWI5NDUwOTQ5MjUwNTA1MDU2NWI2MDYwNjAwMDYxMWYyNzgzNjEzOTBlNTY1YjkwNTA4MDYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTFmNDE1NzYxMWY0MTYxNDcxYTU2NWI2MDQwNTE5MDgwODI1MjgwNjAyMDAyNjAyMDAxODIwMTYwNDA1MjgwMTU2MTFmN2E1NzgxNjAyMDAxNWI2MTFmNjc2MTNmYjQ1NjViODE1MjYwMjAwMTkwNjAwMTkwMDM5MDgxNjExZjVmNTc5MDUwNWI1MDkxNTA2MDAwNWI4MTgxMTAxNTYxMWE4NzU3NjExZjkyODQ4MjYxMzkxOTU2NWI2MDQwODA1MTYwZTA4MTAxOTA5MTUyODE1NDYwMDE2MDAxNjBhMDFiMDMxNjgxNTI2MDAxODIwMTgwNTQ5MTkyOTE2MDIwODQwMTkxOTA2MTFmYzI5MDYxNGMwZjU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjExZmVlOTA2MTRjMGY1NjViODAxNTYxMjAzYjU3ODA2MDFmMTA2MTIwMTA1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMjAzYjU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjEyMDFlNTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDUwNTA4MTUyNjAyMDAxNjAwMjgyMDE2MDQwNTE4MDYwYTAwMTYwNDA1MjkwODE2MDAwODIwMTU0ODE1MjYwMjAwMTYwMDE4MjAxNTQ4MTUyNjAyMDAxNjAwMjgyMDE1NDgxNTI2MDIwMDE2MDAzODIwMTU0ODE1MjYwMjAwMTYwMDQ4MjAxODA1NDYxMjA4YzkwNjE0YzBmNTY1YjgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ2MTIwYjg5MDYxNGMwZjU2NWI4MDE1NjEyMTA1NTc4MDYwMWYxMDYxMjBkYTU3NjEwMTAwODA4MzU0MDQwMjgzNTI5MTYwMjAwMTkxNjEyMTA1NTY1YjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0ODE1MjkwNjAwMTAxOTA2MDIwMDE4MDgzMTE2MTIwZTg1NzgyOTAwMzYwMWYxNjgyMDE5MTViNTA1MDUwOTE5MDkyNTI1MDUwNTA4MTUyNjAwNzgyMDE1NDYwMjA4MDgzMDE5MTkwOTE1MjYwMDg4MzAxNTQ2MDAxNjAwMTYwYTAxYjAzODExNjYwNDA4MDg1MDE5MTkwOTE1MjYwMDE2MGEwMWI5MDkxMDQ2MGZmMTYxNTE1NjA2MDg0MDE1MjYwMDk4NDAxODA1NDgyNTE4MTg1MDI4MTAxODUwMTkwOTM1MjgwODM1MjYwODA5MDk0MDE5MzkxOTI5MDkxOTA2MDAwOTA4NDAxNWI4MjgyMTAxNTYxMjIxYjU3ODM4MjkwNjAwMDUyNjAyMDYwMDAyMDAxODA1NDYxMjE4ZTkwNjE0YzBmNTY1YjgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ2MTIxYmE5MDYxNGMwZjU2NWI4MDE1NjEyMjA3NTc4MDYwMWYxMDYxMjFkYzU3NjEwMTAwODA4MzU0MDQwMjgzNTI5MTYwMjAwMTkxNjEyMjA3NTY1YjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0ODE1MjkwNjAwMTAxOTA2MDIwMDE4MDgzMTE2MTIxZWE1NzgyOTAwMzYwMWYxNjgyMDE5MTViNTA1MDUwNTA1MDgxNTI2MDIwMDE5MDYwMDEwMTkwNjEyMTZmNTY1YjUwNTA1MDUwODE1MjUwNTA4MzgyODE1MTgxMTA2MTIyMzU1NzYxMjIzNTYxNGM0OTU2NWI2MDIwMDI2MDIwMDEwMTgxOTA1MjUwODA2MTIyNGE5MDYxNTAwMTU2NWI5MDUwNjExZjgwNTY1YjYwMDA4MDYxMjI1Zjg1ODU4NTYxMzllYTU2NWI2MDA0MDE1NDk1OTQ1MDUwNTA1MDUwNTY1YjYwMDA2MTFhYTM4NDg0ODQ2MTM5ZWE1NjViNjAwMDYxMjI4NDg4NjEzYTRkNTY1YjkwNTA2MTIyOTA4OTgyNjEzOTc3NTY1YjYxMjJlZDU3NjEyMmU2ODk4MjYwNDA1MTgwNjBlMDAxNjA0MDUyODA4YzYwMDE2MDAxNjBhMDFiMDMxNjgxNTI2MDIwMDE4YjgxNTI2MDIwMDE4YTgxNTI2MDIwMDE4OTgxNTI2MDIwMDE4ODYwMDE2MDAxNjBhMDFiMDMxNjgxNTI2MDIwMDE2MDAwMTUxNTgxNTI2MDIwMDE4NjgxNTI1MDYxM2E4MjU2NWI1MDUwNjEyMzk0NTY1YjYwMDA2MTIyZjk4YThhNjEzOTgzNTY1YjkwNTA2MDAxODEwMTYxMjMwOTg5ODI2MTUwNDA1NjViNTA4NjUxNjAwMjgyMDE5MDgxNTU2MDIwODgwMTUxNjAwMzgzMDE1NTYwNDA4ODAxNTE2MDA0ODMwMTU1NjA2MDg4MDE1MTYwMDU4MzAxNTU2MDgwODgwMTUxODg5MTkwNjAwNjg0MDE5MDYxMjM0ODkwODI2MTUwNDA1NjViNTA1MDUwNjAwNzgxMDE4NjkwNTU2MDA4ODEwMTgwNTQ4NTE1MTU2MDAxNjBhMDFiMDI2MDAxNjAwMTYwYTgxYjAzMTk5MDkxMTY2MDAxNjAwMTYwYTAxYjAzODgxNjE3MTc5MDU1ODI1MTYxMjM5MDkwNjAwOTgzMDE5MDYwMjA4NjAxOTA2MTQwOWM1NjViNTA1MDUwNWI1MDUwNTA1MDUwNTA1MDUwNTY1YjYwMDA4MDYwMDA4MDYxMjNhZjg4ODg4ODYxMzllYTU2NWI2MDA1ODEwMTU0OTA5MTUwNjAwMDAzNjEyM2NlNTc2MDAwOTM1MDgwNjAwNDAxNTQ5MTUwNjEyNTViNTY1YjYwMDU4MTAxNTQ2MDAwOTA2MDAxNjAwMTYwNDAxYjAzODExMTE1NjEyM2VkNTc2MTIzZWQ2MTQ3MWE1NjViNjA0MDUxOTA4MDgyNTI4MDYwMjAwMjYwMjAwMTgyMDE2MDQwNTI4MDE1NjEyNDRiNTc4MTYwMjAwMTViNjEyNDM4NjA0MDUxODA2MDgwMDE2MDQwNTI4MDYwMDA4MTUyNjAyMDAxNjAwMDgxNTI2MDIwMDE2MDAwODE1MjYwMjAwMTYwMDAxNTE1ODE1MjUwOTA1NjViODE1MjYwMjAwMTkwNjAwMTkwMDM5MDgxNjEyNDBiNTc5MDUwNWI1MDkwNTA2MDAwODA5NTUwNjAwMDkzNTA2MDAwNWI2MDA1ODQwMTU0ODExMDE1NjEyNTRjNTc2MDAwODQ2MDA1MDE4MjgxNTQ4MTEwNjEyNDdkNTc2MTI0N2Q2MTRjNDk1NjViNjAwMDkxODI1MjYwMjA5MDkxMjA2MDA0OTA5MTAyMDE2MDAzODEwMTU0OTA5MTUwNjBmZjE2MTU2MTI0YTM1NzUwNjEyNTNhNTY1Yjg4ODE2MDAyMDE1NDYxMjRiMzkxOTA2MTUwMWE1NjViNDIxMDYxMjRjZjU3NjAwMTgxMDE1NDYxMjRjODkwODk2MTUwMWE1NjViOTc1MDYxMjUzODU2NWI2MDQwNTE4MDYwODAwMTYwNDA1MjgwODQ4MTUyNjAyMDAxODI2MDAxMDE1NDgxNTI2MDIwMDE4MjYwMDIwMTU0ODE1MjYwMjAwMTYwMDAxNTE1ODE1MjUwODQ4NDgxNTE4MTEwNjEyNTBkNTc2MTI1MGQ2MTRjNDk1NjViNjAyMDAyNjAyMDAxMDE4MTkwNTI1MDgwNjAwMTAxNTQ4NjYxMjUyODkxOTA2MTUwMWE1NjViOTU1MDgyNjEyNTM0ODE2MTUwMDE1NjViOTM1MDUwNWI1MDViODA2MTI1NDQ4MTYxNTAwMTU2NWI5MTUwNTA2MTI0NWE1NjViNTA2MTI1NTg4MzgzODM2MTNiN2Q1NjViNTA1MDViODM4MTYwMDMwMTYwMDA4MjgyNTQ2MTI1NmY5MTkwNjE1MDJkNTY1YjkwOTE1NTUwNTA2MDA0ODEwMTgyOTA1NTYwMDMwMTU0OTI5NzkyOTY1MDk0NTA5MDkyNTA1MDUwNTY1YjYwMDE2MDAxNjBhMDFiMDM4MzE2NjAwMDkwODE1MjYwMDQ4NTAxNjAyMDUyNjA0MDgxMjA2MDYwOTE5MDYxMjViNDgxNjEzOWQ0NTY1YjkxNTA4MTg1MTA2MTI1ZjY1NzYwNDA4MDUxNjAwMDgwODI1MjYwMjA4MjAxOTA5MjUyOTA2MTFiMTg1NjViNjEyNWRiNjE0MDM1NTY1YjgxNTI2MDIwMDE5MDYwMDE5MDAzOTA4MTYxMjVkMzU3OTA1MDUwOTI1MDUwNjExZjExNTY1YjYwMDA4NDE1NjEyNjBkNTc2MTI2MDg4NTg3NjE1MDFhNTY1YjYxMjYwZjU2NWI4MjViOTA1MDgyODExMTE1NjEyNjFjNTc1MDgxNWI2MDAwNjEyNjI4ODc4MzYxNTAyZDU2NWI5MDUwODA2MDAxNjAwMTYwNDAxYjAzODExMTE1NjEyNjQyNTc2MTI2NDI2MTQ3MWE1NjViNjA0MDUxOTA4MDgyNTI4MDYwMjAwMjYwMjAwMTgyMDE2MDQwNTI4MDE1NjEyNjdiNTc4MTYwMjAwMTViNjEyNjY4NjE0MDM1NTY1YjgxNTI2MDIwMDE5MDYwMDE5MDAzOTA4MTYxMjY2MDU3OTA1MDViNTA5NDUwNjAwMDViODE4MTEwMTU2MTFmMGM1NzYwMDA2MTI2OTg2MTFiYzM4MzhiNjE1MDFhNTY1YjYwMDA4MTgxNTI2MDAyODA4ZTAxNjAyMDkwODE1MjYwNDA4MDg0MjA4MTUxNjEwMTIwODEwMTgzNTI4MTU0NjAwMTYwMDE2MGEwMWIwMzkwODExNjgyNTI2MDAxODMwMTU0MTY4MTg1MDE1MjkzODEwMTU0ODQ4MzAxNTI2MDAzODEwMTU0NjA2MDg1MDE1MjYwMDQ4MTAxNTQ2MDgwODUwMTUyNjAwNTgxMDE4MDU0ODM1MTgxODYwMjgxMDE4NjAxOTA5NDUyODA4NDUyOTY5NzUwOTM5NTkwOTQ2MGEwODcwMTk0OTI5Mzg0MDE1YjgyODIxMDE1NjEyNzY5NTc2MDAwODQ4MTUyNjAyMDkwODE5MDIwNjA0MDgwNTE2MDgwODEwMTgyNTI2MDA0ODYwMjkwOTIwMTgwNTQ4MzUyNjAwMTgwODIwMTU0ODQ4NjAxNTI2MDAyODIwMTU0OTI4NDAxOTI5MDkyNTI2MDAzMDE1NDYwZmYxNjE1MTU2MDYwODMwMTUyOTA4MzUyOTA5MjAxOTEwMTYxMjcxMDU2NWI1MDUwNTA1MDgxNTI2MDIwMDE2MDA2ODIwMTgwNTQ2MTI3ODE5MDYxNGMwZjU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjEyN2FkOTA2MTRjMGY1NjViODAxNTYxMjdmYTU3ODA2MDFmMTA2MTI3Y2Y1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMjdmYTU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjEyN2RkNTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDkxODM1MjUwNTA2MDA3ODIwMTU0NjAwMTYwMDE2MGEwMWIwMzE2NjAyMDgwODMwMTkxOTA5MTUyNjAwODgzMDE4MDU0NjA0MDgwNTE4Mjg1MDI4MTAxODUwMTgyNTI4MjgxNTI5NDAxOTM5MjYwMDA5MDg0MDE1YjgyODIxMDE1NjEyOWExNTc4MzgyOTA2MDAwNTI2MDIwNjAwMDIwOTA2MDAzMDIwMTYwNDA1MTgwNjA2MDAxNjA0MDUyOTA4MTYwMDA4MjAxODA1NDYxMjg2YzkwNjE0YzBmNTY1YjgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ2MTI4OTg5MDYxNGMwZjU2NWI4MDE1NjEyOGU1NTc4MDYwMWYxMDYxMjhiYTU3NjEwMTAwODA4MzU0MDQwMjgzNTI5MTYwMjAwMTkxNjEyOGU1NTY1YjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0ODE1MjkwNjAwMTAxOTA2MDIwMDE4MDgzMTE2MTI4Yzg1NzgyOTAwMzYwMWYxNjgyMDE5MTViNTA1MDUwNTA1MDgxNTI2MDIwMDE2MDAxODIwMTgwNTQ2MTI4ZmU5MDYxNGMwZjU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjEyOTJhOTA2MTRjMGY1NjViODAxNTYxMjk3NzU3ODA2MDFmMTA2MTI5NGM1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMjk3NzU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjEyOTVhNTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDkxODM1MjUwNTA2MDAyOTE5MDkxMDE1NDYwZmYxNjE1MTU2MDIwOTE4MjAxNTI5MDgyNTI2MDAxOTI5MDkyMDE5MTAxNjEyODM5NTY1YjUwNTA1MDUwODE1MjUwNTA4NzgzODE1MTgxMTA2MTI5YmI1NzYxMjliYjYxNGM0OTU2NWI2MDIwMDI2MDIwMDEwMTgxOTA1MjUwNTA4MDgwNjEyOWQyOTA2MTUwMDE1NjViOTE1MDUwNjEyNjgxNTY1YjYxMjllODg0NjExYTllODU4NTYxMzkzZjU2NWI2MTJhMTg1NzYwNDA1MTYzMDIzMjgwZWI2MGUyMWI4MTUyNjAwMTYwMDE2MGEwMWIwMzgwODUxNjYwMDQ4MzAxNTI4MzE2NjAyNDgyMDE1MjYwNDQwMTYxMDkyNzU2NWI2MDAwNjEyYTI1ODU4NTg1NjEzOWVhNTY1YjkwNTA4MDYwMDgwMTgyODE1NDgxMTA2MTJhM2M1NzYxMmEzYzYxNGM0OTU2NWI5MDYwMDA1MjYwMjA2MDAwMjA5MDYwMDMwMjAxNjAwMDAxODA1NDYxMmE1ODkwNjE0YzBmNTY1YjkwNTA2MDAwMDM2MTJhYTk1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMjA2MDA0ODIwMTUyNjAxYjYwMjQ4MjAxNTI3ZjY0NjU2YzY5NzY2NTcyNjE2MjZjNjUyMDY0NmY2NTczMjA2ZTZmNzQyMDY1Nzg2OTczNzQyZTAwMDAwMDAwMDA2MDQ0ODIwMTUyNjA2NDAxNjEwOTI3NTY1YjYwMDE4MTYwMDgwMTgzODE1NDgxMTA2MTJhYzA1NzYxMmFjMDYxNGM0OTU2NWI2MDAwOTE4MjUyNjAyMDkwOTEyMDYwMDM5MDkxMDIwMTYwMDIwMTgwNTQ2MGZmMTkxNjkxMTUxNTkxOTA5MTE3OTA1NTUwNTA1MDUwNTA1NjViNjAwMDYxMmFmNjg0ODQ4NDYxMzllYTU2NWI5MDUwNjAwMDgxNjAwNDAxNTQ4MjYwMDMwMTU0NjEyYjBlOTE5MDYxNTAyZDU2NWI5MDUwODA2MDAwMDM2MTJiMWY1NzUwNTA1MDUwNTA1NjViNjA0MDgwNTE2MDgwODEwMTgyNTI2MDA1ODQwMTgwNTQ4MDgzNTI2MDIwODA4NDAxODY4MTUyNDI5NTg1MDE5NTg2NTI2MDAwNjA2MDg2MDE4MTgxNTI2MDAxODA4NjAxODc1NTk1ODI1MjkyODEyMDk1NTE2MDA0OTQ4NTAyOTA5NjAxOTU4NjU1OTA1MTkzODUwMTkzOTA5MzU1OTM1MTYwMDI4NDAxNTU5MjUxNjAwMzkwOTIwMTgwNTQ2MGZmMTkxNjkyMTUxNTkyOTA5MjE3OTA5MTU1OTA4MzAxODA1NDgzOTI5MDYxMmI5ZTkwODQ5MDYxNTAxYTU2NWI5MDkxNTU1MDUwNTA1MDUwNTA1MDU2NWI2MDAwNTQ2MDAxNjAwMTYwYTAxYjAzMTYzMzE0NjEwZDMzNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE4MTkwNTI2MDI0ODIwMTUyN2Y0Zjc3NmU2MTYyNmM2NTNhMjA2MzYxNmM2YzY1NzIyMDY5NzMyMDZlNmY3NDIwNzQ2ODY1MjA2Zjc3NmU2NTcyNjA0NDgyMDE1MjYwNjQwMTYxMDkyNzU2NWI2MDAwODA1NDYwMDE2MDAxNjBhMDFiMDM4MzgxMTY2MDAxNjAwMTYwYTAxYjAzMTk4MzE2ODExNzg0NTU2MDQwNTE5MTkwOTIxNjkyODM5MTdmOGJlMDA3OWM1MzE2NTkxNDEzNDRjZDFmZDBhNGYyODQxOTQ5N2Y5NzIyYTNkYWFmZTNiNDE4NmY2YjY0NTdlMDkxOTBhMzUwNTA1NjViNjAwMDgwNjAwMDYxMmM2NDg4ODg4ODYxMzllYTU2NWI5MDUwNjAwMDg1MTE4MDE1NjEyYzc5NTc1MDYwMDU4MTAxNTQxNTE1NWIxNTYxMmU4ZDU3NjAwNTgxMDE1NDYwMDA5MDYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTJjOWQ1NzYxMmM5ZDYxNDcxYTU2NWI2MDQwNTE5MDgwODI1MjgwNjAyMDAyNjAyMDAxODIwMTYwNDA1MjgwMTU2MTJjZmI1NzgxNjAyMDAxNWI2MTJjZTg2MDQwNTE4MDYwODAwMTYwNDA1MjgwNjAwMDgxNTI2MDIwMDE2MDAwODE1MjYwMjAwMTYwMDA4MTUyNjAyMDAxNjAwMDE1MTU4MTUyNTA5MDU2NWI4MTUyNjAyMDAxOTA2MDAxOTAwMzkwODE2MTJjYmI1NzkwNTA1YjUwOTA1MDYwMDA4NjgxODA1YjYwMDU4NjAxNTQ4MTEwMTU2MTJlNzU1NzYwMDA4NjYwMDUwMTgyODE1NDgxMTA2MTJkMjc1NzYxMmQyNzYxNGM0OTU2NWI2MDAwOTE4MjUyNjAyMDkwOTEyMDYwMDQ5MDkxMDIwMTYwMDM4MTAxNTQ5MDkxNTA2MGZmMTYxNTYxMmQ0ZDU3NTA2MTJlNjM1NjViODA2MDAxMDE1NDg0MTA2MTJkNmU1NzYwMDE4MTAxNTQ2MTJkNjc5MDg1NjE1MDJkNTY1YjkzNTA2MTJlNjE1NjViODMxNTYxMmRmMDU3NjAwMDg0ODI2MDAxMDE1NDYxMmQ4NjkxOTA2MTUwMmQ1NjViOTA1MDYwNDA1MTgwNjA4MDAxNjA0MDUyODA4NzgxNTI2MDIwMDE4MjgxNTI2MDIwMDE4MzYwMDIwMTU0ODE1MjYwMjAwMTYwMDAxNTE1ODE1MjUwODc4NzgxNTE4MTEwNjEyZGMyNTc2MTJkYzI2MTRjNDk1NjViNjAyMDkwODEwMjkxOTA5MTAxMDE1MjYxMmRkNzgxODU2MTUwMWE1NjViOTM1MDg1NjEyZGUzODE2MTUwMDE1NjViOTY1MDUwNjAwMDk0NTA1MDYxMmU2MTU2NWI2MDQwODA1MTYwODA4MTAxODI1Mjg2ODE1MjYwMDE4MzAxNTQ2MDIwODIwMTUyNjAwMjgzMDE1NDkxODEwMTkxOTA5MTUyNjAwMzgyMDE1NDYwZmYxNjE1MTU2MDYwODIwMTUyODY1MTg3OTA4NzkwODExMDYxMmUzNjU3NjEyZTM2NjE0YzQ5NTY1YjYwMjAwMjYwMjAwMTAxODE5MDUyNTA4MDYwMDEwMTU0ODM2MTJlNTE5MTkwNjE1MDFhNTY1YjkyNTA4NDYxMmU1ZDgxNjE1MDAxNTY1Yjk1NTA1MDViNTA1YjgwNjEyZTZkODE2MTUwMDE1NjViOTE1MDUwNjEyZDA0NTY1YjUwNjAwNDg1MDE4MTkwNTU2MTJlODg4NTg1ODU2MTNiN2Q1NjViNTA1MDUwNTA1YjgzODE2MDAzMDE2MDAwODI4MjU0NjEyZWExOTE5MDYxNTAxYTU2NWI5MDkxNTU1MDUwNjAwMzgxMDE1NDYwMDQ5MDkxMDE1NDkwOTg5MDk3NTA5NTUwNTA1MDUwNTA1MDU2NWI2MDAwNjEyZWNiODM4MzYxMzkzZjU2NWI5MDUwNjEyZWQ3ODQ4MjYxMzk3NzU2NWI2MTJlZTE1NzUwNTA1MDUwNTY1YjYwMDE2MDAxNjBhMDFiMDM4MjE2NjAwMDkwODE1MjYwMDM4NTAxNjAyMDUyNjA0MDkwMjA2MTJmMDU5MDgyNjEzYzE2NTY1YjUwNjAwMTYwMDE2MGEwMWIwMzgzMTY2MDAwOTA4MTUyNjAwNDg1MDE2MDIwNTI2MDQwOTAyMDYxMmYyYTkwODI2MTNjMTY1NjViNTA2MTJmMzU4NDgyNjEzYzE2NTY1YjUwNjAwMDgxODE1MjYwMDI4MDg2MDE2MDIwNTI2MDQwODIyMDgwNTQ2MDAxNjAwMTYwYTAxYjAzMTk5MDgxMTY4MjU1NjAwMTgyMDE4MDU0OTA5MTE2OTA1NTkwODEwMTgyOTA1NTYwMDM4MTAxODI5MDU1NjAwNDgxMDE4MjkwNTU5MDYxMmY4NDYwMDU4MzAxODI2MTQwZjI1NjViNjEyZjkyNjAwNjgzMDE2MDAwNjE0MTEzNTY1YjYwMDc4MjAxODA1NDYwMDE2MDAxNjBhMDFiMDMxOTE2OTA1NTYxMmZiMjYwMDg4MzAxNjAwMDYxNDE0ZDU2NWI1MDUwNTA1MDUwNTA1NjViNjAwMDgwNjEyZmM2ODQ2MTNjMjI1NjViOTA1MDYwMDA2MTJmZDM4MjYxM2M1MzU2NWI5MDUwODM2MDAxNjAwMTYwYTAxYjAzMTY2MTJmZWQ4Mjg3NjBhMDAxNTE2MTNjOGU1NjViNjAwMTYwMDE2MGEwMWIwMzE2MTQ5NTk0NTA1MDUwNTA1MDU2NWI4MTYwMDQwMTU0ODI2MDAzMDE1NDYxMzAxNDkxOTA2MTUwMmQ1NjViODExMTE1NjEzMTc5NTc2MDAwODI2MDA0MDE1NDgzNjAwMzAxNTQ2MTMwMzE5MTkwNjE1MDJkNTY1YjYxMzAzYjkwODM2MTUwMmQ1NjViOTA1MDgwODM2MDA0MDE1NDEwMTU2MTMwYTA1NzYwNDA1MTYzZGU4M2M1NDM2MGUwMWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDI1NjAyNDgyMDE1MjdmNjk2ZTczNzU2NjY2Njk2MzY5NjU2ZTc0MjA2MjYxNmM2MTZlNjM2NTIwNjk2ZTIwNzA2NTZlNjQ2OTZlNjc1MjYwNDQ4MjAxNTI2NDE5NTk5ZDViOTk2MGRhMWI2MDY0ODIwMTUyNjA4NDAxNjEwOTI3NTY1YjgwODM2MDA0MDE2MDAwODI4MjU0NjEzMGI0OTE5MDYxNTAyZDU2NWI5MDkxNTU1MDUwNjAwNTgzMDE1NDYwMDA5MDYxMzBjZDkwNjAwMTkwNjE1MDJkNTY1YjkwNTA1YjYwMDA4MTEyNjEzMTc2NTc2MDAwODQ2MDA1MDE4MjgxNTQ4MTEwNjEzMGVmNTc2MTMwZWY2MTRjNDk1NjViNjAwMDkxODI1MjYwMjA5MDkxMjA2MDA0OTA5MTAyMDE2MDAzODEwMTU0OTA5MTUwNjBmZjE2MTU2MTMxMTU1NzUwNjEzMTY0NTY1YjgyODE2MDAxMDE1NDExNjEzMTM2NTc2MDAxODEwMTU0NjEzMTJmOTA4NDYxNTAyZDU2NWI5MjUwNjEzMTU0NTY1YjgyODE2MDAxMDE2MDAwODI4MjU0NjEzMTRhOTE5MDYxNTAyZDU2NWI5MDkxNTU1MDYwMDA5MzUwNTA1YjgyNjAwMDAzNjEzMTYyNTc1MDYxMzE3NjU2NWI1MDViODA2MTMxNmU4MTYxNTBmZjU2NWI5MTUwNTA2MTMwZDA1NjViNTA1MDViODA4MjYwMDMwMTYwMDA4MjgyNTQ2MTMxOGQ5MTkwNjE1MDJkNTY1YjkwOTE1NTUwNTA2MDAzNTQ4MjU0NjA0MDUxNjMxYmIxNDgyMzYwZTMxYjgxNTI2MDAxNjAwMTYwYTAxYjAzOTE4MjE2NjAwNDgyMDE1MjYwMjQ4MTAxODQ5MDUyOTExNjkwNjNkZDhhNDExODkwNjA0NDAxNjAwMDYwNDA1MTgwODMwMzgxNjAwMDg3ODAzYjE1ODAxNTYxMzFlMTU3NjAwMDgwZmQ1YjUwNWFmMTE1ODAxNTYxMzFmNTU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwODM1NDYwMDM4NTAxNTQ2MDA0ODYwMTU0NjA0MDgwNTE5MjgzNTI2MDIwODMwMTkxOTA5MTUyMzM5NDUwNjAwMTYwMDE2MGEwMWIwMzkwOTIxNjkyNTA3ZjUyNjgyNDk0NDA0N2RhNWI4MTA3MWZiNjM0OTQxMjAwNWM1ZGE4MTM4MGIzMzYxMDNmYmU1ZGQzNDU1NmM3NzY5MTAxNjA0MDUxODA5MTAzOTBhMzYwNDA1MTMzOTA4MjE1NjEwOGZjMDI5MDgzOTA2MDAwODE4MTgxODU4ODg4ZjE5MzUwNTA1MDUwMTU4MDE1NjEzMjdhNTczZDYwMDA4MDNlM2Q2MDAwZmQ1YjUwNTA1MDU2NWI2MTMyOGQ4NDYxMWE5ZTg1ODU2MTM5M2Y1NjViNjEzMmJkNTc2MDQwNTE2MzAyMzI4MGViNjBlMjFiODE1MjYwMDE2MDAxNjBhMDFiMDM4MDg1MTY2MDA0ODMwMTUyODMxNjYwMjQ4MjAxNTI2MDQ0MDE2MTA5Mjc1NjViNjAwMDYxMzJjYTg1ODU4NTYxMzllYTU2NWI2MDQwODA1MTYwNjA4MTAxODI1Mjg0ODE1MjgxNTE2MDIwODE4MTAxODQ1MjYwMDA4MDgzNTI4MTg0MDE5MjkwOTI1MjkyODIwMTgxOTA1MjYwMDg4NDAxODA1NDYwMDE4MTAxODI1NTkwODI1MjkyOTAyMDgxNTE5Mzk0NTA5MDkyODM5MjYwMDMwMjkwOTEwMTkwODE5MDYxMzMyMDkwODI2MTUwNDA1NjViNTA2MDIwODIwMTUxNjAwMTgyMDE5MDYxMzMzNTkwODI2MTUwNDA1NjViNTA2MDQwOTE5MDkxMDE1MTYwMDI5MDkxMDE4MDU0NjBmZjE5MTY5MTE1MTU5MTkwOTExNzkwNTU1MDUwNTA1MDUwNTA1NjViNjA2MDYxMDFmNDgzMTExNTYxMzNhZDU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDFlNjAyNDgyMDE1MjdmNDI2MTc0NjM2ODIwNzM2OTdhNjUyMDc0NmY2ZjIwNmM2MTcyNjc2NTIwMjg2ZDYxNzgyMDM1MzAzMDI5MDAwMDYwNDQ4MjAxNTI2MDY0MDE2MTA5Mjc1NjViODI2MDAxNjAwMTYwNDAxYjAzODExMTE1NjEzM2M1NTc2MTMzYzU2MTQ3MWE1NjViNjA0MDUxOTA4MDgyNTI4MDYwMjAwMjYwMjAwMTgyMDE2MDQwNTI4MDE1NjEzM2ZlNTc4MTYwMjAwMTViNjEzM2ViNjE0MDM1NTY1YjgxNTI2MDIwMDE5MDYwMDE5MDAzOTA4MTYxMzNlMzU3OTA1MDViNTA5MDUwNjAwMDViODM4MTEwMTU2MTM3OTA1NzYwMDA2MTM0M2U4Njg2ODQ4MTgxMTA2MTM0MjM1NzYxMzQyMzYxNGM0OTU2NWI5MDUwNjAyMDAyMDE2MDIwODEwMTkwNjEzNDM4OTE5MDYxNDRkZTU2NWI4NTYxMzkzZjU2NWI5MDUwNjEzNDRhODc4MjYxMzk3NzU2NWIxNTYxMzc3ZDU3NjAwMDgxODE1MjYwMDI4MDg5MDE2MDIwOTA4MTUyNjA0MDgwODQyMDgxNTE2MTAxMjA4MTAxODM1MjgxNTQ2MDAxNjAwMTYwYTAxYjAzOTA4MTE2ODI1MjYwMDE4MzAxNTQxNjgxODUwMTUyOTM4MTAxNTQ4NDgzMDE1MjYwMDM4MTAxNTQ2MDYwODUwMTUyNjAwNDgxMDE1NDYwODA4NTAxNTI2MDA1ODEwMTgwNTQ4MzUxODE4NjAyODEwMTg2MDE5MDk0NTI4MDg0NTI5NDk1OTE5NDYwYTA4NzAxOTQ5MTkyOTA5MTg0MDE1YjgyODIxMDE1NjEzNTFmNTc2MDAwODQ4MTUyNjAyMDkwODE5MDIwNjA0MDgwNTE2MDgwODEwMTgyNTI2MDA0ODYwMjkwOTIwMTgwNTQ4MzUyNjAwMTgwODIwMTU0ODQ4NjAxNTI2MDAyODIwMTU0OTI4NDAxOTI5MDkyNTI2MDAzMDE1NDYwZmYxNjE1MTU2MDYwODMwMTUyOTA4MzUyOTA5MjAxOTEwMTYxMzRjNjU2NWI1MDUwNTA1MDgxNTI2MDIwMDE2MDA2ODIwMTgwNTQ2MTM1Mzc5MDYxNGMwZjU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjEzNTYzOTA2MTRjMGY1NjViODAxNTYxMzViMDU3ODA2MDFmMTA2MTM1ODU1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMzViMDU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjEzNTkzNTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDkxODM1MjUwNTA2MDA3ODIwMTU0NjAwMTYwMDE2MGEwMWIwMzE2NjAyMDgwODMwMTkxOTA5MTUyNjAwODgzMDE4MDU0NjA0MDgwNTE4Mjg1MDI4MTAxODUwMTgyNTI4MjgxNTI5NDAxOTM5MjYwMDA5MDg0MDE1YjgyODIxMDE1NjEzNzU3NTc4MzgyOTA2MDAwNTI2MDIwNjAwMDIwOTA2MDAzMDIwMTYwNDA1MTgwNjA2MDAxNjA0MDUyOTA4MTYwMDA4MjAxODA1NDYxMzYyMjkwNjE0YzBmNTY1YjgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MjkxOTA4MTgxNTI2MDIwMDE4MjgwNTQ2MTM2NGU5MDYxNGMwZjU2NWI4MDE1NjEzNjliNTc4MDYwMWYxMDYxMzY3MDU3NjEwMTAwODA4MzU0MDQwMjgzNTI5MTYwMjAwMTkxNjEzNjliNTY1YjgyMDE5MTkwNjAwMDUyNjAyMDYwMDAyMDkwNWI4MTU0ODE1MjkwNjAwMTAxOTA2MDIwMDE4MDgzMTE2MTM2N2U1NzgyOTAwMzYwMWYxNjgyMDE5MTViNTA1MDUwNTA1MDgxNTI2MDIwMDE2MDAxODIwMTgwNTQ2MTM2YjQ5MDYxNGMwZjU2NWI4MDYwMWYwMTYwMjA4MDkxMDQwMjYwMjAwMTYwNDA1MTkwODEwMTYwNDA1MjgwOTI5MTkwODE4MTUyNjAyMDAxODI4MDU0NjEzNmUwOTA2MTRjMGY1NjViODAxNTYxMzcyZDU3ODA2MDFmMTA2MTM3MDI1NzYxMDEwMDgwODM1NDA0MDI4MzUyOTE2MDIwMDE5MTYxMzcyZDU2NWI4MjAxOTE5MDYwMDA1MjYwMjA2MDAwMjA5MDViODE1NDgxNTI5MDYwMDEwMTkwNjAyMDAxODA4MzExNjEzNzEwNTc4MjkwMDM2MDFmMTY4MjAxOTE1YjUwNTA1MDkxODM1MjUwNTA2MDAyOTE5MDkxMDE1NDYwZmYxNjE1MTU2MDIwOTE4MjAxNTI5MDgyNTI2MDAxOTI5MDkyMDE5MTAxNjEzNWVmNTY1YjUwNTA1MDUwODE1MjUwNTA4MzgzODE1MTgxMTA2MTM3NzE1NzYxMzc3MTYxNGM0OTU2NWI2MDIwMDI2MDIwMDEwMTgxOTA1MjUwNWI1MDgwNjEzNzg4ODE2MTUwMDE1NjViOTE1MDUwNjEzNDA0NTY1YjUwOTQ5MzUwNTA1MDUwNTY1YjYwMDA2MTM3YTQ4MjYxM2E0ZDU2NWI5MDUwNjEzN2IwODM4MjYxMzk3NzU2NWI2MTM3ZDg1NzYwNDA1MTYzMDRjNzZkM2Y2MGUxMWI4MTUyNjAwMTYwMDE2MGEwMWIwMzgzMTY2MDA0ODIwMTUyNjAyNDAxNjEwOTI3NTY1YjYxMzdlMjgzODI2MTNkMGQ1NjViNTA1MDUwNTA1NjViNjAwMDgwNjAwMDYxMzdmNzg3ODc2MTM5M2Y1NjViOTA1MDYxMzgwMzg4ODI2MTM5Nzc1NjViMTU2MTM4MzQ1NzYwNDA1MTYzMmNmMDY3NTk2MGUyMWI4MTUyNjAwMTYwMDE2MGEwMWIwMzgwODkxNjYwMDQ4MzAxNTI4NzE2NjAyNDgyMDE1MjYwNDQwMTYxMDkyNzU2NWI2MTM4NDI4ODgyODk4OTg5ODk2MTNkOWQ1NjViNjAwMTYwMDE2MGEwMWIwMzg2MTY2MDAwOTA4MTUyNjAwMzg5MDE2MDIwNTI2MDQwOTAyMDYxMzg2NjkwODI2MTNkZjU1NjViNTA2MDAxNjAwMTYwYTAxYjAzODcxNjYwMDA5MDgxNTI2MDA0ODkwMTYwMjA1MjYwNDA5MDIwNjEzODhiOTA4MjYxM2RmNTU2NWI1MDkzOTc2MDAwOTc1MDk1NTA1MDUwNTA1MDUwNTY1YjYxMzhhOTg0NjExYTllODU4NTYxMzkzZjU2NWI2MTM4ZDk1NzYwNDA1MTYzMDIzMjgwZWI2MGUyMWI4MTUyNjAwMTYwMDE2MGEwMWIwMzgwODUxNjYwMDQ4MzAxNTI4MzE2NjAyNDgyMDE1MjYwNDQwMTYxMDkyNzU2NWI2MDAwNjEzOGU2ODU4NTg1NjEzOWVhNTY1YjYwMDcwMTgwNTQ2MDAxNjAwMTYwYTAxYjAzMTkxNjYwMDE2MDAxNjBhMDFiMDM5MzkwOTMxNjkyOTA5MjE3OTA5MTU1NTA1MDUwNTA1NjViNjAwMDYxMDYyYjgyNjEzOWQ0NTY1YjYwMDA4MDYxMzkyNjg0ODQ2MTM5ZGU1NjViNjAwMDkwODE1MjYwMDI4NTAxNjAyMDUyNjA0MDkwMjA5MTUwNTA5MjkxNTA1MDU2NWI2MDQwODA1MTYwMDE2MDAxNjBhMDFiMDM5Mzg0MTY2MDIwODA4MzAxOTE5MDkxNTI5MjkwOTMxNjgzODIwMTUyODA1MTgwODQwMzgyMDE4MTUyNjA2MDkwOTMwMTkwNTI4MTUxOTEwMTIwOTA1NjViNjAwMDYxMDYyODgzODM2MTNlMDE1NjViNjAwMDgwNjEzOThmODM2MTNhNGQ1NjViNjAwMDgxODE1MjYwMDI4NjAxNjAyMDUyNjA0MDkwMjA5MDkxNTA2MTM5YWM4NTgzNjEzOTc3NTY1YjYxMWFhMzU3NjA0MDUxNjMwNGM3NmQzZjYwZTExYjgxNTI2MDAxNjAwMTYwYTAxYjAzODUxNjYwMDQ4MjAxNTI2MDI0MDE2MTA5Mjc1NjViNjAwMDYxMDYyYjgyNTQ5MDU2NWI2MDAwNjEwNjI4ODM4MzYxM2UxOTU2NWI2MDAwODA2MTM5Zjc4NDg0NjEzOTNmNTY1YjYwMDA4MTgxNTI2MDAyODcwMTYwMjA1MjYwNDA5MDIwOTA5MTUwNjEzYTE0ODY4MzYxMzk3NzU2NWI2MTNhNDQ1NzYwNDA1MTYzMDIzMjgwZWI2MGUyMWI4MTUyNjAwMTYwMDE2MGEwMWIwMzgwODcxNjYwMDQ4MzAxNTI4NTE2NjAyNDgyMDE1MjYwNDQwMTYxMDkyNzU2NWI5NTk0NTA1MDUwNTA1MDU2NWI2MDQwODA1MTYwMDE2MDAxNjBhMDFiMDM4MzE2NjAyMDgyMDE1MjYwMDA5MTAxNWI2MDQwNTE2MDIwODE4MzAzMDM4MTUyOTA2MDQwNTI4MDUxOTA2MDIwMDEyMDkwNTA5MTkwNTA1NjViNjAwMDgyODE1MjYwMDI4NDAxNjAyMDkwODE1MjYwNDA4MjIwODM1MTgxNTQ2MDAxNjAwMTYwYTAxYjAzMTkxNjYwMDE2MDAxNjBhMDFiMDM5MDkxMTYxNzgxNTU5MDgzMDE1MTgzOTE5MDYwMDE4MjAxOTA2MTNhYzY5MDgyNjE1MDQwNTY1YjUwNjA0MDgyMDE1MTgxNjAwMjAxNjAwMDgyMDE1MTgxNjAwMDAxNTU2MDIwODIwMTUxODE2MDAxMDE1NTYwNDA4MjAxNTE4MTYwMDIwMTU1NjA2MDgyMDE1MTgxNjAwMzAxNTU2MDgwODIwMTUxODE2MDA0MDE5MDgxNjEzYjBkOTE5MDYxNTA0MDU2NWI1MDUwNTA2MDYwODIwMTUxNjAwNzgyMDE1NTYwODA4MjAxNTE2MDA4ODIwMTgwNTQ2MGEwODUwMTUxMTUxNTYwMDE2MGEwMWIwMjYwMDE2MDAxNjBhODFiMDMxOTkwOTExNjYwMDE2MDAxNjBhMDFiMDM5MDkzMTY5MjkwOTIxNzkxOTA5MTE3OTA1NTYwYzA4MjAxNTE4MDUxNjEzYjZlOTE2MDA5ODQwMTkxNjAyMDkwOTEwMTkwNjE0MDljNTY1YjUwNjExYWEzOTE1MDg1OTA1MDg0NjEzZGY1NTY1YjYxM2I4YjYwMDU4NDAxNjAwMDYxNDBmMjU2NWI2MDAwNWI4MTgxMTAxNTYxMzdlMjU3ODM2MDA1MDE4MzgyODE1MTgxMTA2MTNiYWM1NzYxM2JhYzYxNGM0OTU2NWI2MDIwOTA4MTAyOTE5MDkxMDE4MTAxNTE4MjU0NjAwMTgwODIwMTg1NTU2MDAwOTQ4NTUyOTM4MzkwMjA4MjUxNjAwNDkwOTIwMjAxOTA4MTU1OTE4MTAxNTE5MjgyMDE5MjkwOTI1NTYwNDA4MjAxNTE2MDAyODIwMTU1NjA2MDkwOTEwMTUxNjAwMzkwOTEwMTgwNTQ2MGZmMTkxNjkxMTUxNTkxOTA5MTE3OTA1NTgwNjEzYzBlODE2MTUwMDE1NjViOTE1MDUwNjEzYjhlNTY1YjYwMDA2MTA2Mjg4MzgzNjEzZTQzNTY1YjYwMjA4MDgyMDE1MTYwNDA4MDg0MDE1MTYwNjA4NTAxNTE2MDgwODYwMTUxNjBjMDg3MDE1MTYwZTA4ODAxNTE5NDUxNjAwMDk3NjEzYTY1OTc5NjkxMDE2MTUxMWM1NjViNjA0MDUxN2YxOTQ1NzQ2ODY1NzI2NTc1NmQyMDUzNjk2NzZlNjU2NDIwNGQ2NTczNzM2MTY3NjUzYTBhMzMzMjAwMDAwMDAwNjAyMDgyMDE1MjYwM2M4MTAxODI5MDUyNjAwMDkwNjA1YzAxNjEzYTY1NTY1YjYwMDA4MDYwMDA4MDYxM2M5ZDg1NjEzZjM2NTY1YjYwNDA4MDUxNjAwMDgxNTI2MDIwODEwMTgwODM1MjhiOTA1MjYwZmY4NTE2OTE4MTAxOTE5MDkxNTI2MDYwODEwMTgzOTA1MjYwODA4MTAxODI5MDUyOTI5NTUwOTA5MzUwOTE1MDYwMDE5MDYwYTAwMTYwMjA2MDQwNTE2MDIwODEwMzkwODA4NDAzOTA4NTVhZmExNTgwMTU2MTNjZjg1NzNkNjAwMDgwM2UzZDYwMDBmZDViNTA1MDYwNDA1MTYwMWYxOTAxNTE5Nzk2NTA1MDUwNTA1MDUwNTA1NjViNjAwMDgxODE1MjYwMDI4MzAxNjAyMDUyNjA0MDgxMjA4MDU0NjAwMTYwMDE2MGEwMWIwMzE5MTY4MTU1ODE2MTNkMzk2MDAxODMwMTgyNjE0MTEzNTY1YjYwMDA2MDAyODMwMTgxODE1NTYwMDM4NDAxODI5MDU1NjAwNDg0MDE4MjkwNTU2MDA1ODQwMTgyOTA1NTkwNjEzZDY1NjAwNjg1MDE4MjYxNDExMzU2NWI1MDUwNjAwMDYwMDc4MzAxODE5MDU1NjAwODgzMDE4MDU0NjAwMTYwMDE2MGE4MWIwMzE5MTY5MDU1NjEzZDkwOTA2MDA5ODQwMTkwNjE0MTZlNTY1YjUwNjEwNjI4OTA1MDgzODM2MTNjMTY1NjViNjAwMDg1ODE1MjYwMDI4NzAxNjAyMDUyNjA0MDkwMjA2MDAzODEwMTgzOTA1NTgwNTQ2MDAxNjAwMTYwYTAxYjAzODA4NzE2NjAwMTYwMDE2MGEwMWIwMzE5OTI4MzE2MTc4MzU1NjAwMTgzMDE4MDU0OTE4NzE2OTE5MDkyMTYxNzkwNTU2MDA2ODEwMTYxM2RlZTgzODI2MTUwNDA1NjViNTA2MTIzOTQ4Nzg3NWI2MDAwNjEwNjI4ODM4MzYxM2Y2NTU2NWI2MDAwODE4MTUyNjAwMTgzMDE2MDIwNTI2MDQwODEyMDU0MTUxNTYxMDYyODU2NWI2MDAwODI2MDAwMDE4MjgxNTQ4MTEwNjEzZTMwNTc2MTNlMzA2MTRjNDk1NjViOTA2MDAwNTI2MDIwNjAwMDIwMDE1NDkwNTA5MjkxNTA1MDU2NWI2MDAwODE4MTUyNjAwMTgzMDE2MDIwNTI2MDQwODEyMDU0ODAxNTYxM2YyYzU3NjAwMDYxM2U2NzYwMDE4MzYxNTAyZDU2NWI4NTU0OTA5MTUwNjAwMDkwNjEzZTdiOTA2MDAxOTA2MTUwMmQ1NjViOTA1MDgxODExNDYxM2VlMDU3NjAwMDg2NjAwMDAxODI4MTU0ODExMDYxM2U5YjU3NjEzZTliNjE0YzQ5NTY1YjkwNjAwMDUyNjAyMDYwMDAyMDAxNTQ5MDUwODA4NzYwMDAwMTg0ODE1NDgxMTA2MTNlYmU1NzYxM2ViZTYxNGM0OTU2NWI2MDAwOTE4MjUyNjAyMDgwODMyMDkwOTEwMTkyOTA5MjU1OTE4MjUyNjAwMTg4MDE5MDUyNjA0MDkwMjA4MzkwNTU1Yjg1NTQ4NjkwODA2MTNlZjE1NzYxM2VmMTYxNTE3YzU2NWI2MDAxOTAwMzgxODE5MDYwMDA1MjYwMjA2MDAwMjAwMTYwMDA5MDU1OTA1NTg1NjAwMTAxNjAwMDg2ODE1MjYwMjAwMTkwODE1MjYwMjAwMTYwMDAyMDYwMDA5MDU1NjAwMTkzNTA1MDUwNTA2MTA2MmI1NjViNjAwMDkxNTA1MDYxMDYyYjU2NWI2MDAwODA2MDAwODM1MTYwNDExNDYxM2Y0OTU3NjAwMDgwZmQ1YjUwNTA1MDYwMjA4MTAxNTE2MDQwODIwMTUxNjA2MDkwOTIwMTUxNjAwMDFhOTI5MDkxOTA1NjViNjAwMDgxODE1MjYwMDE4MzAxNjAyMDUyNjA0MDgxMjA1NDYxM2ZhYzU3NTA4MTU0NjAwMTgxODEwMTg0NTU2MDAwODQ4MTUyNjAyMDgwODIyMDkwOTMwMTg0OTA1NTg0NTQ4NDgyNTI4Mjg2MDE5MDkzNTI2MDQwOTAyMDkxOTA5MTU1NjEwNjJiNTY1YjUwNjAwMDYxMDYyYjU2NWI2MDQwNTE4MDYwZTAwMTYwNDA1MjgwNjAwMDYwMDE2MDAxNjBhMDFiMDMxNjgxNTI2MDIwMDE2MDYwODE1MjYwMjAwMTYxNDAwODYwNDA1MTgwNjBhMDAxNjA0MDUyODA2MDAwODE1MjYwMjAwMTYwMDA4MTUyNjAyMDAxNjAwMDgxNTI2MDIwMDE2MDAwODE1MjYwMjAwMTYwNjA4MTUyNTA5MDU2NWI4MTUyNjAyMDAxNjAwMDgxNTI2MDIwMDE2MDAwNjAwMTYwMDE2MGEwMWIwMzE2ODE1MjYwMjAwMTYwMDAxNTE1ODE1MjYwMjAwMTYwNjA4MTUyNTA5MDU2NWI2MDQwNTE4MDYxMDEyMDAxNjA0MDUyODA2MDAwNjAwMTYwMDE2MGEwMWIwMzE2ODE1MjYwMjAwMTYwMDA2MDAxNjAwMTYwYTAxYjAzMTY4MTUyNjAyMDAxNjAwMDgxNTI2MDIwMDE2MDAwODE1MjYwMjAwMTYwMDA4MTUyNjAyMDAxNjA2MDgxNTI2MDIwMDE2MDYwODE1MjYwMjAwMTYwMDA2MDAxNjAwMTYwYTAxYjAzMTY4MTUyNjAyMDAxNjA2MDgxNTI1MDkwNTY1YjgyODA1NDgyODI1NTkwNjAwMDUyNjAyMDYwMDAyMDkwODEwMTkyODIxNTYxNDBlMjU3OTE2MDIwMDI4MjAxNWI4MjgxMTExNTYxNDBlMjU3ODI1MTgyOTA2MTQwZDI5MDgyNjE1MDQwNTY1YjUwOTE2MDIwMDE5MTkwNjAwMTAxOTA2MTQwYmM1NjViNTA2MTQwZWU5MjkxNTA2MTQxODg1NjViNTA5MDU2NWI1MDgwNTQ2MDAwODI1NTYwMDQwMjkwNjAwMDUyNjAyMDYwMDAyMDkwODEwMTkwNjExM2FjOTE5MDYxNDFhNTU2NWI1MDgwNTQ2MTQxMWY5MDYxNGMwZjU2NWI2MDAwODI1NTgwNjAxZjEwNjE0MTJmNTc1MDUwNTY1YjYwMWYwMTYwMjA5MDA0OTA2MDAwNTI2MDIwNjAwMDIwOTA4MTAxOTA2MTEzYWM5MTkwNjE0MWQzNTY1YjUwODA1NDYwMDA4MjU1NjAwMzAyOTA2MDAwNTI2MDIwNjAwMDIwOTA4MTAxOTA2MTEzYWM5MTkwNjE0MWU4NTY1YjUwODA1NDYwMDA4MjU1OTA2MDAwNTI2MDIwNjAwMDIwOTA4MTAxOTA2MTEzYWM5MTkwNWI4MDgyMTExNTYxNDBlZTU3NjAwMDYxNDE5YzgyODI2MTQxMTM1NjViNTA2MDAxMDE2MTQxODg1NjViNWI4MDgyMTExNTYxNDBlZTU3NjAwMDgwODI1NTYwMDE4MjAxODE5MDU1NjAwMjgyMDE1NTYwMDM4MTAxODA1NDYwZmYxOTE2OTA1NTYwMDQwMTYxNDFhNjU2NWI1YjgwODIxMTE1NjE0MGVlNTc2MDAwODE1NTYwMDEwMTYxNDFkNDU2NWI4MDgyMTExNTYxNDBlZTU3NjAwMDYxNDFmYzgyODI2MTQxMTM1NjViNjE0MjBhNjAwMTgzMDE2MDAwNjE0MTEzNTY1YjUwNjAwMjgxMDE4MDU0NjBmZjE5MTY5MDU1NjAwMzAxNjE0MWU4NTY1YjYwMDA4MTUxODA4NDUyNjAyMDgwODUwMTk0NTA4MDg0MDE2MDAwNWI4MzgxMTAxNTYxNDI3MTU3ODE1MTgwNTE4ODUyODM4MTAxNTE4NDg5MDE1MjYwNDA4MDgyMDE1MTkwODkwMTUyNjA2MDkwODEwMTUxMTUxNTkwODgwMTUyNjA4MDkwOTYwMTk1OTA4MjAxOTA2MDAxMDE2MTQyMzM1NjViNTA5NDk1OTQ1MDUwNTA1MDUwNTY1YjYwMDA1YjgzODExMDE1NjE0Mjk3NTc4MTgxMDE1MTgzODIwMTUyNjAyMDAxNjE0MjdmNTY1YjUwNTA2MDAwOTEwMTUyNTY1YjYwMDA4MTUxODA4NDUyNjE0MmI4ODE2MDIwODYwMTYwMjA4NjAxNjE0MjdjNTY1YjYwMWYwMTYwMWYxOTE2OTI5MDkyMDE2MDIwMDE5MjkxNTA1MDU2NWI2MDAwODE1MTYwNjA4NDUyNjE0MmUxNjA2MDg1MDE4MjYxNDJhMDU2NWI5MDUwNjAyMDgzMDE1MTg0ODIwMzYwMjA4NjAxNTI2MTQyZmE4MjgyNjE0MmEwNTY1YjkxNTA1MDYwNDA4MzAxNTExNTE1NjA0MDg1MDE1MjgwOTE1MDUwOTI5MTUwNTA1NjViNjAwMDgyODI1MTgwODU1MjYwMjA4MDg2MDE5NTUwODA4MjYwMDUxYjg0MDEwMTgxODYwMTYwMDA1Yjg0ODExMDE1NjE0MzVlNTc2MDFmMTk4Njg0MDMwMTg5NTI2MTQzNGM4MzgzNTE2MTQyY2M1NjViOTg4NDAxOTg5MjUwOTA4MzAxOTA2MDAxMDE2MTQzMzA1NjViNTA5MDk3OTY1MDUwNTA1MDUwNTA1MDU2NWI4MDUxNjAwMTYwMDE2MGEwMWIwMzE2ODI1MjYwMDA2MTAxMjA2MDIwODMwMTUxNjE0Mzk3NjAyMDg2MDE4MjYwMDE2MDAxNjBhMDFiMDMxNjkwNTI1NjViNTA2MDQwODMwMTUxNjA0MDg1MDE1MjYwNjA4MzAxNTE2MDYwODUwMTUyNjA4MDgzMDE1MTYwODA4NTAxNTI2MGEwODMwMTUxODE2MGEwODYwMTUyNjE0M2NkODI4NjAxODI2MTQyMWY1NjViOTE1MDUwNjBjMDgzMDE1MTg0ODIwMzYwYzA4NjAxNTI2MTQzZTc4MjgyNjE0MmEwNTY1YjkxNTA1MDYwZTA4MzAxNTE2MTQ0MDQ2MGUwODYwMTgyNjAwMTYwMDE2MGEwMWIwMzE2OTA1MjU2NWI1MDYxMDEwMDgwODQwMTUxODU4MzAzODI4NzAxNTI2MTQ0MWQ4MzgyNjE0MzEzNTY1Yjk2OTU1MDUwNTA1MDUwNTA1NjViNjAwMDgxNTE4MDg0NTI2MDIwODA4NTAxODA4MTk2NTA4MzYwMDUxYjgxMDE5MTUwODI4NjAxNjAwMDViODU4MTEwMTU2MTQ0NmY1NzgyODQwMzg5NTI2MTQ0NWQ4NDgzNTE2MTQzNmI1NjViOTg4NTAxOTg5MzUwOTA4NDAxOTA2MDAxMDE2MTQ0NDU1NjViNTA5MTk3OTY1MDUwNTA1MDUwNTA1MDU2NWI2MDIwODE1MjYwMDA2MTA2Mjg2MDIwODMwMTg0NjE0NDI3NTY1YjgwMzU2MDAxNjAwMTYwYTAxYjAzODExNjgxMTQ2MTQ0YTY1NzYwMDA4MGZkNWI5MTkwNTA1NjViNjAwMDgwNjA0MDgzODUwMzEyMTU2MTQ0YmU1NzYwMDA4MGZkNWI2MTQ0Yzc4MzYxNDQ4ZjU2NWI5MTUwNjE0NGQ1NjAyMDg0MDE2MTQ0OGY1NjViOTA1MDkyNTA5MjkwNTA1NjViNjAwMDYwMjA4Mjg0MDMxMjE1NjE0NGYwNTc2MDAwODBmZDViNjEwNjI4ODI2MTQ0OGY1NjViODA1MTgyNTI2MDIwODEwMTUxNjAyMDgzMDE1MjYwNDA4MTAxNTE2MDQwODMwMTUyNjA2MDgxMDE1MTYwNjA4MzAxNTI2MDAwNjA4MDgyMDE1MTYwYTA2MDgwODUwMTUyNjExYWEzNjBhMDg1MDE4MjYxNDJhMDU2NWI2MDAwNjAwMTgwNjBhMDFiMDM4MDgzNTExNjg0NTI2MDIwODA4NDAxNTE2MGUwODI4NzAxNTI2MTQ1NWU2MGUwODcwMTgyNjE0MmEwNTY1YjkwNTA2MDQwODUwMTUxODY4MjAzNjA0MDg4MDE1MjYxNDU3NzgyODI2MTQ0Zjk1NjViOTE1MDUwNjA2MDg1MDE1MTYwNjA4NzAxNTI4MjYwODA4NjAxNTExNjYwODA4NzAxNTI2MGEwODUwMTUxMTUxNTYwYTA4NzAxNTI2MGMwODUwMTUxOTI1MDg1ODEwMzYwYzA4NzAxNTI4MDgzNTE4MDgzNTI4MzgzMDE5MTUwODM4MTYwMDUxYjg0MDEwMTg0ODYwMTk1NTA2MDAwNWI4MjgxMTAxNTYxNDVmNDU3NjAxZjE5ODU4MzAzMDE4NDUyNjE0NWUyODI4ODUxNjE0MmEwNTY1Yjk2ODYwMTk2OTM4NjAxOTM5MTUwNjAwMTAxNjE0NWM2NTY1YjUwOTg5NzUwNTA1MDUwNTA1MDUwNTA1NjViNjAyMDgxNTI2MDAwNjEwNjI4NjAyMDgzMDE4NDYxNDUzNjU2NWI2MDAwODA2MDAwNjA2MDg0ODYwMzEyMTU2MTQ2Mjk1NzYwMDA4MGZkNWI2MTQ2MzI4NDYxNDQ4ZjU2NWI5NTYwMjA4NTAxMzU5NTUwNjA0MDkwOTQwMTM1OTM5MjUwNTA1MDU2NWI2MDQwODE1MjYwMDA2MTQ2NWE2MDQwODMwMTg1NjE0NDI3NTY1YjkwNTA4MjYwMjA4MzAxNTI5MzkyNTA1MDUwNTY1YjYwMDA2MDIwODA4MzAxODE4NDUyODA4NTUxODA4MzUyNjA0MDg2MDE5MTUwNjA0MDgxNjAwNTFiODcwMTAxOTI1MDgzODcwMTYwMDA1YjgyODExMDE1NjE0NmJlNTc2MDNmMTk4ODg2MDMwMTg0NTI2MTQ2YWM4NTgzNTE2MTQ1MzY1NjViOTQ1MDkyODUwMTkyOTA4NTAxOTA2MDAxMDE2MTQ2OTA1NjViNTA5Mjk3OTY1MDUwNTA1MDUwNTA1MDU2NWI2MDAwODA2MDAwNjA2MDg0ODYwMzEyMTU2MTQ2ZTA1NzYwMDA4MGZkNWI2MTQ2ZTk4NDYxNDQ4ZjU2NWI5MjUwNjE0NmY3NjAyMDg1MDE2MTQ0OGY1NjViOTE1MDYwNDA4NDAxMzU5MDUwOTI1MDkyNTA5MjU2NWI2MDIwODE1MjYwMDA2MTA2Mjg2MDIwODMwMTg0NjE0MmNjNTY1YjYzNGU0ODdiNzE2MGUwMWI2MDAwNTI2MDQxNjAwNDUyNjAyNDYwMDBmZDViNjA0MDUxNjEwMTAwODEwMTYwMDE2MDAxNjA0MDFiMDM4MTExODI4MjEwMTcxNTYxNDc1MzU3NjE0NzUzNjE0NzFhNTY1YjYwNDA1MjkwNTY1YjYwNDA1MTYwMWY4MjAxNjAxZjE5MTY4MTAxNjAwMTYwMDE2MDQwMWIwMzgxMTE4MjgyMTAxNzE1NjE0NzgxNTc2MTQ3ODE2MTQ3MWE1NjViNjA0MDUyOTE5MDUwNTY1YjYwMDA4MjYwMWY4MzAxMTI2MTQ3OWE1NzYwMDA4MGZkNWI4MTM1NjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxNDdiMzU3NjE0N2IzNjE0NzFhNTY1YjYxNDdjNjYwMWY4MjAxNjAxZjE5MTY2MDIwMDE2MTQ3NTk1NjViODE4MTUyODQ2MDIwODM4NjAxMDExMTE1NjE0N2RiNTc2MDAwODBmZDViODE2MDIwODUwMTYwMjA4MzAxMzc2MDAwOTE4MTAxNjAyMDAxOTE5MDkxNTI5MzkyNTA1MDUwNTY1YjYwMDA2MGEwODI4NDAzMTIxNTYxNDgwYTU3NjAwMDgwZmQ1YjYwNDA1MTYwYTA4MTAxNjAwMTYwMDE2MDQwMWIwMzgyODIxMDgxODMxMTE3MTU2MTQ4MmQ1NzYxNDgyZDYxNDcxYTU2NWI4MTYwNDA1MjgyOTM1MDg0MzU4MzUyNjAyMDg1MDEzNTYwMjA4NDAxNTI2MDQwODUwMTM1NjA0MDg0MDE1MjYwNjA4NTAxMzU2MDYwODQwMTUyNjA4MDg1MDEzNTkxNTA4MDgyMTExNTYxNDg2YTU3NjAwMDgwZmQ1YjUwNjE0ODc3ODU4Mjg2MDE2MTQ3ODk1NjViNjA4MDgzMDE1MjUwNTA5MjkxNTA1MDU2NWI4MDM1ODAxNTE1ODExNDYxNDRhNjU3NjAwMDgwZmQ1YjYwMDA4MjYwMWY4MzAxMTI2MTQ4YTU1NzYwMDA4MGZkNWI4MTM1NjAyMDYwMDE2MDAxNjA0MDFiMDM4MDgzMTExNTYxNDhjMTU3NjE0OGMxNjE0NzFhNTY1YjgyNjAwNTFiNjE0OGQwODM4MjAxNjE0NzU5NTY1YjkzODQ1Mjg1ODEwMTgzMDE5MzgzODEwMTkwODg4NjExMTU2MTQ4ZWE1NzYwMDA4MGZkNWI4NDg4MDE5MjUwNWI4NTgzMTAxNTYxNDkyNjU3ODIzNTg0ODExMTE1NjE0OTA4NTc2MDAwODA4MWZkNWI2MTQ5MTY4YTg3ODM4YzAxMDE2MTQ3ODk1NjViODM1MjUwOTE4NDAxOTE5MDg0MDE5MDYxNDhmMDU2NWI5ODk3NTA1MDUwNTA1MDUwNTA1MDU2NWI2MDAwODA2MDAwODA2MDAwODA2MDAwNjBjMDg4OGEwMzEyMTU2MTQ5NGQ1NzYwMDA4MGZkNWI4NzM1NjAwMTYwMDE2MDQwMWIwMzgwODIxMTE1NjE0OTY0NTc2MDAwODBmZDViODE4YTAxOTE1MDhhNjAxZjgzMDExMjYxNDk3ODU3NjAwMDgwZmQ1YjgxMzU4MTgxMTExNTYxNDk4NzU3NjAwMDgwZmQ1YjhiNjAyMDgyODUwMTAxMTExNTYxNDk5OTU3NjAwMDgwZmQ1YjYwMjA5MjgzMDE5OTUwOTc1MDkwODkwMTM1OTA4MDgyMTExNTYxNDliNDU3NjAwMDgwZmQ1YjYxNDljMDhiODM4YzAxNjE0N2Y4NTY1Yjk2NTA2MDQwOGEwMTM1OTU1MDYxNDlkNTYwNjA4YjAxNjE0NDhmNTY1Yjk0NTA2MTQ5ZTM2MDgwOGIwMTYxNDg4NDU2NWI5MzUwNjBhMDhhMDEzNTkxNTA4MDgyMTExNTYxNDlmOTU3NjAwMDgwZmQ1YjUwNjE0YTA2OGE4MjhiMDE2MTQ4OTQ1NjViOTE1MDUwOTI5NTk4OTE5NDk3NTA5Mjk1NTA1NjViNjAwMDgwNjA0MDgzODUwMzEyMTU2MTRhMjg1NzYwMDA4MGZkNWI2MTRhMzE4MzYxNDQ4ZjU2NWI5NDYwMjA5MzkwOTMwMTM1OTM1MDUwNTA1NjViNjAwMDYwMjA4Mjg0MDMxMjE1NjE0YTUxNTc2MDAwODBmZDViODEzNTYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTRhNjc1NzYwMDA4MGZkNWI4MjAxNjEwMTAwODE4NTAzMTIxNTYxNGE3YTU3NjAwMDgwZmQ1YjkzOTI1MDUwNTA1NjViNjAwMDgwNjA0MDgzODUwMzEyMTU2MTRhOTQ1NzYwMDA4MGZkNWI2MTRhOWQ4MzYxNDQ4ZjU2NWI5MTUwNjAyMDgzMDEzNTYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTRhYjg1NzYwMDA4MGZkNWI2MTRhYzQ4NTgyODYwMTYxNDc4OTU2NWI5MTUwNTA5MjUwOTI5MDUwNTY1YjYwMDA4MDYwMjA4Mzg1MDMxMjE1NjE0YWUxNTc2MDAwODBmZDViODIzNTYwMDE2MDAxNjA0MDFiMDM4MDgyMTExNTYxNGFmODU3NjAwMDgwZmQ1YjgxODUwMTkxNTA4NTYwMWY4MzAxMTI2MTRiMGM1NzYwMDA4MGZkNWI4MTM1ODE4MTExMTU2MTRiMWI1NzYwMDA4MGZkNWI4NjYwMjA4MjYwMDUxYjg1MDEwMTExMTU2MTRiMzA1NzYwMDA4MGZkNWI2MDIwOTI5MDkyMDE5NjkxOTU1MDkwOTM1MDUwNTA1MDU2NWI2MDAwODA2MDAwODA2MDgwODU4NzAzMTIxNTYxNGI1ODU3NjAwMDgwZmQ1Yjg0MzU5MzUwNjE0YjY4NjAyMDg2MDE2MTQ0OGY1NjViOTI1MDYxNGI3NjYwNDA4NjAxNjE0NDhmNTY1YjkzOTY5Mjk1NTA5MjkzNjA2MDAxMzU5MjUwNTA1NjViNjAwMDgwNjAwMDYwNjA4NDg2MDMxMjE1NjE0YjliNTc2MDAwODBmZDViNjE0YmE0ODQ2MTQ0OGY1NjViOTI1MDYxNGJiMjYwMjA4NTAxNjE0NDhmNTY1YjkxNTA2MDQwODQwMTM1NjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxNGJjZDU3NjAwMDgwZmQ1YjYxNGJkOTg2ODI4NzAxNjE0Nzg5NTY1YjkxNTA1MDkyNTA5MjUwOTI1NjViNjAwMDYwMjA4Mjg0MDMxMjE1NjE0YmY1NTc2MDAwODBmZDViNTAzNTkxOTA1MDU2NWI2MDIwODE1MjYwMDA2MTA2Mjg2MDIwODMwMTg0NjE0MzZiNTY1YjYwMDE4MTgxMWM5MDgyMTY4MDYxNGMyMzU3NjA3ZjgyMTY5MTUwNWI2MDIwODIxMDgxMDM2MTRjNDM1NzYzNGU0ODdiNzE2MGUwMWI2MDAwNTI2MDIyNjAwNDUyNjAyNDYwMDBmZDViNTA5MTkwNTA1NjViNjM0ZTQ4N2I3MTYwZTAxYjYwMDA1MjYwMzI2MDA0NTI2MDI0NjAwMGZkNWI2MGEwODE1Mjg1NjBhMDgyMDE1Mjg1ODc2MGMwODMwMTM3NjAwMDYwYzA4NzgzMDEwMTUyNjAwMDYwMWYxOTYwMWY4ODAxMTY4MjAxNjBjMDgzODIwMzAxNjAyMDg0MDE1MjYxNGM5ZDYwYzA4MjAxODg2MTQ0Zjk1NjViNjA0MDg0MDE5NjkwOTY1MjUwNTA2MDAxNjAwMTYwYTAxYjAzOTI5MDkyMTY2MDYwODMwMTUyMTUxNTYwODA5MDkxMDE1MjkzOTI1MDUwNTA1NjViNjAyMDgwODI1MjYwMjE5MDgyMDE1MjdmNDM2MTZjNmM2NTcyMjA2OTczMjA2ZTZmNzQyMDc0Njg2NTIwNmM2NTY0Njc2NTcyMjA2MzZmNmU3NDcyNjE2MzYwNDA4MjAxNTI2MDFkNjBmYTFiNjA2MDgyMDE1MjYwODAwMTkwNTY1YjYwMDA4MDgzMzU2MDFlMTk4NDM2MDMwMTgxMTI2MTRkMWY1NzYwMDA4MGZkNWI4MzAxODAzNTkxNTA2MDAxNjAwMTYwNDAxYjAzODIxMTE1NjE0ZDM5NTc2MDAwODBmZDViNjAyMDAxOTE1MDM2ODE5MDAzODIxMzE1NjE0ZDRlNTc2MDAwODBmZDViOTI1MDkyOTA1MDU2NWI4MTgzODIzNzYwMDA5MTAxOTA4MTUyOTE5MDUwNTY1YjYwMDA4MDgzNTQ2MTRkNzM4MTYxNGMwZjU2NWI2MDAxODI4MTE2ODAxNTYxNGQ4YjU3NjAwMTgxMTQ2MTRkYTA1NzYxNGRjZjU2NWI2MGZmMTk4NDE2ODc1MjgyMTUxNTgzMDI4NzAxOTQ1MDYxNGRjZjU2NWI4NzYwMDA1MjYwMjA4MDYwMDAyMDYwMDA1Yjg1ODExMDE1NjE0ZGM2NTc4MTU0OGE4MjAxNTI5MDg0MDE5MDgyMDE2MTRkYWQ1NjViNTA1MDUwODI4NzAxOTQ1MDViNTA5Mjk2OTU1MDUwNTA1MDUwNTA1NjViNjAwMDYxMDEwMDgyMzYwMzEyMTU2MTRkZWU1NzYwMDA4MGZkNWI2MTRkZjY2MTQ3MzA1NjViODIzNTgxNTI2MDIwODMwMTM1NjAwMTYwMDE2MDQwMWIwMzgwODIxMTE1NjE0ZTE0NTc2MDAwODBmZDViNjE0ZTIwMzY4Mzg3MDE2MTQ3ODk1NjViNjAyMDg0MDE1MjYwNDA4NTAxMzU5MTUwODA4MjExMTU2MTRlMzk1NzYwMDA4MGZkNWI2MTRlNDUzNjgzODcwMTYxNDc4OTU2NWI2MDQwODQwMTUyNjA2MDg1MDEzNTYwNjA4NDAxNTI2MTRlNjA2MDgwODYwMTYxNDQ4ZjU2NWI2MDgwODQwMTUyNjBhMDg1MDEzNTkxNTA4MDgyMTExNTYxNGU3OTU3NjAwMDgwZmQ1YjUwNjE0ZTg2MzY4Mjg2MDE2MTQ3ODk1NjViNjBhMDgzMDE1MjUwNjBjMDgzMDEzNTYwYzA4MjAxNTI2MTRlYTI2MGUwODQwMTYxNDQ4ZjU2NWI2MGUwODIwMTUyOTI5MTUwNTA1NjViNjAxZjgyMTExNTYxMzI3YTU3NjAwMDgxODE1MjYwMjA4MTIwNjAxZjg1MDE2MDA1MWM4MTAxNjAyMDg2MTAxNTYxNGVkNDU3NTA4MDViNjAxZjg1MDE2MDA1MWM4MjAxOTE1MDViODE4MTEwMTU2MTJmYjI1NzgyODE1NTYwMDEwMTYxNGVlMDU2NWI2MDAxNjAwMTYwNDAxYjAzODMxMTE1NjE0ZjBhNTc2MTRmMGE2MTQ3MWE1NjViNjE0ZjFlODM2MTRmMTg4MzU0NjE0YzBmNTY1YjgzNjE0ZWFkNTY1YjYwMDA2MDFmODQxMTYwMDE4MTE0NjE0ZjUyNTc2MDAwODUxNTYxNGYzYTU3NTA4MzgyMDEzNTViNjAwMDE5NjAwMzg3OTAxYjFjMTkxNjYwMDE4NjkwMWIxNzgzNTU2MTExY2Y1NjViNjAwMDgzODE1MjYwMjA5MDIwNjAxZjE5ODYxNjkwODM1YjgyODExMDE1NjE0ZjgzNTc4Njg1MDEzNTgyNTU2MDIwOTQ4NTAxOTQ2MDAxOTA5MjAxOTEwMTYxNGY2MzU2NWI1MDg2ODIxMDE1NjE0ZmEwNTc2MDAwMTk2MGY4ODg2MDAzMWIxNjFjMTk4NDg3MDEzNTE2ODE1NTViNTA1MDYwMDE4NTYwMDExYjAxODM1NTUwNTA1MDUwNTA1NjViNjM0ZTQ4N2I3MTYwZTAxYjYwMDA1MjYwMTE2MDA0NTI2MDI0NjAwMGZkNWI4MDgyMDI4MTE1ODI4MjA0ODQxNDE3NjEwNjJiNTc2MTA2MmI2MTRmYjI1NjViNjAwMDgyNjE0ZmZjNTc2MzRlNDg3YjcxNjBlMDFiNjAwMDUyNjAxMjYwMDQ1MjYwMjQ2MDAwZmQ1YjUwMDQ5MDU2NWI2MDAwNjAwMTgyMDE2MTUwMTM1NzYxNTAxMzYxNGZiMjU2NWI1MDYwMDEwMTkwNTY1YjgwODIwMTgwODIxMTE1NjEwNjJiNTc2MTA2MmI2MTRmYjI1NjViODE4MTAzODE4MTExMTU2MTA2MmI1NzYxMDYyYjYxNGZiMjU2NWI4MTUxNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxNTA1OTU3NjE1MDU5NjE0NzFhNTY1YjYxNTA2ZDgxNjE1MDY3ODQ1NDYxNGMwZjU2NWI4NDYxNGVhZDU2NWI2MDIwODA2MDFmODMxMTYwMDE4MTE0NjE1MGEyNTc2MDAwODQxNTYxNTA4YTU3NTA4NTgzMDE1MTViNjAwMDE5NjAwMzg2OTAxYjFjMTkxNjYwMDE4NTkwMWIxNzg1NTU2MTJmYjI1NjViNjAwMDg1ODE1MjYwMjA4MTIwNjAxZjE5ODYxNjkxNWI4MjgxMTAxNTYxNTBkMTU3ODg4NjAxNTE4MjU1OTQ4NDAxOTQ2MDAxOTA5MTAxOTA4NDAxNjE1MGIyNTY1YjUwODU4MjEwMTU2MTUwZWY1Nzg3ODUwMTUxNjAwMDE5NjAwMzg4OTAxYjYwZjgxNjFjMTkxNjgxNTU1YjUwNTA1MDUwNTA2MDAxOTA4MTFiMDE5MDU1NTA1NjViNjAwMDYwMDE2MGZmMWI4MjAxNjE1MTE0NTc2MTUxMTQ2MTRmYjI1NjViNTA2MDAwMTkwMTkwNTY1YjYwMDA4NzUxNjE1MTJlODE4NDYwMjA4YzAxNjE0MjdjNTY1Yjg3NTE5MDgzMDE5MDYxNTE0MjgxODM2MDIwOGMwMTYxNDI3YzU2NWIwMTk1ODY1MjUwNTA2YmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjE5NjA2MDkzODQxYjgxMTY2MDIwODYwMTUyNjAzNDg1MDE5MjkwOTI1MjkwOTExYjE2NjA1NDgyMDE1MjYwNjgwMTkyOTE1MDUwNTY1YjYzNGU0ODdiNzE2MGUwMWI2MDAwNTI2MDMxNjAwNDUyNjAyNDYwMDBmZGZlYTI2NDY5NzA2NjczNTgyMjEyMjAzMjQ5NmZmODg1ZDIxYzk0MWZkNTdlNjI5ODM1MzNkMDJhMTUyNmFhMThmMzUwZDZlYjg5ZTA5OTY0ZmY4YTg4NjQ3MzZmNmM2MzQzMDAwODE0MDAzMyc7XG5jb25zdCBpc1N1cGVyQXJncyA9ICh4cykgPT4geHMubGVuZ3RoID4gMTtcbmNsYXNzIEZpbmVUdW5pbmdTZXJ2aW5nX19mYWN0b3J5IGV4dGVuZHMgQ29udHJhY3RGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIGlmIChpc1N1cGVyQXJncyhhcmdzKSkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcihfYWJpLCBfYnl0ZWNvZGUsIGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldERlcGxveVRyYW5zYWN0aW9uKG92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0RGVwbG95VHJhbnNhY3Rpb24ob3ZlcnJpZGVzIHx8IHt9KTtcbiAgICB9XG4gICAgZGVwbG95KG92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gc3VwZXIuZGVwbG95KG92ZXJyaWRlcyB8fCB7fSk7XG4gICAgfVxuICAgIGNvbm5lY3QocnVubmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5jb25uZWN0KHJ1bm5lcik7XG4gICAgfVxuICAgIHN0YXRpYyBieXRlY29kZSA9IF9ieXRlY29kZTtcbiAgICBzdGF0aWMgYWJpID0gX2FiaTtcbiAgICBzdGF0aWMgY3JlYXRlSW50ZXJmYWNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZShfYWJpKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbm5lY3QoYWRkcmVzcywgcnVubmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3QoYWRkcmVzcywgX2FiaSwgcnVubmVyKTtcbiAgICB9XG59XG5cbi8vIENyZWF0ZSBpbnRlcmZhY2VzIGZyb20gdGhlIGNvbnRyYWN0IGZhY3Rvcmllc1xuY29uc3QgbGVkZ2VySW50ZXJmYWNlID0gbmV3IEludGVyZmFjZShMZWRnZXJNYW5hZ2VyX19mYWN0b3J5LmFiaSk7XG5jb25zdCBpbmZlcmVuY2VJbnRlcmZhY2UgPSBuZXcgSW50ZXJmYWNlKEluZmVyZW5jZVNlcnZpbmdfX2ZhY3RvcnkuYWJpKTtcbmNvbnN0IGZpbmVUdW5pbmdJbnRlcmZhY2UgPSBuZXcgSW50ZXJmYWNlKEZpbmVUdW5pbmdTZXJ2aW5nX19mYWN0b3J5LmFiaSk7XG5jb25zdCBjb250cmFjdEludGVyZmFjZXMgPSB7XG4gICAgbGVkZ2VyOiBsZWRnZXJJbnRlcmZhY2UsXG4gICAgaW5mZXJlbmNlOiBpbmZlcmVuY2VJbnRlcmZhY2UsXG4gICAgZmluZVR1bmluZzogZmluZVR1bmluZ0ludGVyZmFjZSxcbn07XG5mdW5jdGlvbiBkZWNvZGVDdXN0b21FcnJvcihlcnJvcikge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFR5cGUgZ3VhcmQgZm9yIGVycm9yIHdpdGggZGF0YSBwcm9wZXJ0eVxuICAgICAgICBjb25zdCBlcnJvcldpdGhEYXRhID0gZXJyb3I7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gZXRoZXJzIGVycm9yIHdpdGggY3VzdG9tIGVycm9yIGRhdGFcbiAgICAgICAgaWYgKGVycm9yV2l0aERhdGEuZGF0YSAmJiB0eXBlb2YgZXJyb3JXaXRoRGF0YS5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gZXJyb3JXaXRoRGF0YS5kYXRhO1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGRlY29kZSB3aXRoIGVhY2ggY29udHJhY3QgaW50ZXJmYWNlXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIGNvbnRyYWN0SW50ZXJmYWNlXSBvZiBPYmplY3QuZW50cmllcyhjb250cmFjdEludGVyZmFjZXMpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGN1c3RvbSBlcnJvclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVkRXJyb3IgPSBjb250cmFjdEludGVyZmFjZS5wYXJzZUVycm9yKGVycm9yRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWNvZGVkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCB0aGUgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiB0aGUgZXJyb3IgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTGVkZ2VyTm90RXhpc3RzJzogJ0FjY291bnQgZG9lcyBub3QgZXhpc3QuIFBsZWFzZSBjcmVhdGUgYW4gYWNjb3VudCBmaXJzdCB1c2luZyBcImFkZC1hY2NvdW50XCIuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTGVkZ2VyRXhpc3RzJzogJ0FjY291bnQgYWxyZWFkeSBleGlzdHMuIFVzZSBcImRlcG9zaXRcIiB0byBhZGQgZnVuZHMgb3IgXCJnZXQtYWNjb3VudFwiIHRvIHZpZXcgZGV0YWlscy4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJbnN1ZmZpY2llbnRCYWxhbmNlJzogJ0luc3VmZmljaWVudCBiYWxhbmNlIGluIHRoZSBhY2NvdW50LicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1NlcnZpY2VOb3RFeGlzdCc6ICdTZXJ2aWNlIHByb3ZpZGVyIGRvZXMgbm90IGV4aXN0LiBQbGVhc2UgY2hlY2sgdGhlIHByb3ZpZGVyIGFkZHJlc3MuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudE5vdEV4aXN0JzogJ1N1Yi1hY2NvdW50IGRvZXMgbm90IGV4aXN0IGZvciB0aGlzIHByb3ZpZGVyLicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnRFeGlzdCc6ICdTdWItYWNjb3VudCBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyBwcm92aWRlci4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJbnZhbGlkVmVyaWZpZXJJbnB1dCc6ICdJbnZhbGlkIHZlcmlmaWNhdGlvbiBpbnB1dCBwcm92aWRlZC4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVbmF1dGhvcml6ZWQnOiAnVW5hdXRob3JpemVkLiBZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBwZXJmb3JtIHRoaXMgYWN0aW9uLicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWRJbnB1dCc6ICdJbnZhbGlkIGlucHV0IHBhcmFtZXRlcnMgcHJvdmlkZWQuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGVycm9yTWVzc2FnZXNbZGVjb2RlZEVycm9yLm5hbWVdIHx8IGBFcnJvcjogJHtkZWNvZGVkRXJyb3IubmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHBhcmFtZXRlciBkZXRhaWxzIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlY29kZWRFcnJvci5hcmdzICYmIGRlY29kZWRFcnJvci5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdEZXRhaWxzID0gZGVjb2RlZEVycm9yLmFyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoYXJnLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGFuIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIGFyZy5zdGFydHNXaXRoKCcweCcpICYmIGFyZy5sZW5ndGggPT09IDQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYEFkZHJlc3M6ICR7YXJnfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBBcmcke2luZGV4fTogJHthcmd9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdEZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCAoJHthcmdEZXRhaWxzfSlgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgdG8gbmV4dCBpbnRlcmZhY2UgaWYgdGhpcyBvbmUgZG9lc24ndCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGVycm9yIHJlYXNvblxuICAgICAgICBpZiAoZXJyb3JXaXRoRGF0YS5yZWFzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcldpdGhEYXRhLnJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3Igc2hvcnRNZXNzYWdlXG4gICAgICAgIGlmIChlcnJvcldpdGhEYXRhLnNob3J0TWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yV2l0aERhdGEuc2hvcnRNZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKGVycm9yKSB7XG4gICAgLy8gRmlyc3QgdHJ5IHRvIGRlY29kZSBjdXN0b20gZXJyb3JcbiAgICBjb25zdCBkZWNvZGVkRXJyb3IgPSBkZWNvZGVDdXN0b21FcnJvcihlcnJvcik7XG4gICAgaWYgKGRlY29kZWRFcnJvcikge1xuICAgICAgICByZXR1cm4gZGVjb2RlZEVycm9yO1xuICAgIH1cbiAgICBjb25zdCBlcnJvcldpdGhNZXNzYWdlID0gZXJyb3I7XG4gICAgLy8gQ2hlY2sgZm9yIGNvbW1vbiBlcnJvciBwYXR0ZXJuc1xuICAgIGlmIChlcnJvcldpdGhNZXNzYWdlLm1lc3NhZ2UpIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGdhcyBlc3RpbWF0aW9uIGVycm9yc1xuICAgICAgICBpZiAoZXJyb3JXaXRoTWVzc2FnZS5tZXNzYWdlLmluY2x1ZGVzKCdleGVjdXRpb24gcmV2ZXJ0ZWQnKSkge1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZUN1c3RvbUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBUcmFuc2FjdGlvbiBmYWlsZWQ6ICR7ZGVjb2RlZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdUcmFuc2FjdGlvbiBleGVjdXRpb24gcmV2ZXJ0ZWQuIFRoaXMgdXN1YWxseSBtZWFucyBhIHJlcXVpcmVtZW50IHdhcyBub3QgbWV0Lic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGluc3VmZmljaWVudCBmdW5kc1xuICAgICAgICBpZiAoZXJyb3JXaXRoTWVzc2FnZS5tZXNzYWdlLmluY2x1ZGVzKCdpbnN1ZmZpY2llbnQgZnVuZHMnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdJbnN1ZmZpY2llbnQgZnVuZHMgZm9yIHRyYW5zYWN0aW9uLiBQbGVhc2UgY2hlY2sgeW91ciB3YWxsZXQgYmFsYW5jZS4nO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBub25jZSBlcnJvcnNcbiAgICAgICAgaWYgKGVycm9yV2l0aE1lc3NhZ2UubWVzc2FnZS5pbmNsdWRlcygnbm9uY2UnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdUcmFuc2FjdGlvbiBub25jZSBlcnJvci4gUGxlYXNlIHdhaXQgYSBtb21lbnQgYW5kIHRyeSBhZ2Fpbi4nO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciB1c2VyIHJlamVjdGVkXG4gICAgICAgIGlmIChlcnJvcldpdGhNZXNzYWdlLm1lc3NhZ2UuaW5jbHVkZXMoJ3VzZXIgcmVqZWN0ZWQnKSB8fCBlcnJvcldpdGhNZXNzYWdlLm1lc3NhZ2UuaW5jbHVkZXMoJ1VzZXIgZGVuaWVkJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnVHJhbnNhY3Rpb24gd2FzIHJlamVjdGVkIGJ5IHRoZSB1c2VyLic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG5ldHdvcmsgZXJyb3JzXG4gICAgICAgIGlmIChlcnJvcldpdGhNZXNzYWdlLm1lc3NhZ2UuaW5jbHVkZXMoJ25ldHdvcmsnKSB8fCBlcnJvcldpdGhNZXNzYWdlLm1lc3NhZ2UuaW5jbHVkZXMoJ3RpbWVvdXQnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdOZXR3b3JrIGVycm9yLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uIGFuZCB0cnkgYWdhaW4uJztcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgYWRkaXRpb25hbCBzcGVjaWZpYyBwYXR0ZXJuc1xuICAgICAgICBpZiAoZXJyb3JXaXRoTWVzc2FnZS5tZXNzYWdlLmluY2x1ZGVzKCdEZWxpdmVyYWJsZSBub3QgYWNrbm93bGVkZ2VkIHlldCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJEZWxpdmVyYWJsZSBub3QgYWNrbm93bGVkZ2VkIHlldC4gUGxlYXNlIHVzZSAnYWNrbm93bGVkZ2UtbW9kZWwnIHRvIGFja25vd2xlZGdlIHRoZSBkZWxpdmVyYWJsZS5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JXaXRoTWVzc2FnZS5tZXNzYWdlLmluY2x1ZGVzKCdFbmNyeXB0ZWRTZWNyZXQgbm90IGZvdW5kJykpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlNlY3JldCB0byBkZWNyeXB0IG1vZGVsIG5vdCBmb3VuZC4gUGxlYXNlIGVuc3VyZSB0aGUgdGFzayBzdGF0dXMgaXMgJ0ZpbmlzaGVkJy5cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm4gb3JpZ2luYWwgZXJyb3IgbWVzc2FnZVxuICAgIHJldHVybiBlcnJvcldpdGhNZXNzYWdlLm1lc3NhZ2UgfHwgU3RyaW5nKGVycm9yKTtcbn1cbi8vIEhlbHBlciBmdW5jdGlvbiB0byB0aHJvdyBmb3JtYXR0ZWQgZXJyb3JzIGZyb20gd2l0aGluIFNESyBmdW5jdGlvbnNcbmZ1bmN0aW9uIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpIHtcbiAgICBjb25zdCBmb3JtYXR0ZWRNZXNzYWdlID0gZm9ybWF0RXJyb3IoZXJyb3IpO1xuICAgIGNvbnN0IGZvcm1hdHRlZEVycm9yID0gbmV3IEVycm9yKGZvcm1hdHRlZE1lc3NhZ2UpO1xuICAgIC8vIFByZXNlcnZlIG9yaWdpbmFsIGVycm9yIHByb3BlcnRpZXMgaWYgcG9zc2libGVcbiAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGZvcm1hdHRlZEVycm9yLCBlcnJvcik7XG4gICAgICAgIGZvcm1hdHRlZEVycm9yLm1lc3NhZ2UgPSBmb3JtYXR0ZWRNZXNzYWdlO1xuICAgIH1cbiAgICB0aHJvdyBmb3JtYXR0ZWRFcnJvcjtcbn1cblxubGV0IGVkZHNhO1xubGV0IGJhYnlqdWJqdWI7XG5hc3luYyBmdW5jdGlvbiBpbml0QmFieUp1YigpIHtcbiAgICBpZiAoIWJhYnlqdWJqdWIpIHtcbiAgICAgICAgYmFieWp1Ymp1YiA9IGF3YWl0IGJ1aWxkQmFieWp1YigpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGluaXRFZGRzYSgpIHtcbiAgICBpZiAoIWVkZHNhKSB7XG4gICAgICAgIGVkZHNhID0gYXdhaXQgYnVpbGRFZGRzYSgpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGJhYnlKdWJKdWJHZW5lcmF0ZVByaXZhdGVLZXkoKSB7XG4gICAgYXdhaXQgaW5pdEJhYnlKdWIoKTtcbiAgICByZXR1cm4gYmFieWp1Ymp1Yi5GLnJhbmRvbSgpO1xufVxuYXN5bmMgZnVuY3Rpb24gYmFieUp1Ykp1YkdlbmVyYXRlUHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICBhd2FpdCBpbml0RWRkc2EoKTtcbiAgICByZXR1cm4gZWRkc2EucHJ2MnB1Yihwcml2YXRlS2V5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJhYnlKdWJKdWJTaWduYXR1cmUobXNnLCBwcml2YXRlS2V5KSB7XG4gICAgYXdhaXQgaW5pdEVkZHNhKCk7XG4gICAgcmV0dXJuIGVkZHNhLnNpZ25QZWRlcnNlbihwcml2YXRlS2V5LCBtc2cpO1xufVxuYXN5bmMgZnVuY3Rpb24gcGFja1NpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBhd2FpdCBpbml0RWRkc2EoKTtcbiAgICByZXR1cm4gZWRkc2EucGFja1NpZ25hdHVyZShzaWduYXR1cmUpO1xufVxuYXN5bmMgZnVuY3Rpb24gcGFja1BvaW50KHBvaW50KSB7XG4gICAgYXdhaXQgaW5pdEJhYnlKdWIoKTtcbiAgICByZXR1cm4gYmFieWp1Ymp1Yi5wYWNrUG9pbnQocG9pbnQpO1xufVxuYXN5bmMgZnVuY3Rpb24gcGVkZXJzZW5IYXNoKG1zZykge1xuICAgIGNvbnN0IGggPSBhd2FpdCBidWlsZFBlZGVyc2VuSGFzaCgpO1xuICAgIHJldHVybiBoLmhhc2gobXNnKTtcbn1cblxuY29uc3QgQllURV9TSVpFID0gODtcbmZ1bmN0aW9uIGJpZ2ludFRvQnl0ZXMoYmlnaW50LCBsZW5ndGgpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBieXRlc1tpXSA9IE51bWJlcigoYmlnaW50ID4+IEJpZ0ludChCWVRFX1NJWkUgKiBpKSkgJiBCaWdJbnQoMHhmZikpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBieXRlc1RvQmlnaW50KGJ5dGVzKSB7XG4gICAgbGV0IGJpZ2ludCA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJpZ2ludCArPSBCaWdJbnQoYnl0ZXNbaV0pIDw8IEJpZ0ludChCWVRFX1NJWkUgKiBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpZ2ludDtcbn1cblxuY29uc3QgRklFTERfU0laRSA9IDMyO1xuYXN5bmMgZnVuY3Rpb24gc2lnblJlcXVlc3RzKHJlcXVlc3RzLCBwcml2YXRlS2V5KSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFJlcXVlc3RUcmFjZSA9IHJlcXVlc3RzLm1hcCgocmVxdWVzdCkgPT4gcmVxdWVzdC5zZXJpYWxpemUoKSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VyaWFsaXplZFJlcXVlc3RUcmFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBiYWJ5SnViSnViU2lnbmF0dXJlKHNlcmlhbGl6ZWRSZXF1ZXN0VHJhY2VbaV0sIHByaXZhdGVLZXkpO1xuICAgICAgICBzaWduYXR1cmVzLnB1c2goYXdhaXQgcGFja1NpZ25hdHVyZShzaWduYXR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ25hdHVyZXM7XG59XG5cbmNvbnN0IEJJR0lOVF9TSVpFID0gMTY7XG5hc3luYyBmdW5jdGlvbiBnZW5LZXlQYWlyKCkge1xuICAgIC8vIGdlbmVyYXRlIHByaXZhdGUga2V5XG4gICAgY29uc3QgcHJpdmtleSA9IGF3YWl0IGJhYnlKdWJKdWJHZW5lcmF0ZVByaXZhdGVLZXkoKTtcbiAgICAvLyBnZW5lcmF0ZSBwdWJsaWMga2V5XG4gICAgY29uc3QgcHVia2V5ID0gYXdhaXQgYmFieUp1Ykp1YkdlbmVyYXRlUHVibGljS2V5KHByaXZrZXkpO1xuICAgIC8vIHBhY2sgcHVibGljIGtleSB0byBGSUVMRF9TSVpFIGJ5dGVzXG4gICAgY29uc3QgcGFja2VkUHVia2V5ID0gYXdhaXQgcGFja1BvaW50KHB1YmtleSk7XG4gICAgLy8gdW5wYWNrIHBhY2tlZCBwdWJrZXkgdG8gYmlnaW50XG4gICAgY29uc3QgcGFja2VkUHVia2V5MCA9IGJ5dGVzVG9CaWdpbnQocGFja2VkUHVia2V5LnNsaWNlKDAsIEJJR0lOVF9TSVpFKSk7XG4gICAgY29uc3QgcGFja2VkUHVia2V5MSA9IGJ5dGVzVG9CaWdpbnQocGFja2VkUHVia2V5LnNsaWNlKEJJR0lOVF9TSVpFKSk7XG4gICAgLy8gdW5wYWNrIHByaXZhdGUga2V5IHRvIGJpZ2ludFxuICAgIGNvbnN0IHBhY2tQcml2a2V5MCA9IGJ5dGVzVG9CaWdpbnQocHJpdmtleS5zbGljZSgwLCBCSUdJTlRfU0laRSkpO1xuICAgIGNvbnN0IHBhY2tQcml2a2V5MSA9IGJ5dGVzVG9CaWdpbnQocHJpdmtleS5zbGljZShCSUdJTlRfU0laRSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhY2tlZFByaXZrZXk6IFtwYWNrUHJpdmtleTAsIHBhY2tQcml2a2V5MV0sXG4gICAgICAgIGRvdWJsZVBhY2tlZFB1YmtleTogW3BhY2tlZFB1YmtleTAsIHBhY2tlZFB1YmtleTFdLFxuICAgIH07XG59XG5hc3luYyBmdW5jdGlvbiBzaWduRGF0YShkYXRhLCBwYWNrZWRQcml2a2V5KSB7XG4gICAgLy8gdW5wYWNrIHByaXZhdGUga2V5IHRvIGJ5dGVzXG4gICAgY29uc3QgcGFja2VkUHJpdmtleTAgPSBiaWdpbnRUb0J5dGVzKHBhY2tlZFByaXZrZXlbMF0sIEJJR0lOVF9TSVpFKTtcbiAgICBjb25zdCBwYWNrZWRQcml2a2V5MSA9IGJpZ2ludFRvQnl0ZXMocGFja2VkUHJpdmtleVsxXSwgQklHSU5UX1NJWkUpO1xuICAgIC8vIGNvbWJpbmUgYnl0ZXMgdG8gVWludDhBcnJheVxuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBuZXcgVWludDhBcnJheShGSUVMRF9TSVpFKTtcbiAgICBwcml2YXRlS2V5LnNldChwYWNrZWRQcml2a2V5MCwgMCk7XG4gICAgcHJpdmF0ZUtleS5zZXQocGFja2VkUHJpdmtleTEsIEJJR0lOVF9TSVpFKTtcbiAgICAvLyBzaWduIGRhdGFcbiAgICBjb25zdCBzaWduYXR1cmVzID0gYXdhaXQgc2lnblJlcXVlc3RzKGRhdGEsIHByaXZhdGVLZXkpO1xuICAgIHJldHVybiBzaWduYXR1cmVzO1xufVxuXG5jb25zdCBBRERSX0xFTkdUSCA9IDIwO1xuY29uc3QgTk9OQ0VfTEVOR1RIID0gODtcbmNvbnN0IEZFRV9MRU5HVEggPSAxNjtcbmxldCBSZXF1ZXN0JDEgPSBjbGFzcyBSZXF1ZXN0IHtcbiAgICBub25jZTtcbiAgICBmZWU7XG4gICAgdXNlckFkZHJlc3M7XG4gICAgcHJvdmlkZXJBZGRyZXNzO1xuICAgIGNvbnN0cnVjdG9yKG5vbmNlLCBmZWUsIHVzZXJBZGRyZXNzLCAvLyBoZXhzdHJpbmcgZm9ybWF0IHdpdGggJzB4JyBwcmVmaXhcbiAgICBwcm92aWRlckFkZHJlc3MgLy8gaGV4c3RyaW5nIGZvcm1hdCB3aXRoICcweCcgcHJlZml4XG4gICAgKSB7XG4gICAgICAgIHRoaXMubm9uY2UgPSBCaWdJbnQobm9uY2UpO1xuICAgICAgICB0aGlzLmZlZSA9IEJpZ0ludChmZWUpO1xuICAgICAgICB0aGlzLnVzZXJBZGRyZXNzID0gQmlnSW50KHVzZXJBZGRyZXNzKTtcbiAgICAgICAgdGhpcy5wcm92aWRlckFkZHJlc3MgPSBCaWdJbnQocHJvdmlkZXJBZGRyZXNzKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoTk9OQ0VfTEVOR1RIICsgQUREUl9MRU5HVEggKiAyICsgRkVFX0xFTkdUSCk7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAvLyB3cml0ZSBub25jZSAodTY0KVxuICAgICAgICBjb25zdCBub25jZUJ5dGVzID0gYmlnaW50VG9CeXRlcyh0aGlzLm5vbmNlLCBOT05DRV9MRU5HVEgpO1xuICAgICAgICBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCwgTk9OQ0VfTEVOR1RIKS5zZXQobm9uY2VCeXRlcyk7XG4gICAgICAgIG9mZnNldCArPSBOT05DRV9MRU5HVEg7XG4gICAgICAgIC8vIHdyaXRlIGZlZSAodTEyOClcbiAgICAgICAgY29uc3QgZmVlQnl0ZXMgPSBiaWdpbnRUb0J5dGVzKHRoaXMuZmVlLCBGRUVfTEVOR1RIKTtcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQsIEZFRV9MRU5HVEgpLnNldChmZWVCeXRlcyk7XG4gICAgICAgIG9mZnNldCArPSBGRUVfTEVOR1RIO1xuICAgICAgICAvLyB3cml0ZSB1c2VyQWRkcmVzcyAodTE2MClcbiAgICAgICAgY29uc3QgdXNlckFkZHJlc3NCeXRlcyA9IGJpZ2ludFRvQnl0ZXModGhpcy51c2VyQWRkcmVzcywgQUREUl9MRU5HVEgpO1xuICAgICAgICBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCwgQUREUl9MRU5HVEgpLnNldCh1c2VyQWRkcmVzc0J5dGVzKTtcbiAgICAgICAgb2Zmc2V0ICs9IEFERFJfTEVOR1RIO1xuICAgICAgICAvLyB3cml0ZSBwcm92aWRlckFkZHJlc3MgKHUxNjApXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyQWRkcmVzc0J5dGVzID0gYmlnaW50VG9CeXRlcyh0aGlzLnByb3ZpZGVyQWRkcmVzcywgQUREUl9MRU5HVEgpO1xuICAgICAgICBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCwgQUREUl9MRU5HVEgpLnNldChwcm92aWRlckFkZHJlc3NCeXRlcyk7XG4gICAgICAgIG9mZnNldCArPSBBRERSX0xFTkdUSDtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgfVxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlQXJyYXkpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRMZW5ndGggPSBOT05DRV9MRU5HVEggKyBBRERSX0xFTkdUSCAqIDIgKyBGRUVfTEVOR1RIO1xuICAgICAgICBpZiAoYnl0ZUFycmF5Lmxlbmd0aCAhPT0gZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBieXRlIGFycmF5IGxlbmd0aCBmb3IgZGVzZXJpYWxpemF0aW9uLiBFeHBlY3RlZDogJHtleHBlY3RlZExlbmd0aH0sIGJ1dCBnb3Q6ICR7Ynl0ZUFycmF5Lmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgLy8gcmVhZCBub25jZSAodTY0KVxuICAgICAgICBjb25zdCBub25jZSA9IGJ5dGVzVG9CaWdpbnQobmV3IFVpbnQ4QXJyYXkoYnl0ZUFycmF5LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgTk9OQ0VfTEVOR1RIKSkpO1xuICAgICAgICBvZmZzZXQgKz0gTk9OQ0VfTEVOR1RIO1xuICAgICAgICAvLyByZWFkIGZlZSAodTEyOClcbiAgICAgICAgY29uc3QgZmVlID0gYnl0ZXNUb0JpZ2ludChuZXcgVWludDhBcnJheShieXRlQXJyYXkuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBGRUVfTEVOR1RIKSkpO1xuICAgICAgICBvZmZzZXQgKz0gRkVFX0xFTkdUSDtcbiAgICAgICAgLy8gcmVhZCB1c2VyQWRkcmVzcyAodTE2MClcbiAgICAgICAgY29uc3QgdXNlckFkZHJlc3MgPSBieXRlc1RvQmlnaW50KG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheS5zbGljZShvZmZzZXQsIG9mZnNldCArIEFERFJfTEVOR1RIKSkpO1xuICAgICAgICBvZmZzZXQgKz0gQUREUl9MRU5HVEg7XG4gICAgICAgIC8vIHJlYWQgcHJvdmlkZXJBZGRyZXNzICh1MTYwKVxuICAgICAgICBjb25zdCBwcm92aWRlckFkZHJlc3MgPSBieXRlc1RvQmlnaW50KG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheS5zbGljZShvZmZzZXQsIG9mZnNldCArIEFERFJfTEVOR1RIKSkpO1xuICAgICAgICBvZmZzZXQgKz0gQUREUl9MRU5HVEg7XG4gICAgICAgIHJldHVybiBuZXcgUmVxdWVzdChub25jZS50b1N0cmluZygpLCBmZWUudG9TdHJpbmcoKSwgJzB4JyArIHVzZXJBZGRyZXNzLnRvU3RyaW5nKDE2KSwgJzB4JyArIHByb3ZpZGVyQWRkcmVzcy50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICAvLyBHZXR0ZXJzXG4gICAgZ2V0Tm9uY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vbmNlO1xuICAgIH1cbiAgICBnZXRGZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZlZTtcbiAgICB9XG4gICAgZ2V0VXNlckFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXJBZGRyZXNzO1xuICAgIH1cbiAgICBnZXRQcm92aWRlckFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyQWRkcmVzcztcbiAgICB9XG59O1xuXG5jbGFzcyBaR1NlcnZpbmdVc2VyQnJva2VyQmFzZSB7XG4gICAgY29udHJhY3Q7XG4gICAgbWV0YWRhdGE7XG4gICAgY2FjaGU7XG4gICAgY2hlY2tBY2NvdW50VGhyZXNob2xkID0gQmlnSW50KDEwMCk7XG4gICAgdG9wVXBUcmlnZ2VyVGhyZXNob2xkID0gQmlnSW50KDUwMCk7XG4gICAgdG9wVXBUYXJnZXRUaHJlc2hvbGQgPSBCaWdJbnQoMTAwMCk7XG4gICAgbGVkZ2VyO1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBsZWRnZXIsIG1ldGFkYXRhLCBjYWNoZSkge1xuICAgICAgICB0aGlzLmNvbnRyYWN0ID0gY29udHJhY3Q7XG4gICAgICAgIHRoaXMubGVkZ2VyID0gbGVkZ2VyO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJvdmlkZXJEYXRhKCkge1xuICAgICAgICBjb25zdCBrZXkgPSBgJHt0aGlzLmNvbnRyYWN0LmdldFVzZXJBZGRyZXNzKCl9YDtcbiAgICAgICAgY29uc3QgW3NldHRsZVNpZ25lclByaXZhdGVLZXldID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5nZXRTZXR0bGVTaWduZXJQcml2YXRlS2V5KGtleSksXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4geyBzZXR0bGVTaWduZXJQcml2YXRlS2V5IH07XG4gICAgfVxuICAgIGFzeW5jIGdldFNlcnZpY2UocHJvdmlkZXJBZGRyZXNzLCB1c2VDYWNoZSA9IHRydWUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcHJvdmlkZXJBZGRyZXNzO1xuICAgICAgICBjb25zdCBjYWNoZWRTdmMgPSBhd2FpdCB0aGlzLmNhY2hlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZFN2YyAmJiB1c2VDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFN2YztcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3ZjID0gYXdhaXQgdGhpcy5jb250cmFjdC5nZXRTZXJ2aWNlKHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNhY2hlLnNldEl0ZW0oa2V5LCBzdmMsIDEwICogNjAgKiAxMDAwLCBDYWNoZVZhbHVlVHlwZUVudW0uU2VydmljZSk7XG4gICAgICAgICAgICByZXR1cm4gc3ZjO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UXVvdGUocHJvdmlkZXJBZGRyZXNzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlID0gYXdhaXQgdGhpcy5nZXRTZXJ2aWNlKHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBzZXJ2aWNlLnVybDtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dXJsfS92MS9xdW90ZWA7XG4gICAgICAgICAgICBjb25zdCBxdW90ZVN0cmluZyA9IGF3YWl0IHRoaXMuZmV0Y2hUZXh0KGVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gSlNPTi5wYXJzZShxdW90ZVN0cmluZywgKF8sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVzZXJBY2tub3dsZWRnZWQocHJvdmlkZXJBZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IHVzZXJBZGRyZXNzID0gdGhpcy5jb250cmFjdC5nZXRVc2VyQWRkcmVzcygpO1xuICAgICAgICBjb25zdCBrZXkgPSBgJHt1c2VyQWRkcmVzc31fJHtwcm92aWRlckFkZHJlc3N9X2Fja2A7XG4gICAgICAgIGNvbnN0IGNhY2hlZFN2YyA9IGF3YWl0IHRoaXMuY2FjaGUuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoY2FjaGVkU3ZjKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IHRoaXMuY29udHJhY3QuZ2V0QWNjb3VudChwcm92aWRlckFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKGFjY291bnQucHJvdmlkZXJQdWJLZXlbMF0gIT09IDBuICYmXG4gICAgICAgICAgICAgICAgYWNjb3VudC5wcm92aWRlclB1YktleVsxXSAhPT0gMG4pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNhY2hlLnNldEl0ZW0oa2V5LCBhY2NvdW50LnByb3ZpZGVyUHViS2V5LCAxMCAqIDYwICogMTAwMCwgQ2FjaGVWYWx1ZVR5cGVFbnVtLk90aGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZldGNoVGV4dChlbmRwb2ludCwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBTdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShidWZmZXIpLnRvU3RyaW5nKCd1dGYtOCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0RXh0cmFjdG9yKHByb3ZpZGVyQWRkcmVzcywgdXNlQ2FjaGUgPSB0cnVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdmMgPSBhd2FpdCB0aGlzLmdldFNlcnZpY2UocHJvdmlkZXJBZGRyZXNzLCB1c2VDYWNoZSk7XG4gICAgICAgICAgICBjb25zdCBleHRyYWN0b3IgPSB0aGlzLmNyZWF0ZUV4dHJhY3RvcihzdmMpO1xuICAgICAgICAgICAgcmV0dXJuIGV4dHJhY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUV4dHJhY3RvcihzdmMpIHtcbiAgICAgICAgc3dpdGNoIChzdmMuc2VydmljZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NoYXRib3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhdEJvdChzdmMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gc2VydmljZSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYTBnaVRvTmV1cm9uKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlU3RyID0gdmFsdWUudG9GaXhlZCgxOCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gdmFsdWVTdHIuc3BsaXQoJy4nKTtcbiAgICAgICAgLy8gSGFuZGxlIGludGVnZXIgcGFydFxuICAgICAgICBjb25zdCBpbnRlZ2VyUGFydCA9IHBhcnRzWzBdO1xuICAgICAgICBsZXQgaW50ZWdlclBhcnRBc0JpZ0ludCA9IEJpZ0ludChpbnRlZ2VyUGFydCkgKiBCaWdJbnQoMTAgKiogMTgpO1xuICAgICAgICAvLyBIYW5kbGUgZnJhY3Rpb25hbCBwYXJ0IGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGV0IGZyYWN0aW9uYWxQYXJ0ID0gcGFydHNbMV07XG4gICAgICAgICAgICB3aGlsZSAoZnJhY3Rpb25hbFBhcnQubGVuZ3RoIDwgMTgpIHtcbiAgICAgICAgICAgICAgICBmcmFjdGlvbmFsUGFydCArPSAnMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJhY3Rpb25hbFBhcnQubGVuZ3RoID4gMTgpIHtcbiAgICAgICAgICAgICAgICBmcmFjdGlvbmFsUGFydCA9IGZyYWN0aW9uYWxQYXJ0LnNsaWNlKDAsIDE4KTsgLy8gVHJ1bmNhdGUgdG8gYXZvaWQgb3ZlcmZsb3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZyYWN0aW9uYWxQYXJ0QXNCaWdJbnQgPSBCaWdJbnQoZnJhY3Rpb25hbFBhcnQpO1xuICAgICAgICAgICAgaW50ZWdlclBhcnRBc0JpZ0ludCArPSBmcmFjdGlvbmFsUGFydEFzQmlnSW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlZ2VyUGFydEFzQmlnSW50O1xuICAgIH1cbiAgICBuZXVyb25Ub0EwZ2kodmFsdWUpIHtcbiAgICAgICAgY29uc3QgZGl2aXNvciA9IEJpZ0ludCgxMCAqKiAxOCk7XG4gICAgICAgIGNvbnN0IGludGVnZXJQYXJ0ID0gdmFsdWUgLyBkaXZpc29yO1xuICAgICAgICBjb25zdCByZW1haW5kZXIgPSB2YWx1ZSAlIGRpdmlzb3I7XG4gICAgICAgIGNvbnN0IGRlY2ltYWxQYXJ0ID0gTnVtYmVyKHJlbWFpbmRlcikgLyBOdW1iZXIoZGl2aXNvcik7XG4gICAgICAgIHJldHVybiBOdW1iZXIoaW50ZWdlclBhcnQpICsgZGVjaW1hbFBhcnQ7XG4gICAgfVxuICAgIGFzeW5jIGdldEhlYWRlcihwcm92aWRlckFkZHJlc3MsIGNvbnRlbnQsIG91dHB1dEZlZSwgdmxsbVByb3h5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyQWRkcmVzcyA9IHRoaXMuY29udHJhY3QuZ2V0VXNlckFkZHJlc3MoKTtcbiAgICAgICAgICAgIGlmICghKGF3YWl0IHRoaXMudXNlckFja25vd2xlZGdlZChwcm92aWRlckFkZHJlc3MpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZXIgc2lnbmVyIGlzIG5vdCBhY2tub3dsZWRnZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4dHJhY3RvciA9IGF3YWl0IHRoaXMuZ2V0RXh0cmFjdG9yKHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCB7IHNldHRsZVNpZ25lclByaXZhdGVLZXkgfSA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXJEYXRhKCk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB1c2VyQWRkcmVzcztcbiAgICAgICAgICAgIGxldCBwcml2YXRlS2V5ID0gc2V0dGxlU2lnbmVyUHJpdmF0ZUtleTtcbiAgICAgICAgICAgIGlmICghcHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmdldEFjY291bnQocHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5U3RyID0gYXdhaXQgZGVjcnlwdERhdGEodGhpcy5jb250cmFjdC5zaWduZXIsIGFjY291bnQuYWRkaXRpb25hbEluZm8pO1xuICAgICAgICAgICAgICAgIHByaXZhdGVLZXkgPSBzdHJUb1ByaXZhdGVLZXkocHJpdmF0ZUtleVN0cik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1ByaXZhdGUga2V5IG5ldzonLCBwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnN0b3JlU2V0dGxlU2lnbmVyUHJpdmF0ZUtleShrZXksIHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCBnZXROb25jZVdpdGhDYWNoZSh0aGlzLmNhY2hlKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0RmVlID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVJbnB1dEZlZXMoZXh0cmFjdG9yLCBjb250ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGZlZSA9IGlucHV0RmVlICsgb3V0cHV0RmVlO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0JDEobm9uY2UudG9TdHJpbmcoKSwgZmVlLnRvU3RyaW5nKCksIHVzZXJBZGRyZXNzLCBwcm92aWRlckFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3Qgc2V0dGxlU2lnbmF0dXJlID0gYXdhaXQgc2lnbkRhdGEoW3JlcXVlc3RdLCBwcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZyA9IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20oc2V0dGxlU2lnbmF0dXJlWzBdKSk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SGFzaCA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlUGVkZXJzZW5IYXNoKG5vbmNlLCB1c2VyQWRkcmVzcywgcHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ1gtUGhhbGEtU2lnbmF0dXJlLVR5cGUnOiAnU3RhbmRhbG9uZUFwaScsXG4gICAgICAgICAgICAgICAgQWRkcmVzczogdXNlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgRmVlOiBmZWUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAnSW5wdXQtRmVlJzogaW5wdXRGZWUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBOb25jZTogbm9uY2UudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAnUmVxdWVzdC1IYXNoJzogcmVxdWVzdEhhc2gsXG4gICAgICAgICAgICAgICAgU2lnbmF0dXJlOiBzaWcsXG4gICAgICAgICAgICAgICAgJ1ZMTE0tUHJveHknOiBgJHt2bGxtUHJveHl9YCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjYWxjdWxhdGVQZWRlcnNlbkhhc2gobm9uY2UsIHVzZXJBZGRyZXNzLCBwcm92aWRlckFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgQUREUl9MRU5HVEggPSAyMDtcbiAgICAgICAgY29uc3QgTk9OQ0VfTEVOR1RIID0gODtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKE5PTkNFX0xFTkdUSCArIEFERFJfTEVOR1RIICogMik7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCBub25jZUJ5dGVzID0gYmlnaW50VG9CeXRlcyhCaWdJbnQobm9uY2UpLCBOT05DRV9MRU5HVEgpO1xuICAgICAgICBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCwgTk9OQ0VfTEVOR1RIKS5zZXQobm9uY2VCeXRlcyk7XG4gICAgICAgIG9mZnNldCArPSBOT05DRV9MRU5HVEg7XG4gICAgICAgIG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgb2Zmc2V0LCBBRERSX0xFTkdUSCkuc2V0KGJpZ2ludFRvQnl0ZXMoQmlnSW50KHVzZXJBZGRyZXNzKSwgQUREUl9MRU5HVEgpKTtcbiAgICAgICAgb2Zmc2V0ICs9IEFERFJfTEVOR1RIO1xuICAgICAgICBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCwgQUREUl9MRU5HVEgpLnNldChiaWdpbnRUb0J5dGVzKEJpZ0ludChwcm92aWRlckFkZHJlc3MpLCBBRERSX0xFTkdUSCkpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShhd2FpdCBwZWRlcnNlbkhhc2goQnVmZmVyLmZyb20oYnVmZmVyKSkpO1xuICAgIH1cbiAgICBhc3luYyBjYWxjdWxhdGVJbnB1dEZlZXMoZXh0cmFjdG9yLCBjb250ZW50KSB7XG4gICAgICAgIGNvbnN0IHN2YyA9IGF3YWl0IGV4dHJhY3Rvci5nZXRTdmNJbmZvKCk7XG4gICAgICAgIGNvbnN0IGlucHV0Q291bnQgPSBhd2FpdCBleHRyYWN0b3IuZ2V0SW5wdXRDb3VudChjb250ZW50KTtcbiAgICAgICAgY29uc3QgaW5wdXRGZWUgPSBCaWdJbnQoaW5wdXRDb3VudCkgKiBzdmMuaW5wdXRQcmljZTtcbiAgICAgICAgcmV0dXJuIGlucHV0RmVlO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVDYWNoZWRGZWUocHJvdmlkZXIsIGZlZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY3VyRmVlID0gKGF3YWl0IHRoaXMuY2FjaGUuZ2V0SXRlbShwcm92aWRlciArICdfY2FjaGVkRmVlJykpIHx8IEJpZ0ludCgwKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2FjaGUuc2V0SXRlbShwcm92aWRlciArICdfY2FjaGVkRmVlJywgQmlnSW50KGN1ckZlZSkgKyBmZWUsIDEgKiA2MCAqIDEwMDAsIENhY2hlVmFsdWVUeXBlRW51bS5CaWdJbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY2xlYXJDYWNoZUZlZShwcm92aWRlciwgZmVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjdXJGZWUgPSAoYXdhaXQgdGhpcy5jYWNoZS5nZXRJdGVtKHByb3ZpZGVyICsgJ19jYWNoZWRGZWUnKSkgfHwgQmlnSW50KDApO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jYWNoZS5zZXRJdGVtKHByb3ZpZGVyLCBCaWdJbnQoY3VyRmVlKSArIGZlZSwgMSAqIDYwICogMTAwMCwgQ2FjaGVWYWx1ZVR5cGVFbnVtLkJpZ0ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2ZlciBmdW5kIGZyb20gbGVkZ2VyIGlmIGZ1bmQgaW4gdGhlIGluZmVyZW5jZSBhY2NvdW50IGlzIGxlc3MgdGhhbiBhIDUwMCAqIChpbnB1dFByaWNlICsgb3V0cHV0UHJpY2UpXG4gICAgICovXG4gICAgYXN5bmMgdG9wVXBBY2NvdW50SWZOZWVkZWQocHJvdmlkZXIsIGNvbnRlbnQsIGdhc1ByaWNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHJ1bm5pbmcgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXh0cmFjdG9yID0gYXdhaXQgdGhpcy5nZXRFeHRyYWN0b3IocHJvdmlkZXIpO1xuICAgICAgICAgICAgY29uc3Qgc3ZjID0gYXdhaXQgZXh0cmFjdG9yLmdldFN2Y0luZm8oKTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0YXJnZXQgYW5kIHRyaWdnZXIgdGhyZXNob2xkc1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0VGhyZXNob2xkID0gdGhpcy50b3BVcFRhcmdldFRocmVzaG9sZCAqIChzdmMuaW5wdXRQcmljZSArIHN2Yy5vdXRwdXRQcmljZSk7XG4gICAgICAgICAgICBjb25zdCB0cmlnZ2VyVGhyZXNob2xkID0gdGhpcy50b3BVcFRyaWdnZXJUaHJlc2hvbGQgKiAoc3ZjLmlucHV0UHJpY2UgKyBzdmMub3V0cHV0UHJpY2UpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyB0aGUgZmlyc3Qgcm91bmRcbiAgICAgICAgICAgIGNvbnN0IGlzRmlyc3RSb3VuZCA9IChhd2FpdCB0aGlzLmNhY2hlLmdldEl0ZW0oJ2ZpcnN0Um91bmQnKSkgIT09ICdmYWxzZSc7XG4gICAgICAgICAgICBpZiAoaXNGaXJzdFJvdW5kKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVGaXJzdFJvdW5kKHByb3ZpZGVyLCB0cmlnZ2VyVGhyZXNob2xkLCB0YXJnZXRUaHJlc2hvbGQsIGdhc1ByaWNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IGZlZSBhbmQgdXBkYXRlIGNhY2hlZCBmZWVcbiAgICAgICAgICAgIGNvbnN0IG5ld0ZlZSA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlSW5wdXRGZWVzKGV4dHJhY3RvciwgY29udGVudCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZUNhY2hlZEZlZShwcm92aWRlciwgbmV3RmVlKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gY2hlY2sgdGhlIGFjY291bnRcbiAgICAgICAgICAgIGlmICghKGF3YWl0IHRoaXMuc2hvdWxkQ2hlY2tBY2NvdW50KHN2YykpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIFJlLWNoZWNrIHRoZSBhY2NvdW50IGJhbGFuY2VcbiAgICAgICAgICAgIGNvbnN0IGFjYyA9IGF3YWl0IHRoaXMuY29udHJhY3QuZ2V0QWNjb3VudChwcm92aWRlcik7XG4gICAgICAgICAgICBjb25zdCBsb2NrZWRGdW5kID0gYWNjLmJhbGFuY2UgLSBhY2MucGVuZGluZ1JlZnVuZDtcbiAgICAgICAgICAgIGlmIChsb2NrZWRGdW5kIDwgdHJpZ2dlclRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubGVkZ2VyLnRyYW5zZmVyRnVuZChwcm92aWRlciwgJ2luZmVyZW5jZScsIHRhcmdldFRocmVzaG9sZCwgZ2FzUHJpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGVhckNhY2hlRmVlKHByb3ZpZGVyLCBuZXdGZWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlRmlyc3RSb3VuZChwcm92aWRlciwgdHJpZ2dlclRocmVzaG9sZCwgdGFyZ2V0VGhyZXNob2xkLCBnYXNQcmljZSkge1xuICAgICAgICBsZXQgbmVlZFRyYW5zZmVyID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhY2MgPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmdldEFjY291bnQocHJvdmlkZXIpO1xuICAgICAgICAgICAgY29uc3QgbG9ja2VkRnVuZCA9IGFjYy5iYWxhbmNlIC0gYWNjLnBlbmRpbmdSZWZ1bmQ7XG4gICAgICAgICAgICBuZWVkVHJhbnNmZXIgPSBsb2NrZWRGdW5kIDwgdHJpZ2dlclRocmVzaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICBuZWVkVHJhbnNmZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkVHJhbnNmZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubGVkZ2VyLnRyYW5zZmVyRnVuZChwcm92aWRlciwgJ2luZmVyZW5jZScsIHRhcmdldFRocmVzaG9sZCwgZ2FzUHJpY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hcmsgdGhlIGZpcnN0IHJvdW5kIGFzIGNvbXBsZXRlXG4gICAgICAgIGF3YWl0IHRoaXMuY2FjaGUuc2V0SXRlbSgnZmlyc3RSb3VuZCcsICdmYWxzZScsIDEwMDAwMDAwICogNjAgKiAxMDAwLCBDYWNoZVZhbHVlVHlwZUVudW0uT3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGUgY2FjaGUgZnVuZCBmb3IgdGhpcyBwcm92aWRlciwgcmV0dXJuIHRydWUgaWYgdGhlIGZ1bmQgaXMgYWJvdmUgMTAwMCAqIChpbnB1dFByaWNlICsgb3V0cHV0UHJpY2UpXG4gICAgICogQHBhcmFtIHN2Y1xuICAgICAqL1xuICAgIGFzeW5jIHNob3VsZENoZWNrQWNjb3VudChzdmMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHN2Yy5wcm92aWRlciArICdfY2FjaGVkRmVlJztcbiAgICAgICAgICAgIGNvbnN0IHVzZWRGdW5kID0gKGF3YWl0IHRoaXMuY2FjaGUuZ2V0SXRlbShrZXkpKSB8fCBCaWdJbnQoMCk7XG4gICAgICAgICAgICByZXR1cm4gKHVzZWRGdW5kID5cbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQWNjb3VudFRocmVzaG9sZCAqIChzdmMuaW5wdXRQcmljZSArIHN2Yy5vdXRwdXRQcmljZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQWNjb3VudFByb2Nlc3NvciBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZywgZGVwb3NpdGluZyBmdW5kcywgYW5kIHJldHJpZXZpbmcgMEcgU2VydmluZyBBY2NvdW50cy5cbiAqL1xuY2xhc3MgQWNjb3VudFByb2Nlc3NvciBleHRlbmRzIFpHU2VydmluZ1VzZXJCcm9rZXJCYXNlIHtcbiAgICBhc3luYyBnZXRBY2NvdW50KHByb3ZpZGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cmFjdC5nZXRBY2NvdW50KHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldEFjY291bnRXaXRoRGV0YWlsKHByb3ZpZGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbYWNjb3VudCwgbG9ja1RpbWVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJhY3QuZ2V0QWNjb3VudChwcm92aWRlciksXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cmFjdC5sb2NrVGltZSgpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBCaWdJbnQoTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkpO1xuICAgICAgICAgICAgY29uc3QgcmVmdW5kcyA9IGFjY291bnQucmVmdW5kc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHJlZnVuZCkgPT4gIXJlZnVuZC5wcm9jZXNzZWQpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocmVmdW5kKSA9PiByZWZ1bmQuYW1vdW50ICE9PSBCaWdJbnQoMCkpXG4gICAgICAgICAgICAgICAgLm1hcCgocmVmdW5kKSA9PiAoe1xuICAgICAgICAgICAgICAgIGFtb3VudDogcmVmdW5kLmFtb3VudCxcbiAgICAgICAgICAgICAgICByZW1haW5UaW1lOiBsb2NrVGltZSAtIChub3cgLSByZWZ1bmQuY3JlYXRlZEF0KSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBbYWNjb3VudCwgcmVmdW5kc107XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0QWNjb3VudCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyYWN0Lmxpc3RBY2NvdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgSW5mZXJlbmNlU2VydmluZ0NvbnRyYWN0IHtcbiAgICBzZXJ2aW5nO1xuICAgIHNpZ25lcjtcbiAgICBfdXNlckFkZHJlc3M7XG4gICAgY29uc3RydWN0b3Ioc2lnbmVyLCBjb250cmFjdEFkZHJlc3MsIHVzZXJBZGRyZXNzKSB7XG4gICAgICAgIHRoaXMuc2VydmluZyA9IEluZmVyZW5jZVNlcnZpbmdfX2ZhY3RvcnkuY29ubmVjdChjb250cmFjdEFkZHJlc3MsIHNpZ25lcik7XG4gICAgICAgIHRoaXMuc2lnbmVyID0gc2lnbmVyO1xuICAgICAgICB0aGlzLl91c2VyQWRkcmVzcyA9IHVzZXJBZGRyZXNzO1xuICAgIH1cbiAgICBsb2NrVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmluZy5sb2NrVGltZSgpO1xuICAgIH1cbiAgICBhc3luYyBsaXN0U2VydmljZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VzID0gYXdhaXQgdGhpcy5zZXJ2aW5nLmdldEFsbFNlcnZpY2VzKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VydmljZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0QWNjb3VudCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5zZXJ2aW5nLmdldEFsbEFjY291bnRzKCk7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudHM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRBY2NvdW50KHByb3ZpZGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gdGhpcy5nZXRVc2VyQWRkcmVzcygpO1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IHRoaXMuc2VydmluZy5nZXRBY2NvdW50KHVzZXIsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgYWNrbm93bGVkZ2VQcm92aWRlclNpZ25lcihwcm92aWRlckFkZHJlc3MsIHByb3ZpZGVyU2lnbmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuc2VydmluZy5hY2tub3dsZWRnZVByb3ZpZGVyU2lnbmVyKHByb3ZpZGVyQWRkcmVzcywgcHJvdmlkZXJTaWduZXIpO1xuICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcbiAgICAgICAgICAgIGlmICghcmVjZWlwdCB8fCByZWNlaXB0LnN0YXR1cyAhPT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFNlcnZpY2UocHJvdmlkZXJBZGRyZXNzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aW5nLmdldFNlcnZpY2UocHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFVzZXJBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlckFkZHJlc3M7XG4gICAgfVxufVxuXG4vKipcbiAqIE1FU1NBR0VfRk9SX0VOQ1JZUFRJT05fS0VZIGlzIGEgZml4ZWQgbWVzc2FnZSB1c2VkIHRvIGRlcml2ZSB0aGUgZW5jcnlwdGlvbiBrZXkuXG4gKlxuICogQmFja2dyb3VuZDpcbiAqIFRvIGVuc3VyZSBhIGNvbnNpc3RlbnQgYW5kIHVuaXF1ZSBlbmNyeXB0aW9uIGtleSBjYW4gYmUgZ2VuZXJhdGVkIGZyb20gYSB1c2VyJ3MgRXRoZXJldW0gd2FsbGV0LFxuICogd2UgdXRpbGl6ZSBhIGZpeGVkIG1lc3NhZ2UgY29tYmluZWQgd2l0aCBhIHNpZ25pbmcgbWVjaGFuaXNtLlxuICpcbiAqIFB1cnBvc2U6XG4gKiAtIFRoaXMgc3RyaW5nIGlzIHByb3ZpZGVkIHRvIHRoZSBFdGhlcmV1bSBzaWduaW5nIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgZGlnaXRhbCBzaWduYXR1cmUgYmFzZWQgb24gdGhlIHVzZXIncyBwcml2YXRlIGtleS5cbiAqIC0gVGhlIHByb2R1Y2VkIHNpZ25hdHVyZSBpcyB0aGVuIGhhc2hlZCAodXNpbmcgU0hBLTI1NikgdG8gY3JlYXRlIGEgY29uc2lzdGVudCAyNTYtYml0IGVuY3J5cHRpb24ga2V5IGZyb20gdGhlIHNhbWUgd2FsbGV0LlxuICogLSBUaGlzIHByb2Nlc3Mgb2ZmZXJzIGEgd2F5IHRvIHByb3RlY3QgZGF0YSB3aXRob3V0IHN0b3JpbmcgYWRkaXRpb25hbCBrZXlzLlxuICpcbiAqIE5vdGU6XG4gKiAtIFRoZSB1bmlxdWVuZXNzIGFuZCBzdGFiaWxpdHkgb2YgdGhpcyBtZXNzYWdlIGFyZSBjcnVjaWFsOyBkbyBub3QgY2hhbmdlIGl0IHVubGVzcyB5b3UgZnVsbHkgdW5kZXJzdGFuZCB0aGUgaW1wYWN0XG4gKiAgIG9uIHRoZSBrZXkgZGVyaXZhdGlvbiBhbmQgZW5jcnlwdGlvbiBwcm9jZXNzLlxuICogLSBCZWNhdXNlIHRoZSBzaWduYXR1cmUgaXMgZGVyaXZlZCBmcm9tIHRoZSB3YWxsZXQncyBwcml2YXRlIGtleSwgaXQgZW5zdXJlcyB0aGF0IGRpZmZlcmVudCB3YWxsZXRzIGNhbm5vdCBwcm9kdWNlIHRoZSBzYW1lIGtleS5cbiAqL1xuY29uc3QgWkdfUlBDX0VORFBPSU5UX1RFU1RORVQgPSAnaHR0cHM6Ly9ldm1ycGMtdGVzdG5ldC4wZy5haSc7XG5jb25zdCBJTkRFWEVSX1VSTF9UVVJCTyA9ICdodHRwOi8vNDcuMjUxLjQwLjE4OToxMjM0NSc7XG5jb25zdCBUT0tFTl9DT1VOVEVSX01FUktMRV9ST09UID0gJzB4NGU4YWUzNzkwOTIwYjk5NzEzOTdmMDg4ZmNmYWNiYjlkYWQwYzI4ZWMyODMxZjM3ZjM0ODE5MzNiMWZkYmRiYyc7XG5jb25zdCBUT0tFTl9DT1VOVEVSX0ZJTEVfSEFTSCA9ICcyNmFiMjY2YTEyYzljZTM0NjExYWJhM2Y4MmJhZjA1NmRjNjgzMTgxMjM2ZDVmYTE1ZWRiOGViOGM4ZGIzODcyJztcbmNvbnN0IE1PREVMX0hBU0hfTUFQID0ge1xuICAgICdkaXN0aWxiZXJ0LWJhc2UtdW5jYXNlZCc6IHtcbiAgICAgICAgdHVyYm86ICcweDdmMjI0NGIyNWNkMjIxOWRmZDlkMTRjMDUyOTgyZWNjZTQwOTM1NmUwZjA4ZTgzOWI3OTc5NmUyNzBkMTEwYTcnLFxuICAgICAgICBzdGFuZGFyZDogJycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnRGlzdGlsQkVSVCBpcyBhIHRyYW5zZm9ybWVycyBtb2RlbCwgc21hbGxlciBhbmQgZmFzdGVyIHRoYW4gQkVSVCwgd2hpY2ggd2FzIHByZXRyYWluZWQgb24gdGhlIHNhbWUgY29ycHVzIGluIGEgc2VsZi1zdXBlcnZpc2VkIGZhc2hpb24sIHVzaW5nIHRoZSBCRVJUIGJhc2UgbW9kZWwgYXMgYSB0ZWFjaGVyLiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGF0OiBodHRwczovL2h1Z2dpbmdmYWNlLmNvL2Rpc3RpbGJlcnQvZGlzdGlsYmVydC1iYXNlLXVuY2FzZWQnLFxuICAgICAgICB0b2tlbml6ZXI6ICcweDMzMTcxMjc2NzFhMzIxNzU4MzA2OTAwMWIyYTAwNDU0ZWY0ZDFlODM4ZjhmMWY0ZmZiZTY0ZGIwZWM3ZWQ5NjAnLFxuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgfSxcbiAgICAvLyBtb2JpbGVuZXRfdjI6IHtcbiAgICAvLyAgICAgdHVyYm86ICcweDg2NDU4MTZjMTdhOGE3MGViZjMyYmNjN2U2MjFjNjU5ZThkMDE1MGIxYTZiZmNhMjdmNDhmODMwMTBjNmQxMmUnLFxuICAgIC8vICAgICBzdGFuZGFyZDogJycsXG4gICAgLy8gICAgIGRlc2NyaXB0aW9uOlxuICAgIC8vICAgICAgICAgJ01vYmlsZU5ldCBWMiBtb2RlbCBwcmUtdHJhaW5lZCBvbiBJbWFnZU5ldC0xayBhdCByZXNvbHV0aW9uIDIyNHgyMjQuIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgYXQ6IGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZ29vZ2xlL21vYmlsZW5ldF92Ml8xLjBfMjI0JyxcbiAgICAvLyB0b2tlbml6ZXI6XG4gICAgLy8gICAgICcweGNmZGI0Y2YxOTk4MjlhM2NiZDQ1M2RkMzljZWE1YzMzN2EyOWQ0YmU1YTg3YmFkOTlkNzZmNWEzM2FjMmRmYmEnLFxuICAgIC8vIHR5cGU6ICdpbWFnZScsXG4gICAgLy8gfSxcbiAgICAvLyAnZGVlcHNlZWstcjEtZGlzdGlsbC1xd2VuLTEuNWInOiB7XG4gICAgLy8gICAgIHR1cmJvOiAnMHgyMDg0ZmRkOTA0YzlhMzMxN2RkZTk4MTQ3ZDRlNzc3OGE0MGUwNzZiNWIwZWI0NjlmN2E4ZjI3YWU1YjEzZTdmJyxcbiAgICAvLyAgICAgc3RhbmRhcmQ6ICcnLFxuICAgIC8vICAgICBkZXNjcmlwdGlvbjpcbiAgICAvLyAgICAgICAgICdEZWVwU2Vlay1SMS1aZXJvLCBhIG1vZGVsIHRyYWluZWQgdmlhIGxhcmdlLXNjYWxlIHJlaW5mb3JjZW1lbnQgbGVhcm5pbmcgKFJMKSB3aXRob3V0IHN1cGVydmlzZWQgZmluZS10dW5pbmcgKFNGVCkgYXMgYSBwcmVsaW1pbmFyeSBzdGVwLCBkZW1vbnN0cmF0ZWQgcmVtYXJrYWJsZSBwZXJmb3JtYW5jZSBvbiByZWFzb25pbmcuIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgYXQ6IGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGVlcHNlZWstYWkvRGVlcFNlZWstUjEtRGlzdGlsbC1Rd2VuLTEuNUInLFxuICAgIC8vIHRva2VuaXplcjpcbiAgICAvLyAgICAgJzB4MzgyODQyNTYxZTU5ZDcxZjkwYzE4NjEwNDE5ODk0MjhkZDJjMWY2NjRlNjVhNTZlYTIxZjNhZGUyMTZiMjA0NicsXG4gICAgLy8gdHlwZTogJ3RleHQnLFxuICAgIC8vIH0sXG4gICAgLy8gJ2NvY2t0YWlsc2dkLW9wdC0xLjNiJzoge1xuICAgIC8vICAgICB0dXJibzogJzB4MDJlZDZkMzg4OWJlYmFkOWUyY2Q0MDA4MDY2NDc4NjU0YzA4ODZiMTJhZDI1ZWE3Y2Y3ZDMxZGYzNDQxMTgyZScsXG4gICAgLy8gICAgIHN0YW5kYXJkOiAnJyxcbiAgICAvLyAgICAgZGVzY3JpcHRpb246XG4gICAgLy8gICAgICAgICAnQ29ja3RhaWxTR0Qtb3B0LTEuM0IgZmluZXR1bmVzIHRoZSBPcHQtMS4zQiBsYW5nYXVnZSBtb2RlbCB3aXRoIENvY2t0YWlsU0dELCB3aGljaCBpcyBhIG5vdmVsIGRpc3RyaWJ1dGVkIGZpbmV0dW5pbmcgZnJhbWV3b3JrLiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGF0OiBodHRwczovL2dpdGh1Yi5jb20vRFMzTGFiL0NvY2t0YWlsU0dEJyxcbiAgICAvLyAgICAgdG9rZW5pemVyOlxuICAgIC8vICAgICAgICAgJzB4NDU5MzExNTE3YmRlYjNhOTU1NDY2ZDRlNWUzOTY5NDRiMmZkYzY4ODkwZGU3OGY1MDYyNjFkOTVlNmQxYjAwMCcsXG4gICAgLy8gICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAvLyB9LFxuICAgIC8vIC8vIFRPRE86IHJlbW92ZVxuICAgIC8vICdtb2NrLW1vZGVsJzoge1xuICAgIC8vICAgICB0dXJibzogJzB4Y2I0MmI1Y2E5ZTk5OGM4MmRkMjM5ZWYyZDIwZDIyYTRhZTE2YjNkYzBjZTBhODU1YzkzYjUyYzdjMmJhYjZkYycsXG4gICAgLy8gICAgIHN0YW5kYXJkOiAnJyxcbiAgICAvLyAgICAgZGVzY3JpcHRpb246ICcnLFxuICAgIC8vICAgICB0b2tlbml6ZXI6XG4gICAgLy8gICAgICAgICAnMHgzODI4NDI1NjFlNTlkNzFmOTBjMTg2MTA0MTk4OTQyOGRkMmMxZjY2NGU2NWE1NmVhMjFmM2FkZTIxNmIyMDQ2JyxcbiAgICAvLyAgICAgdHlwZTogJ3RleHQnLFxuICAgIC8vIH0sXG59O1xuLy8gQXV0b21hdGFEY2FwQXR0ZXN0YXRpb24gZm9yIHF1b3RlIHZlcmlmaWNhdGlvblxuLy8gaHR0cHM6Ly9leHBsb3Jlci5hdGEubmV0d29yay9hZGRyZXNzLzB4RTI2RTExQjI1Nzg1NkIwYkVCYzRDNzU5YWFCRGRlYTcyQjY0MzUxRi9jb250cmFjdC82NTUzNl8yL3JlYWRDb250cmFjdCNGNlxuY29uc3QgQVVUT01BVEFfUlBDID0gJ2h0dHBzOi8vMXJwYy5pby9hdGEnO1xuY29uc3QgQVVUT01BVEFfQ09OVFJBQ1RfQUREUkVTUyA9ICcweEUyNkUxMUIyNTc4NTZCMGJFQmM0Qzc1OWFhQkRkZWE3MkI2NDM1MUYnO1xuY29uc3QgQVVUT01BVEFfQUJJID0gW1xuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdyYXdRdW90ZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICd2ZXJpZnlBbmRBdHRlc3RPbkNoYWluJyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnb3V0cHV0JyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbl07XG5cbmNsYXNzIEF1dG9tYXRhIHtcbiAgICBwcm92aWRlcjtcbiAgICBjb250cmFjdDtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEFVVE9NQVRBX1JQQyk7XG4gICAgICAgIHRoaXMuY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEFVVE9NQVRBX0NPTlRSQUNUX0FERFJFU1MsIEFVVE9NQVRBX0FCSSwgdGhpcy5wcm92aWRlcik7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeVF1b3RlKHJhd1F1b3RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbc3VjY2Vzc10gPSBhd2FpdCB0aGlzLmNvbnRyYWN0LnZlcmlmeUFuZEF0dGVzdE9uQ2hhaW4ocmF3UXVvdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBSZXF1ZXN0UHJvY2Vzc29yIGlzIGEgc3ViY2xhc3Mgb2YgWkdTZXJ2aW5nVXNlckJyb2tlci5cbiAqIEl0IG5lZWRzIHRvIGJlIGluaXRpYWxpemVkIHdpdGggY3JlYXRlWkdTZXJ2aW5nVXNlckJyb2tlclxuICogYmVmb3JlIHVzZS5cbiAqL1xuY2xhc3MgUmVxdWVzdFByb2Nlc3NvciBleHRlbmRzIFpHU2VydmluZ1VzZXJCcm9rZXJCYXNlIHtcbiAgICBhdXRvbWF0YTtcbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgbWV0YWRhdGEsIGNhY2hlLCBsZWRnZXIpIHtcbiAgICAgICAgc3VwZXIoY29udHJhY3QsIGxlZGdlciwgbWV0YWRhdGEsIGNhY2hlKTtcbiAgICAgICAgdGhpcy5hdXRvbWF0YSA9IG5ldyBBdXRvbWF0YSgpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZXJ2aWNlTWV0YWRhdGEocHJvdmlkZXJBZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCB0aGlzLmdldFNlcnZpY2UocHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuZHBvaW50OiBgJHtzZXJ2aWNlLnVybH0vdjEvcHJveHlgLFxuICAgICAgICAgICAgbW9kZWw6IHNlcnZpY2UubW9kZWwsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qXG4gICAgICogMS4gVG8gRW5zdXJlIE5vIEluc3VmZmljaWVudCBCYWxhbmNlIE9jY3Vycy5cbiAgICAgKlxuICAgICAqIFRoZSBwcm92aWRlciBzZXR0bGVzIGFjY291bnRzIHJlZ3VsYXJseS4gSW4gYWRkaXRpb24sIHdlIHdpbGwgYWRkIGEgcnVsZSB0byB0aGUgcHJvdmlkZXIncyBzZXR0bGVtZW50IGxvZ2ljOlxuICAgICAqIGlmIHRoZSBhY3R1YWwgYmFsYW5jZSBvZiB0aGUgY3VzdG9tZXIncyBhY2NvdW50IGlzIGxlc3MgdGhhbiA1MDAsIHNldHRsZW1lbnQgd2lsbCBiZSB0cmlnZ2VyZWQgaW1tZWRpYXRlbHkuXG4gICAgICogVGhlIGFjdHVhbCBiYWxhbmNlIGlzIGRlZmluZWQgYXMgdGhlIGN1c3RvbWVyJ3MgaW5mZXJlbmNlIGFjY291bnQgYmFsYW5jZSBtaW51cyBhbnkgdW5zZXR0bGVkIGFtb3VudHMuXG4gICAgICpcbiAgICAgKiBUaGlzIHdheSwgaWYgdGhlIGN1c3RvbWVyIGNoZWNrcyB0aGVpciBhY2NvdW50IGFuZCBzZWVzIGEgYmFsYW5jZSBncmVhdGVyIHRoYW4gNTAwLCBldmVuIGlmIHRoZSBwcm92aWRlciBzZXR0bGVzXG4gICAgICogaW1tZWRpYXRlbHksIHRoZSBkZWR1Y3Rpb24gd2lsbCBsZWF2ZSBhYm91dCA1MDAsIGVuc3VyaW5nIHRoYXQgbm8gaW5zdWZmaWNpZW50IGJhbGFuY2Ugc2l0dWF0aW9uIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIDIuIFRvIEF2b2lkIEZyZXF1ZW50IFRyYW5zZmVyc1xuICAgICAqXG4gICAgICogT24gdGhlIGN1c3RvbWVyJ3Mgc2lkZSwgaWYgdGhlIGJhbGFuY2UgZmFsbHMgYmVsb3cgNTAwLCBpdCBzaG91bGQgYmUgdG9wcGVkIHVwIHRvIDEwMDAuIFRoaXMgaXMgdG8gYXZvaWQgZnJlcXVlbnRcbiAgICAgKiB0cmFuc2ZlcnMuXG4gICAgICpcbiAgICAgKiAzLiBUbyBBdm9pZCBIYXZpbmcgdG8gQ2hlY2sgdGhlIEJhbGFuY2Ugb24gRXZlcnkgQ3VzdG9tZXIgUmVxdWVzdFxuICAgICAqXG4gICAgICogUmVjb3JkIGV4cGVuZGl0dXJlcyBpbiBwcm9jZXNzUmVzcG9uc2UgYW5kIG1haW50YWluIGEgdG90YWwgY29uc3VtcHRpb24gYW1vdW50LiBFdmVyeSB0aW1lIHRoZSB0b3RhbCBleHBlbmRpdHVyZVxuICAgICAqIHJlYWNoZXMgMTAwMCwgcmVjaGVjayB0aGUgYmFsYW5jZSBhbmQgcGVyZm9ybSBhIHRyYW5zZmVyIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIHBzOiBUaGUgdW5pdHMgZm9yIDUwMCBhbmQgMTAwMCBjYW4gYmUgKHNlcnZpY2UuaW5wdXRQcmljZVBlclRva2VuICsgc2VydmljZS5vdXRwdXRQcmljZVBlclRva2VuKS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0SGVhZGVycyhwcm92aWRlckFkZHJlc3MsIGNvbnRlbnQsIHZsbG1Qcm94eSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50b3BVcEFjY291bnRJZk5lZWRlZChwcm92aWRlckFkZHJlc3MsIGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKHZsbG1Qcm94eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmxsbVByb3h5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEhlYWRlcihwcm92aWRlckFkZHJlc3MsIGNvbnRlbnQsIEJpZ0ludCgwKSwgdmxsbVByb3h5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGFja25vd2xlZGdlUHJvdmlkZXJTaWduZXIocHJvdmlkZXJBZGRyZXNzLCBnYXNQcmljZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNvbnRyYWN0LmdldEFjY291bnQocHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxlZGdlci50cmFuc2ZlckZ1bmQocHJvdmlkZXJBZGRyZXNzLCAnaW5mZXJlbmNlJywgQmlnSW50KDApLCBnYXNQcmljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgeyBxdW90ZSwgcHJvdmlkZXJfc2lnbmVyLCBrZXkgfSA9IGF3YWl0IHRoaXMuZ2V0UXVvdGUocHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgICAgIGlmICghcXVvdGUgfHwgIXByb3ZpZGVyX3NpZ25lcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBxdW90ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFxdW90ZS5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSAnMHgnICsgcXVvdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25zdCBycGMgPSBwcm9jZXNzLmVudi5SUENfRU5EUE9JTlRcbiAgICAgICAgICAgIC8vIGJ5cGFzcyBxdW90ZSB2ZXJpZmljYXRpb24gaWYgdGVzdGluZyBvbiBsb2NhbGhvc3RcbiAgICAgICAgICAgIC8vIGlmICghcnBjIHx8ICEvbG9jYWxob3N0fDEyN1xcLjBcXC4wXFwuMS8udGVzdChycGMpKSB7XG4gICAgICAgICAgICAvLyAgICAgY29uc3QgaXNWZXJpZmllZCA9IGF3YWl0IHRoaXMuYXV0b21hdGEudmVyaWZ5UXVvdGUocXVvdGUpXG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coJ1F1b3RlIHZlcmlmaWNhdGlvbjonLCBpc1ZlcmlmaWVkKVxuICAgICAgICAgICAgLy8gICAgIGlmICghaXNWZXJpZmllZCkge1xuICAgICAgICAgICAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1b3RlIHZlcmlmaWNhdGlvbiBmYWlsZWQnKVxuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vICAgICBpZiAobnZpZGlhX3BheWxvYWQpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgY29uc3Qgc3ZjID0gYXdhaXQgdGhpcy5nZXRTZXJ2aWNlKHByb3ZpZGVyQWRkcmVzcylcbiAgICAgICAgICAgIC8vICAgICAgICAgY29uc3QgdmFsaWQgPSBhd2FpdCBWZXJpZmllci52ZXJpZnlSQShcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHN2Yy51cmwsXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICBudmlkaWFfcGF5bG9hZFxuICAgICAgICAgICAgLy8gICAgICAgICApXG4gICAgICAgICAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKCdudmlkaWEgcGF5bG9hZCB2ZXJpZmljYXRpb246JywgdmFsaWQpXG4gICAgICAgICAgICAvLyAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbnZpZGlhIHBheWxvYWQgdmVyaWZ5IGZhaWxlZCcpXG4gICAgICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5jb250cmFjdC5nZXRBY2NvdW50KHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAoYWNjb3VudC5wcm92aWRlclB1YktleVswXSA9PT0ga2V5WzBdICYmXG4gICAgICAgICAgICAgICAgYWNjb3VudC5wcm92aWRlclB1YktleVsxXSA9PT0ga2V5WzFdKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1Byb3ZpZGVyIHNpZ25lciBhbHJlYWR5IGFja25vd2xlZGdlZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY29udHJhY3QuYWNrbm93bGVkZ2VQcm92aWRlclNpZ25lcihwcm92aWRlckFkZHJlc3MsIGtleSk7XG4gICAgICAgICAgICBjb25zdCB1c2VyQWRkcmVzcyA9IHRoaXMuY29udHJhY3QuZ2V0VXNlckFkZHJlc3MoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7dXNlckFkZHJlc3N9XyR7cHJvdmlkZXJBZGRyZXNzfV9hY2tgO1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXRJdGVtKGNhY2hlS2V5LCBrZXksIDEgKiA2MCAqIDEwMDAsIENhY2hlVmFsdWVUeXBlRW51bS5PdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIFZlcmlmaWFiaWxpdHlFbnVtO1xuKGZ1bmN0aW9uIChWZXJpZmlhYmlsaXR5RW51bSkge1xuICAgIFZlcmlmaWFiaWxpdHlFbnVtW1wiT3BNTFwiXSA9IFwiT3BNTFwiO1xuICAgIFZlcmlmaWFiaWxpdHlFbnVtW1wiVGVlTUxcIl0gPSBcIlRlZU1MXCI7XG4gICAgVmVyaWZpYWJpbGl0eUVudW1bXCJaS01MXCJdID0gXCJaS01MXCI7XG59KShWZXJpZmlhYmlsaXR5RW51bSB8fCAoVmVyaWZpYWJpbGl0eUVudW0gPSB7fSkpO1xubGV0IE1vZGVsUHJvY2Vzc29yJDEgPSBjbGFzcyBNb2RlbFByb2Nlc3NvciBleHRlbmRzIFpHU2VydmluZ1VzZXJCcm9rZXJCYXNlIHtcbiAgICBhc3luYyBsaXN0U2VydmljZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VzID0gYXdhaXQgdGhpcy5jb250cmFjdC5saXN0U2VydmljZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2VzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZnVuY3Rpb24gaXNWZXJpZmlhYmlsaXR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoVmVyaWZpYWJpbGl0eUVudW0pLmluY2x1ZGVzKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgVmVyaWZpZXIgY2xhc3MgY29udGFpbnMgbWV0aG9kcyBmb3IgdmVyaWZ5aW5nIHNlcnZpY2UgcmVsaWFiaWxpdHkuXG4gKi9cbmNsYXNzIFZlcmlmaWVyIGV4dGVuZHMgWkdTZXJ2aW5nVXNlckJyb2tlckJhc2Uge1xuICAgIGFzeW5jIHZlcmlmeVNlcnZpY2UocHJvdmlkZXJBZGRyZXNzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IHZhbGlkIH0gPSBhd2FpdCB0aGlzLmdldFNpZ25pbmdBZGRyZXNzKHByb3ZpZGVyQWRkcmVzcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRTaWduaW5nQWRkcmVzcyB2ZXJpZmllcyB3aGV0aGVyIHRoZSBzaWduaW5nIGFkZHJlc3NcbiAgICAgKiBvZiB0aGUgc2lnbmVyIGNvcnJlc3BvbmRzIHRvIGEgdmFsaWQgUkEuXG4gICAgICpcbiAgICAgKiBJdCBhbHNvIHN0b3JlcyB0aGUgc2lnbmluZyBhZGRyZXNzIG9mIHRoZSBSQSBpblxuICAgICAqIGxvY2FsU3RvcmFnZSBhbmQgcmV0dXJucyBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm92aWRlckFkZHJlc3MgLSBwcm92aWRlciBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB2ZXJpZnlSQSAtIHdoZXRoZXIgdG8gdmVyaWZ5IHRoZSBSQe+8jCBkZWZhdWx0IGlzIGZhbHNlLlxuICAgICAqIEByZXR1cm5zIFRoZSBmaXJzdCByZXR1cm4gdmFsdWUgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIFJBIGlzIHZhbGlkLFxuICAgICAqIGFuZCB0aGUgc2Vjb25kIHJldHVybiB2YWx1ZSBpbmRpY2F0ZXMgdGhlIHNpZ25pbmcgYWRkcmVzcyBvZiB0aGUgUkEuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2lnbmluZ0FkZHJlc3MocHJvdmlkZXJBZGRyZXNzLCB2ZXJpZnlSQSA9IGZhbHNlLCB2bGxtUHJveHkgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGAke3RoaXMuY29udHJhY3QuZ2V0VXNlckFkZHJlc3MoKX1fJHtwcm92aWRlckFkZHJlc3N9YDtcbiAgICAgICAgbGV0IHNpZ25pbmdLZXkgPSBhd2FpdCB0aGlzLm1ldGFkYXRhLmdldFNpZ25pbmdLZXkoa2V5KTtcbiAgICAgICAgaWYgKCF2ZXJpZnlSQSAmJiBzaWduaW5nS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbGlkOiBudWxsLFxuICAgICAgICAgICAgICAgIHNpZ25pbmdBZGRyZXNzOiBzaWduaW5nS2V5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXh0cmFjdG9yID0gYXdhaXQgdGhpcy5nZXRFeHRyYWN0b3IocHJvdmlkZXJBZGRyZXNzLCBmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBzdmMgPSBhd2FpdCBleHRyYWN0b3IuZ2V0U3ZjSW5mbygpO1xuICAgICAgICAgICAgbGV0IHNpZ25lclJBID0ge1xuICAgICAgICAgICAgICAgIHNpZ25pbmdfYWRkcmVzczogJycsXG4gICAgICAgICAgICAgICAgbnZpZGlhX3BheWxvYWQ6ICcnLFxuICAgICAgICAgICAgICAgIGludGVsX3F1b3RlOiAnJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodmxsbVByb3h5KSB7XG4gICAgICAgICAgICAgICAgc2lnbmVyUkEgPSBhd2FpdCBWZXJpZmllci5mZXRTaWduZXJSQShzdmMudXJsLCBzdmMubW9kZWwpO1xuICAgICAgICAgICAgICAgIGlmICghc2lnbmVyUkE/LnNpZ25pbmdfYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25pbmcgYWRkcmVzcyBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcXVvdGUsIHByb3ZpZGVyX3NpZ25lciwgbnZpZGlhX3BheWxvYWQgfSA9IGF3YWl0IHRoaXMuZ2V0UXVvdGUocHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBzaWduZXJSQSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmluZ19hZGRyZXNzOiBwcm92aWRlcl9zaWduZXIsXG4gICAgICAgICAgICAgICAgICAgIG52aWRpYV9wYXlsb2FkOiBudmlkaWFfcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZWxfcXVvdGU6IHF1b3RlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWduaW5nS2V5ID0gYCR7dGhpcy5jb250cmFjdC5nZXRVc2VyQWRkcmVzcygpfV8ke3Byb3ZpZGVyQWRkcmVzc31gO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5tZXRhZGF0YS5zdG9yZVNpZ25pbmdLZXkoc2lnbmluZ0tleSwgc2lnbmVyUkEuc2lnbmluZ19hZGRyZXNzKTtcbiAgICAgICAgICAgIC8vIFRPRE86IHVzZSBpbnRlbF9xdW90ZSB0byB2ZXJpZnkgc2lnbmluZyBhZGRyZXNzXG4gICAgICAgICAgICBjb25zdCB2YWxpZCA9IGF3YWl0IFZlcmlmaWVyLnZlcmlmeVJBKHN2Yy51cmwsIHNpZ25lclJBLm52aWRpYV9wYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsaWQsXG4gICAgICAgICAgICAgICAgc2lnbmluZ0FkZHJlc3M6IHNpZ25lclJBLnNpZ25pbmdfYWRkcmVzcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRTaWduZXJSYURvd25sb2FkTGluayhwcm92aWRlckFkZHJlc3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN2YyA9IGF3YWl0IHRoaXMuZ2V0U2VydmljZShwcm92aWRlckFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIGAke3N2Yy51cmx9L3YxL3Byb3h5L2F0dGVzdGF0aW9uL3JlcG9ydGA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRDaGF0U2lnbmF0dXJlRG93bmxvYWRMaW5rKHByb3ZpZGVyQWRkcmVzcywgY2hhdElEKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdmMgPSBhd2FpdCB0aGlzLmdldFNlcnZpY2UocHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBgJHtzdmMudXJsfS92MS9wcm94eS9zaWduYXR1cmUvJHtjaGF0SUR9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyB2ZXJpZnlSQShwcm92aWRlckJyb2tlclVSTCwgbnZpZGlhX3BheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKGAke3Byb3ZpZGVyQnJva2VyVVJMfS92MS9xdW90ZS92ZXJpZnkvZ3B1YCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShudmlkaWFfcGF5bG9hZCksXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2ZXJpZnkgUkEgZXJyb3I6IDQwNCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGZldFNpZ25lclJBKHByb3ZpZGVyQnJva2VyVVJMLCBtb2RlbCkge1xuICAgICAgICByZXR1cm4gZmV0Y2goYCR7cHJvdmlkZXJCcm9rZXJVUkx9L3YxL3Byb3h5L2F0dGVzdGF0aW9uL3JlcG9ydD9tb2RlbD0ke21vZGVsfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGRhdGEubnZpZGlhX3BheWxvYWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLm52aWRpYV9wYXlsb2FkID0gSlNPTi5wYXJzZShkYXRhLm52aWRpYV9wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdwYXJzaW5nIG52aWRpYV9wYXlsb2FkIGVycm9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuaW50ZWxfcXVvdGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmludGVsX3F1b3RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICcweCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGRhdGEuaW50ZWxfcXVvdGUsICdiYXNlNjQnKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigncGFyc2luZyBpbnRlbF9xdW90ZSBlcnJvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZmV0U2lnbmF0dXJlQnlDaGF0SUQocHJvdmlkZXJCcm9rZXJVUkwsIGNoYXRJRCwgbW9kZWwsIHZsbG1Qcm94eSkge1xuICAgICAgICByZXR1cm4gZmV0Y2goYCR7cHJvdmlkZXJCcm9rZXJVUkx9L3YxL3Byb3h5L3NpZ25hdHVyZS8ke2NoYXRJRH0/bW9kZWw9JHttb2RlbH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgJ1ZMTE0tUHJveHknOiBgJHt2bGxtUHJveHl9YCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldHRpbmcgc2lnbmF0dXJlIGVycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgdmVyaWZ5U2lnbmF0dXJlKG1lc3NhZ2UsIHNpZ25hdHVyZSwgZXhwZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VIYXNoID0gZXRoZXJzLmhhc2hNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCByZWNvdmVyZWRBZGRyZXNzID0gZXRoZXJzLnJlY292ZXJBZGRyZXNzKG1lc3NhZ2VIYXNoLCBzaWduYXR1cmUpO1xuICAgICAgICByZXR1cm4gcmVjb3ZlcmVkQWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBleHBlY3RlZEFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVzcG9uc2VQcm9jZXNzb3IgaXMgYSBzdWJjbGFzcyBvZiBaR1NlcnZpbmdVc2VyQnJva2VyLlxuICogSXQgbmVlZHMgdG8gYmUgaW5pdGlhbGl6ZWQgd2l0aCBjcmVhdGVaR1NlcnZpbmdVc2VyQnJva2VyXG4gKiBiZWZvcmUgdXNlLlxuICovXG5jbGFzcyBSZXNwb25zZVByb2Nlc3NvciBleHRlbmRzIFpHU2VydmluZ1VzZXJCcm9rZXJCYXNlIHtcbiAgICB2ZXJpZmllcjtcbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgbGVkZ2VyLCBtZXRhZGF0YSwgY2FjaGUpIHtcbiAgICAgICAgc3VwZXIoY29udHJhY3QsIGxlZGdlciwgbWV0YWRhdGEsIGNhY2hlKTtcbiAgICAgICAgdGhpcy52ZXJpZmllciA9IG5ldyBWZXJpZmllcihjb250cmFjdCwgbGVkZ2VyLCBtZXRhZGF0YSwgY2FjaGUpO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzUmVzcG9uc2UocHJvdmlkZXJBZGRyZXNzLCBjb250ZW50LCBjaGF0SUQsIHZsbG1Qcm94eSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXh0cmFjdG9yID0gYXdhaXQgdGhpcy5nZXRFeHRyYWN0b3IocHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEZlZSA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlT3V0cHV0RmVlcyhleHRyYWN0b3IsIGNvbnRlbnQpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVDYWNoZWRGZWUocHJvdmlkZXJBZGRyZXNzLCBvdXRwdXRGZWUpO1xuICAgICAgICAgICAgY29uc3Qgc3ZjID0gYXdhaXQgZXh0cmFjdG9yLmdldFN2Y0luZm8oKTtcbiAgICAgICAgICAgIGlmICghaXNWZXJpZmlhYmlsaXR5KHN2Yy52ZXJpZmlhYmlsaXR5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2hhdElEKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGF0IElEIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmxsbVByb3h5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2bGxtUHJveHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNpbmdlclJBVmVyaWZpY2F0aW9uUmVzdWx0ID0gYXdhaXQgdGhpcy52ZXJpZmllci5nZXRTaWduaW5nQWRkcmVzcyhwcm92aWRlckFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKCFzaW5nZXJSQVZlcmlmaWNhdGlvblJlc3VsdC52YWxpZCkge1xuICAgICAgICAgICAgICAgIHNpbmdlclJBVmVyaWZpY2F0aW9uUmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy52ZXJpZmllci5nZXRTaWduaW5nQWRkcmVzcyhwcm92aWRlckFkZHJlc3MsIHRydWUsIHZsbG1Qcm94eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNpbmdlclJBVmVyaWZpY2F0aW9uUmVzdWx0LnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaWduaW5nIGFkZHJlc3MgaXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgUmVzcG9uc2VTaWduYXR1cmUgPSBhd2FpdCBWZXJpZmllci5mZXRTaWduYXR1cmVCeUNoYXRJRChzdmMudXJsLCBjaGF0SUQsIHN2Yy5tb2RlbCwgdmxsbVByb3h5KTtcbiAgICAgICAgICAgIHJldHVybiBWZXJpZmllci52ZXJpZnlTaWduYXR1cmUoUmVzcG9uc2VTaWduYXR1cmUudGV4dCwgUmVzcG9uc2VTaWduYXR1cmUuc2lnbmF0dXJlLCBzaW5nZXJSQVZlcmlmaWNhdGlvblJlc3VsdC5zaWduaW5nQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjYWxjdWxhdGVPdXRwdXRGZWVzKGV4dHJhY3RvciwgY29udGVudCkge1xuICAgICAgICBjb25zdCBzdmMgPSBhd2FpdCBleHRyYWN0b3IuZ2V0U3ZjSW5mbygpO1xuICAgICAgICBjb25zdCBvdXRwdXRDb3VudCA9IGF3YWl0IGV4dHJhY3Rvci5nZXRPdXRwdXRDb3VudChjb250ZW50KTtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChvdXRwdXRDb3VudCkgKiBzdmMub3V0cHV0UHJpY2U7XG4gICAgfVxufVxuXG5jbGFzcyBJbmZlcmVuY2VCcm9rZXIge1xuICAgIHJlcXVlc3RQcm9jZXNzb3I7XG4gICAgcmVzcG9uc2VQcm9jZXNzb3I7XG4gICAgdmVyaWZpZXI7XG4gICAgYWNjb3VudFByb2Nlc3NvcjtcbiAgICBtb2RlbFByb2Nlc3NvcjtcbiAgICBzaWduZXI7XG4gICAgY29udHJhY3RBZGRyZXNzO1xuICAgIGxlZGdlcjtcbiAgICBjb25zdHJ1Y3RvcihzaWduZXIsIGNvbnRyYWN0QWRkcmVzcywgbGVkZ2VyKSB7XG4gICAgICAgIHRoaXMuc2lnbmVyID0gc2lnbmVyO1xuICAgICAgICB0aGlzLmNvbnRyYWN0QWRkcmVzcyA9IGNvbnRyYWN0QWRkcmVzcztcbiAgICAgICAgdGhpcy5sZWRnZXIgPSBsZWRnZXI7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGxldCB1c2VyQWRkcmVzcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVzZXJBZGRyZXNzID0gYXdhaXQgdGhpcy5zaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgSW5mZXJlbmNlU2VydmluZ0NvbnRyYWN0KHRoaXMuc2lnbmVyLCB0aGlzLmNvbnRyYWN0QWRkcmVzcywgdXNlckFkZHJlc3MpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBNZXRhZGF0YSgpO1xuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBDYWNoZSgpO1xuICAgICAgICB0aGlzLnJlcXVlc3RQcm9jZXNzb3IgPSBuZXcgUmVxdWVzdFByb2Nlc3Nvcihjb250cmFjdCwgbWV0YWRhdGEsIGNhY2hlLCB0aGlzLmxlZGdlcik7XG4gICAgICAgIHRoaXMucmVzcG9uc2VQcm9jZXNzb3IgPSBuZXcgUmVzcG9uc2VQcm9jZXNzb3IoY29udHJhY3QsIHRoaXMubGVkZ2VyLCBtZXRhZGF0YSwgY2FjaGUpO1xuICAgICAgICB0aGlzLmFjY291bnRQcm9jZXNzb3IgPSBuZXcgQWNjb3VudFByb2Nlc3Nvcihjb250cmFjdCwgdGhpcy5sZWRnZXIsIG1ldGFkYXRhLCBjYWNoZSk7XG4gICAgICAgIHRoaXMubW9kZWxQcm9jZXNzb3IgPSBuZXcgTW9kZWxQcm9jZXNzb3IkMShjb250cmFjdCwgdGhpcy5sZWRnZXIsIG1ldGFkYXRhLCBjYWNoZSk7XG4gICAgICAgIHRoaXMudmVyaWZpZXIgPSBuZXcgVmVyaWZpZXIoY29udHJhY3QsIHRoaXMubGVkZ2VyLCBtZXRhZGF0YSwgY2FjaGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIHNlcnZpY2VzIGZyb20gdGhlIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2VydmljZVN0cnVjdE91dHB1dFtdPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgU2VydmljZVN0cnVjdE91dHB1dCBvYmplY3RzLlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIHNlcnZpY2UgbGlzdCBjYW5ub3QgYmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIGxpc3RTZXJ2aWNlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubW9kZWxQcm9jZXNzb3IubGlzdFNlcnZpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGFjY291bnQgaW5mb3JtYXRpb24gZm9yIGEgZ2l2ZW4gcHJvdmlkZXIgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlckFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgcHJvdmlkZXIgaWRlbnRpZnlpbmcgdGhlIGFjY291bnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgYWNjb3VudCBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgYWNjb3VudCByZXRyaWV2YWwgcHJvY2VzcyBmYWlscy5cbiAgICAgKi9cbiAgICBnZXRBY2NvdW50ID0gYXN5bmMgKHByb3ZpZGVyQWRkcmVzcykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWNjb3VudFByb2Nlc3Nvci5nZXRBY2NvdW50KHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZ2V0QWNjb3VudFdpdGhEZXRhaWwgPSBhc3luYyAocHJvdmlkZXJBZGRyZXNzKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5hY2NvdW50UHJvY2Vzc29yLmdldEFjY291bnRXaXRoRGV0YWlsKHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogY2hlY2tzIGlmIHRoZSB1c2VyIGhhcyBhY2tub3dsZWRnZWQgdGhlIHByb3ZpZGVyIHNpZ25lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlckFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgcHJvdmlkZXIuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHVzZXJcbiAgICAgKiBoYXMgYWNrbm93bGVkZ2VkIHRoZSBwcm92aWRlciBzaWduZXIuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBhY2tub3dsZWRnbWVudCBjaGVjayBmYWlscy5cbiAgICAgKi9cbiAgICB1c2VyQWNrbm93bGVkZ2VkID0gYXN5bmMgKHByb3ZpZGVyQWRkcmVzcykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdFByb2Nlc3Nvci51c2VyQWNrbm93bGVkZ2VkKHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWNrbm93bGVkZ2UgdGhlIGdpdmVuIHByb3ZpZGVyIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJBZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHByb3ZpZGVyIGlkZW50aWZ5aW5nIHRoZSBhY2NvdW50LlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgZmFpbGVkIHRvIGFja25vd2xlZGdlLlxuICAgICAqL1xuICAgIGFja25vd2xlZGdlUHJvdmlkZXJTaWduZXIgPSBhc3luYyAocHJvdmlkZXJBZGRyZXNzLCBnYXNQcmljZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdFByb2Nlc3Nvci5hY2tub3dsZWRnZVByb3ZpZGVyU2lnbmVyKHByb3ZpZGVyQWRkcmVzcywgZ2FzUHJpY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyByZXF1ZXN0IG1ldGFkYXRhIGZvciB0aGUgcHJvdmlkZXIgc2VydmljZS5cbiAgICAgKiBJbmNsdWRlczpcbiAgICAgKiAxLiBSZXF1ZXN0IGVuZHBvaW50IGZvciB0aGUgcHJvdmlkZXIgc2VydmljZVxuICAgICAqIDIuIE1vZGVsIGluZm9ybWF0aW9uIGZvciB0aGUgcHJvdmlkZXIgc2VydmljZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVyQWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsgZW5kcG9pbnQsIG1vZGVsIH0gLSBPYmplY3QgY29udGFpbmluZyBlbmRwb2ludCBhbmQgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGVycm9ycyBvY2N1ciBkdXJpbmcgdGhlIHByb2Nlc3Npbmcgb2YgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0U2VydmljZU1ldGFkYXRhID0gYXN5bmMgKHByb3ZpZGVyQWRkcmVzcykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdFByb2Nlc3Nvci5nZXRTZXJ2aWNlTWV0YWRhdGEocHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRSZXF1ZXN0SGVhZGVycyBnZW5lcmF0ZXMgYmlsbGluZy1yZWxhdGVkIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogd2hlbiB0aGUgdXNlciB1c2VzIHRoZSBwcm92aWRlciBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogSW4gdGhlIDBHIFNlcnZpbmcgc3lzdGVtLCBhIHJlcXVlc3Qgd2l0aCB2YWxpZCBiaWxsaW5nIGhlYWRlcnNcbiAgICAgKiBpcyBjb25zaWRlcmVkIGEgc2V0dGxlbWVudCBwcm9vZiBhbmQgd2lsbCBiZSB1c2VkIGJ5IHRoZSBwcm92aWRlclxuICAgICAqIGZvciBjb250cmFjdCBzZXR0bGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVyQWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAtIFRoZSBjb250ZW50IGJlaW5nIGJpbGxlZC4gRm9yIGV4YW1wbGUsIGluIGEgY2hhdGJvdCBzZXJ2aWNlLCBpdCBpcyB0aGUgdGV4dCBpbnB1dCBieSB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZsbG1Qcm94eSAtIENoYXQgc2lnbmF0dXJlIHByb3h5LCBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBoZWFkZXJzLiBSZWNvcmRzIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHJlcXVlc3QgZmVlIGFuZCB1c2VyIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCB7IGVuZHBvaW50LCBtb2RlbCB9ID0gYXdhaXQgYnJva2VyLmdldFNlcnZpY2VNZXRhZGF0YShcbiAgICAgKiAgIHByb3ZpZGVyQWRkcmVzcyxcbiAgICAgKiAgIHNlcnZpY2VOYW1lLFxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiBjb25zdCBoZWFkZXJzID0gYXdhaXQgYnJva2VyLmdldFNlcnZpY2VNZXRhZGF0YShcbiAgICAgKiAgIHByb3ZpZGVyQWRkcmVzcyxcbiAgICAgKiAgIHNlcnZpY2VOYW1lLFxuICAgICAqICAgY29udGVudCxcbiAgICAgKiApO1xuICAgICAqXG4gICAgICogY29uc3Qgb3BlbmFpID0gbmV3IE9wZW5BSSh7XG4gICAgICogICBiYXNlVVJMOiBlbmRwb2ludCxcbiAgICAgKiAgIGFwaUtleTogXCJcIixcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnN0IGNvbXBsZXRpb24gPSBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoXG4gICAgICogICB7XG4gICAgICogICAgIG1lc3NhZ2VzOiBbeyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50IH1dLFxuICAgICAqICAgICBtb2RlbCxcbiAgICAgKiAgIH0sXG4gICAgICogICBoZWFkZXJzOiB7XG4gICAgICogICAgIC4uLmhlYWRlcnMsXG4gICAgICogICB9LFxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGVycm9ycyBvY2N1ciBkdXJpbmcgdGhlIHByb2Nlc3Npbmcgb2YgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0UmVxdWVzdEhlYWRlcnMgPSBhc3luYyAocHJvdmlkZXJBZGRyZXNzLCBjb250ZW50LCB2bGxtUHJveHkpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcXVlc3RQcm9jZXNzb3IuZ2V0UmVxdWVzdEhlYWRlcnMocHJvdmlkZXJBZGRyZXNzLCBjb250ZW50LCB2bGxtUHJveHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHByb2Nlc3NSZXNwb25zZSBpcyB1c2VkIGFmdGVyIHRoZSB1c2VyIHN1Y2Nlc3NmdWxseSBvYnRhaW5zIGEgcmVzcG9uc2UgZnJvbSB0aGUgcHJvdmlkZXIgc2VydmljZS5cbiAgICAgKlxuICAgICAqIEl0IHdpbGwgc2V0dGxlIHRoZSBmZWUgZm9yIHRoZSByZXNwb25zZSBjb250ZW50LiBBZGRpdGlvbmFsbHksIGlmIHRoZSBzZXJ2aWNlIGlzIHZlcmlmaWFibGUsXG4gICAgICogaW5wdXQgdGhlIGNoYXQgSUQgZnJvbSB0aGUgcmVzcG9uc2UgYW5kIHByb2Nlc3NSZXNwb25zZSB3aWxsIGRldGVybWluZSB0aGUgdmFsaWRpdHkgb2YgdGhlXG4gICAgICogcmV0dXJuZWQgY29udGVudCBieSBjaGVja2luZyB0aGUgcHJvdmlkZXIgc2VydmljZSdzIHJlc3BvbnNlIGFuZCBjb3JyZXNwb25kaW5nIHNpZ25hdHVyZSBhc3NvY2lhdGVkXG4gICAgICogd2l0aCB0aGUgY2hhdCBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlckFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgcHJvdmlkZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgLSBUaGUgbWFpbiBjb250ZW50IHJldHVybmVkIGJ5IHRoZSBzZXJ2aWNlLiBGb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2Ugb2YgYSBjaGF0Ym90IHNlcnZpY2UsXG4gICAgICogaXQgd291bGQgYmUgdGhlIHJlc3BvbnNlIHRleHQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXRJRCAtIE9ubHkgZm9yIHZlcmlmaWFibGUgc2VydmljZXMuIFlvdSBjYW4gcHJvdmlkZSB0aGUgY2hhdCBJRCBvYnRhaW5lZCBmcm9tIHRoZSByZXNwb25zZSB0b1xuICAgICAqIGF1dG9tYXRpY2FsbHkgZG93bmxvYWQgdGhlIHJlc3BvbnNlIHNpZ25hdHVyZS4gVGhlIGZ1bmN0aW9uIHdpbGwgdmVyaWZ5IHRoZSByZWxpYWJpbGl0eSBvZiB0aGUgcmVzcG9uc2VcbiAgICAgKiB1c2luZyB0aGUgc2VydmljZSdzIHNpZ25pbmcgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZsbG1Qcm94eSAtIENoYXQgc2lnbmF0dXJlIHByb3h5LCBkZWZhdWx0IGlzIHRydWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZS4gVHJ1ZSBpbmRpY2F0ZXMgdGhlIHJldHVybmVkIGNvbnRlbnQgaXMgdmFsaWQsIG90aGVyd2lzZSBpdCBpcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBhbnkgaXNzdWVzIG9jY3VyIGR1cmluZyB0aGUgcHJvY2Vzc2luZyBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICovXG4gICAgcHJvY2Vzc1Jlc3BvbnNlID0gYXN5bmMgKHByb3ZpZGVyQWRkcmVzcywgY29udGVudCwgY2hhdElELCB2bGxtUHJveHkpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlc3BvbnNlUHJvY2Vzc29yLnByb2Nlc3NSZXNwb25zZShwcm92aWRlckFkZHJlc3MsIGNvbnRlbnQsIGNoYXRJRCwgdmxsbVByb3h5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB2ZXJpZnlTZXJ2aWNlIGlzIHVzZWQgdG8gdmVyaWZ5IHRoZSByZWxpYWJpbGl0eSBvZiB0aGUgc2VydmljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlckFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIDxib29sZWFuIHwgbnVsbD4gdmFsdWUuIFRydWUgaW5kaWNhdGVzIHRoZSBzZXJ2aWNlIGlzIHJlbGlhYmxlLCBvdGhlcndpc2UgaXQgaXMgdW5yZWxpYWJsZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgZXJyb3JzIG9jY3VyIGR1cmluZyB0aGUgdmVyaWZpY2F0aW9uIHByb2Nlc3MuXG4gICAgICovXG4gICAgdmVyaWZ5U2VydmljZSA9IGFzeW5jIChwcm92aWRlckFkZHJlc3MpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnZlcmlmaWVyLnZlcmlmeVNlcnZpY2UocHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRTaWduZXJSYURvd25sb2FkTGluayByZXR1cm5zIHRoZSBkb3dubG9hZCBsaW5rIGZvciB0aGUgU2lnbmVyIFJBLlxuICAgICAqXG4gICAgICogSXQgY2FuIGJlIHByb3ZpZGVkIHRvIHVzZXJzIHdobyB3aXNoIHRvIG1hbnVhbGx5IHZlcmlmeSB0aGUgU2lnbmVyIFJBLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVyQWRkcmVzcyAtIHByb3ZpZGVyIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBEb3dubG9hZCBsaW5rLlxuICAgICAqL1xuICAgIGdldFNpZ25lclJhRG93bmxvYWRMaW5rID0gYXN5bmMgKHByb3ZpZGVyQWRkcmVzcykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudmVyaWZpZXIuZ2V0U2lnbmVyUmFEb3dubG9hZExpbmsocHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRDaGF0U2lnbmF0dXJlRG93bmxvYWRMaW5rIHJldHVybnMgdGhlIGRvd25sb2FkIGxpbmsgZm9yIHRoZSBzaWduYXR1cmUgb2YgYSBzaW5nbGUgY2hhdC5cbiAgICAgKlxuICAgICAqIEl0IGNhbiBiZSBwcm92aWRlZCB0byB1c2VycyB3aG8gd2lzaCB0byBtYW51YWxseSB2ZXJpZnkgdGhlIGNvbnRlbnQgb2YgYSBzaW5nbGUgY2hhdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlckFkZHJlc3MgLSBwcm92aWRlciBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGF0SUQgLSBJRCBvZiB0aGUgY2hhdC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIFRvIHZlcmlmeSB0aGUgY2hhdCBzaWduYXR1cmUsIHVzZSB0aGUgZm9sbG93aW5nIGNvZGU6XG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgbWVzc2FnZUhhc2ggPSBldGhlcnMuaGFzaE1lc3NhZ2UobWVzc2FnZVRvQmVWZXJpZmllZClcbiAgICAgKiBjb25zdCByZWNvdmVyZWRBZGRyZXNzID0gZXRoZXJzLnJlY292ZXJBZGRyZXNzKG1lc3NhZ2VIYXNoLCBzaWduYXR1cmUpXG4gICAgICogY29uc3QgaXNWYWxpZCA9IHJlY292ZXJlZEFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gc2lnbmluZ0FkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgRG93bmxvYWQgbGluay5cbiAgICAgKi9cbiAgICBnZXRDaGF0U2lnbmF0dXJlRG93bmxvYWRMaW5rID0gYXN5bmMgKHByb3ZpZGVyQWRkcmVzcywgY2hhdElEKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy52ZXJpZmllci5nZXRDaGF0U2lnbmF0dXJlRG93bmxvYWRMaW5rKHByb3ZpZGVyQWRkcmVzcywgY2hhdElEKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogY3JlYXRlSW5mZXJlbmNlQnJva2VyIGlzIHVzZWQgdG8gaW5pdGlhbGl6ZSBaR1NlcnZpbmdVc2VyQnJva2VyXG4gKlxuICogQHBhcmFtIHNpZ25lciAtIFNpZ25lciBmcm9tIGV0aGVycy5qcy5cbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSAwRyBTZXJ2aW5nIGNvbnRyYWN0IGFkZHJlc3MsIHVzZSBkZWZhdWx0IGFkZHJlc3MgaWYgbm90IHByb3ZpZGVkLlxuICpcbiAqIEByZXR1cm5zIGJyb2tlciBpbnN0YW5jZS5cbiAqXG4gKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBicm9rZXIgY2Fubm90IGJlIGluaXRpYWxpemVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVJbmZlcmVuY2VCcm9rZXIoc2lnbmVyLCBjb250cmFjdEFkZHJlc3MsIGxlZGdlcikge1xuICAgIGNvbnN0IGJyb2tlciA9IG5ldyBJbmZlcmVuY2VCcm9rZXIoc2lnbmVyLCBjb250cmFjdEFkZHJlc3MsIGxlZGdlcik7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgYnJva2VyLmluaXRpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIGJyb2tlcjtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cblxuY2xhc3MgQnJva2VyQmFzZSB7XG4gICAgY29udHJhY3Q7XG4gICAgbGVkZ2VyO1xuICAgIHNlcnZpbmdQcm92aWRlcjtcbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgbGVkZ2VyLCBzZXJ2aW5nUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5jb250cmFjdCA9IGNvbnRyYWN0O1xuICAgICAgICB0aGlzLmxlZGdlciA9IGxlZGdlcjtcbiAgICAgICAgdGhpcy5zZXJ2aW5nUHJvdmlkZXIgPSBzZXJ2aW5nUHJvdmlkZXI7XG4gICAgfVxufVxuXG5jb25zdCBUSU1FT1VUX01TJDEgPSAzMDBfMDAwO1xuY2xhc3MgRmluZVR1bmluZ1NlcnZpbmdDb250cmFjdCB7XG4gICAgc2VydmluZztcbiAgICBzaWduZXI7XG4gICAgX3VzZXJBZGRyZXNzO1xuICAgIF9nYXNQcmljZTtcbiAgICBfbWF4R2FzUHJpY2U7XG4gICAgX3N0ZXA7XG4gICAgY29uc3RydWN0b3Ioc2lnbmVyLCBjb250cmFjdEFkZHJlc3MsIHVzZXJBZGRyZXNzLCBnYXNQcmljZSwgbWF4R2FzUHJpY2UsIHN0ZXApIHtcbiAgICAgICAgdGhpcy5zZXJ2aW5nID0gRmluZVR1bmluZ1NlcnZpbmdfX2ZhY3RvcnkuY29ubmVjdChjb250cmFjdEFkZHJlc3MsIHNpZ25lcik7XG4gICAgICAgIHRoaXMuc2lnbmVyID0gc2lnbmVyO1xuICAgICAgICB0aGlzLl91c2VyQWRkcmVzcyA9IHVzZXJBZGRyZXNzO1xuICAgICAgICB0aGlzLl9nYXNQcmljZSA9IGdhc1ByaWNlO1xuICAgICAgICBpZiAobWF4R2FzUHJpY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21heEdhc1ByaWNlID0gQmlnSW50KG1heEdhc1ByaWNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGVwID0gc3RlcCB8fCAxMTtcbiAgICB9XG4gICAgbG9ja1RpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpbmcubG9ja1RpbWUoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFR4KG5hbWUsIHR4QXJncywgdHhPcHRpb25zKSB7XG4gICAgICAgIGlmICh0eE9wdGlvbnMuZ2FzUHJpY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHhPcHRpb25zLmdhc1ByaWNlID0gKGF3YWl0IHRoaXMuc2lnbmVyLnByb3ZpZGVyPy5nZXRGZWVEYXRhKCkpPy5nYXNQcmljZTtcbiAgICAgICAgICAgIC8vIEFkZCBhIGRlbGF5IHRvIGF2b2lkIHRvbyBmcmVxdWVudCBSUEMgY2FsbHNcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR4T3B0aW9ucy5nYXNQcmljZSA9IEJpZ0ludCh0eE9wdGlvbnMuZ2FzUHJpY2UpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzZW5kaW5nIHR4IHdpdGggZ2FzIHByaWNlJywgdHhPcHRpb25zLmdhc1ByaWNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuc2VydmluZy5nZXRGdW5jdGlvbihuYW1lKSguLi50eEFyZ3MsIHR4T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3R4IGhhc2g6JywgdHguaGFzaCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IChhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgICAgICB0eC53YWl0KCksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignR2V0IFJlY2VpcHQgdGltZW91dCwgdHJ5IHNldCBoaWdoZXIgZ2FzIHByaWNlJykpLCBUSU1FT1VUX01TJDEpKSxcbiAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1JlY2VpcHQocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgJ0dldCBSZWNlaXB0IHRpbWVvdXQsIHRyeSBzZXQgaGlnaGVyIGdhcyBwcmljZScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCB0aGlzLnNpZ25lci5nZXROb25jZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nTm9uY2UgPSBhd2FpdCB0aGlzLnNpZ25lci5wcm92aWRlcj8uZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLl91c2VyQWRkcmVzcywgJ3BlbmRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdOb25jZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTm9uY2UgLSBub25jZSA+IDUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4T3B0aW9ucy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFNpZ25pZmljYW50IGdhcCBkZXRlY3RlZCBiZXR3ZWVuIHBlbmRpbmcgbm9uY2UgKCR7cGVuZGluZ05vbmNlfSkgYW5kIGN1cnJlbnQgbm9uY2UgKCR7bm9uY2V9KS4gVGhpcyBtYXkgaW5kaWNhdGUgc2tpcHBlZCBvciBtaXNzaW5nIHRyYW5zYWN0aW9ucy4gVXNpbmcgdGhlIGN1cnJlbnQgY29uZmlybWVkIG5vbmNlIGZvciB0aGUgdHJhbnNhY3Rpb24uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eE9wdGlvbnMubm9uY2UgPSBub25jZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF4R2FzUHJpY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLmluZm8/LmVycm9yPy5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yLmluZm8uZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmV0cnkgPSBSRVRSWV9FUlJPUl9TVUJTVFJJTkdTLnNvbWUoKHN1YnN0cikgPT4gZXJyb3JNZXNzYWdlLmluY2x1ZGVzKHN1YnN0cikpO1xuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXRyeWluZyB0cmFuc2FjdGlvbiB3aXRoIGhpZ2hlciBnYXMgcHJpY2UgZHVlIHRvOicsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRHYXNQcmljZSA9IHR4T3B0aW9ucy5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEdhc1ByaWNlID49IHRoaXMuX21heEdhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50R2FzUHJpY2UgPVxuICAgICAgICAgICAgICAgICAgICAoY3VycmVudEdhc1ByaWNlICogQmlnSW50KHRoaXMuX3N0ZXApKSAvIEJpZ0ludCgxMCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRHYXNQcmljZSA+IHRoaXMuX21heEdhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHYXNQcmljZSA9IHRoaXMuX21heEdhc1ByaWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eE9wdGlvbnMuZ2FzUHJpY2UgPSBjdXJyZW50R2FzUHJpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdFNlcnZpY2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlcyA9IGF3YWl0IHRoaXMuc2VydmluZy5nZXRBbGxTZXJ2aWNlcygpO1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2VzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEFjY291bnQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuc2VydmluZy5nZXRBbGxBY2NvdW50cygpO1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0QWNjb3VudChwcm92aWRlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IHRoaXMuZ2V0VXNlckFkZHJlc3MoKTtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLnNlcnZpbmcuZ2V0QWNjb3VudCh1c2VyLCBwcm92aWRlcik7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGFja25vd2xlZGdlUHJvdmlkZXJTaWduZXIocHJvdmlkZXJBZGRyZXNzLCBwcm92aWRlclNpZ25lciwgZ2FzUHJpY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHR4T3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgaWYgKGdhc1ByaWNlIHx8IHRoaXMuX2dhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgdHhPcHRpb25zLmdhc1ByaWNlID0gZ2FzUHJpY2UgfHwgdGhpcy5fZ2FzUHJpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRUeCgnYWNrbm93bGVkZ2VQcm92aWRlclNpZ25lcicsIFtwcm92aWRlckFkZHJlc3MsIHByb3ZpZGVyU2lnbmVyXSwgdHhPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGFja25vd2xlZGdlRGVsaXZlcmFibGUocHJvdmlkZXJBZGRyZXNzLCBpbmRleCwgZ2FzUHJpY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHR4T3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgaWYgKGdhc1ByaWNlIHx8IHRoaXMuX2dhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgdHhPcHRpb25zLmdhc1ByaWNlID0gZ2FzUHJpY2UgfHwgdGhpcy5fZ2FzUHJpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRUeCgnYWNrbm93bGVkZ2VEZWxpdmVyYWJsZScsIFtwcm92aWRlckFkZHJlc3MsIGluZGV4XSwgdHhPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFNlcnZpY2UocHJvdmlkZXJBZGRyZXNzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aW5nLmdldFNlcnZpY2UocHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldERlbGl2ZXJhYmxlKHByb3ZpZGVyQWRkcmVzcywgaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSB0aGlzLmdldFVzZXJBZGRyZXNzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aW5nLmdldERlbGl2ZXJhYmxlKHVzZXIsIHByb3ZpZGVyQWRkcmVzcywgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VXNlckFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91c2VyQWRkcmVzcztcbiAgICB9XG4gICAgY2hlY2tSZWNlaXB0KHJlY2VpcHQpIHtcbiAgICAgICAgaWYgKCFyZWNlaXB0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZhaWxlZCB3aXRoIG5vIHJlY2VpcHQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjZWlwdC5zdGF0dXMgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gcmV2ZXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkKHByaXZhdGVLZXksIGRhdGFQYXRoLCBnYXNQcmljZSwgbWF4R2FzUHJpY2UpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBmaWxlU2l6ZSA9IGF3YWl0IGdldEZpbGVDb250ZW50U2l6ZShkYXRhUGF0aCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21tYW5kID0gcGF0aF9fZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJy4uJywgJy4uJywgJ2JpbmFyeScsICcwZy1zdG9yYWdlLWNsaWVudCcpO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IFtcbiAgICAgICAgICAgICAgICAndXBsb2FkJyxcbiAgICAgICAgICAgICAgICAnLS11cmwnLFxuICAgICAgICAgICAgICAgIFpHX1JQQ19FTkRQT0lOVF9URVNUTkVULFxuICAgICAgICAgICAgICAgICctLWtleScsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICAnLS1pbmRleGVyJyxcbiAgICAgICAgICAgICAgICBJTkRFWEVSX1VSTF9UVVJCTyxcbiAgICAgICAgICAgICAgICAnLS1maWxlJyxcbiAgICAgICAgICAgICAgICBkYXRhUGF0aCxcbiAgICAgICAgICAgICAgICAnLS1za2lwLXR4PWZhbHNlJyxcbiAgICAgICAgICAgICAgICAnLS1sb2ctbGV2ZWw9ZGVidWcnLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChnYXNQcmljZSkge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgnLS1nYXMtcHJpY2UnLCBnYXNQcmljZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhHYXNQcmljZSkge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgnLS1tYXgtZ2FzLXByaWNlJywgbWF4R2FzUHJpY2UudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gc3Bhd24kMShjb21tYW5kLCBhcmdzKTtcbiAgICAgICAgICAgIHByb2Nlc3Muc3Rkb3V0Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtkYXRhfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9jZXNzLnN0ZGVyci5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgJHtkYXRhfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9jZXNzLm9uKCdjbG9zZScsIChjb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgUHJvY2VzcyBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX1gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRmlsZSBzaXplOiAke2ZpbGVTaXplfSBieXRlc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9jZXNzLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZChkYXRhUGF0aCwgZGF0YVJvb3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBjb21tYW5kID0gcGF0aF9fZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJy4uJywgJy4uJywgJ2JpbmFyeScsICcwZy1zdG9yYWdlLWNsaWVudCcpO1xuICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgJ2Rvd25sb2FkJyxcbiAgICAgICAgICAgICctLWZpbGUnLFxuICAgICAgICAgICAgZGF0YVBhdGgsXG4gICAgICAgICAgICAnLS1pbmRleGVyJyxcbiAgICAgICAgICAgIElOREVYRVJfVVJMX1RVUkJPLFxuICAgICAgICAgICAgJy0tcm9vdHMnLFxuICAgICAgICAgICAgZGF0YVJvb3QsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHByb2Nlc3MgPSBzcGF3biQxKGNvbW1hbmQsIGFyZ3MpO1xuICAgICAgICBsZXQgbG9nID0gJyc7XG4gICAgICAgIHByb2Nlc3Muc3Rkb3V0Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxvZyArPSBvdXRwdXQ7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvY2Vzcy5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JPdXRwdXQgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsb2cgKz0gZXJyb3JPdXRwdXQ7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yT3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2Nlc3Mub24oJ2Nsb3NlJywgKGNvZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYFByb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsb2dcbiAgICAgICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAgICAgLmVuZHNXaXRoKCdTdWNjZWVkZWQgdG8gdmFsaWRhdGUgdGhlIGRvd25sb2FkZWQgZmlsZScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkb3dubG9hZCB0aGUgZmlsZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2Nlc3Mub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZUNvbnRlbnRTaXplKGZpbGVQYXRoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmlsZUhhbmRsZSA9IGF3YWl0IGZzJDEub3BlbihmaWxlUGF0aCwgJ3InKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZmlsZUhhbmRsZS5zdGF0KCk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHMuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IGZpbGVIYW5kbGUuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBmaWxlOiAke2VyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBTdHJpbmcoZXJyKX1gKTtcbiAgICB9XG59XG5cbi8vIER5bmFtaWMgaW1wb3J0cyBmb3IgTm9kZS5qcyBzcGVjaWZpYyBtb2R1bGVzXG5sZXQgZnM7XG5sZXQgb3M7XG5sZXQgcGF0aDtcbmxldCBBZG1aaXA7XG5sZXQgc3Bhd247XG5sZXQgZXhlYztcbmxldCBjcmVhdGVIYXNoO1xubGV0IGNyZWF0ZVJlYWRTdHJlYW07XG5hc3luYyBmdW5jdGlvbiBpbml0Tm9kZU1vZHVsZXMoKSB7XG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVG9rZW4gY2FsY3VsYXRpb24gZnVuY3Rpb25zIGFyZSBub3QgYXZhaWxhYmxlIGluIGJyb3dzZXIgZW52aXJvbm1lbnQuIFBsZWFzZSB1c2UgdGhlc2UgZnVuY3Rpb25zIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudC4nKTtcbiAgICB9XG4gICAgaWYgKCFmcykge1xuICAgICAgICBmcyA9XG4gICAgICAgICAgICAoYXdhaXQgaW1wb3J0KCdmcy9wcm9taXNlcycpKS5kZWZhdWx0IHx8XG4gICAgICAgICAgICAgICAgKGF3YWl0IGltcG9ydCgnZnMvcHJvbWlzZXMnKSk7XG4gICAgICAgIG9zID0gKGF3YWl0IGltcG9ydCgnb3MnKSkuZGVmYXVsdCB8fCAoYXdhaXQgaW1wb3J0KCdvcycpKTtcbiAgICAgICAgcGF0aCA9IChhd2FpdCBpbXBvcnQoJ3BhdGgnKSkuZGVmYXVsdCB8fCAoYXdhaXQgaW1wb3J0KCdwYXRoJykpO1xuICAgICAgICBBZG1aaXAgPSAoYXdhaXQgaW1wb3J0KCcuL2FkbS16aXAtODZmMzBkNDcuanMnKS50aGVuKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLmE7IH0pKS5kZWZhdWx0O1xuICAgICAgICBjb25zdCBjaGlsZFByb2Nlc3MgPSBhd2FpdCBpbXBvcnQoJ2NoaWxkX3Byb2Nlc3MnKTtcbiAgICAgICAgc3Bhd24gPSBjaGlsZFByb2Nlc3Muc3Bhd247XG4gICAgICAgIGV4ZWMgPSBjaGlsZFByb2Nlc3MuZXhlYztcbiAgICAgICAgY29uc3QgY3J5cHRvID0gYXdhaXQgaW1wb3J0KCdjcnlwdG8nKTtcbiAgICAgICAgY3JlYXRlSGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoO1xuICAgICAgICBjcmVhdGVSZWFkU3RyZWFtID0gKGF3YWl0IGltcG9ydCgnZnMnKSkuY3JlYXRlUmVhZFN0cmVhbTtcbiAgICB9XG59XG4vLyBSZS1leHBvcnQgZG93bmxvYWQgd2l0aCBicm93c2VyIGNoZWNrXG5hc3luYyBmdW5jdGlvbiBzYWZlRHluYW1pY0ltcG9ydCgpIHtcbiAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdaRyBTdG9yYWdlIG9wZXJhdGlvbnMgYXJlIG5vdCBhdmFpbGFibGUgaW4gYnJvd3NlciBlbnZpcm9ubWVudC4nKTtcbiAgICB9XG4gICAgY29uc3QgeyBkb3dubG9hZCB9ID0gYXdhaXQgaW1wb3J0KCcuL2luZGV4LWI1Mjk0MmQyLmpzJyk7XG4gICAgcmV0dXJuIHsgZG93bmxvYWQgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZVRva2VuU2l6ZVZpYUV4ZSh0b2tlbml6ZXJSb290SGFzaCwgZGF0YXNldFBhdGgsIGRhdGFzZXRUeXBlLCB0b2tlbkNvdW50ZXJNZXJrbGVSb290LCB0b2tlbkNvdW50ZXJGaWxlSGFzaCkge1xuICAgIGF3YWl0IGluaXROb2RlTW9kdWxlcygpO1xuICAgIGNvbnN0IHsgZG93bmxvYWQgfSA9IGF3YWl0IHNhZmVEeW5hbWljSW1wb3J0KCk7XG4gICAgY29uc3QgZXhlY3V0b3JEaXIgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nLCAnLi4nLCAnYmluYXJ5Jyk7XG4gICAgY29uc3QgYmluYXJ5RmlsZSA9IHBhdGguam9pbihleGVjdXRvckRpciwgJ3Rva2VuX2NvdW50ZXInKTtcbiAgICBsZXQgbmVlZERvd25sb2FkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZnMuYWNjZXNzKGJpbmFyeUZpbGUpO1xuICAgICAgICBjb25zb2xlLmxvZygnY2FsY3VsYXRpbmcgZmlsZSBIYXNoJyk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBjYWxjdWxhdGVGaWxlSGFzaChiaW5hcnlGaWxlKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2ZpbGUgaGFzaDogJywgaGFzaCk7XG4gICAgICAgIGlmICh0b2tlbkNvdW50ZXJGaWxlSGFzaCAhPT0gaGFzaCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYGZpbGUgaGFzaCBtaXNtYXRjaCwgZXhwZWN0ZWQ6IGAsIHRva2VuQ291bnRlckZpbGVIYXNoKTtcbiAgICAgICAgICAgIG5lZWREb3dubG9hZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBGaWxlICR7YmluYXJ5RmlsZX0gZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICAgIG5lZWREb3dubG9hZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChuZWVkRG93bmxvYWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGZzLnVubGluayhiaW5hcnlGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBkZWxldGUgJHtiaW5hcnlGaWxlfTpgLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coYERvd25sb2FkaW5nICR7YmluYXJ5RmlsZX1gKTtcbiAgICAgICAgYXdhaXQgZG93bmxvYWQoYmluYXJ5RmlsZSwgdG9rZW5Db3VudGVyTWVya2xlUm9vdCk7XG4gICAgICAgIGF3YWl0IGZzLmNobW9kKGJpbmFyeUZpbGUsIDBvNzU1KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGNhbGN1bGF0ZVRva2VuU2l6ZSh0b2tlbml6ZXJSb290SGFzaCwgZGF0YXNldFBhdGgsIGRhdGFzZXRUeXBlLCBiaW5hcnlGaWxlLCBbXSk7XG59XG5hc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVUb2tlblNpemVWaWFQeXRob24odG9rZW5pemVyUm9vdEhhc2gsIGRhdGFzZXRQYXRoLCBkYXRhc2V0VHlwZSkge1xuICAgIGF3YWl0IGluaXROb2RlTW9kdWxlcygpO1xuICAgIGNvbnN0IGlzUHl0aG9uSW5zdGFsbGVkID0gYXdhaXQgY2hlY2tQeXRob25JbnN0YWxsZWQoKTtcbiAgICBpZiAoIWlzUHl0aG9uSW5zdGFsbGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHl0aG9uIGlzIHJlcXVpcmVkIGJ1dCBub3QgaW5zdGFsbGVkLiBQbGVhc2UgaW5zdGFsbCBQeXRob24gZmlyc3QuJyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcGFja2FnZU5hbWUgb2YgWyd0cmFuc2Zvcm1lcnMnLCAnZGF0YXNldHMnXSkge1xuICAgICAgICBjb25zdCBpc1BhY2thZ2VJbnN0YWxsZWQgPSBhd2FpdCBjaGVja1BhY2thZ2VJbnN0YWxsZWQocGFja2FnZU5hbWUpO1xuICAgICAgICBpZiAoIWlzUGFja2FnZUluc3RhbGxlZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCR7cGFja2FnZU5hbWV9IGlzIG5vdCBpbnN0YWxsZWQuIEluc3RhbGxpbmcuLi5gKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgaW5zdGFsbFBhY2thZ2UocGFja2FnZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gaW5zdGFsbCAke3BhY2thZ2VOYW1lfTogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9qZWN0Um9vdCA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLi8uLi8uLi8uLi8nKTtcbiAgICByZXR1cm4gYXdhaXQgY2FsY3VsYXRlVG9rZW5TaXplKHRva2VuaXplclJvb3RIYXNoLCBkYXRhc2V0UGF0aCwgZGF0YXNldFR5cGUsICdweXRob24zJywgW3BhdGguam9pbihwcm9qZWN0Um9vdCwgJ3Rva2VuLmNvdW50ZXInLCAndG9rZW5fY291bnRlci5weScpXSk7XG59XG5hc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVUb2tlblNpemUodG9rZW5pemVyUm9vdEhhc2gsIGRhdGFzZXRQYXRoLCBkYXRhc2V0VHlwZSwgZXhlY3V0b3IsIGFyZ3MpIHtcbiAgICBjb25zdCB7IGRvd25sb2FkIH0gPSBhd2FpdCBzYWZlRHluYW1pY0ltcG9ydCgpO1xuICAgIGNvbnN0IHRtcERpciA9IGF3YWl0IGZzLm1rZHRlbXAoYCR7b3MudG1wZGlyKCl9JHtwYXRoLnNlcH1gKTtcbiAgICBjb25zb2xlLmxvZyhgY3VycmVudCB0ZW1wb3JhcnkgZGlyZWN0b3J5ICR7dG1wRGlyfWApO1xuICAgIGNvbnN0IHRva2VuaXplclBhdGggPSBwYXRoLmpvaW4odG1wRGlyLCAndG9rZW5pemVyLnppcCcpO1xuICAgIGF3YWl0IGRvd25sb2FkKHRva2VuaXplclBhdGgsIHRva2VuaXplclJvb3RIYXNoKTtcbiAgICBjb25zdCBzdWJEaXJlY3RvcmllcyA9IGF3YWl0IGdldFN1YmRpcmVjdG9yaWVzKHRtcERpcik7XG4gICAgdW56aXBGaWxlKHRva2VuaXplclBhdGgsIHRtcERpcik7XG4gICAgY29uc3QgbmV3RGlyZWN0b3JpZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGF3YWl0IGdldFN1YmRpcmVjdG9yaWVzKHRtcERpcikpIHtcbiAgICAgICAgaWYgKCFzdWJEaXJlY3Rvcmllcy5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgIG5ld0RpcmVjdG9yaWVzLmFkZChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3RGlyZWN0b3JpZXMuc2l6ZSAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdG9rZW5pemVyIGRpcmVjdG9yeScpO1xuICAgIH1cbiAgICBjb25zdCB0b2tlbml6ZXJVbnppcFBhdGggPSBwYXRoLmpvaW4odG1wRGlyLCBBcnJheS5mcm9tKG5ld0RpcmVjdG9yaWVzKVswXSk7XG4gICAgbGV0IGRhdGFzZXRVbnppcFBhdGggPSBkYXRhc2V0UGF0aDtcbiAgICBpZiAoYXdhaXQgaXNaaXBGaWxlKGRhdGFzZXRQYXRoKSkge1xuICAgICAgICB1bnppcEZpbGUoZGF0YXNldFBhdGgsIHRtcERpcik7XG4gICAgICAgIGRhdGFzZXRVbnppcFBhdGggPSBwYXRoLmpvaW4odG1wRGlyLCAnZGF0YScpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZnMuYWNjZXNzKGRhdGFzZXRVbnppcFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXdhaXQgZnMubWtkaXIoZGF0YXNldFVuemlwUGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ1bkV4ZWN1dG9yKGV4ZWN1dG9yLCBbXG4gICAgICAgIC4uLmFyZ3MsXG4gICAgICAgIGRhdGFzZXRVbnppcFBhdGgsXG4gICAgICAgIGRhdGFzZXRUeXBlLFxuICAgICAgICB0b2tlbml6ZXJVbnppcFBhdGgsXG4gICAgXSlcbiAgICAgICAgLnRoZW4oKG91dHB1dCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygndG9rZW5fY291bnRlciBzY3JpcHQgb3V0cHV0OicsIG91dHB1dCk7XG4gICAgICAgIGlmICghb3V0cHV0IHx8IHR5cGVvZiBvdXRwdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3V0cHV0IGZyb20gdG9rZW4gY291bnRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtudW0xLCBudW0yXSA9IG91dHB1dFxuICAgICAgICAgICAgLnNwbGl0KCcgJylcbiAgICAgICAgICAgIC5tYXAoKHN0cikgPT4gcGFyc2VJbnQoc3RyLCAxMCkpO1xuICAgICAgICBpZiAoaXNOYU4obnVtMSkgfHwgaXNOYU4obnVtMikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtMTtcbiAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJ1bm5pbmcgUHl0aG9uIHNjcmlwdDonLCBlcnJvcik7XG4gICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tQeXRob25JbnN0YWxsZWQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZXhlYygncHl0aG9uMyAtLXZlcnNpb24nLCAoZXJyb3IsIHN0ZG91dCwgc3RkZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQeXRob24gaXMgbm90IGluc3RhbGxlZCBvciBub3QgaW4gUEFUSCcpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjaGVja1BhY2thZ2VJbnN0YWxsZWQocGFja2FnZU5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBleGVjKGBwaXAgc2hvdyAke3BhY2thZ2VOYW1lfWAsIChlcnJvciwgc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbnN0YWxsUGFja2FnZShwYWNrYWdlTmFtZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGV4ZWMoYHBpcCBpbnN0YWxsICR7cGFja2FnZU5hbWV9YCwgKGVycm9yLCBzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGluc3RhbGwgJHtwYWNrYWdlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCR7cGFja2FnZU5hbWV9IGluc3RhbGxlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcnVuRXhlY3V0b3IoZXhlY3V0b3IsIGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgUnVuICR7ZXhlY3V0b3J9ICR7YXJnc31gKTtcbiAgICAgICAgY29uc3QgcHl0aG9uUHJvY2VzcyA9IHNwYXduKGV4ZWN1dG9yLCBbLi4uYXJnc10pO1xuICAgICAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgICAgIGxldCBlcnJvck91dHB1dCA9ICcnO1xuICAgICAgICBweXRob25Qcm9jZXNzLnN0ZG91dC5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gZGF0YS50b1N0cmluZygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHl0aG9uUHJvY2Vzcy5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgZXJyb3JPdXRwdXQgKz0gZGF0YS50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUHl0aG9uIGVycm9yOiAke2Vycm9yT3V0cHV0fWApO1xuICAgICAgICB9KTtcbiAgICAgICAgcHl0aG9uUHJvY2Vzcy5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dC50cmltKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGBQeXRob24gc2NyaXB0IGZhaWxlZCB3aXRoIGNvZGUgJHtjb2RlfTogJHtlcnJvck91dHB1dC50cmltKCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdW56aXBGaWxlKHppcEZpbGVQYXRoLCB0YXJnZXREaXIpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB6aXAgPSBuZXcgQWRtWmlwKHppcEZpbGVQYXRoKTtcbiAgICAgICAgemlwLmV4dHJhY3RBbGxUbyh0YXJnZXREaXIsIHRydWUpO1xuICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IHVuemlwcGVkIHRvICR7dGFyZ2V0RGlyfWApO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIHVuemlwcGluZzonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGlzWmlwRmlsZSh0YXJnZXRQYXRoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBmcy5zdGF0KHRhcmdldFBhdGgpO1xuICAgICAgICByZXR1cm4gKHN0YXRzLmlzRmlsZSgpICYmIHBhdGguZXh0bmFtZSh0YXJnZXRQYXRoKS50b0xvd2VyQ2FzZSgpID09PSAnLnppcCcpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN1YmRpcmVjdG9yaWVzKGRpclBhdGgpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgZnMucmVhZGRpcihkaXJQYXRoLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IHN1YmRpcmVjdG9yaWVzID0gbmV3IFNldChlbnRyaWVzXG4gICAgICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkuaXNEaXJlY3RvcnkoKSkgLy8gT25seSBrZWVwIGRpcmVjdG9yaWVzXG4gICAgICAgICAgICAubWFwKChlbnRyeSkgPT4gZW50cnkubmFtZSkpO1xuICAgICAgICByZXR1cm4gc3ViZGlyZWN0b3JpZXM7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIGRpcmVjdG9yeTonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBuZXcgU2V0KCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlRmlsZUhhc2goZmlsZVBhdGgsIGFsZ29yaXRobSA9ICdzaGEyNTYnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaGFzaCA9IGNyZWF0ZUhhc2goYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbShmaWxlUGF0aCk7XG4gICAgICAgIHN0cmVhbS5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgaGFzaC51cGRhdGUoY2h1bmspO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKGhhc2guZGlnZXN0KCdoZXgnKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5jbGFzcyBNb2RlbFByb2Nlc3NvciBleHRlbmRzIEJyb2tlckJhc2Uge1xuICAgIGFzeW5jIGxpc3RNb2RlbCgpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZXMgPSBhd2FpdCB0aGlzLmNvbnRyYWN0Lmxpc3RTZXJ2aWNlKCk7XG4gICAgICAgIGxldCBjdXN0b21pemVkTW9kZWxzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc2VydmljZSBvZiBzZXJ2aWNlcykge1xuICAgICAgICAgICAgaWYgKHNlcnZpY2UubW9kZWxzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IHNlcnZpY2UudXJsO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVscyA9IGF3YWl0IHRoaXMuc2VydmluZ1Byb3ZpZGVyLmdldEN1c3RvbWl6ZWRNb2RlbHModXJsKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgbW9kZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbWl6ZWRNb2RlbHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGl0ZW0uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHNlcnZpY2UucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtPYmplY3QuZW50cmllcyhNT0RFTF9IQVNIX01BUCksIGN1c3RvbWl6ZWRNb2RlbHNdO1xuICAgIH1cbiAgICBhc3luYyB1cGxvYWREYXRhc2V0KHByaXZhdGVLZXksIGRhdGFQYXRoLCBnYXNQcmljZSwgbWF4R2FzUHJpY2UpIHtcbiAgICAgICAgYXdhaXQgdXBsb2FkKHByaXZhdGVLZXksIGRhdGFQYXRoLCBnYXNQcmljZSk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGN1bGF0ZVRva2VuKGRhdGFzZXRQYXRoLCB1c2VQeXRob24sIHByZVRyYWluZWRNb2RlbE5hbWUsIHByb3ZpZGVyQWRkcmVzcykge1xuICAgICAgICBsZXQgdG9rZW5pemVyO1xuICAgICAgICBsZXQgZGF0YVR5cGU7XG4gICAgICAgIGlmIChwcmVUcmFpbmVkTW9kZWxOYW1lIGluIE1PREVMX0hBU0hfTUFQKSB7XG4gICAgICAgICAgICB0b2tlbml6ZXIgPSBNT0RFTF9IQVNIX01BUFtwcmVUcmFpbmVkTW9kZWxOYW1lXS50b2tlbml6ZXI7XG4gICAgICAgICAgICBkYXRhVHlwZSA9IE1PREVMX0hBU0hfTUFQW3ByZVRyYWluZWRNb2RlbE5hbWVdLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXJBZGRyZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVyIGFkZHJlc3MgaXMgcmVxdWlyZWQgZm9yIGN1c3RvbWl6ZWQgbW9kZWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb2RlbCA9IGF3YWl0IHRoaXMuc2VydmluZ1Byb3ZpZGVyLmdldEN1c3RvbWl6ZWRNb2RlbChwcm92aWRlckFkZHJlc3MsIHByZVRyYWluZWRNb2RlbE5hbWUpO1xuICAgICAgICAgICAgdG9rZW5pemVyID0gbW9kZWwudG9rZW5pemVyO1xuICAgICAgICAgICAgZGF0YVR5cGUgPSBtb2RlbC5kYXRhVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YVNpemUgPSAwO1xuICAgICAgICBpZiAodXNlUHl0aG9uKSB7XG4gICAgICAgICAgICBkYXRhU2l6ZSA9IGF3YWl0IGNhbGN1bGF0ZVRva2VuU2l6ZVZpYVB5dGhvbih0b2tlbml6ZXIsIGRhdGFzZXRQYXRoLCBkYXRhVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhU2l6ZSA9IGF3YWl0IGNhbGN1bGF0ZVRva2VuU2l6ZVZpYUV4ZSh0b2tlbml6ZXIsIGRhdGFzZXRQYXRoLCBkYXRhVHlwZSwgVE9LRU5fQ09VTlRFUl9NRVJLTEVfUk9PVCwgVE9LRU5fQ09VTlRFUl9GSUxFX0hBU0gpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKGBUaGUgdG9rZW4gc2l6ZSBmb3IgdGhlIGRhdGFzZXQgJHtkYXRhc2V0UGF0aH0gaXMgJHtkYXRhU2l6ZX1gKTtcbiAgICB9XG4gICAgYXN5bmMgZG93bmxvYWREYXRhc2V0KGRhdGFQYXRoLCBkYXRhUm9vdCkge1xuICAgICAgICBkb3dubG9hZChkYXRhUGF0aCwgZGF0YVJvb3QpO1xuICAgIH1cbiAgICBhc3luYyBhY2tub3dsZWRnZU1vZGVsKHByb3ZpZGVyQWRkcmVzcywgZGF0YVBhdGgsIGdhc1ByaWNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5jb250cmFjdC5nZXRBY2NvdW50KHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBsYXRlc3REZWxpdmVyYWJsZSA9IGFjY291bnQuZGVsaXZlcmFibGVzW2FjY291bnQuZGVsaXZlcmFibGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKCFsYXRlc3REZWxpdmVyYWJsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGVsaXZlcmFibGUgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGRvd25sb2FkKGRhdGFQYXRoLCBoZXhUb1Jvb3RzKGxhdGVzdERlbGl2ZXJhYmxlLm1vZGVsUm9vdEhhc2gpKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY29udHJhY3QuYWNrbm93bGVkZ2VEZWxpdmVyYWJsZShwcm92aWRlckFkZHJlc3MsIGFjY291bnQuZGVsaXZlcmFibGVzLmxlbmd0aCAtIDEsIGdhc1ByaWNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlY3J5cHRNb2RlbChwcm92aWRlckFkZHJlc3MsIGVuY3J5cHRlZE1vZGVsUGF0aCwgZGVjcnlwdGVkTW9kZWxQYXRoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5jb250cmFjdC5nZXRBY2NvdW50KHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBsYXRlc3REZWxpdmVyYWJsZSA9IGFjY291bnQuZGVsaXZlcmFibGVzW2FjY291bnQuZGVsaXZlcmFibGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKCFsYXRlc3REZWxpdmVyYWJsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGVsaXZlcmFibGUgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbGF0ZXN0RGVsaXZlcmFibGUuYWNrbm93bGVkZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWxpdmVyYWJsZSBub3QgYWNrbm93bGVkZ2VkIHlldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsYXRlc3REZWxpdmVyYWJsZS5lbmNyeXB0ZWRTZWNyZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZFNlY3JldCBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlY3JldCA9IGF3YWl0IGVjaWVzRGVjcnlwdCh0aGlzLmNvbnRyYWN0LnNpZ25lciwgbGF0ZXN0RGVsaXZlcmFibGUuZW5jcnlwdGVkU2VjcmV0KTtcbiAgICAgICAgICAgIGF3YWl0IGFlc0dDTURlY3J5cHRUb0ZpbGUoc2VjcmV0LCBlbmNyeXB0ZWRNb2RlbFBhdGgsIGRlY3J5cHRlZE1vZGVsUGF0aCwgYWNjb3VudC5wcm92aWRlclNpZ25lcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuXG4vLyBCcm93c2VyLXNhZmUgZnVuY3Rpb24gdG8gYXZvaWQgcmVhZGxpbmUgZGVwZW5kZW5jeVxuYXN5bmMgZnVuY3Rpb24gYXNrVXNlcihxdWVzdGlvbikge1xuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVyYWN0aXZlIGlucHV0IG9wZXJhdGlvbnMgYXJlIG5vdCBhdmFpbGFibGUgaW4gYnJvd3NlciBlbnZpcm9ubWVudC4gUGxlYXNlIHVzZSB0aGVzZSBmdW5jdGlvbnMgaW4gYSBOb2RlLmpzIGVudmlyb25tZW50LicpO1xuICAgIH1cbiAgICAvLyBPbmx5IGltcG9ydCByZWFkbGluZSBpbiBOb2RlLmpzIGVudmlyb25tZW50XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVhZGxpbmUgPSBhd2FpdCBpbXBvcnQoJ3JlYWRsaW5lJyk7XG4gICAgICAgIGNvbnN0IHJsID0gcmVhZGxpbmUuY3JlYXRlSW50ZXJmYWNlKHtcbiAgICAgICAgICAgIGlucHV0OiBwcm9jZXNzLnN0ZGluLFxuICAgICAgICAgICAgb3V0cHV0OiBwcm9jZXNzLnN0ZG91dCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmwucXVlc3Rpb24ocXVlc3Rpb24sIChhbnN3ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBybC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoYW5zd2VyLnRyaW0oKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlYWRsaW5lIG1vZHVsZSBpcyBub3QgYXZhaWxhYmxlLiBUaGlzIGZ1bmN0aW9uIGNhbiBvbmx5IGJlIHVzZWQgaW4gTm9kZS5qcyBlbnZpcm9ubWVudC4nKTtcbiAgICB9XG59XG4vLyBCcm93c2VyLXNhZmUgZnVuY3Rpb24gdG8gYXZvaWQgZnMgZGVwZW5kZW5jeVxuYXN5bmMgZnVuY3Rpb24gcmVhZEZpbGVDb250ZW50KGZpbGVQYXRoKSB7XG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsZSBzeXN0ZW0gb3BlcmF0aW9ucyBhcmUgbm90IGF2YWlsYWJsZSBpbiBicm93c2VyIGVudmlyb25tZW50LiBQbGVhc2UgdXNlIHRoZXNlIGZ1bmN0aW9ucyBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQuJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZzID0gYXdhaXQgaW1wb3J0KCdmcy9wcm9taXNlcycpO1xuICAgICAgICByZXR1cm4gYXdhaXQgZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGYtOCcpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcyBtb2R1bGUgaXMgbm90IGF2YWlsYWJsZS4gVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSB1c2VkIGluIE5vZGUuanMgZW52aXJvbm1lbnQuJyk7XG4gICAgfVxufVxuY2xhc3MgU2VydmljZVByb2Nlc3NvciBleHRlbmRzIEJyb2tlckJhc2Uge1xuICAgIGF1dG9tYXRhO1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBsZWRnZXIsIHNlcnZpbmdQcm92aWRlcikge1xuICAgICAgICBzdXBlcihjb250cmFjdCwgbGVkZ2VyLCBzZXJ2aW5nUHJvdmlkZXIpO1xuICAgICAgICB0aGlzLmF1dG9tYXRhID0gbmV3IEF1dG9tYXRhKCk7XG4gICAgfVxuICAgIGFzeW5jIGdldExvY2tUaW1lKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbG9ja1RpbWUgPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmxvY2tUaW1lKCk7XG4gICAgICAgICAgICByZXR1cm4gbG9ja1RpbWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRBY2NvdW50KHByb3ZpZGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5jb250cmFjdC5nZXRBY2NvdW50KHByb3ZpZGVyKTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0QWNjb3VudFdpdGhEZXRhaWwocHJvdmlkZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmdldEFjY291bnQocHJvdmlkZXIpO1xuICAgICAgICAgICAgY29uc3QgbG9ja1RpbWUgPSBhd2FpdCB0aGlzLmdldExvY2tUaW1lKCk7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBCaWdJbnQoTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkpOyAvLyBDb252ZXJ0cyBtaWxsaXNlY29uZHMgdG8gc2Vjb25kc1xuICAgICAgICAgICAgY29uc3QgcmVmdW5kcyA9IGFjY291bnQucmVmdW5kc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHJlZnVuZCkgPT4gIXJlZnVuZC5wcm9jZXNzZWQpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocmVmdW5kKSA9PiByZWZ1bmQuYW1vdW50ICE9PSBCaWdJbnQoMCkpXG4gICAgICAgICAgICAgICAgLm1hcCgocmVmdW5kKSA9PiAoe1xuICAgICAgICAgICAgICAgIGFtb3VudDogcmVmdW5kLmFtb3VudCxcbiAgICAgICAgICAgICAgICByZW1haW5UaW1lOiBsb2NrVGltZSAtIChub3cgLSByZWZ1bmQuY3JlYXRlZEF0KSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiB7IGFjY291bnQsIHJlZnVuZHMgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RTZXJ2aWNlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmljZXMgPSBhd2FpdCB0aGlzLmNvbnRyYWN0Lmxpc3RTZXJ2aWNlKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VydmljZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBhY2tub3dsZWRnZVByb3ZpZGVyU2lnbmVyKHByb3ZpZGVyQWRkcmVzcywgZ2FzUHJpY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb250cmFjdC5nZXRBY2NvdW50KHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5sZWRnZXIudHJhbnNmZXJGdW5kKHByb3ZpZGVyQWRkcmVzcywgJ2ZpbmUtdHVuaW5nJywgQmlnSW50KDApLCBnYXNQcmljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgeyBxdW90ZSwgcHJvdmlkZXJfc2lnbmVyIH0gPSBhd2FpdCB0aGlzLnNlcnZpbmdQcm92aWRlci5nZXRRdW90ZShwcm92aWRlckFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKCFxdW90ZSB8fCAhcHJvdmlkZXJfc2lnbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHF1b3RlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXF1b3RlLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgICAgICBxdW90ZSA9ICcweCcgKyBxdW90ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJwYyA9IHByb2Nlc3MuZW52LlJQQ19FTkRQT0lOVDtcbiAgICAgICAgICAgIC8vIGJ5cGFzcyBxdW90ZSB2ZXJpZmljYXRpb24gaWYgdGVzdGluZyBvbiBsb2NhbGhvc3RcbiAgICAgICAgICAgIGlmICghcnBjIHx8ICEvbG9jYWxob3N0fDEyN1xcLjBcXC4wXFwuMS8udGVzdChycGMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNWZXJpZmllZCA9IGF3YWl0IHRoaXMuYXV0b21hdGEudmVyaWZ5UXVvdGUocXVvdGUpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdRdW90ZSB2ZXJpZmljYXRpb246JywgaXNWZXJpZmllZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZlcmlmaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVvdGUgdmVyaWZpY2F0aW9uIGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmdldEFjY291bnQocHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgICAgIGlmIChhY2NvdW50LnByb3ZpZGVyU2lnbmVyID09PSBwcm92aWRlcl9zaWduZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUHJvdmlkZXIgc2lnbmVyIGFscmVhZHkgYWNrbm93bGVkZ2VkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jb250cmFjdC5hY2tub3dsZWRnZVByb3ZpZGVyU2lnbmVyKHByb3ZpZGVyQWRkcmVzcywgcHJvdmlkZXJfc2lnbmVyLCBnYXNQcmljZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjcmVhdGVUYXNrKHByb3ZpZGVyQWRkcmVzcywgcHJlVHJhaW5lZE1vZGVsTmFtZSwgZGF0YVNpemUsIGRhdGFzZXRIYXNoLCB0cmFpbmluZ1BhdGgsIGdhc1ByaWNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcHJlVHJhaW5lZE1vZGVsSGFzaDtcbiAgICAgICAgICAgIGlmIChwcmVUcmFpbmVkTW9kZWxOYW1lIGluIE1PREVMX0hBU0hfTUFQKSB7XG4gICAgICAgICAgICAgICAgcHJlVHJhaW5lZE1vZGVsSGFzaCA9IE1PREVMX0hBU0hfTUFQW3ByZVRyYWluZWRNb2RlbE5hbWVdLnR1cmJvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBhd2FpdCB0aGlzLnNlcnZpbmdQcm92aWRlci5nZXRDdXN0b21pemVkTW9kZWwocHJvdmlkZXJBZGRyZXNzLCBwcmVUcmFpbmVkTW9kZWxOYW1lKTtcbiAgICAgICAgICAgICAgICBwcmVUcmFpbmVkTW9kZWxIYXNoID0gbW9kZWwuaGFzaDtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgY3VzdG9taXplZCBtb2RlbCBoYXNoOiAke3ByZVRyYWluZWRNb2RlbEhhc2h9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlID0gYXdhaXQgdGhpcy5jb250cmFjdC5nZXRTZXJ2aWNlKHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCB0cmFpbmluZ1BhcmFtcyA9IGF3YWl0IHJlYWRGaWxlQ29udGVudCh0cmFpbmluZ1BhdGgpO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkUGFyYW1zID0gdGhpcy52ZXJpZnlUcmFpbmluZ1BhcmFtcyh0cmFpbmluZ1BhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCB0cmFpbkVwb2NocyA9IChwYXJzZWRQYXJhbXMubnVtX3RyYWluX2Vwb2NocyB8fCBwYXJzZWRQYXJhbXMudG90YWxfc3RlcHMpID8/IDM7XG4gICAgICAgICAgICBjb25zdCBmZWUgPSBzZXJ2aWNlLnByaWNlUGVyVG9rZW4gKiBCaWdJbnQoZGF0YVNpemUpICogQmlnSW50KHRyYWluRXBvY2hzKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFc3RpbWF0ZWQgZmVlOiAke2ZlZX0gKG5ldXJvbiksIGRhdGEgc2l6ZTogJHtkYXRhU2l6ZX0sIHRyYWluIGVwb2NoczogJHt0cmFpbkVwb2Noc30sIHByaWNlIHBlciB0b2tlbjogJHtzZXJ2aWNlLnByaWNlUGVyVG9rZW59IChuZXVyb24pYCk7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5jb250cmFjdC5nZXRBY2NvdW50KHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAoYWNjb3VudC5iYWxhbmNlIC0gYWNjb3VudC5wZW5kaW5nUmVmdW5kIDwgZmVlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5sZWRnZXIudHJhbnNmZXJGdW5kKHByb3ZpZGVyQWRkcmVzcywgJ2ZpbmUtdHVuaW5nJywgZmVlLCBnYXNQcmljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGdldE5vbmNlKCk7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzaWduUmVxdWVzdCh0aGlzLmNvbnRyYWN0LnNpZ25lciwgdGhpcy5jb250cmFjdC5nZXRVc2VyQWRkcmVzcygpLCBCaWdJbnQobm9uY2UpLCBkYXRhc2V0SGFzaCwgZmVlKTtcbiAgICAgICAgICAgIGxldCB3YWl0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjb3VudGVyID0gYXdhaXQgdGhpcy5zZXJ2aW5nUHJvdmlkZXIuZ2V0UGVuZGluZ1Rhc2tDb3VudGVyKHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAoY291bnRlciA+IDApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCBhc2tVc2VyKGBUaGVyZSBhcmUgJHtjb3VudGVyfSB0YXNrcyBpbiB0aGUgcXVldWUuIERvIHlvdSB3YW50IHRvIGNvbnRpbnVlPyAoeWVzL25vKTogYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbnN3ZXIudG9Mb3dlckNhc2UoKSA9PT0gJ3llcycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuc3dlci50b0xvd2VyQ2FzZSgpID09PSAneScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoWydubycsICduJ10uaW5jbHVkZXMoYW5zd2VyLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgb3B0ZWQgbm90IHRvIGNvbnRpbnVlIGR1ZSB0byBwZW5kaW5nIHRhc2tzIGluIHRoZSBxdWV1ZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIGlucHV0LiBQbGVhc2UgcmVzcG9uZCB3aXRoIHllcy95IG9yIG5vL24uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXNrID0ge1xuICAgICAgICAgICAgICAgIHVzZXJBZGRyZXNzOiB0aGlzLmNvbnRyYWN0LmdldFVzZXJBZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgZGF0YXNldEhhc2gsXG4gICAgICAgICAgICAgICAgdHJhaW5pbmdQYXJhbXMsXG4gICAgICAgICAgICAgICAgcHJlVHJhaW5lZE1vZGVsSGFzaCxcbiAgICAgICAgICAgICAgICBmZWU6IGZlZS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG5vbmNlOiBub25jZS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICB3YWl0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcnZpbmdQcm92aWRlci5jcmVhdGVUYXNrKHByb3ZpZGVyQWRkcmVzcywgdGFzayk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjYW5jZWxUYXNrKHByb3ZpZGVyQWRkcmVzcywgdGFza0lEKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzaWduVGFza0lEKHRoaXMuY29udHJhY3Quc2lnbmVyLCB0YXNrSUQpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VydmluZ1Byb3ZpZGVyLmNhbmNlbFRhc2socHJvdmlkZXJBZGRyZXNzLCBzaWduYXR1cmUsIHRhc2tJRCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0VGFzayhwcm92aWRlckFkZHJlc3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcnZpbmdQcm92aWRlci5saXN0VGFzayhwcm92aWRlckFkZHJlc3MsIHRoaXMuY29udHJhY3QuZ2V0VXNlckFkZHJlc3MoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUYXNrKHByb3ZpZGVyQWRkcmVzcywgdGFza0lEKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXRhc2tJRCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2tzID0gYXdhaXQgdGhpcy5zZXJ2aW5nUHJvdmlkZXIubGlzdFRhc2socHJvdmlkZXJBZGRyZXNzLCB0aGlzLmNvbnRyYWN0LmdldFVzZXJBZGRyZXNzKCksIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0YXNrIGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcnZpbmdQcm92aWRlci5nZXRUYXNrKHByb3ZpZGVyQWRkcmVzcywgdGhpcy5jb250cmFjdC5nZXRVc2VyQWRkcmVzcygpLCB0YXNrSUQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gOC4gW2BjYWxsIHByb3ZpZGVyYF0gY2FsbCBwcm92aWRlciB0YXNrIHByb2dyZXNzIGFwaSB0byBnZXQgdGFzayBwcm9ncmVzc1xuICAgIGFzeW5jIGdldExvZyhwcm92aWRlckFkZHJlc3MsIHRhc2tJRCkge1xuICAgICAgICBpZiAoIXRhc2tJRCkge1xuICAgICAgICAgICAgY29uc3QgdGFza3MgPSBhd2FpdCB0aGlzLnNlcnZpbmdQcm92aWRlci5saXN0VGFzayhwcm92aWRlckFkZHJlc3MsIHRoaXMuY29udHJhY3QuZ2V0VXNlckFkZHJlc3MoKSwgdHJ1ZSk7XG4gICAgICAgICAgICB0YXNrSUQgPSB0YXNrc1swXS5pZDtcbiAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGggPT09IDAgfHwgIXRhc2tJRCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdGFzayBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpbmdQcm92aWRlci5nZXRMb2cocHJvdmlkZXJBZGRyZXNzLCB0aGlzLmNvbnRyYWN0LmdldFVzZXJBZGRyZXNzKCksIHRhc2tJRCk7XG4gICAgfVxuICAgIGFzeW5jIG1vZGVsVXNhZ2UocHJvdmlkZXJBZGRyZXNzLCBwcmVUcmFpbmVkTW9kZWxOYW1lLCBvdXRwdXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcnZpbmdQcm92aWRlci5nZXRDdXN0b21pemVkTW9kZWxEZXRhaWxVc2FnZShwcm92aWRlckFkZHJlc3MsIHByZVRyYWluZWRNb2RlbE5hbWUsIG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2ZXJpZnlUcmFpbmluZ1BhcmFtcyh0cmFpbmluZ1BhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodHJhaW5pbmdQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCc7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTiBpbiB0cmFpbmluZ1BhdGggZmlsZTogJHtlcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbmNvbnN0IHt0b1N0cmluZ30gPSBPYmplY3QucHJvdG90eXBlO1xuY29uc3Qge2dldFByb3RvdHlwZU9mfSA9IE9iamVjdDtcblxuY29uc3Qga2luZE9mID0gKGNhY2hlID0+IHRoaW5nID0+IHtcbiAgICBjb25zdCBzdHIgPSB0b1N0cmluZy5jYWxsKHRoaW5nKTtcbiAgICByZXR1cm4gY2FjaGVbc3RyXSB8fCAoY2FjaGVbc3RyXSA9IHN0ci5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKSk7XG59KShPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuY29uc3Qga2luZE9mVGVzdCA9ICh0eXBlKSA9PiB7XG4gIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAodGhpbmcpID0+IGtpbmRPZih0aGluZykgPT09IHR5cGVcbn07XG5cbmNvbnN0IHR5cGVPZlRlc3QgPSB0eXBlID0+IHRoaW5nID0+IHR5cGVvZiB0aGluZyA9PT0gdHlwZTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IHtpc0FycmF5fSA9IEFycmF5O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzVW5kZWZpbmVkID0gdHlwZU9mVGVzdCgndW5kZWZpbmVkJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgaXNGdW5jdGlvbih2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIpICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQXJyYXlCdWZmZXIgPSBraW5kT2ZUZXN0KCdBcnJheUJ1ZmZlcicpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAoaXNBcnJheUJ1ZmZlcih2YWwuYnVmZmVyKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1N0cmluZyA9IHR5cGVPZlRlc3QoJ3N0cmluZycpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRnVuY3Rpb24gPSB0eXBlT2ZUZXN0KCdmdW5jdGlvbicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzTnVtYmVyID0gdHlwZU9mVGVzdCgnbnVtYmVyJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzT2JqZWN0ID0gKHRoaW5nKSA9PiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQm9vbGVhblxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQm9vbGVhbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQm9vbGVhbiA9IHRoaW5nID0+IHRoaW5nID09PSB0cnVlIHx8IHRoaW5nID09PSBmYWxzZTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4ge1xuICBpZiAoa2luZE9mKHZhbCkgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIChwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpID09PSBudWxsKSAmJiAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWwpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbCk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNEYXRlID0ga2luZE9mVGVzdCgnRGF0ZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlID0ga2luZE9mVGVzdCgnRmlsZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNCbG9iID0ga2luZE9mVGVzdCgnQmxvYicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZUxpc3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRmlsZUxpc3QgPSBraW5kT2ZUZXN0KCdGaWxlTGlzdCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzU3RyZWFtID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGb3JtRGF0YSA9ICh0aGluZykgPT4ge1xuICBsZXQga2luZDtcbiAgcmV0dXJuIHRoaW5nICYmIChcbiAgICAodHlwZW9mIEZvcm1EYXRhID09PSAnZnVuY3Rpb24nICYmIHRoaW5nIGluc3RhbmNlb2YgRm9ybURhdGEpIHx8IChcbiAgICAgIGlzRnVuY3Rpb24odGhpbmcuYXBwZW5kKSAmJiAoXG4gICAgICAgIChraW5kID0ga2luZE9mKHRoaW5nKSkgPT09ICdmb3JtZGF0YScgfHxcbiAgICAgICAgLy8gZGV0ZWN0IGZvcm0tZGF0YSBpbnN0YW5jZVxuICAgICAgICAoa2luZCA9PT0gJ29iamVjdCcgJiYgaXNGdW5jdGlvbih0aGluZy50b1N0cmluZykgJiYgdGhpbmcudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgRm9ybURhdGFdJylcbiAgICAgIClcbiAgICApXG4gIClcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VSTFNlYXJjaFBhcmFtcyA9IGtpbmRPZlRlc3QoJ1VSTFNlYXJjaFBhcmFtcycpO1xuXG5jb25zdCBbaXNSZWFkYWJsZVN0cmVhbSwgaXNSZXF1ZXN0LCBpc1Jlc3BvbnNlLCBpc0hlYWRlcnNdID0gWydSZWFkYWJsZVN0cmVhbScsICdSZXF1ZXN0JywgJ1Jlc3BvbnNlJywgJ0hlYWRlcnMnXS5tYXAoa2luZE9mVGVzdCk7XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmNvbnN0IHRyaW0gPSAoc3RyKSA9PiBzdHIudHJpbSA/XG4gIHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXMgPSBmYWxzZV1cbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbiwge2FsbE93bktleXMgPSBmYWxzZX0gPSB7fSkge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBpO1xuICBsZXQgbDtcblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAoaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgY29uc3Qga2V5cyA9IGFsbE93bktleXMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopIDogT2JqZWN0LmtleXMob2JqKTtcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kS2V5KG9iaiwga2V5KSB7XG4gIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IF9rZXk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgX2tleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSA9PT0gX2tleS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gX2tleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IF9nbG9iYWwgPSAoKCkgPT4ge1xuICAvKmVzbGludCBuby11bmRlZjowKi9cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcbn0pKCk7XG5cbmNvbnN0IGlzQ29udGV4dERlZmluZWQgPSAoY29udGV4dCkgPT4gIWlzVW5kZWZpbmVkKGNvbnRleHQpICYmIGNvbnRleHQgIT09IF9nbG9iYWw7XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgY29uc3Qge2Nhc2VsZXNzfSA9IGlzQ29udGV4dERlZmluZWQodGhpcykgJiYgdGhpcyB8fCB7fTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGFzc2lnblZhbHVlID0gKHZhbCwga2V5KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gY2FzZWxlc3MgJiYgZmluZEtleShyZXN1bHQsIGtleSkgfHwga2V5O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFt0YXJnZXRLZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2UocmVzdWx0W3RhcmdldEtleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBhcmd1bWVudHNbaV0gJiYgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbYWxsT3duS2V5c11cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuY29uc3QgZXh0ZW5kID0gKGEsIGIsIHRoaXNBcmcsIHthbGxPd25LZXlzfT0ge30pID0+IHtcbiAgZm9yRWFjaChiLCAodmFsLCBrZXkpID0+IHtcbiAgICBpZiAodGhpc0FyZyAmJiBpc0Z1bmN0aW9uKHZhbCkpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSwge2FsbE93bktleXN9KTtcbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5jb25zdCBzdHJpcEJPTSA9IChjb250ZW50KSA9PiB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufTtcblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3BzXVxuICogQHBhcmFtIHtvYmplY3R9IFtkZXNjcmlwdG9yc11cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgaW5oZXJpdHMgPSAoY29uc3RydWN0b3IsIHN1cGVyQ29uc3RydWN0b3IsIHByb3BzLCBkZXNjcmlwdG9ycykgPT4ge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCBkZXNjcmlwdG9ycyk7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdzdXBlcicsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgfSk7XG4gIHByb3BzICYmIE9iamVjdC5hc3NpZ24oY29uc3RydWN0b3IucHJvdG90eXBlLCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFJlc29sdmUgb2JqZWN0IHdpdGggZGVlcCBwcm90b3R5cGUgY2hhaW4gdG8gYSBmbGF0IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZU9iaiBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gW2Rlc3RPYmpdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEJvb2xlYW59IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcEZpbHRlcl1cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5jb25zdCB0b0ZsYXRPYmplY3QgPSAoc291cmNlT2JqLCBkZXN0T2JqLCBmaWx0ZXIsIHByb3BGaWx0ZXIpID0+IHtcbiAgbGV0IHByb3BzO1xuICBsZXQgaTtcbiAgbGV0IHByb3A7XG4gIGNvbnN0IG1lcmdlZCA9IHt9O1xuXG4gIGRlc3RPYmogPSBkZXN0T2JqIHx8IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgaWYgKHNvdXJjZU9iaiA9PSBudWxsKSByZXR1cm4gZGVzdE9iajtcblxuICBkbyB7XG4gICAgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VPYmopO1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmICgoIXByb3BGaWx0ZXIgfHwgcHJvcEZpbHRlcihwcm9wLCBzb3VyY2VPYmosIGRlc3RPYmopKSAmJiAhbWVyZ2VkW3Byb3BdKSB7XG4gICAgICAgIGRlc3RPYmpbcHJvcF0gPSBzb3VyY2VPYmpbcHJvcF07XG4gICAgICAgIG1lcmdlZFtwcm9wXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZU9iaiA9IGZpbHRlciAhPT0gZmFsc2UgJiYgZ2V0UHJvdG90eXBlT2Yoc291cmNlT2JqKTtcbiAgfSB3aGlsZSAoc291cmNlT2JqICYmICghZmlsdGVyIHx8IGZpbHRlcihzb3VyY2VPYmosIGRlc3RPYmopKSAmJiBzb3VyY2VPYmogIT09IE9iamVjdC5wcm90b3R5cGUpO1xuXG4gIHJldHVybiBkZXN0T2JqO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgZW5kcyB3aXRoIHRoZSBjaGFyYWN0ZXJzIG9mIGEgc3BlY2lmaWVkIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb249IDBdXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVuZHNXaXRoID0gKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikgPT4ge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPiBzdHIubGVuZ3RoKSB7XG4gICAgcG9zaXRpb24gPSBzdHIubGVuZ3RoO1xuICB9XG4gIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHN0ci5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgbmV3IGFycmF5IGZyb20gYXJyYXkgbGlrZSBvYmplY3Qgb3IgbnVsbCBpZiBmYWlsZWRcbiAqXG4gKiBAcGFyYW0geyp9IFt0aGluZ11cbiAqXG4gKiBAcmV0dXJucyB7P0FycmF5fVxuICovXG5jb25zdCB0b0FycmF5ID0gKHRoaW5nKSA9PiB7XG4gIGlmICghdGhpbmcpIHJldHVybiBudWxsO1xuICBpZiAoaXNBcnJheSh0aGluZykpIHJldHVybiB0aGluZztcbiAgbGV0IGkgPSB0aGluZy5sZW5ndGg7XG4gIGlmICghaXNOdW1iZXIoaSkpIHJldHVybiBudWxsO1xuICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgYXJyW2ldID0gdGhpbmdbaV07XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICogQ2hlY2tpbmcgaWYgdGhlIFVpbnQ4QXJyYXkgZXhpc3RzIGFuZCBpZiBpdCBkb2VzLCBpdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlXG4gKiB0aGluZyBwYXNzZWQgaW4gaXMgYW4gaW5zdGFuY2Ugb2YgVWludDhBcnJheVxuICpcbiAqIEBwYXJhbSB7VHlwZWRBcnJheX1cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5jb25zdCBpc1R5cGVkQXJyYXkgPSAoVHlwZWRBcnJheSA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiB0aGluZyA9PiB7XG4gICAgcmV0dXJuIFR5cGVkQXJyYXkgJiYgdGhpbmcgaW5zdGFuY2VvZiBUeXBlZEFycmF5O1xuICB9O1xufSkodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIGdldFByb3RvdHlwZU9mKFVpbnQ4QXJyYXkpKTtcblxuLyoqXG4gKiBGb3IgZWFjaCBlbnRyeSBpbiB0aGUgb2JqZWN0LCBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBrZXkgYW5kIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PGFueSwgYW55Pn0gb2JqIC0gVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGVudHJ5LlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCBmb3JFYWNoRW50cnkgPSAob2JqLCBmbikgPT4ge1xuICBjb25zdCBnZW5lcmF0b3IgPSBvYmogJiYgb2JqW1N5bWJvbC5pdGVyYXRvcl07XG5cbiAgY29uc3QgaXRlcmF0b3IgPSBnZW5lcmF0b3IuY2FsbChvYmopO1xuXG4gIGxldCByZXN1bHQ7XG5cbiAgd2hpbGUgKChyZXN1bHQgPSBpdGVyYXRvci5uZXh0KCkpICYmICFyZXN1bHQuZG9uZSkge1xuICAgIGNvbnN0IHBhaXIgPSByZXN1bHQudmFsdWU7XG4gICAgZm4uY2FsbChvYmosIHBhaXJbMF0sIHBhaXJbMV0pO1xuICB9XG59O1xuXG4vKipcbiAqIEl0IHRha2VzIGEgcmVndWxhciBleHByZXNzaW9uIGFuZCBhIHN0cmluZywgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBtYXRjaGVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ0V4cCAtIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggYWdhaW5zdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8Ym9vbGVhbj59XG4gKi9cbmNvbnN0IG1hdGNoQWxsID0gKHJlZ0V4cCwgc3RyKSA9PiB7XG4gIGxldCBtYXRjaGVzO1xuICBjb25zdCBhcnIgPSBbXTtcblxuICB3aGlsZSAoKG1hdGNoZXMgPSByZWdFeHAuZXhlYyhzdHIpKSAhPT0gbnVsbCkge1xuICAgIGFyci5wdXNoKG1hdGNoZXMpO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qIENoZWNraW5nIGlmIHRoZSBraW5kT2ZUZXN0IGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB3aGVuIHBhc3NlZCBhbiBIVE1MRm9ybUVsZW1lbnQuICovXG5jb25zdCBpc0hUTUxGb3JtID0ga2luZE9mVGVzdCgnSFRNTEZvcm1FbGVtZW50Jyk7XG5cbmNvbnN0IHRvQ2FtZWxDYXNlID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX1xcc10oW2EtelxcZF0pKFxcdyopL2csXG4gICAgZnVuY3Rpb24gcmVwbGFjZXIobSwgcDEsIHAyKSB7XG4gICAgICByZXR1cm4gcDEudG9VcHBlckNhc2UoKSArIHAyO1xuICAgIH1cbiAgKTtcbn07XG5cbi8qIENyZWF0aW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNoZWNrIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS4gKi9cbmNvbnN0IGhhc093blByb3BlcnR5ID0gKCh7aGFzT3duUHJvcGVydHl9KSA9PiAob2JqLCBwcm9wKSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpKE9iamVjdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNSZWdFeHAgPSBraW5kT2ZUZXN0KCdSZWdFeHAnKTtcblxuY29uc3QgcmVkdWNlRGVzY3JpcHRvcnMgPSAob2JqLCByZWR1Y2VyKSA9PiB7XG4gIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKTtcbiAgY29uc3QgcmVkdWNlZERlc2NyaXB0b3JzID0ge307XG5cbiAgZm9yRWFjaChkZXNjcmlwdG9ycywgKGRlc2NyaXB0b3IsIG5hbWUpID0+IHtcbiAgICBsZXQgcmV0O1xuICAgIGlmICgocmV0ID0gcmVkdWNlcihkZXNjcmlwdG9yLCBuYW1lLCBvYmopKSAhPT0gZmFsc2UpIHtcbiAgICAgIHJlZHVjZWREZXNjcmlwdG9yc1tuYW1lXSA9IHJldCB8fCBkZXNjcmlwdG9yO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCByZWR1Y2VkRGVzY3JpcHRvcnMpO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhbGwgbWV0aG9kcyByZWFkLW9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5jb25zdCBmcmVlemVNZXRob2RzID0gKG9iaikgPT4ge1xuICByZWR1Y2VEZXNjcmlwdG9ycyhvYmosIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XG4gICAgLy8gc2tpcCByZXN0cmljdGVkIHByb3BzIGluIHN0cmljdCBtb2RlXG4gICAgaWYgKGlzRnVuY3Rpb24ob2JqKSAmJiBbJ2FyZ3VtZW50cycsICdjYWxsZXInLCAnY2FsbGVlJ10uaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IG9ialtuYW1lXTtcblxuICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybjtcblxuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCd3cml0YWJsZScgaW4gZGVzY3JpcHRvcikge1xuICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2FuIG5vdCByZXdyaXRlIHJlYWQtb25seSBtZXRob2QgXFwnJyArIG5hbWUgKyAnXFwnJyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCB0b09iamVjdFNldCA9IChhcnJheU9yU3RyaW5nLCBkZWxpbWl0ZXIpID0+IHtcbiAgY29uc3Qgb2JqID0ge307XG5cbiAgY29uc3QgZGVmaW5lID0gKGFycikgPT4ge1xuICAgIGFyci5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgIG9ialt2YWx1ZV0gPSB0cnVlO1xuICAgIH0pO1xuICB9O1xuXG4gIGlzQXJyYXkoYXJyYXlPclN0cmluZykgPyBkZWZpbmUoYXJyYXlPclN0cmluZykgOiBkZWZpbmUoU3RyaW5nKGFycmF5T3JTdHJpbmcpLnNwbGl0KGRlbGltaXRlcikpO1xuXG4gIHJldHVybiBvYmo7XG59O1xuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbmNvbnN0IHRvRmluaXRlTnVtYmVyID0gKHZhbHVlLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlID0gK3ZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufTtcblxuY29uc3QgQUxQSEEgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xuXG5jb25zdCBESUdJVCA9ICcwMTIzNDU2Nzg5JztcblxuY29uc3QgQUxQSEFCRVQgPSB7XG4gIERJR0lULFxuICBBTFBIQSxcbiAgQUxQSEFfRElHSVQ6IEFMUEhBICsgQUxQSEEudG9VcHBlckNhc2UoKSArIERJR0lUXG59O1xuXG5jb25zdCBnZW5lcmF0ZVN0cmluZyA9IChzaXplID0gMTYsIGFscGhhYmV0ID0gQUxQSEFCRVQuQUxQSEFfRElHSVQpID0+IHtcbiAgbGV0IHN0ciA9ICcnO1xuICBjb25zdCB7bGVuZ3RofSA9IGFscGhhYmV0O1xuICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgc3RyICs9IGFscGhhYmV0W01hdGgucmFuZG9tKCkgKiBsZW5ndGh8MF07XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBJZiB0aGUgdGhpbmcgaXMgYSBGb3JtRGF0YSBvYmplY3QsIHJldHVybiB0cnVlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gdGhpbmcgLSBUaGUgdGhpbmcgdG8gY2hlY2suXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3BlY0NvbXBsaWFudEZvcm0odGhpbmcpIHtcbiAgcmV0dXJuICEhKHRoaW5nICYmIGlzRnVuY3Rpb24odGhpbmcuYXBwZW5kKSAmJiB0aGluZ1tTeW1ib2wudG9TdHJpbmdUYWddID09PSAnRm9ybURhdGEnICYmIHRoaW5nW1N5bWJvbC5pdGVyYXRvcl0pO1xufVxuXG5jb25zdCB0b0pTT05PYmplY3QgPSAob2JqKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IEFycmF5KDEwKTtcblxuICBjb25zdCB2aXNpdCA9IChzb3VyY2UsIGkpID0+IHtcblxuICAgIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICBpZiAoc3RhY2suaW5kZXhPZihzb3VyY2UpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZighKCd0b0pTT04nIGluIHNvdXJjZSkpIHtcbiAgICAgICAgc3RhY2tbaV0gPSBzb3VyY2U7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGlzQXJyYXkoc291cmNlKSA/IFtdIDoge307XG5cbiAgICAgICAgZm9yRWFjaChzb3VyY2UsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVkdWNlZFZhbHVlID0gdmlzaXQodmFsdWUsIGkgKyAxKTtcbiAgICAgICAgICAhaXNVbmRlZmluZWQocmVkdWNlZFZhbHVlKSAmJiAodGFyZ2V0W2tleV0gPSByZWR1Y2VkVmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdGFja1tpXSA9IHVuZGVmaW5lZDtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2U7XG4gIH07XG5cbiAgcmV0dXJuIHZpc2l0KG9iaiwgMCk7XG59O1xuXG5jb25zdCBpc0FzeW5jRm4gPSBraW5kT2ZUZXN0KCdBc3luY0Z1bmN0aW9uJyk7XG5cbmNvbnN0IGlzVGhlbmFibGUgPSAodGhpbmcpID0+XG4gIHRoaW5nICYmIChpc09iamVjdCh0aGluZykgfHwgaXNGdW5jdGlvbih0aGluZykpICYmIGlzRnVuY3Rpb24odGhpbmcudGhlbikgJiYgaXNGdW5jdGlvbih0aGluZy5jYXRjaCk7XG5cbi8vIG9yaWdpbmFsIGNvZGVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EaWdpdGFsQnJhaW5KUy9BeGlvc1Byb21pc2UvYmxvYi8xNmRlYWIxMzcxMGVjMDk3Nzk5MjIxMzFmM2ZhNTk1NDMyMGY4M2FiL2xpYi91dGlscy5qcyNMMTEtTDM0XG5cbmNvbnN0IF9zZXRJbW1lZGlhdGUgPSAoKHNldEltbWVkaWF0ZVN1cHBvcnRlZCwgcG9zdE1lc3NhZ2VTdXBwb3J0ZWQpID0+IHtcbiAgaWYgKHNldEltbWVkaWF0ZVN1cHBvcnRlZCkge1xuICAgIHJldHVybiBzZXRJbW1lZGlhdGU7XG4gIH1cblxuICByZXR1cm4gcG9zdE1lc3NhZ2VTdXBwb3J0ZWQgPyAoKHRva2VuLCBjYWxsYmFja3MpID0+IHtcbiAgICBfZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsICh7c291cmNlLCBkYXRhfSkgPT4ge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gX2dsb2JhbCAmJiBkYXRhID09PSB0b2tlbikge1xuICAgICAgICBjYWxsYmFja3MubGVuZ3RoICYmIGNhbGxiYWNrcy5zaGlmdCgpKCk7XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgcmV0dXJuIChjYikgPT4ge1xuICAgICAgY2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgX2dsb2JhbC5wb3N0TWVzc2FnZSh0b2tlbiwgXCIqXCIpO1xuICAgIH1cbiAgfSkoYGF4aW9zQCR7TWF0aC5yYW5kb20oKX1gLCBbXSkgOiAoY2IpID0+IHNldFRpbWVvdXQoY2IpO1xufSkoXG4gIHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicsXG4gIGlzRnVuY3Rpb24oX2dsb2JhbC5wb3N0TWVzc2FnZSlcbik7XG5cbmNvbnN0IGFzYXAgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgIT09ICd1bmRlZmluZWQnID9cbiAgcXVldWVNaWNyb3Rhc2suYmluZChfZ2xvYmFsKSA6ICggdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MubmV4dFRpY2sgfHwgX3NldEltbWVkaWF0ZSk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKlxuXG52YXIgdXRpbHMkMSA9IHtcbiAgaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXIsXG4gIGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZyxcbiAgaXNOdW1iZXIsXG4gIGlzQm9vbGVhbixcbiAgaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzUmVxdWVzdCxcbiAgaXNSZXNwb25zZSxcbiAgaXNIZWFkZXJzLFxuICBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlLFxuICBpc0ZpbGUsXG4gIGlzQmxvYixcbiAgaXNSZWdFeHAsXG4gIGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNUeXBlZEFycmF5LFxuICBpc0ZpbGVMaXN0LFxuICBmb3JFYWNoLFxuICBtZXJnZSxcbiAgZXh0ZW5kLFxuICB0cmltLFxuICBzdHJpcEJPTSxcbiAgaW5oZXJpdHMsXG4gIHRvRmxhdE9iamVjdCxcbiAga2luZE9mLFxuICBraW5kT2ZUZXN0LFxuICBlbmRzV2l0aCxcbiAgdG9BcnJheSxcbiAgZm9yRWFjaEVudHJ5LFxuICBtYXRjaEFsbCxcbiAgaXNIVE1MRm9ybSxcbiAgaGFzT3duUHJvcGVydHksXG4gIGhhc093blByb3A6IGhhc093blByb3BlcnR5LCAvLyBhbiBhbGlhcyB0byBhdm9pZCBFU0xpbnQgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIGRldGVjdGlvblxuICByZWR1Y2VEZXNjcmlwdG9ycyxcbiAgZnJlZXplTWV0aG9kcyxcbiAgdG9PYmplY3RTZXQsXG4gIHRvQ2FtZWxDYXNlLFxuICBub29wLFxuICB0b0Zpbml0ZU51bWJlcixcbiAgZmluZEtleSxcbiAgZ2xvYmFsOiBfZ2xvYmFsLFxuICBpc0NvbnRleHREZWZpbmVkLFxuICBBTFBIQUJFVCxcbiAgZ2VuZXJhdGVTdHJpbmcsXG4gIGlzU3BlY0NvbXBsaWFudEZvcm0sXG4gIHRvSlNPTk9iamVjdCxcbiAgaXNBc3luY0ZuLFxuICBpc1RoZW5hYmxlLFxuICBzZXRJbW1lZGlhdGU6IF9zZXRJbW1lZGlhdGUsXG4gIGFzYXBcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBBeGlvc0Vycm9yKG1lc3NhZ2UsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbiAgfVxuXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMubmFtZSA9ICdBeGlvc0Vycm9yJztcbiAgY29kZSAmJiAodGhpcy5jb2RlID0gY29kZSk7XG4gIGNvbmZpZyAmJiAodGhpcy5jb25maWcgPSBjb25maWcpO1xuICByZXF1ZXN0ICYmICh0aGlzLnJlcXVlc3QgPSByZXF1ZXN0KTtcbiAgaWYgKHJlc3BvbnNlKSB7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzID8gcmVzcG9uc2Uuc3RhdHVzIDogbnVsbDtcbiAgfVxufVxuXG51dGlscyQxLmluaGVyaXRzKEF4aW9zRXJyb3IsIEVycm9yLCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHV0aWxzJDEudG9KU09OT2JqZWN0KHRoaXMuY29uZmlnKSxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXNcbiAgICB9O1xuICB9XG59KTtcblxuY29uc3QgcHJvdG90eXBlJDEgPSBBeGlvc0Vycm9yLnByb3RvdHlwZTtcbmNvbnN0IGRlc2NyaXB0b3JzID0ge307XG5cbltcbiAgJ0VSUl9CQURfT1BUSU9OX1ZBTFVFJyxcbiAgJ0VSUl9CQURfT1BUSU9OJyxcbiAgJ0VDT05OQUJPUlRFRCcsXG4gICdFVElNRURPVVQnLFxuICAnRVJSX05FVFdPUksnLFxuICAnRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUUycsXG4gICdFUlJfREVQUkVDQVRFRCcsXG4gICdFUlJfQkFEX1JFU1BPTlNFJyxcbiAgJ0VSUl9CQURfUkVRVUVTVCcsXG4gICdFUlJfQ0FOQ0VMRUQnLFxuICAnRVJSX05PVF9TVVBQT1JUJyxcbiAgJ0VSUl9JTlZBTElEX1VSTCdcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5dLmZvckVhY2goY29kZSA9PiB7XG4gIGRlc2NyaXB0b3JzW2NvZGVdID0ge3ZhbHVlOiBjb2RlfTtcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBeGlvc0Vycm9yLCBkZXNjcmlwdG9ycyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlJDEsICdpc0F4aW9zRXJyb3InLCB7dmFsdWU6IHRydWV9KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbkF4aW9zRXJyb3IuZnJvbSA9IChlcnJvciwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSwgY3VzdG9tUHJvcHMpID0+IHtcbiAgY29uc3QgYXhpb3NFcnJvciA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlJDEpO1xuXG4gIHV0aWxzJDEudG9GbGF0T2JqZWN0KGVycm9yLCBheGlvc0Vycm9yLCBmdW5jdGlvbiBmaWx0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gRXJyb3IucHJvdG90eXBlO1xuICB9LCBwcm9wID0+IHtcbiAgICByZXR1cm4gcHJvcCAhPT0gJ2lzQXhpb3NFcnJvcic7XG4gIH0pO1xuXG4gIEF4aW9zRXJyb3IuY2FsbChheGlvc0Vycm9yLCBlcnJvci5tZXNzYWdlLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlKTtcblxuICBheGlvc0Vycm9yLmNhdXNlID0gZXJyb3I7XG5cbiAgYXhpb3NFcnJvci5uYW1lID0gZXJyb3IubmFtZTtcblxuICBjdXN0b21Qcm9wcyAmJiBPYmplY3QuYXNzaWduKGF4aW9zRXJyb3IsIGN1c3RvbVByb3BzKTtcblxuICByZXR1cm4gYXhpb3NFcnJvcjtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzdHJpY3RcbnZhciBodHRwQWRhcHRlciA9IG51bGw7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gdGhpbmcgaXMgYSBhcnJheSBvciBqcyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRoaW5nIC0gVGhlIG9iamVjdCBvciBhcnJheSB0byBiZSB2aXNpdGVkLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Zpc2l0YWJsZSh0aGluZykge1xuICByZXR1cm4gdXRpbHMkMS5pc1BsYWluT2JqZWN0KHRoaW5nKSB8fCB1dGlscyQxLmlzQXJyYXkodGhpbmcpO1xufVxuXG4vKipcbiAqIEl0IHJlbW92ZXMgdGhlIGJyYWNrZXRzIGZyb20gdGhlIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBwYXJhbWV0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGtleSB3aXRob3V0IHRoZSBicmFja2V0cy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQnJhY2tldHMoa2V5KSB7XG4gIHJldHVybiB1dGlscyQxLmVuZHNXaXRoKGtleSwgJ1tdJykgPyBrZXkuc2xpY2UoMCwgLTIpIDoga2V5O1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcGF0aCwgYSBrZXksIGFuZCBhIGJvb2xlYW4sIGFuZCByZXR1cm5zIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgY3VycmVudCBvYmplY3QgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkb3RzIC0gSWYgdHJ1ZSwgdGhlIGtleSB3aWxsIGJlIHJlbmRlcmVkIHdpdGggZG90cyBpbnN0ZWFkIG9mIGJyYWNrZXRzLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IGtleS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyS2V5KHBhdGgsIGtleSwgZG90cykge1xuICBpZiAoIXBhdGgpIHJldHVybiBrZXk7XG4gIHJldHVybiBwYXRoLmNvbmNhdChrZXkpLm1hcChmdW5jdGlvbiBlYWNoKHRva2VuLCBpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdG9rZW4gPSByZW1vdmVCcmFja2V0cyh0b2tlbik7XG4gICAgcmV0dXJuICFkb3RzICYmIGkgPyAnWycgKyB0b2tlbiArICddJyA6IHRva2VuO1xuICB9KS5qb2luKGRvdHMgPyAnLicgOiAnJyk7XG59XG5cbi8qKlxuICogSWYgdGhlIGFycmF5IGlzIGFuIGFycmF5IGFuZCBub25lIG9mIGl0cyBlbGVtZW50cyBhcmUgdmlzaXRhYmxlLCB0aGVuIGl0J3MgYSBmbGF0IGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyIC0gVGhlIGFycmF5IHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmxhdEFycmF5KGFycikge1xuICByZXR1cm4gdXRpbHMkMS5pc0FycmF5KGFycikgJiYgIWFyci5zb21lKGlzVmlzaXRhYmxlKTtcbn1cblxuY29uc3QgcHJlZGljYXRlcyA9IHV0aWxzJDEudG9GbGF0T2JqZWN0KHV0aWxzJDEsIHt9LCBudWxsLCBmdW5jdGlvbiBmaWx0ZXIocHJvcCkge1xuICByZXR1cm4gL15pc1tBLVpdLy50ZXN0KHByb3ApO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIGRhdGEgb2JqZWN0IHRvIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHs/T2JqZWN0fSBbZm9ybURhdGFdXG4gKiBAcGFyYW0gez9PYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmlzaXRvcl1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWV0YVRva2VucyA9IHRydWVdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRvdHMgPSBmYWxzZV1cbiAqIEBwYXJhbSB7P0Jvb2xlYW59IFtvcHRpb25zLmluZGV4ZXMgPSBmYWxzZV1cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICoqL1xuXG4vKipcbiAqIEl0IGNvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgRm9ybURhdGEgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgdG8gZm9ybSBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1EYXRhIC0gVGhlIEZvcm1EYXRhIG9iamVjdCB0byBhcHBlbmQgdG8uXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiB0b0Zvcm1EYXRhKG9iaiwgZm9ybURhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCF1dGlscyQxLmlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXQgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBmb3JtRGF0YSA9IGZvcm1EYXRhIHx8IG5ldyAoRm9ybURhdGEpKCk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIG9wdGlvbnMgPSB1dGlscyQxLnRvRmxhdE9iamVjdChvcHRpb25zLCB7XG4gICAgbWV0YVRva2VuczogdHJ1ZSxcbiAgICBkb3RzOiBmYWxzZSxcbiAgICBpbmRleGVzOiBmYWxzZVxuICB9LCBmYWxzZSwgZnVuY3Rpb24gZGVmaW5lZChvcHRpb24sIHNvdXJjZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgIHJldHVybiAhdXRpbHMkMS5pc1VuZGVmaW5lZChzb3VyY2Vbb3B0aW9uXSk7XG4gIH0pO1xuXG4gIGNvbnN0IG1ldGFUb2tlbnMgPSBvcHRpb25zLm1ldGFUb2tlbnM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICBjb25zdCB2aXNpdG9yID0gb3B0aW9ucy52aXNpdG9yIHx8IGRlZmF1bHRWaXNpdG9yO1xuICBjb25zdCBkb3RzID0gb3B0aW9ucy5kb3RzO1xuICBjb25zdCBpbmRleGVzID0gb3B0aW9ucy5pbmRleGVzO1xuICBjb25zdCBfQmxvYiA9IG9wdGlvbnMuQmxvYiB8fCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgQmxvYjtcbiAgY29uc3QgdXNlQmxvYiA9IF9CbG9iICYmIHV0aWxzJDEuaXNTcGVjQ29tcGxpYW50Rm9ybShmb3JtRGF0YSk7XG5cbiAgaWYgKCF1dGlscyQxLmlzRnVuY3Rpb24odmlzaXRvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2aXNpdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29udmVydFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gJyc7XG5cbiAgICBpZiAodXRpbHMkMS5pc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoIXVzZUJsb2IgJiYgdXRpbHMkMS5pc0Jsb2IodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignQmxvYiBpcyBub3Qgc3VwcG9ydGVkLiBVc2UgYSBCdWZmZXIgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMkMS5pc0FycmF5QnVmZmVyKHZhbHVlKSB8fCB1dGlscyQxLmlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB1c2VCbG9iICYmIHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nID8gbmV3IEJsb2IoW3ZhbHVlXSkgOiBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmlzaXRvci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleVxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZ3xOdW1iZXI+fSBwYXRoXG4gICAqIEB0aGlzIHtGb3JtRGF0YX1cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybiB0cnVlIHRvIHZpc2l0IHRoZSBlYWNoIHByb3Agb2YgdGhlIHZhbHVlIHJlY3Vyc2l2ZWx5XG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0VmlzaXRvcih2YWx1ZSwga2V5LCBwYXRoKSB7XG4gICAgbGV0IGFyciA9IHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICYmICFwYXRoICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh1dGlscyQxLmVuZHNXaXRoKGtleSwgJ3t9JykpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGtleSA9IG1ldGFUb2tlbnMgPyBrZXkgOiBrZXkuc2xpY2UoMCwgLTIpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAodXRpbHMkMS5pc0FycmF5KHZhbHVlKSAmJiBpc0ZsYXRBcnJheSh2YWx1ZSkpIHx8XG4gICAgICAgICgodXRpbHMkMS5pc0ZpbGVMaXN0KHZhbHVlKSB8fCB1dGlscyQxLmVuZHNXaXRoKGtleSwgJ1tdJykpICYmIChhcnIgPSB1dGlscyQxLnRvQXJyYXkodmFsdWUpKVxuICAgICAgICApKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBrZXkgPSByZW1vdmVCcmFja2V0cyhrZXkpO1xuXG4gICAgICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uIGVhY2goZWwsIGluZGV4KSB7XG4gICAgICAgICAgISh1dGlscyQxLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgZm9ybURhdGEuYXBwZW5kKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBpbmRleGVzID09PSB0cnVlID8gcmVuZGVyS2V5KFtrZXldLCBpbmRleCwgZG90cykgOiAoaW5kZXhlcyA9PT0gbnVsbCA/IGtleSA6IGtleSArICdbXScpLFxuICAgICAgICAgICAgY29udmVydFZhbHVlKGVsKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzVmlzaXRhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9ybURhdGEuYXBwZW5kKHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpLCBjb252ZXJ0VmFsdWUodmFsdWUpKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHN0YWNrID0gW107XG5cbiAgY29uc3QgZXhwb3NlZEhlbHBlcnMgPSBPYmplY3QuYXNzaWduKHByZWRpY2F0ZXMsIHtcbiAgICBkZWZhdWx0VmlzaXRvcixcbiAgICBjb252ZXJ0VmFsdWUsXG4gICAgaXNWaXNpdGFibGVcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYnVpbGQodmFsdWUsIHBhdGgpIHtcbiAgICBpZiAodXRpbHMkMS5pc1VuZGVmaW5lZCh2YWx1ZSkpIHJldHVybjtcblxuICAgIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IEVycm9yKCdDaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQgaW4gJyArIHBhdGguam9pbignLicpKTtcbiAgICB9XG5cbiAgICBzdGFjay5wdXNoKHZhbHVlKTtcblxuICAgIHV0aWxzJDEuZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gZWFjaChlbCwga2V5KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSAhKHV0aWxzJDEuaXNVbmRlZmluZWQoZWwpIHx8IGVsID09PSBudWxsKSAmJiB2aXNpdG9yLmNhbGwoXG4gICAgICAgIGZvcm1EYXRhLCBlbCwgdXRpbHMkMS5pc1N0cmluZyhrZXkpID8ga2V5LnRyaW0oKSA6IGtleSwgcGF0aCwgZXhwb3NlZEhlbHBlcnNcbiAgICAgICk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgYnVpbGQoZWwsIHBhdGggPyBwYXRoLmNvbmNhdChrZXkpIDogW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc3RhY2sucG9wKCk7XG4gIH1cblxuICBpZiAoIXV0aWxzJDEuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIGJ1aWxkKG9iaik7XG5cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuXG4vKipcbiAqIEl0IGVuY29kZXMgYSBzdHJpbmcgYnkgcmVwbGFjaW5nIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBpbiB0aGUgdW5yZXNlcnZlZCBzZXQgd2l0aFxuICogdGhlaXIgcGVyY2VudC1lbmNvZGVkIGVxdWl2YWxlbnRzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlJDEoc3RyKSB7XG4gIGNvbnN0IGNoYXJNYXAgPSB7XG4gICAgJyEnOiAnJTIxJyxcbiAgICBcIidcIjogJyUyNycsXG4gICAgJygnOiAnJTI4JyxcbiAgICAnKSc6ICclMjknLFxuICAgICd+JzogJyU3RScsXG4gICAgJyUyMCc6ICcrJyxcbiAgICAnJTAwJzogJ1xceDAwJ1xuICB9O1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCl+XXwlMjB8JTAwL2csIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoKSB7XG4gICAgcmV0dXJuIGNoYXJNYXBbbWF0Y2hdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhcmFtcyBvYmplY3QgYW5kIGNvbnZlcnRzIGl0IHRvIGEgRm9ybURhdGEgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBGb3JtRGF0YSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkIHRvIHRoZSBBeGlvcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gQXhpb3NVUkxTZWFyY2hQYXJhbXMocGFyYW1zLCBvcHRpb25zKSB7XG4gIHRoaXMuX3BhaXJzID0gW107XG5cbiAgcGFyYW1zICYmIHRvRm9ybURhdGEocGFyYW1zLCB0aGlzLCBvcHRpb25zKTtcbn1cblxuY29uc3QgcHJvdG90eXBlID0gQXhpb3NVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMuX3BhaXJzLnB1c2goW25hbWUsIHZhbHVlXSk7XG59O1xuXG5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhlbmNvZGVyKSB7XG4gIGNvbnN0IF9lbmNvZGUgPSBlbmNvZGVyID8gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZW5jb2Rlci5jYWxsKHRoaXMsIHZhbHVlLCBlbmNvZGUkMSk7XG4gIH0gOiBlbmNvZGUkMTtcblxuICByZXR1cm4gdGhpcy5fcGFpcnMubWFwKGZ1bmN0aW9uIGVhY2gocGFpcikge1xuICAgIHJldHVybiBfZW5jb2RlKHBhaXJbMF0pICsgJz0nICsgX2VuY29kZShwYWlyWzFdKTtcbiAgfSwgJycpLmpvaW4oJyYnKTtcbn07XG5cbi8qKlxuICogSXQgcmVwbGFjZXMgYWxsIGluc3RhbmNlcyBvZiB0aGUgY2hhcmFjdGVycyBgOmAsIGAkYCwgYCxgLCBgK2AsIGBbYCwgYW5kIGBdYCB3aXRoIHRoZWlyXG4gKiBVUkkgZW5jb2RlZCBjb3VudGVycGFydHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsIFRoZSB2YWx1ZSB0byBiZSBlbmNvZGVkLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHBhcmFtIHs/KG9iamVjdHxGdW5jdGlvbil9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5mdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgb3B0aW9ucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIFxuICBjb25zdCBfZW5jb2RlID0gb3B0aW9ucyAmJiBvcHRpb25zLmVuY29kZSB8fCBlbmNvZGU7XG5cbiAgaWYgKHV0aWxzJDEuaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBzZXJpYWxpemU6IG9wdGlvbnNcbiAgICB9O1xuICB9IFxuXG4gIGNvbnN0IHNlcmlhbGl6ZUZuID0gb3B0aW9ucyAmJiBvcHRpb25zLnNlcmlhbGl6ZTtcblxuICBsZXQgc2VyaWFsaXplZFBhcmFtcztcblxuICBpZiAoc2VyaWFsaXplRm4pIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gc2VyaWFsaXplRm4ocGFyYW1zLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gdXRpbHMkMS5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpID9cbiAgICAgIHBhcmFtcy50b1N0cmluZygpIDpcbiAgICAgIG5ldyBBeGlvc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpLnRvU3RyaW5nKF9lbmNvZGUpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICBjb25zdCBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuXG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59XG5cbmNsYXNzIEludGVyY2VwdG9yTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICAgKi9cbiAgdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgICAgZnVsZmlsbGVkLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBpbnRlcmNlcHRvciB3YXMgcmVtb3ZlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAgICovXG4gIGVqZWN0KGlkKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBpbnRlcmNlcHRvcnMgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVycykge1xuICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICAgKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb3JFYWNoKGZuKSB7XG4gICAgdXRpbHMkMS5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICAgIGZuKGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbnZhciBJbnRlcmNlcHRvck1hbmFnZXIkMSA9IEludGVyY2VwdG9yTWFuYWdlcjtcblxudmFyIHRyYW5zaXRpb25hbERlZmF1bHRzID0ge1xuICBzaWxlbnRKU09OUGFyc2luZzogdHJ1ZSxcbiAgZm9yY2VkSlNPTlBhcnNpbmc6IHRydWUsXG4gIGNsYXJpZnlUaW1lb3V0RXJyb3I6IGZhbHNlXG59O1xuXG52YXIgVVJMU2VhcmNoUGFyYW1zJDEgPSB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyA/IFVSTFNlYXJjaFBhcmFtcyA6IEF4aW9zVVJMU2VhcmNoUGFyYW1zO1xuXG52YXIgRm9ybURhdGEkMSA9IHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBGb3JtRGF0YSA6IG51bGw7XG5cbnZhciBCbG9iJDEgPSB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iIDogbnVsbDtcblxudmFyIHBsYXRmb3JtJDEgPSB7XG4gIGlzQnJvd3NlcjogdHJ1ZSxcbiAgY2xhc3Nlczoge1xuICAgIFVSTFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zJDEsXG4gICAgRm9ybURhdGE6IEZvcm1EYXRhJDEsXG4gICAgQmxvYjogQmxvYiQxXG4gIH0sXG4gIHByb3RvY29sczogWydodHRwJywgJ2h0dHBzJywgJ2ZpbGUnLCAnYmxvYicsICd1cmwnLCAnZGF0YSddXG59O1xuXG5jb25zdCBoYXNCcm93c2VyRW52ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuY29uc3QgX25hdmlnYXRvciA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvciB8fCB1bmRlZmluZWQ7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJFbnYgPSBoYXNCcm93c2VyRW52ICYmXG4gICghX25hdmlnYXRvciB8fCBbJ1JlYWN0TmF0aXZlJywgJ05hdGl2ZVNjcmlwdCcsICdOUyddLmluZGV4T2YoX25hdmlnYXRvci5wcm9kdWN0KSA8IDApO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciB3ZWJXb3JrZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBBbHRob3VnaCB0aGUgYGlzU3RhbmRhcmRCcm93c2VyRW52YCBtZXRob2QgaW5kaWNhdGVzIHRoYXRcbiAqIGBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlcmAsIHRoZSBXZWJXb3JrZXIgd2lsbCBzdGlsbCBiZVxuICogZmlsdGVyZWQgb3V0IGR1ZSB0byBpdHMganVkZ21lbnQgc3RhbmRhcmRcbiAqIGB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnYC5cbiAqIFRoaXMgbGVhZHMgdG8gYSBwcm9ibGVtIHdoZW4gYXhpb3MgcG9zdCBgRm9ybURhdGFgIGluIHdlYldvcmtlclxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJXZWJXb3JrZXJFbnYgPSAoKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgJiZcbiAgICB0eXBlb2Ygc2VsZi5pbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nXG4gICk7XG59KSgpO1xuXG5jb25zdCBvcmlnaW4gPSBoYXNCcm93c2VyRW52ICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICdodHRwOi8vbG9jYWxob3N0JztcblxudmFyIHV0aWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBoYXNCcm93c2VyRW52OiBoYXNCcm93c2VyRW52LFxuICAgIGhhc1N0YW5kYXJkQnJvd3NlckVudjogaGFzU3RhbmRhcmRCcm93c2VyRW52LFxuICAgIGhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudjogaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52LFxuICAgIG5hdmlnYXRvcjogX25hdmlnYXRvcixcbiAgICBvcmlnaW46IG9yaWdpblxufSk7XG5cbnZhciBwbGF0Zm9ybSA9IHtcbiAgLi4udXRpbHMsXG4gIC4uLnBsYXRmb3JtJDFcbn07XG5cbmZ1bmN0aW9uIHRvVVJMRW5jb2RlZEZvcm0oZGF0YSwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Gb3JtRGF0YShkYXRhLCBuZXcgcGxhdGZvcm0uY2xhc3Nlcy5VUkxTZWFyY2hQYXJhbXMoKSwgT2JqZWN0LmFzc2lnbih7XG4gICAgdmlzaXRvcjogZnVuY3Rpb24odmFsdWUsIGtleSwgcGF0aCwgaGVscGVycykge1xuICAgICAgaWYgKHBsYXRmb3JtLmlzTm9kZSAmJiB1dGlscyQxLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhlbHBlcnMuZGVmYXVsdFZpc2l0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIG9wdGlvbnMpKTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHN0cmluZyBsaWtlIGBmb29beF1beV1bel1gIGFuZCByZXR1cm5zIGFuIGFycmF5IGxpa2UgYFsnZm9vJywgJ3gnLCAneScsICd6J11cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VQcm9wUGF0aChuYW1lKSB7XG4gIC8vIGZvb1t4XVt5XVt6XVxuICAvLyBmb28ueC55LnpcbiAgLy8gZm9vLXgteS16XG4gIC8vIGZvbyB4IHkgelxuICByZXR1cm4gdXRpbHMkMS5tYXRjaEFsbCgvXFx3K3xcXFsoXFx3KildL2csIG5hbWUpLm1hcChtYXRjaCA9PiB7XG4gICAgcmV0dXJuIG1hdGNoWzBdID09PSAnW10nID8gJycgOiBtYXRjaFsxXSB8fCBtYXRjaFswXTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBhcnJheSB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnIgLSBUaGUgYXJyYXkgdG8gY29udmVydCB0byBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhbmQgdmFsdWVzIGFzIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnIpIHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcnIpO1xuICBsZXQgaTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBrZXk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgb2JqW2tleV0gPSBhcnJba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgRm9ybURhdGEgb2JqZWN0IGFuZCByZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybURhdGEgVGhlIEZvcm1EYXRhIG9iamVjdCB0byBjb252ZXJ0IHRvIEpTT04uXG4gKlxuICogQHJldHVybnMge09iamVjdDxzdHJpbmcsIGFueT4gfCBudWxsfSBUaGUgY29udmVydGVkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZm9ybURhdGFUb0pTT04oZm9ybURhdGEpIHtcbiAgZnVuY3Rpb24gYnVpbGRQYXRoKHBhdGgsIHZhbHVlLCB0YXJnZXQsIGluZGV4KSB7XG4gICAgbGV0IG5hbWUgPSBwYXRoW2luZGV4KytdO1xuXG4gICAgaWYgKG5hbWUgPT09ICdfX3Byb3RvX18nKSByZXR1cm4gdHJ1ZTtcblxuICAgIGNvbnN0IGlzTnVtZXJpY0tleSA9IE51bWJlci5pc0Zpbml0ZSgrbmFtZSk7XG4gICAgY29uc3QgaXNMYXN0ID0gaW5kZXggPj0gcGF0aC5sZW5ndGg7XG4gICAgbmFtZSA9ICFuYW1lICYmIHV0aWxzJDEuaXNBcnJheSh0YXJnZXQpID8gdGFyZ2V0Lmxlbmd0aCA6IG5hbWU7XG5cbiAgICBpZiAoaXNMYXN0KSB7XG4gICAgICBpZiAodXRpbHMkMS5oYXNPd25Qcm9wKHRhcmdldCwgbmFtZSkpIHtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gW3RhcmdldFtuYW1lXSwgdmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhaXNOdW1lcmljS2V5O1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0W25hbWVdIHx8ICF1dGlscyQxLmlzT2JqZWN0KHRhcmdldFtuYW1lXSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGJ1aWxkUGF0aChwYXRoLCB2YWx1ZSwgdGFyZ2V0W25hbWVdLCBpbmRleCk7XG5cbiAgICBpZiAocmVzdWx0ICYmIHV0aWxzJDEuaXNBcnJheSh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSBhcnJheVRvT2JqZWN0KHRhcmdldFtuYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICFpc051bWVyaWNLZXk7XG4gIH1cblxuICBpZiAodXRpbHMkMS5pc0Zvcm1EYXRhKGZvcm1EYXRhKSAmJiB1dGlscyQxLmlzRnVuY3Rpb24oZm9ybURhdGEuZW50cmllcykpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcblxuICAgIHV0aWxzJDEuZm9yRWFjaEVudHJ5KGZvcm1EYXRhLCAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgIGJ1aWxkUGF0aChwYXJzZVByb3BQYXRoKG5hbWUpLCB2YWx1ZSwgb2JqLCAwKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHN0cmluZywgdHJpZXMgdG8gcGFyc2UgaXQsIGFuZCBpZiBpdCBmYWlscywgaXQgcmV0dXJucyB0aGUgc3RyaW5naWZpZWQgdmVyc2lvblxuICogb2YgdGhlIGlucHV0XG4gKlxuICogQHBhcmFtIHthbnl9IHJhd1ZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHN0cmluZ2lmaWVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGFyc2VyIC0gQSBmdW5jdGlvbiB0aGF0IHBhcnNlcyBhIHN0cmluZyBpbnRvIGEgSmF2YVNjcmlwdCBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVyIC0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmFsdWUgYW5kIHJldHVybnMgYSBzdHJpbmcuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmdpZmllZCB2ZXJzaW9uIG9mIHRoZSByYXdWYWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5U2FmZWx5KHJhd1ZhbHVlLCBwYXJzZXIsIGVuY29kZXIpIHtcbiAgaWYgKHV0aWxzJDEuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzJDEudHJpbShyYXdWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubmFtZSAhPT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoZW5jb2RlciB8fCBKU09OLnN0cmluZ2lmeSkocmF3VmFsdWUpO1xufVxuXG5jb25zdCBkZWZhdWx0cyA9IHtcblxuICB0cmFuc2l0aW9uYWw6IHRyYW5zaXRpb25hbERlZmF1bHRzLFxuXG4gIGFkYXB0ZXI6IFsneGhyJywgJ2h0dHAnLCAnZmV0Y2gnXSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzLmdldENvbnRlbnRUeXBlKCkgfHwgJyc7XG4gICAgY29uc3QgaGFzSlNPTkNvbnRlbnRUeXBlID0gY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTE7XG4gICAgY29uc3QgaXNPYmplY3RQYXlsb2FkID0gdXRpbHMkMS5pc09iamVjdChkYXRhKTtcblxuICAgIGlmIChpc09iamVjdFBheWxvYWQgJiYgdXRpbHMkMS5pc0hUTUxGb3JtKGRhdGEpKSB7XG4gICAgICBkYXRhID0gbmV3IEZvcm1EYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRm9ybURhdGEgPSB1dGlscyQxLmlzRm9ybURhdGEoZGF0YSk7XG5cbiAgICBpZiAoaXNGb3JtRGF0YSkge1xuICAgICAgcmV0dXJuIGhhc0pTT05Db250ZW50VHlwZSA/IEpTT04uc3RyaW5naWZ5KGZvcm1EYXRhVG9KU09OKGRhdGEpKSA6IGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzJDEuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMkMS5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMkMS5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMkMS5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzJDEuaXNCbG9iKGRhdGEpIHx8XG4gICAgICB1dGlscyQxLmlzUmVhZGFibGVTdHJlYW0oZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMkMS5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMkMS5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnLCBmYWxzZSk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGxldCBpc0ZpbGVMaXN0O1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCkge1xuICAgICAgaWYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvVVJMRW5jb2RlZEZvcm0oZGF0YSwgdGhpcy5mb3JtU2VyaWFsaXplcikudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChpc0ZpbGVMaXN0ID0gdXRpbHMkMS5pc0ZpbGVMaXN0KGRhdGEpKSB8fCBjb250ZW50VHlwZS5pbmRleE9mKCdtdWx0aXBhcnQvZm9ybS1kYXRhJykgPiAtMSkge1xuICAgICAgICBjb25zdCBfRm9ybURhdGEgPSB0aGlzLmVudiAmJiB0aGlzLmVudi5Gb3JtRGF0YTtcblxuICAgICAgICByZXR1cm4gdG9Gb3JtRGF0YShcbiAgICAgICAgICBpc0ZpbGVMaXN0ID8geydmaWxlc1tdJzogZGF0YX0gOiBkYXRhLFxuICAgICAgICAgIF9Gb3JtRGF0YSAmJiBuZXcgX0Zvcm1EYXRhKCksXG4gICAgICAgICAgdGhpcy5mb3JtU2VyaWFsaXplclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc09iamVjdFBheWxvYWQgfHwgaGFzSlNPTkNvbnRlbnRUeXBlICkge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24vanNvbicsIGZhbHNlKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTYWZlbHkoZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsIHx8IGRlZmF1bHRzLnRyYW5zaXRpb25hbDtcbiAgICBjb25zdCBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgY29uc3QgSlNPTlJlcXVlc3RlZCA9IHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAodXRpbHMkMS5pc1Jlc3BvbnNlKGRhdGEpIHx8IHV0aWxzJDEuaXNSZWFkYWJsZVN0cmVhbShkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgJiYgdXRpbHMkMS5pc1N0cmluZyhkYXRhKSAmJiAoKGZvcmNlZEpTT05QYXJzaW5nICYmICF0aGlzLnJlc3BvbnNlVHlwZSkgfHwgSlNPTlJlcXVlc3RlZCkpIHtcbiAgICAgIGNvbnN0IHNpbGVudEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5zaWxlbnRKU09OUGFyc2luZztcbiAgICAgIGNvbnN0IHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIEpTT05SZXF1ZXN0ZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lID09PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZSwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFLCB0aGlzLCBudWxsLCB0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgZW52OiB7XG4gICAgRm9ybURhdGE6IHBsYXRmb3JtLmNsYXNzZXMuRm9ybURhdGEsXG4gICAgQmxvYjogcGxhdGZvcm0uY2xhc3Nlcy5CbG9iXG4gIH0sXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfSxcblxuICBoZWFkZXJzOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKicsXG4gICAgICAnQ29udGVudC1UeXBlJzogdW5kZWZpbmVkXG4gICAgfVxuICB9XG59O1xuXG51dGlscyQxLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgKG1ldGhvZCkgPT4ge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG52YXIgZGVmYXVsdHMkMSA9IGRlZmF1bHRzO1xuXG4vLyBSYXdBeGlvc0hlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG5jb25zdCBpZ25vcmVEdXBsaWNhdGVPZiA9IHV0aWxzJDEudG9PYmplY3RTZXQoW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl0pO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3SGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKlxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xudmFyIHBhcnNlSGVhZGVycyA9IHJhd0hlYWRlcnMgPT4ge1xuICBjb25zdCBwYXJzZWQgPSB7fTtcbiAgbGV0IGtleTtcbiAgbGV0IHZhbDtcbiAgbGV0IGk7XG5cbiAgcmF3SGVhZGVycyAmJiByYXdIZWFkZXJzLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IGxpbmUuc3Vic3RyaW5nKDAsIGkpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IGxpbmUuc3Vic3RyaW5nKGkgKyAxKS50cmltKCk7XG5cbiAgICBpZiAoIWtleSB8fCAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2Zba2V5XSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSkge1xuICAgICAgICBwYXJzZWRba2V5XS5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IFt2YWxdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbmNvbnN0ICRpbnRlcm5hbHMgPSBTeW1ib2woJ2ludGVybmFscycpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVIZWFkZXIoaGVhZGVyKSB7XG4gIHJldHVybiBoZWFkZXIgJiYgU3RyaW5nKGhlYWRlcikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB1dGlscyQxLmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZhbHVlKSA6IFN0cmluZyh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9rZW5zKHN0cikge1xuICBjb25zdCB0b2tlbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCB0b2tlbnNSRSA9IC8oW15cXHMsOz1dKylcXHMqKD86PVxccyooW14sO10rKSk/L2c7XG4gIGxldCBtYXRjaDtcblxuICB3aGlsZSAoKG1hdGNoID0gdG9rZW5zUkUuZXhlYyhzdHIpKSkge1xuICAgIHRva2Vuc1ttYXRjaFsxXV0gPSBtYXRjaFsyXTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmNvbnN0IGlzVmFsaWRIZWFkZXJOYW1lID0gKHN0cikgPT4gL15bLV9hLXpBLVowLTleYHx+LCEjJCUmJyorLl0rJC8udGVzdChzdHIudHJpbSgpKTtcblxuZnVuY3Rpb24gbWF0Y2hIZWFkZXJWYWx1ZShjb250ZXh0LCB2YWx1ZSwgaGVhZGVyLCBmaWx0ZXIsIGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICBpZiAodXRpbHMkMS5pc0Z1bmN0aW9uKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLmNhbGwodGhpcywgdmFsdWUsIGhlYWRlcik7XG4gIH1cblxuICBpZiAoaXNIZWFkZXJOYW1lRmlsdGVyKSB7XG4gICAgdmFsdWUgPSBoZWFkZXI7XG4gIH1cblxuICBpZiAoIXV0aWxzJDEuaXNTdHJpbmcodmFsdWUpKSByZXR1cm47XG5cbiAgaWYgKHV0aWxzJDEuaXNTdHJpbmcoZmlsdGVyKSkge1xuICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKGZpbHRlcikgIT09IC0xO1xuICB9XG5cbiAgaWYgKHV0aWxzJDEuaXNSZWdFeHAoZmlsdGVyKSkge1xuICAgIHJldHVybiBmaWx0ZXIudGVzdCh2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0SGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyLnRyaW0oKVxuICAgIC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyhbYS16XFxkXSkoXFx3KikvZywgKHcsIGNoYXIsIHN0cikgPT4ge1xuICAgICAgcmV0dXJuIGNoYXIudG9VcHBlckNhc2UoKSArIHN0cjtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRBY2Nlc3NvcnMob2JqLCBoZWFkZXIpIHtcbiAgY29uc3QgYWNjZXNzb3JOYW1lID0gdXRpbHMkMS50b0NhbWVsQ2FzZSgnICcgKyBoZWFkZXIpO1xuXG4gIFsnZ2V0JywgJ3NldCcsICdoYXMnXS5mb3JFYWNoKG1ldGhvZE5hbWUgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG1ldGhvZE5hbWUgKyBhY2Nlc3Nvck5hbWUsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIHJldHVybiB0aGlzW21ldGhvZE5hbWVdLmNhbGwodGhpcywgaGVhZGVyLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG59XG5cbmNsYXNzIEF4aW9zSGVhZGVycyB7XG4gIGNvbnN0cnVjdG9yKGhlYWRlcnMpIHtcbiAgICBoZWFkZXJzICYmIHRoaXMuc2V0KGhlYWRlcnMpO1xuICB9XG5cbiAgc2V0KGhlYWRlciwgdmFsdWVPclJld3JpdGUsIHJld3JpdGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIHNldEhlYWRlcihfdmFsdWUsIF9oZWFkZXIsIF9yZXdyaXRlKSB7XG4gICAgICBjb25zdCBsSGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoIWxIZWFkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZWFkZXIgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXkgPSB1dGlscyQxLmZpbmRLZXkoc2VsZiwgbEhlYWRlcik7XG5cbiAgICAgIGlmKCFrZXkgfHwgc2VsZltrZXldID09PSB1bmRlZmluZWQgfHwgX3Jld3JpdGUgPT09IHRydWUgfHwgKF9yZXdyaXRlID09PSB1bmRlZmluZWQgJiYgc2VsZltrZXldICE9PSBmYWxzZSkpIHtcbiAgICAgICAgc2VsZltrZXkgfHwgX2hlYWRlcl0gPSBub3JtYWxpemVWYWx1ZShfdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNldEhlYWRlcnMgPSAoaGVhZGVycywgX3Jld3JpdGUpID0+XG4gICAgICB1dGlscyQxLmZvckVhY2goaGVhZGVycywgKF92YWx1ZSwgX2hlYWRlcikgPT4gc2V0SGVhZGVyKF92YWx1ZSwgX2hlYWRlciwgX3Jld3JpdGUpKTtcblxuICAgIGlmICh1dGlscyQxLmlzUGxhaW5PYmplY3QoaGVhZGVyKSB8fCBoZWFkZXIgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICBzZXRIZWFkZXJzKGhlYWRlciwgdmFsdWVPclJld3JpdGUpO1xuICAgIH0gZWxzZSBpZih1dGlscyQxLmlzU3RyaW5nKGhlYWRlcikgJiYgKGhlYWRlciA9IGhlYWRlci50cmltKCkpICYmICFpc1ZhbGlkSGVhZGVyTmFtZShoZWFkZXIpKSB7XG4gICAgICBzZXRIZWFkZXJzKHBhcnNlSGVhZGVycyhoZWFkZXIpLCB2YWx1ZU9yUmV3cml0ZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscyQxLmlzSGVhZGVycyhoZWFkZXIpKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBoZWFkZXIuZW50cmllcygpKSB7XG4gICAgICAgIHNldEhlYWRlcih2YWx1ZSwga2V5LCByZXdyaXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyICE9IG51bGwgJiYgc2V0SGVhZGVyKHZhbHVlT3JSZXdyaXRlLCBoZWFkZXIsIHJld3JpdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KGhlYWRlciwgcGFyc2VyKSB7XG4gICAgaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKGhlYWRlcik7XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscyQxLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNba2V5XTtcblxuICAgICAgICBpZiAoIXBhcnNlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZXIgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbnModmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzJDEuaXNGdW5jdGlvbihwYXJzZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5jYWxsKHRoaXMsIHZhbHVlLCBrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzJDEuaXNSZWdFeHAocGFyc2VyKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuZXhlYyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJzZXIgbXVzdCBiZSBib29sZWFufHJlZ2V4cHxmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhcyhoZWFkZXIsIG1hdGNoZXIpIHtcbiAgICBoZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoaGVhZGVyKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzJDEuZmluZEtleSh0aGlzLCBoZWFkZXIpO1xuXG4gICAgICByZXR1cm4gISEoa2V5ICYmIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkICYmICghbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHRoaXMsIHRoaXNba2V5XSwga2V5LCBtYXRjaGVyKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGRlbGV0ZShoZWFkZXIsIG1hdGNoZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZGVsZXRlSGVhZGVyKF9oZWFkZXIpIHtcbiAgICAgIF9oZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmIChfaGVhZGVyKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHV0aWxzJDEuZmluZEtleShzZWxmLCBfaGVhZGVyKTtcblxuICAgICAgICBpZiAoa2V5ICYmICghbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHNlbGYsIHNlbGZba2V5XSwga2V5LCBtYXRjaGVyKSkpIHtcbiAgICAgICAgICBkZWxldGUgc2VsZltrZXldO1xuXG4gICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXRpbHMkMS5pc0FycmF5KGhlYWRlcikpIHtcbiAgICAgIGhlYWRlci5mb3JFYWNoKGRlbGV0ZUhlYWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZUhlYWRlcihoZWFkZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWxldGVkO1xuICB9XG5cbiAgY2xlYXIobWF0Y2hlcikge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlciwgdHJ1ZSkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBub3JtYWxpemUoZm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuXG4gICAgdXRpbHMkMS5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscyQxLmZpbmRLZXkoaGVhZGVycywgaGVhZGVyKTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBzZWxmW2tleV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGRlbGV0ZSBzZWxmW2hlYWRlcl07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGZvcm1hdCA/IGZvcm1hdEhlYWRlcihoZWFkZXIpIDogU3RyaW5nKGhlYWRlcikudHJpbSgpO1xuXG4gICAgICBpZiAobm9ybWFsaXplZCAhPT0gaGVhZGVyKSB7XG4gICAgICAgIGRlbGV0ZSBzZWxmW2hlYWRlcl07XG4gICAgICB9XG5cbiAgICAgIHNlbGZbbm9ybWFsaXplZF0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZF0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25jYXQoLi4udGFyZ2V0cykge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmNvbmNhdCh0aGlzLCAuLi50YXJnZXRzKTtcbiAgfVxuXG4gIHRvSlNPTihhc1N0cmluZ3MpIHtcbiAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgdXRpbHMkMS5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSAmJiAob2JqW2hlYWRlcl0gPSBhc1N0cmluZ3MgJiYgdXRpbHMkMS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywgJykgOiB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMudG9KU09OKCkpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKS5tYXAoKFtoZWFkZXIsIHZhbHVlXSkgPT4gaGVhZGVyICsgJzogJyArIHZhbHVlKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0F4aW9zSGVhZGVycyc7XG4gIH1cblxuICBzdGF0aWMgZnJvbSh0aGluZykge1xuICAgIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIHRoaXMgPyB0aGluZyA6IG5ldyB0aGlzKHRoaW5nKTtcbiAgfVxuXG4gIHN0YXRpYyBjb25jYXQoZmlyc3QsIC4uLnRhcmdldHMpIHtcbiAgICBjb25zdCBjb21wdXRlZCA9IG5ldyB0aGlzKGZpcnN0KTtcblxuICAgIHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiBjb21wdXRlZC5zZXQodGFyZ2V0KSk7XG5cbiAgICByZXR1cm4gY29tcHV0ZWQ7XG4gIH1cblxuICBzdGF0aWMgYWNjZXNzb3IoaGVhZGVyKSB7XG4gICAgY29uc3QgaW50ZXJuYWxzID0gdGhpc1skaW50ZXJuYWxzXSA9ICh0aGlzWyRpbnRlcm5hbHNdID0ge1xuICAgICAgYWNjZXNzb3JzOiB7fVxuICAgIH0pO1xuXG4gICAgY29uc3QgYWNjZXNzb3JzID0gaW50ZXJuYWxzLmFjY2Vzc29ycztcbiAgICBjb25zdCBwcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGRlZmluZUFjY2Vzc29yKF9oZWFkZXIpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghYWNjZXNzb3JzW2xIZWFkZXJdKSB7XG4gICAgICAgIGJ1aWxkQWNjZXNzb3JzKHByb3RvdHlwZSwgX2hlYWRlcik7XG4gICAgICAgIGFjY2Vzc29yc1tsSGVhZGVyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHMkMS5pc0FycmF5KGhlYWRlcikgPyBoZWFkZXIuZm9yRWFjaChkZWZpbmVBY2Nlc3NvcikgOiBkZWZpbmVBY2Nlc3NvcihoZWFkZXIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuQXhpb3NIZWFkZXJzLmFjY2Vzc29yKFsnQ29udGVudC1UeXBlJywgJ0NvbnRlbnQtTGVuZ3RoJywgJ0FjY2VwdCcsICdBY2NlcHQtRW5jb2RpbmcnLCAnVXNlci1BZ2VudCcsICdBdXRob3JpemF0aW9uJ10pO1xuXG4vLyByZXNlcnZlZCBuYW1lcyBob3RmaXhcbnV0aWxzJDEucmVkdWNlRGVzY3JpcHRvcnMoQXhpb3NIZWFkZXJzLnByb3RvdHlwZSwgKHt2YWx1ZX0sIGtleSkgPT4ge1xuICBsZXQgbWFwcGVkID0ga2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7IC8vIG1hcCBgc2V0YCA9PiBgU2V0YFxuICByZXR1cm4ge1xuICAgIGdldDogKCkgPT4gdmFsdWUsXG4gICAgc2V0KGhlYWRlclZhbHVlKSB7XG4gICAgICB0aGlzW21hcHBlZF0gPSBoZWFkZXJWYWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG51dGlscyQxLmZyZWV6ZU1ldGhvZHMoQXhpb3NIZWFkZXJzKTtcblxudmFyIEF4aW9zSGVhZGVycyQxID0gQXhpb3NIZWFkZXJzO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcGFyYW0gez9PYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZm5zLCByZXNwb25zZSkge1xuICBjb25zdCBjb25maWcgPSB0aGlzIHx8IGRlZmF1bHRzJDE7XG4gIGNvbnN0IGNvbnRleHQgPSByZXNwb25zZSB8fCBjb25maWc7XG4gIGNvbnN0IGhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKGNvbnRleHQuaGVhZGVycyk7XG4gIGxldCBkYXRhID0gY29udGV4dC5kYXRhO1xuXG4gIHV0aWxzJDEuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbmZpZywgZGF0YSwgaGVhZGVycy5ub3JtYWxpemUoKSwgcmVzcG9uc2UgPyByZXNwb25zZS5zdGF0dXMgOiB1bmRlZmluZWQpO1xuICB9KTtcblxuICBoZWFkZXJzLm5vcm1hbGl6ZSgpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59XG5cbi8qKlxuICogQSBgQ2FuY2VsZWRFcnJvcmAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdD19IHJlcXVlc3QgVGhlIHJlcXVlc3QuXG4gKlxuICogQHJldHVybnMge0NhbmNlbGVkRXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBDYW5jZWxlZEVycm9yKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgQXhpb3NFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UgPT0gbnVsbCA/ICdjYW5jZWxlZCcgOiBtZXNzYWdlLCBBeGlvc0Vycm9yLkVSUl9DQU5DRUxFRCwgY29uZmlnLCByZXF1ZXN0KTtcbiAgdGhpcy5uYW1lID0gJ0NhbmNlbGVkRXJyb3InO1xufVxuXG51dGlscyQxLmluaGVyaXRzKENhbmNlbGVkRXJyb3IsIEF4aW9zRXJyb3IsIHtcbiAgX19DQU5DRUxfXzogdHJ1ZVxufSk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybnMge29iamVjdH0gVGhlIHJlc3BvbnNlLlxuICovXG5mdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICBjb25zdCB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgW0F4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0VdW01hdGguZmxvb3IocmVzcG9uc2Uuc3RhdHVzIC8gMTAwKSAtIDRdLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VQcm90b2NvbCh1cmwpIHtcbiAgY29uc3QgbWF0Y2ggPSAvXihbLStcXHddezEsMjV9KSg6P1xcL1xcL3w6KS8uZXhlYyh1cmwpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRhdGEgbWF4UmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtzYW1wbGVzQ291bnQ9IDEwXVxuICogQHBhcmFtIHtOdW1iZXJ9IFttaW49IDEwMDBdXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHNwZWVkb21ldGVyKHNhbXBsZXNDb3VudCwgbWluKSB7XG4gIHNhbXBsZXNDb3VudCA9IHNhbXBsZXNDb3VudCB8fCAxMDtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgQXJyYXkoc2FtcGxlc0NvdW50KTtcbiAgY29uc3QgdGltZXN0YW1wcyA9IG5ldyBBcnJheShzYW1wbGVzQ291bnQpO1xuICBsZXQgaGVhZCA9IDA7XG4gIGxldCB0YWlsID0gMDtcbiAgbGV0IGZpcnN0U2FtcGxlVFM7XG5cbiAgbWluID0gbWluICE9PSB1bmRlZmluZWQgPyBtaW4gOiAxMDAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiBwdXNoKGNodW5rTGVuZ3RoKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGNvbnN0IHN0YXJ0ZWRBdCA9IHRpbWVzdGFtcHNbdGFpbF07XG5cbiAgICBpZiAoIWZpcnN0U2FtcGxlVFMpIHtcbiAgICAgIGZpcnN0U2FtcGxlVFMgPSBub3c7XG4gICAgfVxuXG4gICAgYnl0ZXNbaGVhZF0gPSBjaHVua0xlbmd0aDtcbiAgICB0aW1lc3RhbXBzW2hlYWRdID0gbm93O1xuXG4gICAgbGV0IGkgPSB0YWlsO1xuICAgIGxldCBieXRlc0NvdW50ID0gMDtcblxuICAgIHdoaWxlIChpICE9PSBoZWFkKSB7XG4gICAgICBieXRlc0NvdW50ICs9IGJ5dGVzW2krK107XG4gICAgICBpID0gaSAlIHNhbXBsZXNDb3VudDtcbiAgICB9XG5cbiAgICBoZWFkID0gKGhlYWQgKyAxKSAlIHNhbXBsZXNDb3VudDtcblxuICAgIGlmIChoZWFkID09PSB0YWlsKSB7XG4gICAgICB0YWlsID0gKHRhaWwgKyAxKSAlIHNhbXBsZXNDb3VudDtcbiAgICB9XG5cbiAgICBpZiAobm93IC0gZmlyc3RTYW1wbGVUUyA8IG1pbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhc3NlZCA9IHN0YXJ0ZWRBdCAmJiBub3cgLSBzdGFydGVkQXQ7XG5cbiAgICByZXR1cm4gcGFzc2VkID8gTWF0aC5yb3VuZChieXRlc0NvdW50ICogMTAwMCAvIHBhc3NlZCkgOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbi8qKlxuICogVGhyb3R0bGUgZGVjb3JhdG9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IGZyZXFcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmbiwgZnJlcSkge1xuICBsZXQgdGltZXN0YW1wID0gMDtcbiAgbGV0IHRocmVzaG9sZCA9IDEwMDAgLyBmcmVxO1xuICBsZXQgbGFzdEFyZ3M7XG4gIGxldCB0aW1lcjtcblxuICBjb25zdCBpbnZva2UgPSAoYXJncywgbm93ID0gRGF0ZS5ub3coKSkgPT4ge1xuICAgIHRpbWVzdGFtcCA9IG5vdztcbiAgICBsYXN0QXJncyA9IG51bGw7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBudWxsO1xuICAgIH1cbiAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgfTtcblxuICBjb25zdCB0aHJvdHRsZWQgPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcGFzc2VkID0gbm93IC0gdGltZXN0YW1wO1xuICAgIGlmICggcGFzc2VkID49IHRocmVzaG9sZCkge1xuICAgICAgaW52b2tlKGFyZ3MsIG5vdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RBcmdzID0gYXJncztcbiAgICAgIGlmICghdGltZXIpIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgaW52b2tlKGxhc3RBcmdzKTtcbiAgICAgICAgfSwgdGhyZXNob2xkIC0gcGFzc2VkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZmx1c2ggPSAoKSA9PiBsYXN0QXJncyAmJiBpbnZva2UobGFzdEFyZ3MpO1xuXG4gIHJldHVybiBbdGhyb3R0bGVkLCBmbHVzaF07XG59XG5cbmNvbnN0IHByb2dyZXNzRXZlbnRSZWR1Y2VyID0gKGxpc3RlbmVyLCBpc0Rvd25sb2FkU3RyZWFtLCBmcmVxID0gMykgPT4ge1xuICBsZXQgYnl0ZXNOb3RpZmllZCA9IDA7XG4gIGNvbnN0IF9zcGVlZG9tZXRlciA9IHNwZWVkb21ldGVyKDUwLCAyNTApO1xuXG4gIHJldHVybiB0aHJvdHRsZShlID0+IHtcbiAgICBjb25zdCBsb2FkZWQgPSBlLmxvYWRlZDtcbiAgICBjb25zdCB0b3RhbCA9IGUubGVuZ3RoQ29tcHV0YWJsZSA/IGUudG90YWwgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJvZ3Jlc3NCeXRlcyA9IGxvYWRlZCAtIGJ5dGVzTm90aWZpZWQ7XG4gICAgY29uc3QgcmF0ZSA9IF9zcGVlZG9tZXRlcihwcm9ncmVzc0J5dGVzKTtcbiAgICBjb25zdCBpblJhbmdlID0gbG9hZGVkIDw9IHRvdGFsO1xuXG4gICAgYnl0ZXNOb3RpZmllZCA9IGxvYWRlZDtcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBsb2FkZWQsXG4gICAgICB0b3RhbCxcbiAgICAgIHByb2dyZXNzOiB0b3RhbCA/IChsb2FkZWQgLyB0b3RhbCkgOiB1bmRlZmluZWQsXG4gICAgICBieXRlczogcHJvZ3Jlc3NCeXRlcyxcbiAgICAgIHJhdGU6IHJhdGUgPyByYXRlIDogdW5kZWZpbmVkLFxuICAgICAgZXN0aW1hdGVkOiByYXRlICYmIHRvdGFsICYmIGluUmFuZ2UgPyAodG90YWwgLSBsb2FkZWQpIC8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogdG90YWwgIT0gbnVsbCxcbiAgICAgIFtpc0Rvd25sb2FkU3RyZWFtID8gJ2Rvd25sb2FkJyA6ICd1cGxvYWQnXTogdHJ1ZVxuICAgIH07XG5cbiAgICBsaXN0ZW5lcihkYXRhKTtcbiAgfSwgZnJlcSk7XG59O1xuXG5jb25zdCBwcm9ncmVzc0V2ZW50RGVjb3JhdG9yID0gKHRvdGFsLCB0aHJvdHRsZWQpID0+IHtcbiAgY29uc3QgbGVuZ3RoQ29tcHV0YWJsZSA9IHRvdGFsICE9IG51bGw7XG5cbiAgcmV0dXJuIFsobG9hZGVkKSA9PiB0aHJvdHRsZWRbMF0oe1xuICAgIGxlbmd0aENvbXB1dGFibGUsXG4gICAgdG90YWwsXG4gICAgbG9hZGVkXG4gIH0pLCB0aHJvdHRsZWRbMV1dO1xufTtcblxuY29uc3QgYXN5bmNEZWNvcmF0b3IgPSAoZm4pID0+ICguLi5hcmdzKSA9PiB1dGlscyQxLmFzYXAoKCkgPT4gZm4oLi4uYXJncykpO1xuXG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52ID8gKChvcmlnaW4sIGlzTVNJRSkgPT4gKHVybCkgPT4ge1xuICB1cmwgPSBuZXcgVVJMKHVybCwgcGxhdGZvcm0ub3JpZ2luKTtcblxuICByZXR1cm4gKFxuICAgIG9yaWdpbi5wcm90b2NvbCA9PT0gdXJsLnByb3RvY29sICYmXG4gICAgb3JpZ2luLmhvc3QgPT09IHVybC5ob3N0ICYmXG4gICAgKGlzTVNJRSB8fCBvcmlnaW4ucG9ydCA9PT0gdXJsLnBvcnQpXG4gICk7XG59KShcbiAgbmV3IFVSTChwbGF0Zm9ybS5vcmlnaW4pLFxuICBwbGF0Zm9ybS5uYXZpZ2F0b3IgJiYgLyhtc2llfHRyaWRlbnQpL2kudGVzdChwbGF0Zm9ybS5uYXZpZ2F0b3IudXNlckFnZW50KVxuKSA6ICgpID0+IHRydWU7XG5cbnZhciBjb29raWVzID0gcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52ID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAge1xuICAgIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgY29uc3QgY29va2llID0gW25hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpXTtcblxuICAgICAgdXRpbHMkMS5pc051bWJlcihleHBpcmVzKSAmJiBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG5cbiAgICAgIHV0aWxzJDEuaXNTdHJpbmcocGF0aCkgJiYgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuXG4gICAgICB1dGlscyQxLmlzU3RyaW5nKGRvbWFpbikgJiYgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcblxuICAgICAgc2VjdXJlID09PSB0cnVlICYmIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcblxuICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgfSxcblxuICAgIHJlYWQobmFtZSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlKG5hbWUpIHtcbiAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgfVxuICB9XG5cbiAgOlxuXG4gIC8vIE5vbi1zdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAge1xuICAgIHdyaXRlKCkge30sXG4gICAgcmVhZCgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcmVtb3ZlKCkge31cbiAgfTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGQrXFwtLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5mdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvP1xcLyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIGJhc2VVUkwgd2l0aCB0aGUgcmVxdWVzdGVkVVJMLFxuICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxuICogSWYgdGhlIHJlcXVlc3RVUkwgaXMgYWJzb2x1dGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVxdWVzdGVkVVJMIHVudG91Y2hlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0ZWRVUkwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIHRvIGNvbWJpbmVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufVxuXG5jb25zdCBoZWFkZXJzVG9PYmplY3QgPSAodGhpbmcpID0+IHRoaW5nIGluc3RhbmNlb2YgQXhpb3NIZWFkZXJzJDEgPyB7IC4uLnRoaW5nIH0gOiB0aGluZztcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5mdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgY29uc3QgY29uZmlnID0ge307XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UsIHByb3AsIGNhc2VsZXNzKSB7XG4gICAgaWYgKHV0aWxzJDEuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzJDEuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMkMS5tZXJnZS5jYWxsKHtjYXNlbGVzc30sIHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzJDEuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMkMS5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzJDEuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhhLCBiLCBwcm9wICwgY2FzZWxlc3MpIHtcbiAgICBpZiAoIXV0aWxzJDEuaXNVbmRlZmluZWQoYikpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShhLCBiLCBwcm9wICwgY2FzZWxlc3MpO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzJDEuaXNVbmRlZmluZWQoYSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEsIHByb3AgLCBjYXNlbGVzcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIoYSwgYikge1xuICAgIGlmICghdXRpbHMkMS5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYik7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIoYSwgYikge1xuICAgIGlmICghdXRpbHMkMS5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYik7XG4gICAgfSBlbHNlIGlmICghdXRpbHMkMS5pc1VuZGVmaW5lZChhKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGlyZWN0S2V5cyhhLCBiLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIpO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBtZXJnZU1hcCA9IHtcbiAgICB1cmw6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgbWV0aG9kOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIGRhdGE6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgYmFzZVVSTDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc2Zvcm1SZXF1ZXN0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zZm9ybVJlc3BvbnNlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHBhcmFtc1NlcmlhbGl6ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdGltZW91dDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0aW1lb3V0TWVzc2FnZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB3aXRoQ3JlZGVudGlhbHM6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgd2l0aFhTUkZUb2tlbjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBhZGFwdGVyOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHJlc3BvbnNlVHlwZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmQ29va2llTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmSGVhZGVyTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBvblVwbG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG9uRG93bmxvYWRQcm9ncmVzczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBkZWNvbXByZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG1heENvbnRlbnRMZW5ndGg6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgbWF4Qm9keUxlbmd0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBiZWZvcmVSZWRpcmVjdDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc3BvcnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgaHR0cEFnZW50OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGh0dHBzQWdlbnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgY2FuY2VsVG9rZW46IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgc29ja2V0UGF0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICByZXNwb25zZUVuY29kaW5nOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHZhbGlkYXRlU3RhdHVzOiBtZXJnZURpcmVjdEtleXMsXG4gICAgaGVhZGVyczogKGEsIGIgLCBwcm9wKSA9PiBtZXJnZURlZXBQcm9wZXJ0aWVzKGhlYWRlcnNUb09iamVjdChhKSwgaGVhZGVyc1RvT2JqZWN0KGIpLHByb3AsIHRydWUpXG4gIH07XG5cbiAgdXRpbHMkMS5mb3JFYWNoKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZzEsIGNvbmZpZzIpKSwgZnVuY3Rpb24gY29tcHV0ZUNvbmZpZ1ZhbHVlKHByb3ApIHtcbiAgICBjb25zdCBtZXJnZSA9IG1lcmdlTWFwW3Byb3BdIHx8IG1lcmdlRGVlcFByb3BlcnRpZXM7XG4gICAgY29uc3QgY29uZmlnVmFsdWUgPSBtZXJnZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdLCBwcm9wKTtcbiAgICAodXRpbHMkMS5pc1VuZGVmaW5lZChjb25maWdWYWx1ZSkgJiYgbWVyZ2UgIT09IG1lcmdlRGlyZWN0S2V5cykgfHwgKGNvbmZpZ1twcm9wXSA9IGNvbmZpZ1ZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxudmFyIHJlc29sdmVDb25maWcgPSAoY29uZmlnKSA9PiB7XG4gIGNvbnN0IG5ld0NvbmZpZyA9IG1lcmdlQ29uZmlnKHt9LCBjb25maWcpO1xuXG4gIGxldCB7ZGF0YSwgd2l0aFhTUkZUb2tlbiwgeHNyZkhlYWRlck5hbWUsIHhzcmZDb29raWVOYW1lLCBoZWFkZXJzLCBhdXRofSA9IG5ld0NvbmZpZztcblxuICBuZXdDb25maWcuaGVhZGVycyA9IGhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKGhlYWRlcnMpO1xuXG4gIG5ld0NvbmZpZy51cmwgPSBidWlsZFVSTChidWlsZEZ1bGxQYXRoKG5ld0NvbmZpZy5iYXNlVVJMLCBuZXdDb25maWcudXJsKSwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xuXG4gIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgaWYgKGF1dGgpIHtcbiAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICtcbiAgICAgIGJ0b2EoKGF1dGgudXNlcm5hbWUgfHwgJycpICsgJzonICsgKGF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYXV0aC5wYXNzd29yZCkpIDogJycpKVxuICAgICk7XG4gIH1cblxuICBsZXQgY29udGVudFR5cGU7XG5cbiAgaWYgKHV0aWxzJDEuaXNGb3JtRGF0YShkYXRhKSkge1xuICAgIGlmIChwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgfHwgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52KSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKHVuZGVmaW5lZCk7IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9IGVsc2UgaWYgKChjb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0Q29udGVudFR5cGUoKSkgIT09IGZhbHNlKSB7XG4gICAgICAvLyBmaXggc2VtaWNvbG9uIGR1cGxpY2F0aW9uIGlzc3VlIGZvciBSZWFjdE5hdGl2ZSBGb3JtRGF0YSBpbXBsZW1lbnRhdGlvblxuICAgICAgY29uc3QgW3R5cGUsIC4uLnRva2Vuc10gPSBjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JykubWFwKHRva2VuID0+IHRva2VuLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKFt0eXBlIHx8ICdtdWx0aXBhcnQvZm9ybS1kYXRhJywgLi4udG9rZW5zXS5qb2luKCc7ICcpKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG5cbiAgaWYgKHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudikge1xuICAgIHdpdGhYU1JGVG9rZW4gJiYgdXRpbHMkMS5pc0Z1bmN0aW9uKHdpdGhYU1JGVG9rZW4pICYmICh3aXRoWFNSRlRva2VuID0gd2l0aFhTUkZUb2tlbihuZXdDb25maWcpKTtcblxuICAgIGlmICh3aXRoWFNSRlRva2VuIHx8ICh3aXRoWFNSRlRva2VuICE9PSBmYWxzZSAmJiBpc1VSTFNhbWVPcmlnaW4obmV3Q29uZmlnLnVybCkpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIGNvbnN0IHhzcmZWYWx1ZSA9IHhzcmZIZWFkZXJOYW1lICYmIHhzcmZDb29raWVOYW1lICYmIGNvb2tpZXMucmVhZCh4c3JmQ29va2llTmFtZSk7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgaGVhZGVycy5zZXQoeHNyZkhlYWRlck5hbWUsIHhzcmZWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0NvbmZpZztcbn07XG5cbmNvbnN0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciB4aHJBZGFwdGVyID0gaXNYSFJBZGFwdGVyU3VwcG9ydGVkICYmIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBjb25zdCBfY29uZmlnID0gcmVzb2x2ZUNvbmZpZyhjb25maWcpO1xuICAgIGxldCByZXF1ZXN0RGF0YSA9IF9jb25maWcuZGF0YTtcbiAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IEF4aW9zSGVhZGVycyQxLmZyb20oX2NvbmZpZy5oZWFkZXJzKS5ub3JtYWxpemUoKTtcbiAgICBsZXQge3Jlc3BvbnNlVHlwZSwgb25VcGxvYWRQcm9ncmVzcywgb25Eb3dubG9hZFByb2dyZXNzfSA9IF9jb25maWc7XG4gICAgbGV0IG9uQ2FuY2VsZWQ7XG4gICAgbGV0IHVwbG9hZFRocm90dGxlZCwgZG93bmxvYWRUaHJvdHRsZWQ7XG4gICAgbGV0IGZsdXNoVXBsb2FkLCBmbHVzaERvd25sb2FkO1xuXG4gICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIGZsdXNoVXBsb2FkICYmIGZsdXNoVXBsb2FkKCk7IC8vIGZsdXNoIGV2ZW50c1xuICAgICAgZmx1c2hEb3dubG9hZCAmJiBmbHVzaERvd25sb2FkKCk7IC8vIGZsdXNoIGV2ZW50c1xuXG4gICAgICBfY29uZmlnLmNhbmNlbFRva2VuICYmIF9jb25maWcuY2FuY2VsVG9rZW4udW5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG5cbiAgICAgIF9jb25maWcuc2lnbmFsICYmIF9jb25maWcuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgfVxuXG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHJlcXVlc3Qub3BlbihfY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBfY29uZmlnLnVybCwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IF9jb25maWcudGltZW91dDtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gQXhpb3NIZWFkZXJzJDEuZnJvbShcbiAgICAgICAgJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCAmJiByZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gIXJlc3BvbnNlVHlwZSB8fCByZXNwb25zZVR5cGUgPT09ICd0ZXh0JyB8fCByZXNwb25zZVR5cGUgPT09ICdqc29uJyA/XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShmdW5jdGlvbiBfcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgZnVuY3Rpb24gX3JlamVjdChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcbiAgICAgIC8vIFVzZSBvbmxvYWRlbmQgaWYgYXZhaWxhYmxlXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZSB0byBlbXVsYXRlIG9ubG9hZGVuZFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZGVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignTmV0d29yayBFcnJvcicsIEF4aW9zRXJyb3IuRVJSX05FVFdPUkssIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICBsZXQgdGltZW91dEVycm9yTWVzc2FnZSA9IF9jb25maWcudGltZW91dCA/ICd0aW1lb3V0IG9mICcgKyBfY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnIDogJ3RpbWVvdXQgZXhjZWVkZWQnO1xuICAgICAgY29uc3QgdHJhbnNpdGlvbmFsID0gX2NvbmZpZy50cmFuc2l0aW9uYWwgfHwgdHJhbnNpdGlvbmFsRGVmYXVsdHM7XG4gICAgICBpZiAoX2NvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBfY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UsXG4gICAgICAgIHRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gQXhpb3NFcnJvci5FVElNRURPVVQgOiBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgcmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCAmJiByZXF1ZXN0SGVhZGVycy5zZXRDb250ZW50VHlwZShudWxsKTtcblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscyQxLmZvckVhY2gocmVxdWVzdEhlYWRlcnMudG9KU09OKCksIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzJDEuaXNVbmRlZmluZWQoX2NvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhX2NvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChyZXNwb25zZVR5cGUgJiYgcmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gX2NvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmIChvbkRvd25sb2FkUHJvZ3Jlc3MpIHtcbiAgICAgIChbZG93bmxvYWRUaHJvdHRsZWQsIGZsdXNoRG93bmxvYWRdID0gcHJvZ3Jlc3NFdmVudFJlZHVjZXIob25Eb3dubG9hZFByb2dyZXNzLCB0cnVlKSk7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZG93bmxvYWRUaHJvdHRsZWQpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKG9uVXBsb2FkUHJvZ3Jlc3MgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIChbdXBsb2FkVGhyb3R0bGVkLCBmbHVzaFVwbG9hZF0gPSBwcm9ncmVzc0V2ZW50UmVkdWNlcihvblVwbG9hZFByb2dyZXNzKSk7XG5cbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdXBsb2FkVGhyb3R0bGVkKTtcblxuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIGZsdXNoVXBsb2FkKTtcbiAgICB9XG5cbiAgICBpZiAoX2NvbmZpZy5jYW5jZWxUb2tlbiB8fCBfY29uZmlnLnNpZ25hbCkge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgIG9uQ2FuY2VsZWQgPSBjYW5jZWwgPT4ge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KCFjYW5jZWwgfHwgY2FuY2VsLnR5cGUgPyBuZXcgQ2FuY2VsZWRFcnJvcihudWxsLCBjb25maWcsIHJlcXVlc3QpIDogY2FuY2VsKTtcbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIF9jb25maWcuY2FuY2VsVG9rZW4gJiYgX2NvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICBpZiAoX2NvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgX2NvbmZpZy5zaWduYWwuYWJvcnRlZCA/IG9uQ2FuY2VsZWQoKSA6IF9jb25maWcuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdG9jb2wgPSBwYXJzZVByb3RvY29sKF9jb25maWcudXJsKTtcblxuICAgIGlmIChwcm90b2NvbCAmJiBwbGF0Zm9ybS5wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sICcgKyBwcm90b2NvbCArICc6JywgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIGNvbmZpZykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSB8fCBudWxsKTtcbiAgfSk7XG59O1xuXG5jb25zdCBjb21wb3NlU2lnbmFscyA9IChzaWduYWxzLCB0aW1lb3V0KSA9PiB7XG4gIGNvbnN0IHtsZW5ndGh9ID0gKHNpZ25hbHMgPSBzaWduYWxzID8gc2lnbmFscy5maWx0ZXIoQm9vbGVhbikgOiBbXSk7XG5cbiAgaWYgKHRpbWVvdXQgfHwgbGVuZ3RoKSB7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgICBsZXQgYWJvcnRlZDtcblxuICAgIGNvbnN0IG9uYWJvcnQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoIWFib3J0ZWQpIHtcbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGNvbnN0IGVyciA9IHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yID8gcmVhc29uIDogdGhpcy5yZWFzb247XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoZXJyIGluc3RhbmNlb2YgQXhpb3NFcnJvciA/IGVyciA6IG5ldyBDYW5jZWxlZEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBlcnIpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IHRpbWVyID0gdGltZW91dCAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIG9uYWJvcnQobmV3IEF4aW9zRXJyb3IoYHRpbWVvdXQgJHt0aW1lb3V0fSBvZiBtcyBleGNlZWRlZGAsIEF4aW9zRXJyb3IuRVRJTUVET1VUKSk7XG4gICAgfSwgdGltZW91dCk7XG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgIGlmIChzaWduYWxzKSB7XG4gICAgICAgIHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgc2lnbmFscy5mb3JFYWNoKHNpZ25hbCA9PiB7XG4gICAgICAgICAgc2lnbmFsLnVuc3Vic2NyaWJlID8gc2lnbmFsLnVuc3Vic2NyaWJlKG9uYWJvcnQpIDogc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25hYm9ydCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWduYWxzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uYWJvcnQpKTtcblxuICAgIGNvbnN0IHtzaWduYWx9ID0gY29udHJvbGxlcjtcblxuICAgIHNpZ25hbC51bnN1YnNjcmliZSA9ICgpID0+IHV0aWxzJDEuYXNhcCh1bnN1YnNjcmliZSk7XG5cbiAgICByZXR1cm4gc2lnbmFsO1xuICB9XG59O1xuXG52YXIgY29tcG9zZVNpZ25hbHMkMSA9IGNvbXBvc2VTaWduYWxzO1xuXG5jb25zdCBzdHJlYW1DaHVuayA9IGZ1bmN0aW9uKiAoY2h1bmssIGNodW5rU2l6ZSkge1xuICBsZXQgbGVuID0gY2h1bmsuYnl0ZUxlbmd0aDtcblxuICBpZiAoIWNodW5rU2l6ZSB8fCBsZW4gPCBjaHVua1NpemUpIHtcbiAgICB5aWVsZCBjaHVuaztcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgcG9zID0gMDtcbiAgbGV0IGVuZDtcblxuICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgZW5kID0gcG9zICsgY2h1bmtTaXplO1xuICAgIHlpZWxkIGNodW5rLnNsaWNlKHBvcywgZW5kKTtcbiAgICBwb3MgPSBlbmQ7XG4gIH1cbn07XG5cbmNvbnN0IHJlYWRCeXRlcyA9IGFzeW5jIGZ1bmN0aW9uKiAoaXRlcmFibGUsIGNodW5rU2l6ZSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlYWRTdHJlYW0oaXRlcmFibGUpKSB7XG4gICAgeWllbGQqIHN0cmVhbUNodW5rKGNodW5rLCBjaHVua1NpemUpO1xuICB9XG59O1xuXG5jb25zdCByZWFkU3RyZWFtID0gYXN5bmMgZnVuY3Rpb24qIChzdHJlYW0pIHtcbiAgaWYgKHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICB5aWVsZCogc3RyZWFtO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgdHJ5IHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCB7ZG9uZSwgdmFsdWV9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgeWllbGQgdmFsdWU7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IHJlYWRlci5jYW5jZWwoKTtcbiAgfVxufTtcblxuY29uc3QgdHJhY2tTdHJlYW0gPSAoc3RyZWFtLCBjaHVua1NpemUsIG9uUHJvZ3Jlc3MsIG9uRmluaXNoKSA9PiB7XG4gIGNvbnN0IGl0ZXJhdG9yID0gcmVhZEJ5dGVzKHN0cmVhbSwgY2h1bmtTaXplKTtcblxuICBsZXQgYnl0ZXMgPSAwO1xuICBsZXQgZG9uZTtcbiAgbGV0IF9vbkZpbmlzaCA9IChlKSA9PiB7XG4gICAgaWYgKCFkb25lKSB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIG9uRmluaXNoICYmIG9uRmluaXNoKGUpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHtkb25lLCB2YWx1ZX0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgIF9vbkZpbmlzaCgpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGVuID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBsZXQgbG9hZGVkQnl0ZXMgPSBieXRlcyArPSBsZW47XG4gICAgICAgICAgb25Qcm9ncmVzcyhsb2FkZWRCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX29uRmluaXNoKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIF9vbkZpbmlzaChyZWFzb24pO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yLnJldHVybigpO1xuICAgIH1cbiAgfSwge1xuICAgIGhpZ2hXYXRlck1hcms6IDJcbiAgfSlcbn07XG5cbmNvbnN0IGlzRmV0Y2hTdXBwb3J0ZWQgPSB0eXBlb2YgZmV0Y2ggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFJlcXVlc3QgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFJlc3BvbnNlID09PSAnZnVuY3Rpb24nO1xuY29uc3QgaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCA9IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgdHlwZW9mIFJlYWRhYmxlU3RyZWFtID09PSAnZnVuY3Rpb24nO1xuXG4vLyB1c2VkIG9ubHkgaW5zaWRlIHRoZSBmZXRjaCBhZGFwdGVyXG5jb25zdCBlbmNvZGVUZXh0ID0gaXNGZXRjaFN1cHBvcnRlZCAmJiAodHlwZW9mIFRleHRFbmNvZGVyID09PSAnZnVuY3Rpb24nID9cbiAgICAoKGVuY29kZXIpID0+IChzdHIpID0+IGVuY29kZXIuZW5jb2RlKHN0cikpKG5ldyBUZXh0RW5jb2RlcigpKSA6XG4gICAgYXN5bmMgKHN0cikgPT4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgbmV3IFJlc3BvbnNlKHN0cikuYXJyYXlCdWZmZXIoKSlcbik7XG5cbmNvbnN0IHRlc3QgPSAoZm4sIC4uLmFyZ3MpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFmbiguLi5hcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuXG5jb25zdCBzdXBwb3J0c1JlcXVlc3RTdHJlYW0gPSBpc1JlYWRhYmxlU3RyZWFtU3VwcG9ydGVkICYmIHRlc3QoKCkgPT4ge1xuICBsZXQgZHVwbGV4QWNjZXNzZWQgPSBmYWxzZTtcblxuICBjb25zdCBoYXNDb250ZW50VHlwZSA9IG5ldyBSZXF1ZXN0KHBsYXRmb3JtLm9yaWdpbiwge1xuICAgIGJvZHk6IG5ldyBSZWFkYWJsZVN0cmVhbSgpLFxuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGdldCBkdXBsZXgoKSB7XG4gICAgICBkdXBsZXhBY2Nlc3NlZCA9IHRydWU7XG4gICAgICByZXR1cm4gJ2hhbGYnO1xuICAgIH0sXG4gIH0pLmhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKTtcblxuICByZXR1cm4gZHVwbGV4QWNjZXNzZWQgJiYgIWhhc0NvbnRlbnRUeXBlO1xufSk7XG5cbmNvbnN0IERFRkFVTFRfQ0hVTktfU0laRSA9IDY0ICogMTAyNDtcblxuY29uc3Qgc3VwcG9ydHNSZXNwb25zZVN0cmVhbSA9IGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgJiZcbiAgdGVzdCgoKSA9PiB1dGlscyQxLmlzUmVhZGFibGVTdHJlYW0obmV3IFJlc3BvbnNlKCcnKS5ib2R5KSk7XG5cblxuY29uc3QgcmVzb2x2ZXJzID0ge1xuICBzdHJlYW06IHN1cHBvcnRzUmVzcG9uc2VTdHJlYW0gJiYgKChyZXMpID0+IHJlcy5ib2R5KVxufTtcblxuaXNGZXRjaFN1cHBvcnRlZCAmJiAoKChyZXMpID0+IHtcbiAgWyd0ZXh0JywgJ2FycmF5QnVmZmVyJywgJ2Jsb2InLCAnZm9ybURhdGEnLCAnc3RyZWFtJ10uZm9yRWFjaCh0eXBlID0+IHtcbiAgICAhcmVzb2x2ZXJzW3R5cGVdICYmIChyZXNvbHZlcnNbdHlwZV0gPSB1dGlscyQxLmlzRnVuY3Rpb24ocmVzW3R5cGVdKSA/IChyZXMpID0+IHJlc1t0eXBlXSgpIDpcbiAgICAgIChfLCBjb25maWcpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoYFJlc3BvbnNlIHR5cGUgJyR7dHlwZX0nIGlzIG5vdCBzdXBwb3J0ZWRgLCBBeGlvc0Vycm9yLkVSUl9OT1RfU1VQUE9SVCwgY29uZmlnKTtcbiAgICAgIH0pO1xuICB9KTtcbn0pKG5ldyBSZXNwb25zZSkpO1xuXG5jb25zdCBnZXRCb2R5TGVuZ3RoID0gYXN5bmMgKGJvZHkpID0+IHtcbiAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYodXRpbHMkMS5pc0Jsb2IoYm9keSkpIHtcbiAgICByZXR1cm4gYm9keS5zaXplO1xuICB9XG5cbiAgaWYodXRpbHMkMS5pc1NwZWNDb21wbGlhbnRGb3JtKGJvZHkpKSB7XG4gICAgY29uc3QgX3JlcXVlc3QgPSBuZXcgUmVxdWVzdChwbGF0Zm9ybS5vcmlnaW4sIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keSxcbiAgICB9KTtcbiAgICByZXR1cm4gKGF3YWl0IF9yZXF1ZXN0LmFycmF5QnVmZmVyKCkpLmJ5dGVMZW5ndGg7XG4gIH1cblxuICBpZih1dGlscyQxLmlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpIHx8IHV0aWxzJDEuaXNBcnJheUJ1ZmZlcihib2R5KSkge1xuICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGg7XG4gIH1cblxuICBpZih1dGlscyQxLmlzVVJMU2VhcmNoUGFyYW1zKGJvZHkpKSB7XG4gICAgYm9keSA9IGJvZHkgKyAnJztcbiAgfVxuXG4gIGlmKHV0aWxzJDEuaXNTdHJpbmcoYm9keSkpIHtcbiAgICByZXR1cm4gKGF3YWl0IGVuY29kZVRleHQoYm9keSkpLmJ5dGVMZW5ndGg7XG4gIH1cbn07XG5cbmNvbnN0IHJlc29sdmVCb2R5TGVuZ3RoID0gYXN5bmMgKGhlYWRlcnMsIGJvZHkpID0+IHtcbiAgY29uc3QgbGVuZ3RoID0gdXRpbHMkMS50b0Zpbml0ZU51bWJlcihoZWFkZXJzLmdldENvbnRlbnRMZW5ndGgoKSk7XG5cbiAgcmV0dXJuIGxlbmd0aCA9PSBudWxsID8gZ2V0Qm9keUxlbmd0aChib2R5KSA6IGxlbmd0aDtcbn07XG5cbnZhciBmZXRjaEFkYXB0ZXIgPSBpc0ZldGNoU3VwcG9ydGVkICYmIChhc3luYyAoY29uZmlnKSA9PiB7XG4gIGxldCB7XG4gICAgdXJsLFxuICAgIG1ldGhvZCxcbiAgICBkYXRhLFxuICAgIHNpZ25hbCxcbiAgICBjYW5jZWxUb2tlbixcbiAgICB0aW1lb3V0LFxuICAgIG9uRG93bmxvYWRQcm9ncmVzcyxcbiAgICBvblVwbG9hZFByb2dyZXNzLFxuICAgIHJlc3BvbnNlVHlwZSxcbiAgICBoZWFkZXJzLFxuICAgIHdpdGhDcmVkZW50aWFscyA9ICdzYW1lLW9yaWdpbicsXG4gICAgZmV0Y2hPcHRpb25zXG4gIH0gPSByZXNvbHZlQ29uZmlnKGNvbmZpZyk7XG5cbiAgcmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlID8gKHJlc3BvbnNlVHlwZSArICcnKS50b0xvd2VyQ2FzZSgpIDogJ3RleHQnO1xuXG4gIGxldCBjb21wb3NlZFNpZ25hbCA9IGNvbXBvc2VTaWduYWxzJDEoW3NpZ25hbCwgY2FuY2VsVG9rZW4gJiYgY2FuY2VsVG9rZW4udG9BYm9ydFNpZ25hbCgpXSwgdGltZW91dCk7XG5cbiAgbGV0IHJlcXVlc3Q7XG5cbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBjb21wb3NlZFNpZ25hbCAmJiBjb21wb3NlZFNpZ25hbC51bnN1YnNjcmliZSAmJiAoKCkgPT4ge1xuICAgICAgY29tcG9zZWRTaWduYWwudW5zdWJzY3JpYmUoKTtcbiAgfSk7XG5cbiAgbGV0IHJlcXVlc3RDb250ZW50TGVuZ3RoO1xuXG4gIHRyeSB7XG4gICAgaWYgKFxuICAgICAgb25VcGxvYWRQcm9ncmVzcyAmJiBzdXBwb3J0c1JlcXVlc3RTdHJlYW0gJiYgbWV0aG9kICE9PSAnZ2V0JyAmJiBtZXRob2QgIT09ICdoZWFkJyAmJlxuICAgICAgKHJlcXVlc3RDb250ZW50TGVuZ3RoID0gYXdhaXQgcmVzb2x2ZUJvZHlMZW5ndGgoaGVhZGVycywgZGF0YSkpICE9PSAwXG4gICAgKSB7XG4gICAgICBsZXQgX3JlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgIGR1cGxleDogXCJoYWxmXCJcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgY29udGVudFR5cGVIZWFkZXI7XG5cbiAgICAgIGlmICh1dGlscyQxLmlzRm9ybURhdGEoZGF0YSkgJiYgKGNvbnRlbnRUeXBlSGVhZGVyID0gX3JlcXVlc3QuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSkge1xuICAgICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKGNvbnRlbnRUeXBlSGVhZGVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9yZXF1ZXN0LmJvZHkpIHtcbiAgICAgICAgY29uc3QgW29uUHJvZ3Jlc3MsIGZsdXNoXSA9IHByb2dyZXNzRXZlbnREZWNvcmF0b3IoXG4gICAgICAgICAgcmVxdWVzdENvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoYXN5bmNEZWNvcmF0b3Iob25VcGxvYWRQcm9ncmVzcykpXG4gICAgICAgICk7XG5cbiAgICAgICAgZGF0YSA9IHRyYWNrU3RyZWFtKF9yZXF1ZXN0LmJvZHksIERFRkFVTFRfQ0hVTktfU0laRSwgb25Qcm9ncmVzcywgZmx1c2gpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdXRpbHMkMS5pc1N0cmluZyh3aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICB3aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHMgPyAnaW5jbHVkZScgOiAnb21pdCc7XG4gICAgfVxuXG4gICAgLy8gQ2xvdWRmbGFyZSBXb3JrZXJzIHRocm93cyB3aGVuIGNyZWRlbnRpYWxzIGFyZSBkZWZpbmVkXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG91ZGZsYXJlL3dvcmtlcmQvaXNzdWVzLzkwMlxuICAgIGNvbnN0IGlzQ3JlZGVudGlhbHNTdXBwb3J0ZWQgPSBcImNyZWRlbnRpYWxzXCIgaW4gUmVxdWVzdC5wcm90b3R5cGU7XG4gICAgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwge1xuICAgICAgLi4uZmV0Y2hPcHRpb25zLFxuICAgICAgc2lnbmFsOiBjb21wb3NlZFNpZ25hbCxcbiAgICAgIG1ldGhvZDogbWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLm5vcm1hbGl6ZSgpLnRvSlNPTigpLFxuICAgICAgYm9keTogZGF0YSxcbiAgICAgIGR1cGxleDogXCJoYWxmXCIsXG4gICAgICBjcmVkZW50aWFsczogaXNDcmVkZW50aWFsc1N1cHBvcnRlZCA/IHdpdGhDcmVkZW50aWFscyA6IHVuZGVmaW5lZFxuICAgIH0pO1xuXG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XG5cbiAgICBjb25zdCBpc1N0cmVhbVJlc3BvbnNlID0gc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAocmVzcG9uc2VUeXBlID09PSAnc3RyZWFtJyB8fCByZXNwb25zZVR5cGUgPT09ICdyZXNwb25zZScpO1xuXG4gICAgaWYgKHN1cHBvcnRzUmVzcG9uc2VTdHJlYW0gJiYgKG9uRG93bmxvYWRQcm9ncmVzcyB8fCAoaXNTdHJlYW1SZXNwb25zZSAmJiB1bnN1YnNjcmliZSkpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0ge307XG5cbiAgICAgIFsnc3RhdHVzJywgJ3N0YXR1c1RleHQnLCAnaGVhZGVycyddLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgIG9wdGlvbnNbcHJvcF0gPSByZXNwb25zZVtwcm9wXTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZUNvbnRlbnRMZW5ndGggPSB1dGlscyQxLnRvRmluaXRlTnVtYmVyKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LWxlbmd0aCcpKTtcblxuICAgICAgY29uc3QgW29uUHJvZ3Jlc3MsIGZsdXNoXSA9IG9uRG93bmxvYWRQcm9ncmVzcyAmJiBwcm9ncmVzc0V2ZW50RGVjb3JhdG9yKFxuICAgICAgICByZXNwb25zZUNvbnRlbnRMZW5ndGgsXG4gICAgICAgIHByb2dyZXNzRXZlbnRSZWR1Y2VyKGFzeW5jRGVjb3JhdG9yKG9uRG93bmxvYWRQcm9ncmVzcyksIHRydWUpXG4gICAgICApIHx8IFtdO1xuXG4gICAgICByZXNwb25zZSA9IG5ldyBSZXNwb25zZShcbiAgICAgICAgdHJhY2tTdHJlYW0ocmVzcG9uc2UuYm9keSwgREVGQVVMVF9DSFVOS19TSVpFLCBvblByb2dyZXNzLCAoKSA9PiB7XG4gICAgICAgICAgZmx1c2ggJiYgZmx1c2goKTtcbiAgICAgICAgICB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9KSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGUgfHwgJ3RleHQnO1xuXG4gICAgbGV0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc29sdmVyc1t1dGlscyQxLmZpbmRLZXkocmVzb2x2ZXJzLCByZXNwb25zZVR5cGUpIHx8ICd0ZXh0J10ocmVzcG9uc2UsIGNvbmZpZyk7XG5cbiAgICAhaXNTdHJlYW1SZXNwb25zZSAmJiB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xuXG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBoZWFkZXJzOiBBeGlvc0hlYWRlcnMkMS5mcm9tKHJlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9KTtcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xuXG4gICAgaWYgKGVyciAmJiBlcnIubmFtZSA9PT0gJ1R5cGVFcnJvcicgJiYgL2ZldGNoL2kudGVzdChlcnIubWVzc2FnZSkpIHtcbiAgICAgIHRocm93IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIG5ldyBBeGlvc0Vycm9yKCdOZXR3b3JrIEVycm9yJywgQXhpb3NFcnJvci5FUlJfTkVUV09SSywgY29uZmlnLCByZXF1ZXN0KSxcbiAgICAgICAge1xuICAgICAgICAgIGNhdXNlOiBlcnIuY2F1c2UgfHwgZXJyXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZXJyLCBlcnIgJiYgZXJyLmNvZGUsIGNvbmZpZywgcmVxdWVzdCk7XG4gIH1cbn0pO1xuXG5jb25zdCBrbm93bkFkYXB0ZXJzID0ge1xuICBodHRwOiBodHRwQWRhcHRlcixcbiAgeGhyOiB4aHJBZGFwdGVyLFxuICBmZXRjaDogZmV0Y2hBZGFwdGVyXG59O1xuXG51dGlscyQxLmZvckVhY2goa25vd25BZGFwdGVycywgKGZuLCB2YWx1ZSkgPT4ge1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbmFtZScsIHt2YWx1ZX0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICdhZGFwdGVyTmFtZScsIHt2YWx1ZX0pO1xuICB9XG59KTtcblxuY29uc3QgcmVuZGVyUmVhc29uID0gKHJlYXNvbikgPT4gYC0gJHtyZWFzb259YDtcblxuY29uc3QgaXNSZXNvbHZlZEhhbmRsZSA9IChhZGFwdGVyKSA9PiB1dGlscyQxLmlzRnVuY3Rpb24oYWRhcHRlcikgfHwgYWRhcHRlciA9PT0gbnVsbCB8fCBhZGFwdGVyID09PSBmYWxzZTtcblxudmFyIGFkYXB0ZXJzID0ge1xuICBnZXRBZGFwdGVyOiAoYWRhcHRlcnMpID0+IHtcbiAgICBhZGFwdGVycyA9IHV0aWxzJDEuaXNBcnJheShhZGFwdGVycykgPyBhZGFwdGVycyA6IFthZGFwdGVyc107XG5cbiAgICBjb25zdCB7bGVuZ3RofSA9IGFkYXB0ZXJzO1xuICAgIGxldCBuYW1lT3JBZGFwdGVyO1xuICAgIGxldCBhZGFwdGVyO1xuXG4gICAgY29uc3QgcmVqZWN0ZWRSZWFzb25zID0ge307XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBuYW1lT3JBZGFwdGVyID0gYWRhcHRlcnNbaV07XG4gICAgICBsZXQgaWQ7XG5cbiAgICAgIGFkYXB0ZXIgPSBuYW1lT3JBZGFwdGVyO1xuXG4gICAgICBpZiAoIWlzUmVzb2x2ZWRIYW5kbGUobmFtZU9yQWRhcHRlcikpIHtcbiAgICAgICAgYWRhcHRlciA9IGtub3duQWRhcHRlcnNbKGlkID0gU3RyaW5nKG5hbWVPckFkYXB0ZXIpKS50b0xvd2VyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoYWRhcHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoYFVua25vd24gYWRhcHRlciAnJHtpZH0nYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFkYXB0ZXIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJlamVjdGVkUmVhc29uc1tpZCB8fCAnIycgKyBpXSA9IGFkYXB0ZXI7XG4gICAgfVxuXG4gICAgaWYgKCFhZGFwdGVyKSB7XG5cbiAgICAgIGNvbnN0IHJlYXNvbnMgPSBPYmplY3QuZW50cmllcyhyZWplY3RlZFJlYXNvbnMpXG4gICAgICAgIC5tYXAoKFtpZCwgc3RhdGVdKSA9PiBgYWRhcHRlciAke2lkfSBgICtcbiAgICAgICAgICAoc3RhdGUgPT09IGZhbHNlID8gJ2lzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50JyA6ICdpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBidWlsZCcpXG4gICAgICAgICk7XG5cbiAgICAgIGxldCBzID0gbGVuZ3RoID9cbiAgICAgICAgKHJlYXNvbnMubGVuZ3RoID4gMSA/ICdzaW5jZSA6XFxuJyArIHJlYXNvbnMubWFwKHJlbmRlclJlYXNvbikuam9pbignXFxuJykgOiAnICcgKyByZW5kZXJSZWFzb24ocmVhc29uc1swXSkpIDpcbiAgICAgICAgJ2FzIG5vIGFkYXB0ZXIgc3BlY2lmaWVkJztcblxuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIGBUaGVyZSBpcyBubyBzdWl0YWJsZSBhZGFwdGVyIHRvIGRpc3BhdGNoIHRoZSByZXF1ZXN0IGAgKyBzLFxuICAgICAgICAnRVJSX05PVF9TVVBQT1JUJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRhcHRlcjtcbiAgfSxcbiAgYWRhcHRlcnM6IGtub3duQWRhcHRlcnNcbn07XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cblxuICBpZiAoY29uZmlnLnNpZ25hbCAmJiBjb25maWcuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgQ2FuY2VsZWRFcnJvcihudWxsLCBjb25maWcpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKGNvbmZpZy5oZWFkZXJzKTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgIGNvbmZpZyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIGlmIChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10uaW5kZXhPZihjb25maWcubWV0aG9kKSAhPT0gLTEpIHtcbiAgICBjb25maWcuaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJywgZmFsc2UpO1xuICB9XG5cbiAgY29uc3QgYWRhcHRlciA9IGFkYXB0ZXJzLmdldEFkYXB0ZXIoY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMkMS5hZGFwdGVyKTtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgIGNvbmZpZyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZSxcbiAgICAgIHJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKHJlc3BvbnNlLmhlYWRlcnMpO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZVxuICAgICAgICApO1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyA9IEF4aW9zSGVhZGVycyQxLmZyb20ocmVhc29uLnJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn1cblxuY29uc3QgVkVSU0lPTiA9IFwiMS43LjlcIjtcblxuY29uc3QgdmFsaWRhdG9ycyQxID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaCgodHlwZSwgaSkgPT4ge1xuICB2YWxpZGF0b3JzJDFbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG5jb25zdCBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvciAtIHNldCB0byBmYWxzZSBpZiB0aGUgdHJhbnNpdGlvbmFsIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb24gLSBkZXByZWNhdGVkIHZlcnNpb24gLyByZW1vdmVkIHNpbmNlIHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nP30gbWVzc2FnZSAtIHNvbWUgbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgaW5mb1xuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycyQxLnRyYW5zaXRpb25hbCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25hbCh2YWxpZGF0b3IsIHZlcnNpb24sIG1lc3NhZ2UpIHtcbiAgZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShvcHQsIGRlc2MpIHtcbiAgICByZXR1cm4gJ1tBeGlvcyB2JyArIFZFUlNJT04gKyAnXSBUcmFuc2l0aW9uYWwgb3B0aW9uIFxcJycgKyBvcHQgKyAnXFwnJyArIGRlc2MgKyAobWVzc2FnZSA/ICcuICcgKyBtZXNzYWdlIDogJycpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuICh2YWx1ZSwgb3B0LCBvcHRzKSA9PiB7XG4gICAgaWYgKHZhbGlkYXRvciA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICBmb3JtYXRNZXNzYWdlKG9wdCwgJyBoYXMgYmVlbiByZW1vdmVkJyArICh2ZXJzaW9uID8gJyBpbiAnICsgdmVyc2lvbiA6ICcnKSksXG4gICAgICAgIEF4aW9zRXJyb3IuRVJSX0RFUFJFQ0FURURcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gJiYgIWRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdKSB7XG4gICAgICBkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSA9IHRydWU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBmb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIG9wdCxcbiAgICAgICAgICAnIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdicgKyB2ZXJzaW9uICsgJyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZWFyIGZ1dHVyZSdcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdG9yID8gdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdHMpIDogdHJ1ZTtcbiAgfTtcbn07XG5cbnZhbGlkYXRvcnMkMS5zcGVsbGluZyA9IGZ1bmN0aW9uIHNwZWxsaW5nKGNvcnJlY3RTcGVsbGluZykge1xuICByZXR1cm4gKHZhbHVlLCBvcHQpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihgJHtvcHR9IGlzIGxpa2VseSBhIG1pc3NwZWxsaW5nIG9mICR7Y29ycmVjdFNwZWxsaW5nfWApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKlxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBjb25zdCBvcHQgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTik7XG4gICAgfVxuICB9XG59XG5cbnZhciB2YWxpZGF0b3IgPSB7XG4gIGFzc2VydE9wdGlvbnMsXG4gIHZhbGlkYXRvcnM6IHZhbGlkYXRvcnMkMVxufTtcblxuY29uc3QgdmFsaWRhdG9ycyA9IHZhbGlkYXRvci52YWxpZGF0b3JzO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5jbGFzcyBBeGlvcyB7XG4gIGNvbnN0cnVjdG9yKGluc3RhbmNlQ29uZmlnKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlciQxKCksXG4gICAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlciQxKClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmZpZ09yVXJsIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAgICogQHBhcmFtIHs/T2JqZWN0fSBjb25maWdcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZXF1ZXN0KGNvbmZpZ09yVXJsLCBjb25maWcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGxldCBkdW1teSA9IHt9O1xuXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZHVtbXkpIDogKGR1bW15ID0gbmV3IEVycm9yKCkpO1xuXG4gICAgICAgIC8vIHNsaWNlIG9mZiB0aGUgRXJyb3I6IC4uLiBsaW5lXG4gICAgICAgIGNvbnN0IHN0YWNrID0gZHVtbXkuc3RhY2sgPyBkdW1teS5zdGFjay5yZXBsYWNlKC9eLitcXG4vLCAnJykgOiAnJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIWVyci5zdGFjaykge1xuICAgICAgICAgICAgZXJyLnN0YWNrID0gc3RhY2s7XG4gICAgICAgICAgICAvLyBtYXRjaCB3aXRob3V0IHRoZSAyIHRvcCBzdGFjayBsaW5lc1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhY2sgJiYgIVN0cmluZyhlcnIuc3RhY2spLmVuZHNXaXRoKHN0YWNrLnJlcGxhY2UoL14uK1xcbi4rXFxuLywgJycpKSkge1xuICAgICAgICAgICAgZXJyLnN0YWNrICs9ICdcXG4nICsgc3RhY2s7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaWdub3JlIHRoZSBjYXNlIHdoZXJlIFwic3RhY2tcIiBpcyBhbiB1bi13cml0YWJsZSBwcm9wZXJ0eVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICBfcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICAgIGlmICh0eXBlb2YgY29uZmlnT3JVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICBjb25maWcudXJsID0gY29uZmlnT3JVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZyA9IGNvbmZpZ09yVXJsIHx8IHt9O1xuICAgIH1cblxuICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgICBjb25zdCB7dHJhbnNpdGlvbmFsLCBwYXJhbXNTZXJpYWxpemVyLCBoZWFkZXJzfSA9IGNvbmZpZztcblxuICAgIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XG4gICAgICAgIHNpbGVudEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxuICAgICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKVxuICAgICAgfSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXNTZXJpYWxpemVyICE9IG51bGwpIHtcbiAgICAgIGlmICh1dGlscyQxLmlzRnVuY3Rpb24ocGFyYW1zU2VyaWFsaXplcikpIHtcbiAgICAgICAgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIgPSB7XG4gICAgICAgICAgc2VyaWFsaXplOiBwYXJhbXNTZXJpYWxpemVyXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyhwYXJhbXNTZXJpYWxpemVyLCB7XG4gICAgICAgICAgZW5jb2RlOiB2YWxpZGF0b3JzLmZ1bmN0aW9uLFxuICAgICAgICAgIHNlcmlhbGl6ZTogdmFsaWRhdG9ycy5mdW5jdGlvblxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyhjb25maWcsIHtcbiAgICAgIGJhc2VVcmw6IHZhbGlkYXRvcnMuc3BlbGxpbmcoJ2Jhc2VVUkwnKSxcbiAgICAgIHdpdGhYc3JmVG9rZW46IHZhbGlkYXRvcnMuc3BlbGxpbmcoJ3dpdGhYU1JGVG9rZW4nKVxuICAgIH0sIHRydWUpO1xuXG4gICAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgICBjb25maWcubWV0aG9kID0gKGNvbmZpZy5tZXRob2QgfHwgdGhpcy5kZWZhdWx0cy5tZXRob2QgfHwgJ2dldCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgICBsZXQgY29udGV4dEhlYWRlcnMgPSBoZWFkZXJzICYmIHV0aWxzJDEubWVyZ2UoXG4gICAgICBoZWFkZXJzLmNvbW1vbixcbiAgICAgIGhlYWRlcnNbY29uZmlnLm1ldGhvZF1cbiAgICApO1xuXG4gICAgaGVhZGVycyAmJiB1dGlscyQxLmZvckVhY2goXG4gICAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICAgIChtZXRob2QpID0+IHtcbiAgICAgICAgZGVsZXRlIGhlYWRlcnNbbWV0aG9kXTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5jb25jYXQoY29udGV4dEhlYWRlcnMsIGhlYWRlcnMpO1xuXG4gICAgLy8gZmlsdGVyIG91dCBza2lwcGVkIGludGVyY2VwdG9yc1xuICAgIGNvbnN0IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluID0gW107XG4gICAgbGV0IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHRydWU7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yLnJ1bldoZW4gPT09ICdmdW5jdGlvbicgJiYgaW50ZXJjZXB0b3IucnVuV2hlbihjb25maWcpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyAmJiBpbnRlcmNlcHRvci5zeW5jaHJvbm91cztcblxuICAgICAgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgICByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgICB9KTtcblxuICAgIGxldCBwcm9taXNlO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgbGVuO1xuXG4gICAgaWYgKCFzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMpIHtcbiAgICAgIGNvbnN0IGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdC5iaW5kKHRoaXMpLCB1bmRlZmluZWRdO1xuICAgICAgY2hhaW4udW5zaGlmdC5hcHBseShjaGFpbiwgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4pO1xuICAgICAgY2hhaW4ucHVzaC5hcHBseShjaGFpbiwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcbiAgICAgIGxlbiA9IGNoYWluLmxlbmd0aDtcblxuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluW2krK10sIGNoYWluW2krK10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cbiAgICBsZW4gPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5sZW5ndGg7XG5cbiAgICBsZXQgbmV3Q29uZmlnID0gY29uZmlnO1xuXG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgY29uc3Qgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xuICAgICAgY29uc3Qgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluW2krK107XG4gICAgICB0cnkge1xuICAgICAgICBuZXdDb25maWcgPSBvbkZ1bGZpbGxlZChuZXdDb25maWcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgb25SZWplY3RlZC5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QuY2FsbCh0aGlzLCBuZXdDb25maWcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGxlbiA9IHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW5baSsrXSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluW2krK10pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZ2V0VXJpKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gICAgY29uc3QgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICByZXR1cm4gYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKTtcbiAgfVxufVxuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzJDEuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsLFxuICAgICAgZGF0YTogKGNvbmZpZyB8fCB7fSkuZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscyQxLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVIVFRQTWV0aG9kKGlzRm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBodHRwTWV0aG9kKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IGlzRm9ybSA/IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnXG4gICAgICAgIH0gOiB7fSxcbiAgICAgICAgdXJsLFxuICAgICAgICBkYXRhXG4gICAgICB9KSk7XG4gICAgfTtcbiAgfVxuXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZ2VuZXJhdGVIVFRQTWV0aG9kKCk7XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZCArICdGb3JtJ10gPSBnZW5lcmF0ZUhUVFBNZXRob2QodHJ1ZSk7XG59KTtcblxudmFyIEF4aW9zJDEgPSBBeGlvcztcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7Q2FuY2VsVG9rZW59XG4gKi9cbmNsYXNzIENhbmNlbFRva2VuIHtcbiAgY29uc3RydWN0b3IoZXhlY3V0b3IpIHtcbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVQcm9taXNlO1xuXG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRva2VuID0gdGhpcztcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgdGhpcy5wcm9taXNlLnRoZW4oY2FuY2VsID0+IHtcbiAgICAgIGlmICghdG9rZW4uX2xpc3RlbmVycykgcmV0dXJuO1xuXG4gICAgICBsZXQgaSA9IHRva2VuLl9saXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICB0b2tlbi5fbGlzdGVuZXJzW2ldKGNhbmNlbCk7XG4gICAgICB9XG4gICAgICB0b2tlbi5fbGlzdGVuZXJzID0gbnVsbDtcbiAgICB9KTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgdGhpcy5wcm9taXNlLnRoZW4gPSBvbmZ1bGZpbGxlZCA9PiB7XG4gICAgICBsZXQgX3Jlc29sdmU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0b2tlbi5zdWJzY3JpYmUocmVzb2x2ZSk7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pLnRoZW4ob25mdWxmaWxsZWQpO1xuXG4gICAgICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uIHJlamVjdCgpIHtcbiAgICAgICAgdG9rZW4udW5zdWJzY3JpYmUoX3Jlc29sdmUpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpIHtcbiAgICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbGVkRXJyb3IobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KTtcbiAgICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gICAqL1xuICB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgdGhyb3cgdGhpcy5yZWFzb247XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cblxuICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGxpc3RlbmVyKHRoaXMucmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtsaXN0ZW5lcl07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGNhbmNlbCBzaWduYWxcbiAgICovXG5cbiAgdW5zdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICB0b0Fib3J0U2lnbmFsKCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgICBjb25zdCBhYm9ydCA9IChlcnIpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoZXJyKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJzY3JpYmUoYWJvcnQpO1xuXG4gICAgY29udHJvbGxlci5zaWduYWwudW5zdWJzY3JpYmUgPSAoKSA9PiB0aGlzLnVuc3Vic2NyaWJlKGFib3J0KTtcblxuICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gICAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gICAqL1xuICBzdGF0aWMgc291cmNlKCkge1xuICAgIGxldCBjYW5jZWw7XG4gICAgY29uc3QgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgICAgY2FuY2VsID0gYztcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW4sXG4gICAgICBjYW5jZWxcbiAgICB9O1xuICB9XG59XG5cbnZhciBDYW5jZWxUb2tlbiQxID0gQ2FuY2VsVG9rZW47XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gdXRpbHMkMS5pc09iamVjdChwYXlsb2FkKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufVxuXG5jb25zdCBIdHRwU3RhdHVzQ29kZSA9IHtcbiAgQ29udGludWU6IDEwMCxcbiAgU3dpdGNoaW5nUHJvdG9jb2xzOiAxMDEsXG4gIFByb2Nlc3Npbmc6IDEwMixcbiAgRWFybHlIaW50czogMTAzLFxuICBPazogMjAwLFxuICBDcmVhdGVkOiAyMDEsXG4gIEFjY2VwdGVkOiAyMDIsXG4gIE5vbkF1dGhvcml0YXRpdmVJbmZvcm1hdGlvbjogMjAzLFxuICBOb0NvbnRlbnQ6IDIwNCxcbiAgUmVzZXRDb250ZW50OiAyMDUsXG4gIFBhcnRpYWxDb250ZW50OiAyMDYsXG4gIE11bHRpU3RhdHVzOiAyMDcsXG4gIEFscmVhZHlSZXBvcnRlZDogMjA4LFxuICBJbVVzZWQ6IDIyNixcbiAgTXVsdGlwbGVDaG9pY2VzOiAzMDAsXG4gIE1vdmVkUGVybWFuZW50bHk6IDMwMSxcbiAgRm91bmQ6IDMwMixcbiAgU2VlT3RoZXI6IDMwMyxcbiAgTm90TW9kaWZpZWQ6IDMwNCxcbiAgVXNlUHJveHk6IDMwNSxcbiAgVW51c2VkOiAzMDYsXG4gIFRlbXBvcmFyeVJlZGlyZWN0OiAzMDcsXG4gIFBlcm1hbmVudFJlZGlyZWN0OiAzMDgsXG4gIEJhZFJlcXVlc3Q6IDQwMCxcbiAgVW5hdXRob3JpemVkOiA0MDEsXG4gIFBheW1lbnRSZXF1aXJlZDogNDAyLFxuICBGb3JiaWRkZW46IDQwMyxcbiAgTm90Rm91bmQ6IDQwNCxcbiAgTWV0aG9kTm90QWxsb3dlZDogNDA1LFxuICBOb3RBY2NlcHRhYmxlOiA0MDYsXG4gIFByb3h5QXV0aGVudGljYXRpb25SZXF1aXJlZDogNDA3LFxuICBSZXF1ZXN0VGltZW91dDogNDA4LFxuICBDb25mbGljdDogNDA5LFxuICBHb25lOiA0MTAsXG4gIExlbmd0aFJlcXVpcmVkOiA0MTEsXG4gIFByZWNvbmRpdGlvbkZhaWxlZDogNDEyLFxuICBQYXlsb2FkVG9vTGFyZ2U6IDQxMyxcbiAgVXJpVG9vTG9uZzogNDE0LFxuICBVbnN1cHBvcnRlZE1lZGlhVHlwZTogNDE1LFxuICBSYW5nZU5vdFNhdGlzZmlhYmxlOiA0MTYsXG4gIEV4cGVjdGF0aW9uRmFpbGVkOiA0MTcsXG4gIEltQVRlYXBvdDogNDE4LFxuICBNaXNkaXJlY3RlZFJlcXVlc3Q6IDQyMSxcbiAgVW5wcm9jZXNzYWJsZUVudGl0eTogNDIyLFxuICBMb2NrZWQ6IDQyMyxcbiAgRmFpbGVkRGVwZW5kZW5jeTogNDI0LFxuICBUb29FYXJseTogNDI1LFxuICBVcGdyYWRlUmVxdWlyZWQ6IDQyNixcbiAgUHJlY29uZGl0aW9uUmVxdWlyZWQ6IDQyOCxcbiAgVG9vTWFueVJlcXVlc3RzOiA0MjksXG4gIFJlcXVlc3RIZWFkZXJGaWVsZHNUb29MYXJnZTogNDMxLFxuICBVbmF2YWlsYWJsZUZvckxlZ2FsUmVhc29uczogNDUxLFxuICBJbnRlcm5hbFNlcnZlckVycm9yOiA1MDAsXG4gIE5vdEltcGxlbWVudGVkOiA1MDEsXG4gIEJhZEdhdGV3YXk6IDUwMixcbiAgU2VydmljZVVuYXZhaWxhYmxlOiA1MDMsXG4gIEdhdGV3YXlUaW1lb3V0OiA1MDQsXG4gIEh0dHBWZXJzaW9uTm90U3VwcG9ydGVkOiA1MDUsXG4gIFZhcmlhbnRBbHNvTmVnb3RpYXRlczogNTA2LFxuICBJbnN1ZmZpY2llbnRTdG9yYWdlOiA1MDcsXG4gIExvb3BEZXRlY3RlZDogNTA4LFxuICBOb3RFeHRlbmRlZDogNTEwLFxuICBOZXR3b3JrQXV0aGVudGljYXRpb25SZXF1aXJlZDogNTExLFxufTtcblxuT2JqZWN0LmVudHJpZXMoSHR0cFN0YXR1c0NvZGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICBIdHRwU3RhdHVzQ29kZVt2YWx1ZV0gPSBrZXk7XG59KTtcblxudmFyIEh0dHBTdGF0dXNDb2RlJDEgPSBIdHRwU3RhdHVzQ29kZTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm5zIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICBjb25zdCBjb250ZXh0ID0gbmV3IEF4aW9zJDEoZGVmYXVsdENvbmZpZyk7XG4gIGNvbnN0IGluc3RhbmNlID0gYmluZChBeGlvcyQxLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscyQxLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MkMS5wcm90b3R5cGUsIGNvbnRleHQsIHthbGxPd25LZXlzOiB0cnVlfSk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzJDEuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0LCBudWxsLCB7YWxsT3duS2V5czogdHJ1ZX0pO1xuXG4gIC8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbiAgaW5zdGFuY2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGRlZmF1bHRDb25maWcsIGluc3RhbmNlQ29uZmlnKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbmNvbnN0IGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMkMSk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcyQxO1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbGVkRXJyb3IgPSBDYW5jZWxlZEVycm9yO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbiQxO1xuYXhpb3MuaXNDYW5jZWwgPSBpc0NhbmNlbDtcbmF4aW9zLlZFUlNJT04gPSBWRVJTSU9OO1xuYXhpb3MudG9Gb3JtRGF0YSA9IHRvRm9ybURhdGE7XG5cbi8vIEV4cG9zZSBBeGlvc0Vycm9yIGNsYXNzXG5heGlvcy5BeGlvc0Vycm9yID0gQXhpb3NFcnJvcjtcblxuLy8gYWxpYXMgZm9yIENhbmNlbGVkRXJyb3IgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmF4aW9zLkNhbmNlbCA9IGF4aW9zLkNhbmNlbGVkRXJyb3I7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5cbmF4aW9zLnNwcmVhZCA9IHNwcmVhZDtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gaXNBeGlvc0Vycm9yO1xuXG4vLyBFeHBvc2UgbWVyZ2VDb25maWdcbmF4aW9zLm1lcmdlQ29uZmlnID0gbWVyZ2VDb25maWc7XG5cbmF4aW9zLkF4aW9zSGVhZGVycyA9IEF4aW9zSGVhZGVycyQxO1xuXG5heGlvcy5mb3JtVG9KU09OID0gdGhpbmcgPT4gZm9ybURhdGFUb0pTT04odXRpbHMkMS5pc0hUTUxGb3JtKHRoaW5nKSA/IG5ldyBGb3JtRGF0YSh0aGluZykgOiB0aGluZyk7XG5cbmF4aW9zLmdldEFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyO1xuXG5heGlvcy5IdHRwU3RhdHVzQ29kZSA9IEh0dHBTdGF0dXNDb2RlJDE7XG5cbmF4aW9zLmRlZmF1bHQgPSBheGlvcztcblxuLy8gdGhpcyBtb2R1bGUgc2hvdWxkIG9ubHkgaGF2ZSBhIGRlZmF1bHQgZXhwb3J0XG52YXIgYXhpb3MkMSA9IGF4aW9zO1xuXG5jbGFzcyBQcm92aWRlciB7XG4gICAgY29udHJhY3Q7XG4gICAgY29uc3RydWN0b3IoY29udHJhY3QpIHtcbiAgICAgICAgdGhpcy5jb250cmFjdCA9IGNvbnRyYWN0O1xuICAgIH1cbiAgICBhc3luYyBmZXRjaEpTT04oZW5kcG9pbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZW5kcG9pbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmZXRjaFRleHQoZW5kcG9pbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZW5kcG9pbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYnVmZmVyKS50b1N0cmluZygndXRmLTgnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFByb3ZpZGVyVXJsKHByb3ZpZGVyQWRkcmVzcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmljZSA9IGF3YWl0IHRoaXMuY29udHJhY3QuZ2V0U2VydmljZShwcm92aWRlckFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2UudXJsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UXVvdGUocHJvdmlkZXJBZGRyZXNzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyVXJsKHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3VybH0vdjEvcXVvdGVgO1xuICAgICAgICAgICAgY29uc3QgcXVvdGVTdHJpbmcgPSBhd2FpdCB0aGlzLmZldGNoVGV4dChlbmRwb2ludCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IEpTT04ucGFyc2UocXVvdGVTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVRhc2socHJvdmlkZXJBZGRyZXNzLCB0YXNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyVXJsKHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCB1c2VyQWRkcmVzcyA9IHRoaXMuY29udHJhY3QuZ2V0VXNlckFkZHJlc3MoKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dXJsfS92MS91c2VyLyR7dXNlckFkZHJlc3N9L3Rhc2tgO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoSlNPTihlbmRwb2ludCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRhc2spLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSB0YXNrOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgdGFzaycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNhbmNlbFRhc2socHJvdmlkZXJBZGRyZXNzLCBzaWduYXR1cmUsIHRhc2tJRCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlclVybChwcm92aWRlckFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgdXNlckFkZHJlc3MgPSB0aGlzLmNvbnRyYWN0LmdldFVzZXJBZGRyZXNzKCk7XG4gICAgICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3VybH0vdjEvdXNlci8ke3VzZXJBZGRyZXNzfS90YXNrLyR7dGFza0lEfS9jYW5jZWxgO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoVGV4dChlbmRwb2ludCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRhc2socHJvdmlkZXJBZGRyZXNzLCB1c2VyQWRkcmVzcywgdGFza0lEKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyVXJsKHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3VybH0vdjEvdXNlci8ke2VuY29kZVVSSUNvbXBvbmVudCh1c2VyQWRkcmVzcyl9L3Rhc2svJHt0YXNrSUR9YDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCd1cmwnLCB1cmwpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2VuZHBvaW50JywgZW5kcG9pbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hKU09OKGVuZHBvaW50LCB7IG1ldGhvZDogJ0dFVCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0VGFzayhwcm92aWRlckFkZHJlc3MsIHVzZXJBZGRyZXNzLCBsYXRlc3QgPSBmYWxzZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlclVybChwcm92aWRlckFkZHJlc3MpO1xuICAgICAgICAgICAgbGV0IGVuZHBvaW50ID0gYCR7dXJsfS92MS91c2VyLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHVzZXJBZGRyZXNzKX0vdGFza2A7XG4gICAgICAgICAgICBpZiAobGF0ZXN0KSB7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnQgKz0gJz9sYXRlc3Q9dHJ1ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpTT04oZW5kcG9pbnQsIHsgbWV0aG9kOiAnR0VUJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFBlbmRpbmdUYXNrQ291bnRlcihwcm92aWRlckFkZHJlc3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXJVcmwocHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dXJsfS92MS90YXNrL3BlbmRpbmdgO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihhd2FpdCB0aGlzLmZldGNoVGV4dChlbmRwb2ludCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRMb2cocHJvdmlkZXJBZGRyZXNzLCB1c2VyQWRkcmVzcywgdGFza0lEKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyVXJsKHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3VybH0vdjEvdXNlci8ke3VzZXJBZGRyZXNzfS90YXNrLyR7dGFza0lEfS9sb2dgO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hUZXh0KGVuZHBvaW50LCB7IG1ldGhvZDogJ0dFVCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRDdXN0b21pemVkTW9kZWxzKHVybCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt1cmx9L3YxL21vZGVsYDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaEpTT04oZW5kcG9pbnQsIHsgbWV0aG9kOiAnR0VUJyB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBnZXQgY3VzdG9taXplZCBtb2RlbHM6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0Q3VzdG9taXplZE1vZGVsKHByb3ZpZGVyQWRkcmVzcywgbW9kdWxlTmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlclVybChwcm92aWRlckFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt1cmx9L3YxL21vZGVsLyR7bW9kdWxlTmFtZX1gO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoSlNPTihlbmRwb2ludCwgeyBtZXRob2Q6ICdHRVQnIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0Q3VzdG9taXplZE1vZGVsRGV0YWlsVXNhZ2UocHJvdmlkZXJBZGRyZXNzLCBtb2R1bGVOYW1lLCBvdXRwdXRQYXRoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyVXJsKHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3VybH0vdjEvbW9kZWwvZGVzYy8ke21vZHVsZU5hbWV9YDtcbiAgICAgICAgICAgIGxldCBkZXN0RmlsZSA9IG91dHB1dFBhdGg7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZnMkMS5zdGF0KG91dHB1dFBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RGaWxlID0gcGF0aCQxLmpvaW4ob3V0cHV0UGF0aCwgYCR7bW9kdWxlTmFtZX0uemlwYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IGZzJDEudW5saW5rKGRlc3RGaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHsgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcyQxKHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdnZXQnLFxuICAgICAgICAgICAgICAgIHVybDogZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBmcyQxLndyaXRlRmlsZShkZXN0RmlsZSwgcmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTW9kZWwgZG93bmxvYWRlZCBhbmQgc2F2ZWQgdG8gJHtkZXN0RmlsZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBGaW5lVHVuaW5nQnJva2VyIHtcbiAgICBzaWduZXI7XG4gICAgZmluZVR1bmluZ0NBO1xuICAgIGxlZGdlcjtcbiAgICBtb2RlbFByb2Nlc3NvcjtcbiAgICBzZXJ2aWNlUHJvY2Vzc29yO1xuICAgIHNlcnZpY2VQcm92aWRlcjtcbiAgICBfZ2FzUHJpY2U7XG4gICAgX21heEdhc1ByaWNlO1xuICAgIF9zdGVwO1xuICAgIGNvbnN0cnVjdG9yKHNpZ25lciwgZmluZVR1bmluZ0NBLCBsZWRnZXIsIGdhc1ByaWNlLCBtYXhHYXNQcmljZSwgc3RlcCkge1xuICAgICAgICB0aGlzLnNpZ25lciA9IHNpZ25lcjtcbiAgICAgICAgdGhpcy5maW5lVHVuaW5nQ0EgPSBmaW5lVHVuaW5nQ0E7XG4gICAgICAgIHRoaXMubGVkZ2VyID0gbGVkZ2VyO1xuICAgICAgICB0aGlzLl9nYXNQcmljZSA9IGdhc1ByaWNlO1xuICAgICAgICB0aGlzLl9tYXhHYXNQcmljZSA9IG1heEdhc1ByaWNlO1xuICAgICAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICB9XG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgbGV0IHVzZXJBZGRyZXNzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdXNlckFkZHJlc3MgPSBhd2FpdCB0aGlzLnNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBGaW5lVHVuaW5nU2VydmluZ0NvbnRyYWN0KHRoaXMuc2lnbmVyLCB0aGlzLmZpbmVUdW5pbmdDQSwgdXNlckFkZHJlc3MsIHRoaXMuX2dhc1ByaWNlLCB0aGlzLl9tYXhHYXNQcmljZSwgdGhpcy5fc3RlcCk7XG4gICAgICAgIHRoaXMuc2VydmljZVByb3ZpZGVyID0gbmV3IFByb3ZpZGVyKGNvbnRyYWN0KTtcbiAgICAgICAgdGhpcy5tb2RlbFByb2Nlc3NvciA9IG5ldyBNb2RlbFByb2Nlc3Nvcihjb250cmFjdCwgdGhpcy5sZWRnZXIsIHRoaXMuc2VydmljZVByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlUHJvY2Vzc29yID0gbmV3IFNlcnZpY2VQcm9jZXNzb3IoY29udHJhY3QsIHRoaXMubGVkZ2VyLCB0aGlzLnNlcnZpY2VQcm92aWRlcik7XG4gICAgfVxuICAgIGxpc3RTZXJ2aWNlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VydmljZVByb2Nlc3Nvci5saXN0U2VydmljZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGdldExvY2tlZFRpbWUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXJ2aWNlUHJvY2Vzc29yLmdldExvY2tUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZ2V0QWNjb3VudCA9IGFzeW5jIChwcm92aWRlckFkZHJlc3MpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcnZpY2VQcm9jZXNzb3IuZ2V0QWNjb3VudChwcm92aWRlckFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGdldEFjY291bnRXaXRoRGV0YWlsID0gYXN5bmMgKHByb3ZpZGVyQWRkcmVzcykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VydmljZVByb2Nlc3Nvci5nZXRBY2NvdW50V2l0aERldGFpbChwcm92aWRlckFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFja25vd2xlZGdlUHJvdmlkZXJTaWduZXIgPSBhc3luYyAocHJvdmlkZXJBZGRyZXNzLCBnYXNQcmljZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VydmljZVByb2Nlc3Nvci5hY2tub3dsZWRnZVByb3ZpZGVyU2lnbmVyKHByb3ZpZGVyQWRkcmVzcywgZ2FzUHJpY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxpc3RNb2RlbCA9ICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsUHJvY2Vzc29yLmxpc3RNb2RlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIG1vZGVsVXNhZ2UgPSAocHJvdmlkZXJBZGRyZXNzLCBwcmVUcmFpbmVkTW9kZWxOYW1lLCBvdXRwdXQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2VQcm9jZXNzb3IubW9kZWxVc2FnZShwcm92aWRlckFkZHJlc3MsIHByZVRyYWluZWRNb2RlbE5hbWUsIG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdXBsb2FkRGF0YXNldCA9IGFzeW5jIChkYXRhUGF0aCwgZ2FzUHJpY2UsIG1heEdhc1ByaWNlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm1vZGVsUHJvY2Vzc29yLnVwbG9hZERhdGFzZXQodGhpcy5zaWduZXIucHJpdmF0ZUtleSwgZGF0YVBhdGgsIGdhc1ByaWNlIHx8IHRoaXMuX2dhc1ByaWNlLCBtYXhHYXNQcmljZSB8fCB0aGlzLl9tYXhHYXNQcmljZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZG93bmxvYWREYXRhc2V0ID0gYXN5bmMgKGRhdGFQYXRoLCBkYXRhUm9vdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5tb2RlbFByb2Nlc3Nvci5kb3dubG9hZERhdGFzZXQoZGF0YVBhdGgsIGRhdGFSb290KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjYWxjdWxhdGVUb2tlbiA9IGFzeW5jIChkYXRhc2V0UGF0aCwgcHJlVHJhaW5lZE1vZGVsTmFtZSwgdXNlUHl0aG9uLCBwcm92aWRlckFkZHJlc3MpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubW9kZWxQcm9jZXNzb3IuY2FsY3VsYXRlVG9rZW4oZGF0YXNldFBhdGgsIHVzZVB5dGhvbiwgcHJlVHJhaW5lZE1vZGVsTmFtZSwgcHJvdmlkZXJBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjcmVhdGVUYXNrID0gYXN5bmMgKHByb3ZpZGVyQWRkcmVzcywgcHJlVHJhaW5lZE1vZGVsTmFtZSwgZGF0YVNpemUsIGRhdGFzZXRIYXNoLCB0cmFpbmluZ1BhdGgsIGdhc1ByaWNlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXJ2aWNlUHJvY2Vzc29yLmNyZWF0ZVRhc2socHJvdmlkZXJBZGRyZXNzLCBwcmVUcmFpbmVkTW9kZWxOYW1lLCBkYXRhU2l6ZSwgZGF0YXNldEhhc2gsIHRyYWluaW5nUGF0aCwgZ2FzUHJpY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNhbmNlbFRhc2sgPSBhc3luYyAocHJvdmlkZXJBZGRyZXNzLCB0YXNrSUQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcnZpY2VQcm9jZXNzb3IuY2FuY2VsVGFzayhwcm92aWRlckFkZHJlc3MsIHRhc2tJRCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGlzdFRhc2sgPSBhc3luYyAocHJvdmlkZXJBZGRyZXNzKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXJ2aWNlUHJvY2Vzc29yLmxpc3RUYXNrKHByb3ZpZGVyQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZ2V0VGFzayA9IGFzeW5jIChwcm92aWRlckFkZHJlc3MsIHRhc2tJRCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IGF3YWl0IHRoaXMuc2VydmljZVByb2Nlc3Nvci5nZXRUYXNrKHByb3ZpZGVyQWRkcmVzcywgdGFza0lEKTtcbiAgICAgICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGdldExvZyA9IGFzeW5jIChwcm92aWRlckFkZHJlc3MsIHRhc2tJRCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VydmljZVByb2Nlc3Nvci5nZXRMb2cocHJvdmlkZXJBZGRyZXNzLCB0YXNrSUQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFja25vd2xlZGdlTW9kZWwgPSBhc3luYyAocHJvdmlkZXJBZGRyZXNzLCBkYXRhUGF0aCwgZ2FzUHJpY2UpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm1vZGVsUHJvY2Vzc29yLmFja25vd2xlZGdlTW9kZWwocHJvdmlkZXJBZGRyZXNzLCBkYXRhUGF0aCwgZ2FzUHJpY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRlY3J5cHRNb2RlbCA9IGFzeW5jIChwcm92aWRlckFkZHJlc3MsIGVuY3J5cHRlZE1vZGVsUGF0aCwgZGVjcnlwdGVkTW9kZWxQYXRoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5tb2RlbFByb2Nlc3Nvci5kZWNyeXB0TW9kZWwocHJvdmlkZXJBZGRyZXNzLCBlbmNyeXB0ZWRNb2RlbFBhdGgsIGRlY3J5cHRlZE1vZGVsUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIGNyZWF0ZUZpbmVUdW5pbmdCcm9rZXIgaXMgdXNlZCB0byBpbml0aWFsaXplIFpHU2VydmluZ1VzZXJCcm9rZXJcbiAqXG4gKiBAcGFyYW0gc2lnbmVyIC0gU2lnbmVyIGZyb20gZXRoZXJzLmpzLlxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIDBHIFNlcnZpbmcgY29udHJhY3QgYWRkcmVzcywgdXNlIGRlZmF1bHQgYWRkcmVzcyBpZiBub3QgcHJvdmlkZWQuXG4gKiBAcGFyYW0gbGVkZ2VyIC0gTGVkZ2VyIGJyb2tlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSBnYXNQcmljZSAtIEdhcyBwcmljZSBmb3IgdHJhbnNhY3Rpb25zLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBnYXMgcHJpY2Ugd2lsbCBiZSBjYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogQHJldHVybnMgYnJva2VyIGluc3RhbmNlLlxuICpcbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGJyb2tlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUZpbmVUdW5pbmdCcm9rZXIoc2lnbmVyLCBjb250cmFjdEFkZHJlc3MsIGxlZGdlciwgZ2FzUHJpY2UsIG1heEdhc1ByaWNlLCBzdGVwKSB7XG4gICAgY29uc3QgYnJva2VyID0gbmV3IEZpbmVUdW5pbmdCcm9rZXIoc2lnbmVyLCBjb250cmFjdEFkZHJlc3MsIGxlZGdlciwgZ2FzUHJpY2UsIG1heEdhc1ByaWNlLCBzdGVwKTtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBicm9rZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICByZXR1cm4gYnJva2VyO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuXG4vKipcbiAqIExlZGdlclByb2Nlc3NvciBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZywgZGVwb3NpdGluZyBmdW5kcywgYW5kIHJldHJpZXZpbmcgMEcgQ29tcHV0ZSBOZXR3b3JrIExlZGdlcnMuXG4gKi9cbmNsYXNzIExlZGdlclByb2Nlc3NvciB7XG4gICAgbWV0YWRhdGE7XG4gICAgY2FjaGU7XG4gICAgbGVkZ2VyQ29udHJhY3Q7XG4gICAgaW5mZXJlbmNlQ29udHJhY3Q7XG4gICAgZmluZVR1bmluZ0NvbnRyYWN0O1xuICAgIGNvbnN0cnVjdG9yKG1ldGFkYXRhLCBjYWNoZSwgbGVkZ2VyQ29udHJhY3QsIGluZmVyZW5jZUNvbnRyYWN0LCBmaW5lVHVuaW5nQ29udHJhY3QpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLmxlZGdlckNvbnRyYWN0ID0gbGVkZ2VyQ29udHJhY3Q7XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlQ29udHJhY3QgPSBpbmZlcmVuY2VDb250cmFjdDtcbiAgICAgICAgdGhpcy5maW5lVHVuaW5nQ29udHJhY3QgPSBmaW5lVHVuaW5nQ29udHJhY3Q7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TGVkZ2VyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbGVkZ2VyID0gYXdhaXQgdGhpcy5sZWRnZXJDb250cmFjdC5nZXRMZWRnZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBsZWRnZXI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRMZWRnZXJXaXRoRGV0YWlsKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbGVkZ2VyID0gYXdhaXQgdGhpcy5sZWRnZXJDb250cmFjdC5nZXRMZWRnZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZGdlckluZm8gPSBbXG4gICAgICAgICAgICAgICAgbGVkZ2VyLnRvdGFsQmFsYW5jZSxcbiAgICAgICAgICAgICAgICBsZWRnZXIudG90YWxCYWxhbmNlIC0gbGVkZ2VyLmF2YWlsYWJsZUJhbGFuY2UsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgaW5mZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwobGVkZ2VyLmluZmVyZW5jZVByb3ZpZGVycy5tYXAoYXN5bmMgKHByb3ZpZGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IHRoaXMuaW5mZXJlbmNlQ29udHJhY3QuZ2V0QWNjb3VudChwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtwcm92aWRlciwgYWNjb3VudC5iYWxhbmNlLCBhY2NvdW50LnBlbmRpbmdSZWZ1bmRdO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmZpbmVUdW5pbmdDb250cmFjdCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGxlZGdlckluZm8sIGluZmVycywgZmluZXM6IFtdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaW5lcyA9IGF3YWl0IFByb21pc2UuYWxsKGxlZGdlci5maW5lVHVuaW5nUHJvdmlkZXJzLm1hcChhc3luYyAocHJvdmlkZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5maW5lVHVuaW5nQ29udHJhY3Q/LmdldEFjY291bnQocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbcHJvdmlkZXIsIGFjY291bnQuYmFsYW5jZSwgYWNjb3VudC5wZW5kaW5nUmVmdW5kXTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiB7IGxlZGdlckluZm8sIGluZmVycywgZmluZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RMZWRnZXIoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBsZWRnZXJzID0gYXdhaXQgdGhpcy5sZWRnZXJDb250cmFjdC5saXN0TGVkZ2VyKCk7XG4gICAgICAgICAgICByZXR1cm4gbGVkZ2VycztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGFkZExlZGdlcihiYWxhbmNlLCBnYXNQcmljZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWRnZXIgPSBhd2FpdCB0aGlzLmdldExlZGdlcigpO1xuICAgICAgICAgICAgICAgIGlmIChsZWRnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWRnZXIgYWxyZWFkeSBleGlzdHMsIHdpdGggYmFsYW5jZTogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ldXJvblRvQTBnaShsZWRnZXIudG90YWxCYWxhbmNlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIEEwR0knKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgY29uc3QgeyBzZXR0bGVTaWduZXJQdWJsaWNLZXksIHNldHRsZVNpZ25lckVuY3J5cHRlZFByaXZhdGVLZXkgfSA9IGF3YWl0IHRoaXMuY3JlYXRlU2V0dGxlU2lnbmVyS2V5KCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmxlZGdlckNvbnRyYWN0LmFkZExlZGdlcihzZXR0bGVTaWduZXJQdWJsaWNLZXksIHRoaXMuYTBnaVRvTmV1cm9uKGJhbGFuY2UpLCBzZXR0bGVTaWduZXJFbmNyeXB0ZWRQcml2YXRlS2V5LCBnYXNQcmljZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZWxldGVMZWRnZXIoZ2FzUHJpY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubGVkZ2VyQ29udHJhY3QuZGVsZXRlTGVkZ2VyKGdhc1ByaWNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlcG9zaXRGdW5kKGJhbGFuY2UsIGdhc1ByaWNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhbW91bnQgPSB0aGlzLmEwZ2lUb05ldXJvbihiYWxhbmNlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5sZWRnZXJDb250cmFjdC5kZXBvc2l0RnVuZChhbW91bnQsIGdhc1ByaWNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlZnVuZChiYWxhbmNlLCBnYXNQcmljZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYW1vdW50ID0gdGhpcy5hMGdpVG9OZXVyb24oYmFsYW5jZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubGVkZ2VyQ29udHJhY3QucmVmdW5kKGFtb3VudCwgZ2FzUHJpY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdHJhbnNmZXJGdW5kKHRvLCBzZXJ2aWNlVHlwZVN0ciwgYmFsYW5jZSwgZ2FzUHJpY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFtb3VudCA9IGJhbGFuY2UudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubGVkZ2VyQ29udHJhY3QudHJhbnNmZXJGdW5kKHRvLCBzZXJ2aWNlVHlwZVN0ciwgYW1vdW50LCBnYXNQcmljZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZXRyaWV2ZUZ1bmQoc2VydmljZVR5cGVTdHIsIGdhc1ByaWNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBsZWRnZXIgPSBhd2FpdCB0aGlzLmdldExlZGdlcldpdGhEZXRhaWwoKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IHNlcnZpY2VUeXBlU3RyID09ICdpbmZlcmVuY2UnID8gbGVkZ2VyLmluZmVycyA6IGxlZGdlci5maW5lcztcbiAgICAgICAgICAgIGlmICghcHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwcm92aWRlcnMgZm91bmQsIHBsZWFzZSBlbnN1cmUgeW91IGFyZSB1c2luZyBXYWxsZXQgaW5zdGFuY2UgdG8gY3JlYXRlIHRoZSBicm9rZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyQWRkcmVzc2VzID0gcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4geFsxXSAtIHhbMl0gPiAwbilcbiAgICAgICAgICAgICAgICAubWFwKCh4KSA9PiB4WzBdKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubGVkZ2VyQ29udHJhY3QucmV0cmlldmVGdW5kKHByb3ZpZGVyQWRkcmVzc2VzLCBzZXJ2aWNlVHlwZVN0ciwgZ2FzUHJpY2UpO1xuICAgICAgICAgICAgaWYgKHNlcnZpY2VUeXBlU3RyID09ICdpbmZlcmVuY2UnKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jYWNoZS5zZXRJdGVtKCdmaXJzdFJvdW5kJywgJ3RydWUnLCAxMDAwMDAwMCAqIDYwICogMTAwMCwgQ2FjaGVWYWx1ZVR5cGVFbnVtLk90aGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVNldHRsZVNpZ25lcktleSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFtwcmksIHB1Yl1cbiAgICAgICAgICAgIGNvbnN0IGtleVBhaXIgPSBhd2FpdCBnZW5LZXlQYWlyKCk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHt0aGlzLmxlZGdlckNvbnRyYWN0LmdldFVzZXJBZGRyZXNzKCl9YDtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc3RvcmVTZXR0bGVTaWduZXJQcml2YXRlS2V5KGtleSwga2V5UGFpci5wYWNrZWRQcml2a2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHNldHRsZVNpZ25lckVuY3J5cHRlZFByaXZhdGVLZXkgPSBhd2FpdCBlbmNyeXB0RGF0YSh0aGlzLmxlZGdlckNvbnRyYWN0LnNpZ25lciwgcHJpdmF0ZUtleVRvU3RyKGtleVBhaXIucGFja2VkUHJpdmtleSkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZXR0bGVTaWduZXJFbmNyeXB0ZWRQcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgIHNldHRsZVNpZ25lclB1YmxpY0tleToga2V5UGFpci5kb3VibGVQYWNrZWRQdWJrZXksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYTBnaVRvTmV1cm9uKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlU3RyID0gdmFsdWUudG9GaXhlZCgxOCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gdmFsdWVTdHIuc3BsaXQoJy4nKTtcbiAgICAgICAgLy8gSGFuZGxlIGludGVnZXIgcGFydFxuICAgICAgICBjb25zdCBpbnRlZ2VyUGFydCA9IHBhcnRzWzBdO1xuICAgICAgICBsZXQgaW50ZWdlclBhcnRBc0JpZ0ludCA9IEJpZ0ludChpbnRlZ2VyUGFydCkgKiBCaWdJbnQoMTAgKiogMTgpO1xuICAgICAgICAvLyBIYW5kbGUgZnJhY3Rpb25hbCBwYXJ0IGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGV0IGZyYWN0aW9uYWxQYXJ0ID0gcGFydHNbMV07XG4gICAgICAgICAgICB3aGlsZSAoZnJhY3Rpb25hbFBhcnQubGVuZ3RoIDwgMTgpIHtcbiAgICAgICAgICAgICAgICBmcmFjdGlvbmFsUGFydCArPSAnMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJhY3Rpb25hbFBhcnQubGVuZ3RoID4gMTgpIHtcbiAgICAgICAgICAgICAgICBmcmFjdGlvbmFsUGFydCA9IGZyYWN0aW9uYWxQYXJ0LnNsaWNlKDAsIDE4KTsgLy8gVHJ1bmNhdGUgdG8gYXZvaWQgb3ZlcmZsb3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZyYWN0aW9uYWxQYXJ0QXNCaWdJbnQgPSBCaWdJbnQoZnJhY3Rpb25hbFBhcnQpO1xuICAgICAgICAgICAgaW50ZWdlclBhcnRBc0JpZ0ludCArPSBmcmFjdGlvbmFsUGFydEFzQmlnSW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlZ2VyUGFydEFzQmlnSW50O1xuICAgIH1cbiAgICBuZXVyb25Ub0EwZ2kodmFsdWUpIHtcbiAgICAgICAgY29uc3QgZGl2aXNvciA9IEJpZ0ludCgxMCAqKiAxOCk7XG4gICAgICAgIGNvbnN0IGludGVnZXJQYXJ0ID0gdmFsdWUgLyBkaXZpc29yO1xuICAgICAgICBjb25zdCByZW1haW5kZXIgPSB2YWx1ZSAlIGRpdmlzb3I7XG4gICAgICAgIGNvbnN0IGRlY2ltYWxQYXJ0ID0gTnVtYmVyKHJlbWFpbmRlcikgLyBOdW1iZXIoZGl2aXNvcik7XG4gICAgICAgIHJldHVybiBOdW1iZXIoaW50ZWdlclBhcnQpICsgZGVjaW1hbFBhcnQ7XG4gICAgfVxufVxuXG5jb25zdCBUSU1FT1VUX01TID0gMzAwXzAwMDtcbmNsYXNzIExlZGdlck1hbmFnZXJDb250cmFjdCB7XG4gICAgbGVkZ2VyO1xuICAgIHNpZ25lcjtcbiAgICBfdXNlckFkZHJlc3M7XG4gICAgX2dhc1ByaWNlO1xuICAgIF9tYXhHYXNQcmljZTtcbiAgICBfc3RlcDtcbiAgICBjb25zdHJ1Y3RvcihzaWduZXIsIGNvbnRyYWN0QWRkcmVzcywgdXNlckFkZHJlc3MsIGdhc1ByaWNlLCBtYXhHYXNQcmljZSwgc3RlcCkge1xuICAgICAgICB0aGlzLmxlZGdlciA9IExlZGdlck1hbmFnZXJfX2ZhY3RvcnkuY29ubmVjdChjb250cmFjdEFkZHJlc3MsIHNpZ25lcik7XG4gICAgICAgIHRoaXMuc2lnbmVyID0gc2lnbmVyO1xuICAgICAgICB0aGlzLl91c2VyQWRkcmVzcyA9IHVzZXJBZGRyZXNzO1xuICAgICAgICB0aGlzLl9nYXNQcmljZSA9IGdhc1ByaWNlO1xuICAgICAgICB0aGlzLl9tYXhHYXNQcmljZSA9IG1heEdhc1ByaWNlO1xuICAgICAgICB0aGlzLl9zdGVwID0gc3RlcCB8fCAxLjE7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUeChuYW1lLCB0eEFyZ3MsIHR4T3B0aW9ucykge1xuICAgICAgICBpZiAodHhPcHRpb25zLmdhc1ByaWNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHR4T3B0aW9ucy5nYXNQcmljZSA9IChhd2FpdCB0aGlzLnNpZ25lci5wcm92aWRlcj8uZ2V0RmVlRGF0YSgpKT8uZ2FzUHJpY2U7XG4gICAgICAgICAgICAvLyBBZGQgYSBkZWxheSB0byBhdm9pZCB0b28gZnJlcXVlbnQgUlBDIGNhbGxzXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eE9wdGlvbnMuZ2FzUHJpY2UgPSBCaWdJbnQodHhPcHRpb25zLmdhc1ByaWNlKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc2VuZGluZyB0eCB3aXRoIGdhcyBwcmljZScsIHR4T3B0aW9ucy5nYXNQcmljZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmxlZGdlci5nZXRGdW5jdGlvbihuYW1lKSguLi50eEFyZ3MsIHR4T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3R4IGhhc2g6JywgdHguaGFzaCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IChhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgICAgICB0eC53YWl0KCksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignR2V0IFJlY2VpcHQgdGltZW91dCcpKSwgVElNRU9VVF9NUykpLFxuICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUmVjZWlwdChyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PVxuICAgICAgICAgICAgICAgICAgICAnR2V0IFJlY2VpcHQgdGltZW91dCwgdHJ5IHNldCBoaWdoZXIgZ2FzIHByaWNlJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub25jZSA9IGF3YWl0IHRoaXMuc2lnbmVyLmdldE5vbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdOb25jZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnByb3ZpZGVyPy5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuX3VzZXJBZGRyZXNzLCAncGVuZGluZycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZ05vbmNlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdOb25jZSAtIG5vbmNlID4gNSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHhPcHRpb25zLm5vbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2lnbmlmaWNhbnQgZ2FwIGRldGVjdGVkIGJldHdlZW4gcGVuZGluZyBub25jZSAoJHtwZW5kaW5nTm9uY2V9KSBhbmQgY3VycmVudCBub25jZSAoJHtub25jZX0pLiBUaGlzIG1heSBpbmRpY2F0ZSBza2lwcGVkIG9yIG1pc3NpbmcgdHJhbnNhY3Rpb25zLiBVc2luZyB0aGUgY3VycmVudCBjb25maXJtZWQgbm9uY2UgZm9yIHRoZSB0cmFuc2FjdGlvbi5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4T3B0aW9ucy5ub25jZSA9IG5vbmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXhHYXNQcmljZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IuaW5mbz8uZXJyb3I/Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3IuaW5mby5lcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRSZXRyeSA9IFJFVFJZX0VSUk9SX1NVQlNUUklOR1Muc29tZSgoc3Vic3RyKSA9PiBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoc3Vic3RyKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRSZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JldHJ5aW5nIHRyYW5zYWN0aW9uIHdpdGggaGlnaGVyIGdhcyBwcmljZSBkdWUgdG86JywgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEdhc1ByaWNlID0gdHhPcHRpb25zLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50R2FzUHJpY2UgPj0gdGhpcy5fbWF4R2FzUHJpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRHYXNQcmljZSA9XG4gICAgICAgICAgICAgICAgICAgIChjdXJyZW50R2FzUHJpY2UgKiBCaWdJbnQodGhpcy5fc3RlcCkpIC8gQmlnSW50KDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEdhc1ByaWNlID4gdGhpcy5fbWF4R2FzUHJpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdhc1ByaWNlID0gdGhpcy5fbWF4R2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR4T3B0aW9ucy5nYXNQcmljZSA9IGN1cnJlbnRHYXNQcmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBhZGRMZWRnZXIoc2lnbmVyLCBiYWxhbmNlLCBzZXR0bGVTaWduZXJFbmNyeXB0ZWRQcml2YXRlS2V5LCBnYXNQcmljZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHhPcHRpb25zID0geyB2YWx1ZTogYmFsYW5jZSB9O1xuICAgICAgICAgICAgaWYgKGdhc1ByaWNlIHx8IHRoaXMuX2dhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgdHhPcHRpb25zLmdhc1ByaWNlID0gZ2FzUHJpY2UgfHwgdGhpcy5fZ2FzUHJpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRUeCgnYWRkTGVkZ2VyJywgW3NpZ25lciwgc2V0dGxlU2lnbmVyRW5jcnlwdGVkUHJpdmF0ZUtleV0sIHR4T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0TGVkZ2VyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbGVkZ2VycyA9IGF3YWl0IHRoaXMubGVkZ2VyLmdldEFsbExlZGdlcnMoKTtcbiAgICAgICAgICAgIHJldHVybiBsZWRnZXJzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TGVkZ2VyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IHRoaXMuZ2V0VXNlckFkZHJlc3MoKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZGdlciA9IGF3YWl0IHRoaXMubGVkZ2VyLmdldExlZGdlcih1c2VyKTtcbiAgICAgICAgICAgIHJldHVybiBsZWRnZXI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZXBvc2l0RnVuZChiYWxhbmNlLCBnYXNQcmljZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHhPcHRpb25zID0geyB2YWx1ZTogYmFsYW5jZSB9O1xuICAgICAgICAgICAgaWYgKGdhc1ByaWNlIHx8IHRoaXMuX2dhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgdHhPcHRpb25zLmdhc1ByaWNlID0gZ2FzUHJpY2UgfHwgdGhpcy5fZ2FzUHJpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRUeCgnZGVwb3NpdEZ1bmQnLCBbXSwgdHhPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlZnVuZChhbW91bnQsIGdhc1ByaWNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0eE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChnYXNQcmljZSB8fCB0aGlzLl9nYXNQcmljZSkge1xuICAgICAgICAgICAgICAgIHR4T3B0aW9ucy5nYXNQcmljZSA9IGdhc1ByaWNlIHx8IHRoaXMuX2dhc1ByaWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kVHgoJ3JlZnVuZCcsIFthbW91bnRdLCB0eE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdHJhbnNmZXJGdW5kKHByb3ZpZGVyLCBzZXJ2aWNlVHlwZVN0ciwgYW1vdW50LCBnYXNQcmljZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHhPcHRpb25zID0ge307XG4gICAgICAgICAgICBpZiAoZ2FzUHJpY2UgfHwgdGhpcy5fZ2FzUHJpY2UpIHtcbiAgICAgICAgICAgICAgICB0eE9wdGlvbnMuZ2FzUHJpY2UgPSBnYXNQcmljZSB8fCB0aGlzLl9nYXNQcmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZFR4KCd0cmFuc2ZlckZ1bmQnLCBbcHJvdmlkZXIsIHNlcnZpY2VUeXBlU3RyLCBhbW91bnRdLCB0eE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmV0cmlldmVGdW5kKHByb3ZpZGVycywgc2VydmljZVR5cGVTdHIsIGdhc1ByaWNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0eE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChnYXNQcmljZSB8fCB0aGlzLl9nYXNQcmljZSkge1xuICAgICAgICAgICAgICAgIHR4T3B0aW9ucy5nYXNQcmljZSA9IGdhc1ByaWNlIHx8IHRoaXMuX2dhc1ByaWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kVHgoJ3JldHJpZXZlRnVuZCcsIFtwcm92aWRlcnMsIHNlcnZpY2VUeXBlU3RyXSwgdHhPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUxlZGdlcihnYXNQcmljZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHhPcHRpb25zID0ge307XG4gICAgICAgICAgICBpZiAoZ2FzUHJpY2UgfHwgdGhpcy5fZ2FzUHJpY2UpIHtcbiAgICAgICAgICAgICAgICB0eE9wdGlvbnMuZ2FzUHJpY2UgPSBnYXNQcmljZSB8fCB0aGlzLl9nYXNQcmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZFR4KCdkZWxldGVMZWRnZXInLCBbXSwgdHhPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybWF0dGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFVzZXJBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlckFkZHJlc3M7XG4gICAgfVxuICAgIGNoZWNrUmVjZWlwdChyZWNlaXB0KSB7XG4gICAgICAgIGlmICghcmVjZWlwdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBmYWlsZWQgd2l0aCBubyByZWNlaXB0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY2VpcHQuc3RhdHVzICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIHJldmVydGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIExlZGdlckJyb2tlciB7XG4gICAgbGVkZ2VyO1xuICAgIHNpZ25lcjtcbiAgICBsZWRnZXJDQTtcbiAgICBpbmZlcmVuY2VDQTtcbiAgICBmaW5lVHVuaW5nQ0E7XG4gICAgZ2FzUHJpY2U7XG4gICAgbWF4R2FzUHJpY2U7XG4gICAgc3RlcDtcbiAgICBjb25zdHJ1Y3RvcihzaWduZXIsIGxlZGdlckNBLCBpbmZlcmVuY2VDQSwgZmluZVR1bmluZ0NBLCBnYXNQcmljZSwgbWF4R2FzUHJpY2UsIHN0ZXApIHtcbiAgICAgICAgdGhpcy5zaWduZXIgPSBzaWduZXI7XG4gICAgICAgIHRoaXMubGVkZ2VyQ0EgPSBsZWRnZXJDQTtcbiAgICAgICAgdGhpcy5pbmZlcmVuY2VDQSA9IGluZmVyZW5jZUNBO1xuICAgICAgICB0aGlzLmZpbmVUdW5pbmdDQSA9IGZpbmVUdW5pbmdDQTtcbiAgICAgICAgdGhpcy5nYXNQcmljZSA9IGdhc1ByaWNlO1xuICAgICAgICB0aGlzLm1heEdhc1ByaWNlID0gbWF4R2FzUHJpY2U7XG4gICAgICAgIHRoaXMuc3RlcCA9IHN0ZXA7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGxldCB1c2VyQWRkcmVzcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVzZXJBZGRyZXNzID0gYXdhaXQgdGhpcy5zaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVkZ2VyQ29udHJhY3QgPSBuZXcgTGVkZ2VyTWFuYWdlckNvbnRyYWN0KHRoaXMuc2lnbmVyLCB0aGlzLmxlZGdlckNBLCB1c2VyQWRkcmVzcywgdGhpcy5nYXNQcmljZSwgdGhpcy5tYXhHYXNQcmljZSwgdGhpcy5zdGVwKTtcbiAgICAgICAgY29uc3QgaW5mZXJlbmNlQ29udHJhY3QgPSBuZXcgSW5mZXJlbmNlU2VydmluZ0NvbnRyYWN0KHRoaXMuc2lnbmVyLCB0aGlzLmluZmVyZW5jZUNBLCB1c2VyQWRkcmVzcyk7XG4gICAgICAgIGxldCBmaW5lVHVuaW5nQ29udHJhY3Q7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lciBpbnN0YW5jZW9mIFdhbGxldCkge1xuICAgICAgICAgICAgZmluZVR1bmluZ0NvbnRyYWN0ID0gbmV3IEZpbmVUdW5pbmdTZXJ2aW5nQ29udHJhY3QodGhpcy5zaWduZXIsIHRoaXMuZmluZVR1bmluZ0NBLCB1c2VyQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBuZXcgTWV0YWRhdGEoKTtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBuZXcgQ2FjaGUoKTtcbiAgICAgICAgdGhpcy5sZWRnZXIgPSBuZXcgTGVkZ2VyUHJvY2Vzc29yKG1ldGFkYXRhLCBjYWNoZSwgbGVkZ2VyQ29udHJhY3QsIGluZmVyZW5jZUNvbnRyYWN0LCBmaW5lVHVuaW5nQ29udHJhY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGxlZGdlciB0byB0aGUgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmFsYW5jZSAtIFRoZSBpbml0aWFsIGJhbGFuY2UgdG8gYmUgYXNzaWduZWQgdG8gdGhlIG5ldyBsZWRnZXIuIFVuaXRzIGFyZSBpbiBBMEdJLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnYXNQcmljZSAtIFRoZSBnYXMgcHJpY2UgdG8gYmUgdXNlZCBmb3IgdGhlIHRyYW5zYWN0aW9uLiBJZiBub3QgcHJvdmlkZWQsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGRlZmF1bHQvYXV0by1nZW5lcmF0ZWQgZ2FzIHByaWNlIHdpbGwgYmUgdXNlZC4gVW5pdHMgYXJlIGluIG5ldXJvbi5cbiAgICAgKlxuICAgICAqIEB0aHJvd3MgIEFuIGVycm9yIGlmIHRoZSBsZWRnZXIgY3JlYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFdoZW4gY3JlYXRpbmcgYW4gbGVkZ2VyLCBhIGtleSBwYWlyIGlzIGFsc28gY3JlYXRlZCB0byBzaWduIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFkZExlZGdlciA9IGFzeW5jIChiYWxhbmNlLCBnYXNQcmljZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubGVkZ2VyLmFkZExlZGdlcihiYWxhbmNlLCBnYXNQcmljZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBsZWRnZXIgaW5mb3JtYXRpb24gZm9yIGN1cnJlbnQgd2FsbGV0IGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbGVkZ2VyIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBsZWRnZXIgcmV0cmlldmFsIHByb2Nlc3MgZmFpbHMuXG4gICAgICovXG4gICAgZ2V0TGVkZ2VyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubGVkZ2VyLmdldExlZGdlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlcG9zaXRzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBmdW5kcyBpbnRvIExlZGdlciBjb3JyZXNwb25kaW5nIHRvIHRoZSBjdXJyZW50IHdhbGxldCBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudCAtIFRoZSBhbW91bnQgb2YgZnVuZHMgdG8gYmUgZGVwb3NpdGVkLiBVbml0cyBhcmUgaW4gQTBHSS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2FzUHJpY2UgLSBUaGUgZ2FzIHByaWNlIHRvIGJlIHVzZWQgZm9yIHRoZSB0cmFuc2FjdGlvbi4gSWYgbm90IHByb3ZpZGVkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBkZWZhdWx0L2F1dG8tZ2VuZXJhdGVkIGdhcyBwcmljZSB3aWxsIGJlIHVzZWQuIFVuaXRzIGFyZSBpbiBuZXVyb24uXG4gICAgICpcbiAgICAgKiBAdGhyb3dzICBBbiBlcnJvciBpZiB0aGUgZGVwb3NpdCBmYWlscy5cbiAgICAgKi9cbiAgICBkZXBvc2l0RnVuZCA9IGFzeW5jIChhbW91bnQsIGdhc1ByaWNlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sZWRnZXIuZGVwb3NpdEZ1bmQoYW1vdW50LCBnYXNQcmljZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVmdW5kcyBhIHNwZWNpZmllZCBhbW91bnQgdXNpbmcgdGhlIGxlZGdlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IHRvIGJlIHJlZnVuZGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnYXNQcmljZSAtIFRoZSBnYXMgcHJpY2UgdG8gYmUgdXNlZCBmb3IgdGhlIHRyYW5zYWN0aW9uLiBJZiBub3QgcHJvdmlkZWQsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGRlZmF1bHQvYXV0by1nZW5lcmF0ZWQgZ2FzIHByaWNlIHdpbGwgYmUgdXNlZC4gVW5pdHMgYXJlIGluIG5ldXJvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHJlZnVuZCBpcyBwcm9jZXNzZWQuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSByZWZ1bmQgcHJvY2VzcyBmYWlscy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIFRoZSBhbW91bnQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyLlxuICAgICAqL1xuICAgIHJlZnVuZCA9IGFzeW5jIChhbW91bnQsIGdhc1ByaWNlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sZWRnZXIucmVmdW5kKGFtb3VudCwgZ2FzUHJpY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zZmVycyBhIHNwZWNpZmllZCBhbW91bnQgb2YgZnVuZHMgdG8gYSBwcm92aWRlciBmb3IgYSBnaXZlbiBzZXJ2aWNlIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXIgLSBUaGUgYWRkcmVzcyBvZiB0aGUgcHJvdmlkZXIgdG8gd2hvbSB0aGUgZnVuZHMgYXJlIGJlaW5nIHRyYW5zZmVycmVkLlxuICAgICAqIEBwYXJhbSBzZXJ2aWNlVHlwZVN0ciAtIFRoZSB0eXBlIG9mIHNlcnZpY2UgZm9yIHdoaWNoIHRoZSBmdW5kcyBhcmUgYmVpbmcgdHJhbnNmZXJyZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgSXQgY2FuIGJlIGVpdGhlciAnaW5mZXJlbmNlJyBvciAnZmluZS10dW5pbmcnLlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIGZ1bmRzIHRvIGJlIHRyYW5zZmVycmVkLiBVbml0cyBhcmUgaW4gbmV1cm9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnYXNQcmljZSAtIFRoZSBnYXMgcHJpY2UgdG8gYmUgdXNlZCBmb3IgdGhlIHRyYW5zYWN0aW9uLiBJZiBub3QgcHJvdmlkZWQsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGRlZmF1bHQvYXV0by1nZW5lcmF0ZWQgZ2FzIHByaWNlIHdpbGwgYmUgdXNlZC4gVW5pdHMgYXJlIGluIG5ldXJvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgZnVuZCB0cmFuc2ZlciBvcGVyYXRpb24uXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBmdW5kIHRyYW5zZmVyIG9wZXJhdGlvbiBmYWlscy5cbiAgICAgKi9cbiAgICB0cmFuc2ZlckZ1bmQgPSBhc3luYyAocHJvdmlkZXIsIHNlcnZpY2VUeXBlU3RyLCBhbW91bnQsIGdhc1ByaWNlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sZWRnZXIudHJhbnNmZXJGdW5kKHByb3ZpZGVyLCBzZXJ2aWNlVHlwZVN0ciwgYW1vdW50LCBnYXNQcmljZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGZ1bmRzIGZyb20gdGhlIGFsbCBzdWItYWNjb3VudHMgKGZvciBpbmZlcmVuY2UgYW5kIGZpbmUtdHVuaW5nKSBvZiB0aGUgY3VycmVudCB3YWxsZXQgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXJ2aWNlVHlwZVN0ciAtIFRoZSB0eXBlIG9mIHNlcnZpY2UgZm9yIHdoaWNoIHRoZSBmdW5kcyBhcmUgYmVpbmcgcmV0cmlldmVkLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIEl0IGNhbiBiZSBlaXRoZXIgJ2luZmVyZW5jZScgb3IgJ2ZpbmUtdHVuaW5nJy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2FzUHJpY2UgLSBUaGUgZ2FzIHByaWNlIHRvIGJlIHVzZWQgZm9yIHRoZSB0cmFuc2FjdGlvbi4gSWYgbm90IHByb3ZpZGVkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBkZWZhdWx0L2F1dG8tZ2VuZXJhdGVkIGdhcyBwcmljZSB3aWxsIGJlIHVzZWQuIFVuaXRzIGFyZSBpbiBuZXVyb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmQgcmV0cmlldmFsIG9wZXJhdGlvbi5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGZ1bmQgcmV0cmlldmFsIG9wZXJhdGlvbiBmYWlscy5cbiAgICAgKi9cbiAgICByZXRyaWV2ZUZ1bmQgPSBhc3luYyAoc2VydmljZVR5cGVTdHIsIGdhc1ByaWNlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sZWRnZXIucmV0cmlldmVGdW5kKHNlcnZpY2VUeXBlU3RyLCBnYXNQcmljZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Zvcm1hdHRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgbGVkZ2VyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGN1cnJlbnQgd2FsbGV0IGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2FzUHJpY2UgLSBUaGUgZ2FzIHByaWNlIHRvIGJlIHVzZWQgZm9yIHRoZSB0cmFuc2FjdGlvbi4gSWYgbm90IHByb3ZpZGVkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGRlZmF1bHQvYXV0by1nZW5lcmF0ZWQgZ2FzIHByaWNlIHdpbGwgYmUgdXNlZC4gVW5pdHMgYXJlIGluIG5ldXJvbi5cbiAgICAgKlxuICAgICAqIEB0aHJvd3MgIEFuIGVycm9yIGlmIHRoZSBkZWxldGlvbiBmYWlscy5cbiAgICAgKi9cbiAgICBkZWxldGVMZWRnZXIgPSBhc3luYyAoZ2FzUHJpY2UpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxlZGdlci5kZWxldGVMZWRnZXIoZ2FzUHJpY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGb3JtYXR0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBjcmVhdGVMZWRnZXJCcm9rZXIgaXMgdXNlZCB0byBpbml0aWFsaXplIExlZGdlckJyb2tlclxuICpcbiAqIEBwYXJhbSBzaWduZXIgLSBTaWduZXIgZnJvbSBldGhlcnMuanMuXG4gKiBAcGFyYW0gbGVkZ2VyQ0EgLSBMZWRnZXIgY29udHJhY3QgYWRkcmVzcywgdXNlIGRlZmF1bHQgYWRkcmVzcyBpZiBub3QgcHJvdmlkZWQuXG4gKlxuICogQHJldHVybnMgYnJva2VyIGluc3RhbmNlLlxuICpcbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGJyb2tlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUxlZGdlckJyb2tlcihzaWduZXIsIGxlZGdlckNBLCBpbmZlcmVuY2VDQSwgZmluZVR1bmluZ0NBLCBnYXNQcmljZSwgbWF4R2FzUHJpY2UsIHN0ZXApIHtcbiAgICBjb25zdCBicm9rZXIgPSBuZXcgTGVkZ2VyQnJva2VyKHNpZ25lciwgbGVkZ2VyQ0EsIGluZmVyZW5jZUNBLCBmaW5lVHVuaW5nQ0EsIGdhc1ByaWNlLCBtYXhHYXNQcmljZSwgc3RlcCk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgYnJva2VyLmluaXRpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIGJyb2tlcjtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cblxuY2xhc3MgWkdDb21wdXRlTmV0d29ya0Jyb2tlciB7XG4gICAgbGVkZ2VyO1xuICAgIGluZmVyZW5jZTtcbiAgICBmaW5lVHVuaW5nO1xuICAgIGNvbnN0cnVjdG9yKGxlZGdlciwgaW5mZXJlbmNlQnJva2VyLCBmaW5lVHVuaW5nQnJva2VyKSB7XG4gICAgICAgIHRoaXMubGVkZ2VyID0gbGVkZ2VyO1xuICAgICAgICB0aGlzLmluZmVyZW5jZSA9IGluZmVyZW5jZUJyb2tlcjtcbiAgICAgICAgdGhpcy5maW5lVHVuaW5nID0gZmluZVR1bmluZ0Jyb2tlcjtcbiAgICB9XG59XG4vKipcbiAqIGNyZWF0ZVpHQ29tcHV0ZU5ldHdvcmtCcm9rZXIgaXMgdXNlZCB0byBpbml0aWFsaXplIFpHQ29tcHV0ZU5ldHdvcmtCcm9rZXJcbiAqXG4gKiBAcGFyYW0gc2lnbmVyIC0gU2lnbmVyIGZyb20gZXRoZXJzLmpzLlxuICogQHBhcmFtIGxlZGdlckNBIC0gMEcgQ29tcHV0ZSBOZXR3b3JrIExlZGdlciBDb250YWN0IGFkZHJlc3MsIHVzZSBkZWZhdWx0IGFkZHJlc3MgaWYgbm90IHByb3ZpZGVkLlxuICogQHBhcmFtIGluZmVyZW5jZUNBIC0gMEcgQ29tcHV0ZSBOZXR3b3JrIEluZmVyZW5jZSBTZXJ2aW5nIGNvbnRyYWN0IGFkZHJlc3MsIHVzZSBkZWZhdWx0IGFkZHJlc3MgaWYgbm90IHByb3ZpZGVkLlxuICogQHBhcmFtIGZpbmVUdW5pbmdDQSAtIDBHIENvbXB1dGUgTmV0d29yayBGaW5lIFR1bmluZyBTZXJ2aW5nIGNvbnRyYWN0IGFkZHJlc3MsIHVzZSBkZWZhdWx0IGFkZHJlc3MgaWYgbm90IHByb3ZpZGVkLlxuICogQHBhcmFtIGdhc1ByaWNlIC0gR2FzIHByaWNlIGZvciB0cmFuc2FjdGlvbnMuIElmIG5vdCBwcm92aWRlZCwgdGhlIGdhcyBwcmljZSB3aWxsIGJlIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseS5cbiAqXG4gKiBAcmV0dXJucyBicm9rZXIgaW5zdGFuY2UuXG4gKlxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgYnJva2VyIGNhbm5vdCBiZSBpbml0aWFsaXplZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlWkdDb21wdXRlTmV0d29ya0Jyb2tlcihzaWduZXIsIGxlZGdlckNBID0gJzB4MjBmNkU0MWIyN2ZCNjQzN0I2RUQ2MWE0MkRjZGRCNjMyODc0OUY4NCcsIGluZmVyZW5jZUNBID0gJzB4OUEzMEFlMTVlZTMzQmJkNzc3MTEzYzlDNjRiMzFkN2Y3MTdDOTdBMCcsIGZpbmVUdW5pbmdDQSA9ICcweDRjODcxYzQ2RDkwMTk5MDk4N0VCZjM5Q2I4YTE2ZkM3MzM5MGE0RTUnLCBnYXNQcmljZSwgbWF4R2FzUHJpY2UsIHN0ZXApIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBsZWRnZXIgPSBhd2FpdCBjcmVhdGVMZWRnZXJCcm9rZXIoc2lnbmVyLCBsZWRnZXJDQSwgaW5mZXJlbmNlQ0EsIGZpbmVUdW5pbmdDQSwgZ2FzUHJpY2UsIG1heEdhc1ByaWNlLCBzdGVwKTtcbiAgICAgICAgY29uc3QgaW5mZXJlbmNlQnJva2VyID0gYXdhaXQgY3JlYXRlSW5mZXJlbmNlQnJva2VyKHNpZ25lciwgaW5mZXJlbmNlQ0EsIGxlZGdlcik7XG4gICAgICAgIGxldCBmaW5lVHVuaW5nQnJva2VyO1xuICAgICAgICBpZiAoc2lnbmVyIGluc3RhbmNlb2YgV2FsbGV0KSB7XG4gICAgICAgICAgICBmaW5lVHVuaW5nQnJva2VyID0gYXdhaXQgY3JlYXRlRmluZVR1bmluZ0Jyb2tlcihzaWduZXIsIGZpbmVUdW5pbmdDQSwgbGVkZ2VyLCBnYXNQcmljZSwgbWF4R2FzUHJpY2UsIHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyb2tlciA9IG5ldyBaR0NvbXB1dGVOZXR3b3JrQnJva2VyKGxlZGdlciwgaW5mZXJlbmNlQnJva2VyLCBmaW5lVHVuaW5nQnJva2VyKTtcbiAgICAgICAgcmV0dXJuIGJyb2tlcjtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQWNjb3VudFByb2Nlc3NvciBhcyBBLCBGaW5lVHVuaW5nQnJva2VyIGFzIEYsIEluZmVyZW5jZUJyb2tlciBhcyBJLCBMZWRnZXJCcm9rZXIgYXMgTCwgTW9kZWxQcm9jZXNzb3IkMSBhcyBNLCBSZXF1ZXN0UHJvY2Vzc29yIGFzIFIsIFZlcmlmaWVyIGFzIFYsIFpHQ29tcHV0ZU5ldHdvcmtCcm9rZXIgYXMgWiwgUmVzcG9uc2VQcm9jZXNzb3IgYXMgYSwgY3JlYXRlRmluZVR1bmluZ0Jyb2tlciBhcyBiLCBjcmVhdGVJbmZlcmVuY2VCcm9rZXIgYXMgYywgZG93bmxvYWQgYXMgZCwgY3JlYXRlTGVkZ2VyQnJva2VyIGFzIGUsIGNyZWF0ZVpHQ29tcHV0ZU5ldHdvcmtCcm9rZXIgYXMgZiwgaXNOb2RlIGFzIGcsIGlzV2ViV29ya2VyIGFzIGgsIGlzQnJvd3NlciBhcyBpLCBoYXNXZWJDcnlwdG8gYXMgaiwgZ2V0Q3J5cHRvQWRhcHRlciBhcyBrLCBiaWdpbnRUb0J5dGVzIGFzIGwsIGdlbktleVBhaXIgYXMgbSwgUmVxdWVzdCQxIGFzIG4sIHBlZGVyc2VuSGFzaCBhcyBwLCBzaWduRGF0YSBhcyBzLCB1cGxvYWQgYXMgdSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgtMWU3N2E0NjcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@0glabs/0g-serving-broker/lib.esm/index-1e77a467.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@0glabs/0g-serving-broker/lib.esm/index-b52942d2.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@0glabs/0g-serving-broker/lib.esm/index-b52942d2.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   download: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   upload: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.u)\n/* harmony export */ });\n/* harmony import */ var _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-1e77a467.js */ \"(ssr)/./node_modules/@0glabs/0g-serving-broker/lib.esm/index-1e77a467.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto-js */ \"(ssr)/./node_modules/crypto-js/index.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var circomlibjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! circomlibjs */ \"(ssr)/./node_modules/circomlibjs/main.js\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_5__);\n\n\n\n\n\n\n\n//# sourceMappingURL=index-b52942d2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQDBnbGFicy8wZy1zZXJ2aW5nLWJyb2tlci9saWIuZXNtL2luZGV4LWI1Mjk0MmQyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTtBQUNqRDtBQUNHO0FBQ0U7QUFDRTtBQUNUO0FBQ087QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8wZy1pbmZlcmVuY2UtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0AwZ2xhYnMvMGctc2VydmluZy1icm9rZXIvbGliLmVzbS9pbmRleC1iNTI5NDJkMi5qcz9lMGJlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGQgYXMgZG93bmxvYWQsIHUgYXMgdXBsb2FkIH0gZnJvbSAnLi9pbmRleC0xZTc3YTQ2Ny5qcyc7XG5pbXBvcnQgJ2V0aGVycyc7XG5pbXBvcnQgJ2NyeXB0by1qcyc7XG5pbXBvcnQgJ2NpcmNvbWxpYmpzJztcbmltcG9ydCAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgJ3BhdGgnO1xuaW1wb3J0ICdmcy9wcm9taXNlcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC1iNTI5NDJkMi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@0glabs/0g-serving-broker/lib.esm/index-b52942d2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@0glabs/0g-serving-broker/lib.esm/index.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@0glabs/0g-serving-broker/lib.esm/index.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FineTuningBroker: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   InferenceAccountProcessor: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   InferenceBroker: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   InferenceModelProcessor: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   InferenceRequestProcessor: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.R),\n/* harmony export */   InferenceResponseProcessor: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   InferenceVerifier: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.V),\n/* harmony export */   LedgerBroker: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.L),\n/* harmony export */   Request: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   ZGComputeNetworkBroker: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.Z),\n/* harmony export */   bigintToBytes: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   createFineTuningBroker: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   createInferenceBroker: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createLedgerBroker: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   createZGComputeNetworkBroker: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   genKeyPair: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   getCryptoAdapter: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   hasWebCrypto: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   isBrowser: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   isNode: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   isWebWorker: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   pedersenHash: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   signData: () => (/* reexport safe */ _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__.s)\n/* harmony export */ });\n/* harmony import */ var _index_1e77a467_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-1e77a467.js */ \"(ssr)/./node_modules/@0glabs/0g-serving-broker/lib.esm/index-1e77a467.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto-js */ \"(ssr)/./node_modules/crypto-js/index.js\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var circomlibjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! circomlibjs */ \"(ssr)/./node_modules/circomlibjs/main.js\");\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQDBnbGFicy8wZy1zZXJ2aW5nLWJyb2tlci9saWIuZXNtL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0akI7QUFDNWlCO0FBQ0c7QUFDSTtBQUNUO0FBQ087QUFDQTtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovLzBnLWluZmVyZW5jZS1uZXh0anMvLi9ub2RlX21vZHVsZXMvQDBnbGFicy8wZy1zZXJ2aW5nLWJyb2tlci9saWIuZXNtL2luZGV4Lm1qcz8zNjc1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IEYgYXMgRmluZVR1bmluZ0Jyb2tlciwgQSBhcyBJbmZlcmVuY2VBY2NvdW50UHJvY2Vzc29yLCBJIGFzIEluZmVyZW5jZUJyb2tlciwgTSBhcyBJbmZlcmVuY2VNb2RlbFByb2Nlc3NvciwgUiBhcyBJbmZlcmVuY2VSZXF1ZXN0UHJvY2Vzc29yLCBhIGFzIEluZmVyZW5jZVJlc3BvbnNlUHJvY2Vzc29yLCBWIGFzIEluZmVyZW5jZVZlcmlmaWVyLCBMIGFzIExlZGdlckJyb2tlciwgbiBhcyBSZXF1ZXN0LCBaIGFzIFpHQ29tcHV0ZU5ldHdvcmtCcm9rZXIsIGwgYXMgYmlnaW50VG9CeXRlcywgYiBhcyBjcmVhdGVGaW5lVHVuaW5nQnJva2VyLCBjIGFzIGNyZWF0ZUluZmVyZW5jZUJyb2tlciwgZSBhcyBjcmVhdGVMZWRnZXJCcm9rZXIsIGYgYXMgY3JlYXRlWkdDb21wdXRlTmV0d29ya0Jyb2tlciwgbSBhcyBnZW5LZXlQYWlyLCBrIGFzIGdldENyeXB0b0FkYXB0ZXIsIGogYXMgaGFzV2ViQ3J5cHRvLCBpIGFzIGlzQnJvd3NlciwgZyBhcyBpc05vZGUsIGggYXMgaXNXZWJXb3JrZXIsIHAgYXMgcGVkZXJzZW5IYXNoLCBzIGFzIHNpZ25EYXRhIH0gZnJvbSAnLi9pbmRleC0xZTc3YTQ2Ny5qcyc7XG5pbXBvcnQgJ2V0aGVycyc7XG5pbXBvcnQgJ2NyeXB0by1qcyc7XG5pbXBvcnQgJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICdwYXRoJztcbmltcG9ydCAnZnMvcHJvbWlzZXMnO1xuaW1wb3J0ICdjaXJjb21saWJqcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@0glabs/0g-serving-broker/lib.esm/index.mjs\n");

/***/ })

};
;